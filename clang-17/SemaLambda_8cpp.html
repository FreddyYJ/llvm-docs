<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: lib/Sema/SemaLambda.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">clang<span id="projectnumber">&#160;17.0.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_a417a95896a4c648243c5807aba13ea9.html">Sema</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">SemaLambda.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="DeclSpec_8h_source.html">clang/Sema/DeclSpec.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TypeLocBuilder_8h_source.html">TypeLocBuilder.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ASTLambda_8h_source.html">clang/AST/ASTLambda.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ExprCXX_8h_source.html">clang/AST/ExprCXX.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="include_2clang_2Basic_2TargetInfo_8h_source.html">clang/Basic/TargetInfo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Initialization_8h_source.html">clang/Sema/Initialization.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Sema_2Lookup_8h_source.html">clang/Sema/Lookup.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Scope_8h_source.html">clang/Sema/Scope.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ScopeInfo_8h_source.html">clang/Sema/ScopeInfo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SemaInternal_8h_source.html">clang/Sema/SemaInternal.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SemaLambda_8h_source.html">clang/Sema/SemaLambda.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &lt;optional&gt;</code><br />
</div>
<p><a href="SemaLambda_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a41725a12d87ce3093bd2295930a4ca3d" id="r_a41725a12d87ce3093bd2295930a4ca3d"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41725a12d87ce3093bd2295930a4ca3d">getStackIndexOfNearestEnclosingCaptureReadyLambda</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classclang_1_1sema_1_1FunctionScopeInfo.html">clang::sema::FunctionScopeInfo</a> * &gt; FunctionScopes, <a class="el" href="classclang_1_1ValueDecl.html">ValueDecl</a> *VarToCapture)</td></tr>
<tr class="memdesc:a41725a12d87ce3093bd2295930a4ca3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the FunctionScopeInfo stack to determine the nearest enclosing lambda (to the current lambda) that is 'capture-ready' for the variable referenced in the current lambda (i.e.  <br /></td></tr>
<tr class="separator:a41725a12d87ce3093bd2295930a4ca3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628d675bca07496e0ef85b4efe340c25" id="r_a628d675bca07496e0ef85b4efe340c25"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1TemplateParameterList.html">TemplateParameterList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a628d675bca07496e0ef85b4efe340c25">getGenericLambdaTemplateParameterList</a> (<a class="el" href="classclang_1_1sema_1_1LambdaScopeInfo.html">LambdaScopeInfo</a> *LSI, <a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;SemaRef)</td></tr>
<tr class="separator:a628d675bca07496e0ef85b4efe340c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a5afd241a6316c3b3f6103e6c706d3" id="r_ac7a5afd241a6316c3b3f6103e6c706d3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7a5afd241a6316c3b3f6103e6c706d3">isInInlineFunction</a> (const <a class="el" href="classclang_1_1DeclContext.html">DeclContext</a> *DC)</td></tr>
<tr class="memdesc:ac7a5afd241a6316c3b3f6103e6c706d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the given context is or is enclosed in an inline function.  <br /></td></tr>
<tr class="separator:ac7a5afd241a6316c3b3f6103e6c706d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75263a5d41b23a1db491c39fb33883a" id="r_ab75263a5d41b23a1db491c39fb33883a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab75263a5d41b23a1db491c39fb33883a">buildTypeForLambdaCallOperator</a> (<a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;S, <a class="el" href="classclang_1_1CXXRecordDecl.html">clang::CXXRecordDecl</a> *Class, <a class="el" href="classclang_1_1TemplateParameterList.html">TemplateParameterList</a> *TemplateParams, <a class="el" href="classclang_1_1TypeSourceInfo.html">TypeSourceInfo</a> *MethodTypeInfo)</td></tr>
<tr class="separator:ab75263a5d41b23a1db491c39fb33883a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8791c31e2db2c405252b58a96de9ce95" id="r_a8791c31e2db2c405252b58a96de9ce95"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8791c31e2db2c405252b58a96de9ce95">buildLambdaScopeReturnType</a> (<a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;S, <a class="el" href="classclang_1_1sema_1_1LambdaScopeInfo.html">LambdaScopeInfo</a> *LSI, <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> *CallOperator, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ExplicitResultType)</td></tr>
<tr class="separator:a8791c31e2db2c405252b58a96de9ce95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a23bf214595570196cdf2cc5422717c" id="r_a2a23bf214595570196cdf2cc5422717c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1EnumDecl.html">EnumDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a23bf214595570196cdf2cc5422717c">findEnumForBlockReturn</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a> *E)</td></tr>
<tr class="memdesc:a2a23bf214595570196cdf2cc5422717c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this expression is an enumerator-like expression of some type T, return the type T; otherwise, return null.  <br /></td></tr>
<tr class="separator:a2a23bf214595570196cdf2cc5422717c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b8aa8060275afc6f6e88f64a2405ed" id="r_a22b8aa8060275afc6f6e88f64a2405ed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1EnumDecl.html">EnumDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22b8aa8060275afc6f6e88f64a2405ed">findEnumForBlockReturn</a> (<a class="el" href="classclang_1_1ReturnStmt.html">ReturnStmt</a> *ret)</td></tr>
<tr class="memdesc:a22b8aa8060275afc6f6e88f64a2405ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to find a type T for which the returned expression of the given statement is an enumerator-like expression of that type.  <br /></td></tr>
<tr class="separator:a22b8aa8060275afc6f6e88f64a2405ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a540de78270c8112f864ce68f36b42b" id="r_a2a540de78270c8112f864ce68f36b42b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1EnumDecl.html">EnumDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a540de78270c8112f864ce68f36b42b">findCommonEnumForBlockReturns</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ReturnStmt.html">ReturnStmt</a> * &gt; returns)</td></tr>
<tr class="memdesc:a2a540de78270c8112f864ce68f36b42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to find a common type T for which all of the returned expressions in a block are enumerator-like expressions of that type.  <br /></td></tr>
<tr class="separator:a2a540de78270c8112f864ce68f36b42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea22d8618cf4f72bd846f643614b609" id="r_a5ea22d8618cf4f72bd846f643614b609"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ea22d8618cf4f72bd846f643614b609">adjustBlockReturnsToEnum</a> (<a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;S, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ReturnStmt.html">ReturnStmt</a> * &gt; returns, <a class="el" href="classclang_1_1QualType.html">QualType</a> returnType)</td></tr>
<tr class="memdesc:a5ea22d8618cf4f72bd846f643614b609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the given return statements so that they formally return the given type.  <br /></td></tr>
<tr class="separator:a5ea22d8618cf4f72bd846f643614b609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd6401199e221c212d27e34bf2e0d79" id="r_a4dd6401199e221c212d27e34bf2e0d79"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1sema_1_1LambdaScopeInfo.html">LambdaScopeInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dd6401199e221c212d27e34bf2e0d79">getCurrentLambdaScopeUnsafe</a> (<a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;S)</td></tr>
<tr class="separator:a4dd6401199e221c212d27e34bf2e0d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab32e2c5c4e3882fa28fcfb4537ff33d" id="r_aab32e2c5c4e3882fa28fcfb4537ff33d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1TypeSourceInfo.html">TypeSourceInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab32e2c5c4e3882fa28fcfb4537ff33d">getDummyLambdaType</a> (<a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;S, <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc=<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>())</td></tr>
<tr class="separator:aab32e2c5c4e3882fa28fcfb4537ff33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d75e06c21c1562afa7b4fb090a044e4" id="r_a2d75e06c21c1562afa7b4fb090a044e4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1TypeSourceInfo.html">TypeSourceInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d75e06c21c1562afa7b4fb090a044e4">getLambdaType</a> (<a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;S, <a class="el" href="structclang_1_1LambdaIntroducer.html">LambdaIntroducer</a> &amp;Intro, <a class="el" href="classclang_1_1Declarator.html">Declarator</a> &amp;ParamInfo, <a class="el" href="classclang_1_1Scope.html">Scope</a> *CurScope, <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &amp;ExplicitResultType)</td></tr>
<tr class="separator:a2d75e06c21c1562afa7b4fb090a044e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d2dcd4dca8ec258ca9964dfe21d0c4" id="r_ae2d2dcd4dca8ec258ca9964dfe21d0c4"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:ae2d2dcd4dca8ec258ca9964dfe21d0c4"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae2d2dcd4dca8ec258ca9964dfe21d0c4">repeatForLambdaConversionFunctionCallingConvs</a> (<a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;S, const <a class="el" href="classclang_1_1FunctionProtoType.html">FunctionProtoType</a> &amp;CallOpProto, Func F)</td></tr>
<tr class="separator:ae2d2dcd4dca8ec258ca9964dfe21d0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24320117e405b8e90f28df176290565d" id="r_a24320117e405b8e90f28df176290565d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceclang.html#ae6d16e133294b0b9c8c8d3108aadd25b">CallingConv</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24320117e405b8e90f28df176290565d">getLambdaConversionFunctionCallConv</a> (<a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;S, const <a class="el" href="classclang_1_1FunctionProtoType.html">FunctionProtoType</a> *CallOpProto)</td></tr>
<tr class="separator:a24320117e405b8e90f28df176290565d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21458033c133ccd3c5d645bee697669" id="r_af21458033c133ccd3c5d645bee697669"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af21458033c133ccd3c5d645bee697669">addFunctionPointerConversion</a> (<a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;S, <a class="el" href="classclang_1_1SourceRange.html">SourceRange</a> IntroducerRange, <a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a> *Class, <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> *CallOperator, <a class="el" href="classclang_1_1QualType.html">QualType</a> InvokerFunctionTy)</td></tr>
<tr class="memdesc:af21458033c133ccd3c5d645bee697669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a lambda's conversion to function pointer, as described in C++11 [expr.prim.lambda]p6.  <br /></td></tr>
<tr class="separator:af21458033c133ccd3c5d645bee697669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32d4bc3378f49de3bf268a9509f58a9" id="r_ad32d4bc3378f49de3bf268a9509f58a9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad32d4bc3378f49de3bf268a9509f58a9">addFunctionPointerConversions</a> (<a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;S, <a class="el" href="classclang_1_1SourceRange.html">SourceRange</a> IntroducerRange, <a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a> *Class, <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> *CallOperator)</td></tr>
<tr class="memdesc:ad32d4bc3378f49de3bf268a9509f58a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a lambda's conversion to function pointers, as described in C++11 [expr.prim.lambda]p6.  <br /></td></tr>
<tr class="separator:ad32d4bc3378f49de3bf268a9509f58a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d62418886722845a6f1dc5605bd21f9" id="r_a7d62418886722845a6f1dc5605bd21f9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d62418886722845a6f1dc5605bd21f9">addBlockPointerConversion</a> (<a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;S, <a class="el" href="classclang_1_1SourceRange.html">SourceRange</a> IntroducerRange, <a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a> *Class, <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> *CallOperator)</td></tr>
<tr class="memdesc:a7d62418886722845a6f1dc5605bd21f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a lambda's conversion to block pointer.  <br /></td></tr>
<tr class="separator:a7d62418886722845a6f1dc5605bd21f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e166aa63cd320ad61588025f241c48" id="r_a19e166aa63cd320ad61588025f241c48"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceclang.html#ac25c19be513bebdca2ed5f8ea0599ff3">LambdaCaptureDefault</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19e166aa63cd320ad61588025f241c48">mapImplicitCaptureStyle</a> (<a class="el" href="classclang_1_1sema_1_1CapturingScopeInfo.html#ac5dd383003c5fa015d574548c40621b4">CapturingScopeInfo::ImplicitCaptureStyle</a> ICS)</td></tr>
<tr class="separator:a19e166aa63cd320ad61588025f241c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7d62418886722845a6f1dc5605bd21f9" name="a7d62418886722845a6f1dc5605bd21f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d62418886722845a6f1dc5605bd21f9">&#9670;&#160;</a></span>addBlockPointerConversion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void addBlockPointerConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>S</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceRange.html">SourceRange</a></td>          <td class="paramname"><span class="paramname"><em>IntroducerRange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a> *</td>          <td class="paramname"><span class="paramname"><em>Class</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> *</td>          <td class="paramname"><span class="paramname"><em>CallOperator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a lambda's conversion to block pointer. </p>

<p class="definition">Definition at line <a class="el" href="SemaLambda_8cpp_source.html#l01723">1723</a> of file <a class="el" href="SemaLambda_8cpp_source.html">SemaLambda.cpp</a>.</p>

<p class="reference">References <a class="el" href="Type_8h_source.html#l00266">clang::Qualifiers::addConst()</a>, <a class="el" href="Specifiers_8h_source.html#l00115">clang::AS_public</a>, <a class="el" href="Type_8h_source.html#l07527">clang::Type::castAs()</a>, <a class="el" href="Sema_8h_source.html#l00407">clang::Sema::Context</a>, <a class="el" href="DeclCXX_8cpp_source.html#l02823">clang::CXXConversionDecl::Create()</a>, <a class="el" href="ASTContext_8h_source.html#l00634">clang::ASTContext::DeclarationNames</a>, <a class="el" href="SourceLocation_8h_source.html#l00219">clang::SourceRange::getBegin()</a>, <a class="el" href="ASTContext_8cpp_source.html#l03408">clang::ASTContext::getBlockPointerType()</a>, <a class="el" href="Decl_8cpp_source.html#l03138">clang::FunctionDecl::getBody()</a>, <a class="el" href="ASTContext_8h_source.html#l02524">clang::ASTContext::getCanonicalType()</a>, <a class="el" href="Sema_8h_source.html#l01682">clang::Sema::getCurFPFeatures()</a>, <a class="el" href="DeclarationName_8cpp_source.html#l00337">clang::DeclarationNameTable::getCXXConversionFunctionName()</a>, <a class="el" href="ASTContext_8cpp_source.html#l11976">clang::ASTContext::getDefaultCallingConvention()</a>, <a class="el" href="Stmt_8cpp_source.html#l00349">clang::Stmt::getEndLoc()</a>, <a class="el" href="ASTContext_8h_source.html#l01539">clang::ASTContext::getFunctionType()</a>, <a class="el" href="SemaLambda_8cpp_source.html#l01502">getLambdaConversionFunctionCallConv()</a>, <a class="el" href="SemaLambda_8cpp_source.html#l01517">clang::Sema::getLambdaConversionFunctionResultType()</a>, <a class="el" href="ASTContext_8cpp_source.html#l03005">clang::ASTContext::getTrivialTypeSourceInfo()</a>, <a class="el" href="Decl_8h_source.html#l00712">clang::ValueDecl::getType()</a>, <a class="el" href="LangOptions_8h_source.html#l00740">clang::FPOptions::isFPConstrained()</a>, <a class="el" href="DeclarationName_8h_source.html#l00738">clang::DeclarationNameLoc::makeNamedTypeLoc()</a>, <a class="el" href="DeclBase_8h_source.html#l00486">clang::Decl::setAccess()</a>, <a class="el" href="DeclBase_8h_source.html#l00577">clang::Decl::setImplicit()</a>, <a class="el" href="Type_8h_source.html#l04157">clang::FunctionProtoType::ExtProtoInfo::TypeQuals</a>, and <a class="el" href="namespaceclang.html#a3019e867704f9d3b354988f302282bc5a6fcdc090caeade09d0efd6253932b6f5">clang::Unspecified</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaLambda_8cpp_source.html#l01938">clang::Sema::BuildLambdaExpr()</a>.</p>

</div>
</div>
<a id="af21458033c133ccd3c5d645bee697669" name="af21458033c133ccd3c5d645bee697669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21458033c133ccd3c5d645bee697669">&#9670;&#160;</a></span>addFunctionPointerConversion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void addFunctionPointerConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>S</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceRange.html">SourceRange</a></td>          <td class="paramname"><span class="paramname"><em>IntroducerRange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a> *</td>          <td class="paramname"><span class="paramname"><em>Class</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> *</td>          <td class="paramname"><span class="paramname"><em>CallOperator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a></td>          <td class="paramname"><span class="paramname"><em>InvokerFunctionTy</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a lambda's conversion to function pointer, as described in C++11 [expr.prim.lambda]p6. </p>

<p class="definition">Definition at line <a class="el" href="SemaLambda_8cpp_source.html#l01532">1532</a> of file <a class="el" href="SemaLambda_8cpp_source.html">SemaLambda.cpp</a>.</p>

<p class="reference">References <a class="el" href="Type_8h_source.html#l00266">clang::Qualifiers::addConst()</a>, <a class="el" href="Specifiers_8h_source.html#l00117">clang::AS_private</a>, <a class="el" href="Specifiers_8h_source.html#l00115">clang::AS_public</a>, <a class="el" href="namespaceclang.html#a3019e867704f9d3b354988f302282bc5a0a5c6fb6c25c8100625a4f76bde030a1">clang::Constexpr</a>, <a class="el" href="Sema_8h_source.html#l00407">clang::Sema::Context</a>, <a class="el" href="DeclCXX_8cpp_source.html#l02823">clang::CXXConversionDecl::Create()</a>, <a class="el" href="DeclCXX_8cpp_source.html#l02232">clang::CXXMethodDecl::Create()</a>, <a class="el" href="DeclTemplate_8cpp_source.html#l00410">clang::FunctionTemplateDecl::Create()</a>, <a class="el" href="Decl_8cpp_source.html#l02852">clang::ParmVarDecl::Create()</a>, <a class="el" href="ASTContext_8h_source.html#l00634">clang::ASTContext::DeclarationNames</a>, <a class="el" href="ExceptionSpecificationType_8h_source.html#l00026">clang::EST_BasicNoexcept</a>, <a class="el" href="Type_8h_source.html#l04159">clang::FunctionProtoType::ExtProtoInfo::ExceptionSpec</a>, <a class="el" href="IdentifierTable_8h_source.html#l00639">clang::IdentifierTable::get()</a>, <a class="el" href="TypeLoc_8h_source.html#l00088">clang::TypeLoc::getAs()</a>, <a class="el" href="SourceLocation_8h_source.html#l00219">clang::SourceRange::getBegin()</a>, <a class="el" href="Decl_8h_source.html#l00817">clang::DeclaratorDecl::getBeginLoc()</a>, <a class="el" href="Decl_8cpp_source.html#l03138">clang::FunctionDecl::getBody()</a>, <a class="el" href="ASTContext_8h_source.html#l02524">clang::ASTContext::getCanonicalType()</a>, <a class="el" href="Decl_8h_source.html#l02371">clang::FunctionDecl::getConstexprKind()</a>, <a class="el" href="Sema_8h_source.html#l01682">clang::Sema::getCurFPFeatures()</a>, <a class="el" href="DeclarationName_8cpp_source.html#l00337">clang::DeclarationNameTable::getCXXConversionFunctionName()</a>, <a class="el" href="ASTContext_8cpp_source.html#l11976">clang::ASTContext::getDefaultCallingConvention()</a>, <a class="el" href="Decl_8cpp_source.html#l03916">clang::FunctionDecl::getDescribedFunctionTemplate()</a>, <a class="el" href="Stmt_8cpp_source.html#l00349">clang::Stmt::getEndLoc()</a>, <a class="el" href="ASTContext_8h_source.html#l01539">clang::ASTContext::getFunctionType()</a>, <a class="el" href="Decl_8h_source.html#l00268">clang::NamedDecl::getIdentifier()</a>, <a class="el" href="ASTLambda_8h_source.html#l00022">clang::getLambdaStaticInvokerName()</a>, <a class="el" href="Sema_8h_source.html#l01680">clang::Sema::getLangOpts()</a>, <a class="el" href="DeclBase_8h_source.html#l00432">clang::Decl::getLocation()</a>, <a class="el" href="Decl_8cpp_source.html#l03580">clang::FunctionDecl::getNumParams()</a>, <a class="el" href="Decl_8h_source.html#l02624">clang::FunctionDecl::getParamDecl()</a>, <a class="el" href="ASTContext_8cpp_source.html#l03316">clang::ASTContext::getPointerType()</a>, <a class="el" href="TypeLoc_8h_source.html#l01472">clang::FunctionTypeLoc::getReturnLoc()</a>, <a class="el" href="Decl_8h_source.html#l01125">clang::VarDecl::getStorageClass()</a>, <a class="el" href="DeclTemplate_8h_source.html#l00428">clang::TemplateDecl::getTemplateParameters()</a>, <a class="el" href="Decl_8h_source.html#l00841">clang::DeclaratorDecl::getTrailingRequiresClause()</a>, <a class="el" href="ASTContext_8h_source.html#l01059">clang::ASTContext::getTranslationUnitDecl()</a>, <a class="el" href="ASTContext_8cpp_source.html#l03005">clang::ASTContext::getTrivialTypeSourceInfo()</a>, <a class="el" href="Decl_8h_source.html#l00712">clang::ValueDecl::getType()</a>, <a class="el" href="TypeLoc_8h_source.html#l00249">clang::TypeSourceInfo::getTypeLoc()</a>, <a class="el" href="Decl_8h_source.html#l00794">clang::DeclaratorDecl::getTypeSourceInfo()</a>, <a class="el" href="ASTContext_8h_source.html#l00630">clang::ASTContext::Idents</a>, <a class="el" href="LangOptions_8h_source.html#l00740">clang::FPOptions::isFPConstrained()</a>, <a class="el" href="DeclCXX_8h_source.html#l02062">clang::CXXMethodDecl::isInstance()</a>, <a class="el" href="DeclarationName_8h_source.html#l00738">clang::DeclarationNameLoc::makeNamedTypeLoc()</a>, <a class="el" href="BuildTree_8cpp_source.html#l01601">N</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00564">P</a>, <a class="el" href="Decl_8h_source.html#l02601">clang::FunctionDecl::parameters()</a>, <a class="el" href="Specifiers_8h_source.html#l00243">clang::SC_Static</a>, <a class="el" href="DeclBase_8h_source.html#l00486">clang::Decl::setAccess()</a>, <a class="el" href="Decl_8cpp_source.html#l03921">clang::FunctionDecl::setDescribedFunctionTemplate()</a>, <a class="el" href="DeclBase_8h_source.html#l00577">clang::Decl::setImplicit()</a>, <a class="el" href="Decl_8h_source.html#l02632">clang::FunctionDecl::setParams()</a>, <a class="el" href="Decl_8cpp_source.html#l01962">clang::DeclaratorDecl::setTrailingRequiresClause()</a>, <a class="el" href="Type_8h_source.html#l04129">clang::FunctionProtoType::ExceptionSpecInfo::Type</a>, <a class="el" href="Type_8h_source.html#l04157">clang::FunctionProtoType::ExtProtoInfo::TypeQuals</a>, and <a class="el" href="namespaceclang.html#a3019e867704f9d3b354988f302282bc5a6fcdc090caeade09d0efd6253932b6f5">clang::Unspecified</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaLambda_8cpp_source.html#l01707">addFunctionPointerConversions()</a>.</p>

</div>
</div>
<a id="ad32d4bc3378f49de3bf268a9509f58a9" name="ad32d4bc3378f49de3bf268a9509f58a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32d4bc3378f49de3bf268a9509f58a9">&#9670;&#160;</a></span>addFunctionPointerConversions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void addFunctionPointerConversions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>S</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceRange.html">SourceRange</a></td>          <td class="paramname"><span class="paramname"><em>IntroducerRange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a> *</td>          <td class="paramname"><span class="paramname"><em>Class</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> *</td>          <td class="paramname"><span class="paramname"><em>CallOperator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a lambda's conversion to function pointers, as described in C++11 [expr.prim.lambda]p6. </p>
<p>Note that in most cases, this should emit only a single pointer conversion. In the event that the default calling convention for free and member functions is different, it will emit both conventions. </p>

<p class="definition">Definition at line <a class="el" href="SemaLambda_8cpp_source.html#l01707">1707</a> of file <a class="el" href="SemaLambda_8cpp_source.html">SemaLambda.cpp</a>.</p>

<p class="reference">References <a class="el" href="SemaLambda_8cpp_source.html#l01532">addFunctionPointerConversion()</a>, <a class="el" href="Type_8h_source.html#l07527">clang::Type::castAs()</a>, <a class="el" href="SemaLambda_8cpp_source.html#l01517">clang::Sema::getLambdaConversionFunctionResultType()</a>, <a class="el" href="Decl_8h_source.html#l00712">clang::ValueDecl::getType()</a>, and <a class="el" href="SemaLambda_8cpp_source.html#l01454">repeatForLambdaConversionFunctionCallingConvs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaLambda_8cpp_source.html#l01938">clang::Sema::BuildLambdaExpr()</a>.</p>

</div>
</div>
<a id="a5ea22d8618cf4f72bd846f643614b609" name="a5ea22d8618cf4f72bd846f643614b609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea22d8618cf4f72bd846f643614b609">&#9670;&#160;</a></span>adjustBlockReturnsToEnum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void adjustBlockReturnsToEnum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>S</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ReturnStmt.html">ReturnStmt</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>returns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a></td>          <td class="paramname"><span class="paramname"><em>returnType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjust the given return statements so that they formally return the given type. </p>
<p>It should require, at most, an IntegralCast. </p>

<p class="definition">Definition at line <a class="el" href="SemaLambda_8cpp_source.html#l00589">589</a> of file <a class="el" href="SemaLambda_8cpp_source.html">SemaLambda.cpp</a>.</p>

<p class="reference">References <a class="el" href="Sema_8h_source.html#l00407">clang::Sema::Context</a>, <a class="el" href="Expr_8cpp_source.html#l02090">clang::ImplicitCastExpr::Create()</a>, <a class="el" href="Stmt_8h_source.html#l02871">clang::ReturnStmt::getRetValue()</a>, <a class="el" href="Expr_8h_source.html#l01032">clang::FullExpr::getSubExpr()</a>, <a class="el" href="Expr_8h_source.html#l00142">clang::Expr::getType()</a>, <a class="el" href="ASTContext_8h_source.html#l02540">clang::ASTContext::hasSameType()</a>, <a class="el" href="Type_8cpp_source.html#l01988">clang::Type::isIntegralOrUnscopedEnumerationType()</a>, <a class="el" href="Stmt_8h_source.html#l02873">clang::ReturnStmt::setRetValue()</a>, <a class="el" href="Expr_8h_source.html#l01037">clang::FullExpr::setSubExpr()</a>, and <a class="el" href="Specifiers_8h_source.html#l00126">clang::VK_PRValue</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaLambda_8cpp_source.html#l00616">clang::Sema::deduceClosureReturnType()</a>.</p>

</div>
</div>
<a id="a8791c31e2db2c405252b58a96de9ce95" name="a8791c31e2db2c405252b58a96de9ce95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8791c31e2db2c405252b58a96de9ce95">&#9670;&#160;</a></span>buildLambdaScopeReturnType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buildLambdaScopeReturnType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>S</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1sema_1_1LambdaScopeInfo.html">LambdaScopeInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>LSI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> *</td>          <td class="paramname"><span class="paramname"><em>CallOperator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>ExplicitResultType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SemaLambda_8cpp_source.html#l00434">434</a> of file <a class="el" href="SemaLambda_8cpp_source.html">SemaLambda.cpp</a>.</p>

<p class="reference">References <a class="el" href="Decl_8h_source.html#l00817">clang::DeclaratorDecl::getBeginLoc()</a>, <a class="el" href="Decl_8h_source.html#l02655">clang::FunctionDecl::getReturnType()</a>, <a class="el" href="ScopeInfo_8h_source.html#l00700">clang::sema::CapturingScopeInfo::HasImplicitReturnType</a>, <a class="el" href="Type_8h_source.html#l02345">clang::Type::isDependentType()</a>, <a class="el" href="Type_8h_source.html#l07254">clang::Type::isVoidType()</a>, <a class="el" href="SemaType_8cpp_source.html#l08917">clang::Sema::RequireCompleteType()</a>, and <a class="el" href="ScopeInfo_8h_source.html#l00704">clang::sema::CapturingScopeInfo::ReturnType</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaLambda_8cpp_source.html#l00915">clang::Sema::CompleteLambdaCallOperator()</a>.</p>

</div>
</div>
<a id="ab75263a5d41b23a1db491c39fb33883a" name="ab75263a5d41b23a1db491c39fb33883a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75263a5d41b23a1db491c39fb33883a">&#9670;&#160;</a></span>buildTypeForLambdaCallOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1QualType.html">QualType</a> buildTypeForLambdaCallOperator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>S</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXRecordDecl.html">clang::CXXRecordDecl</a> *</td>          <td class="paramname"><span class="paramname"><em>Class</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1TemplateParameterList.html">TemplateParameterList</a> *</td>          <td class="paramname"><span class="paramname"><em>TemplateParams</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1TypeSourceInfo.html">TypeSourceInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>MethodTypeInfo</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SemaLambda_8cpp_source.html#l00360">360</a> of file <a class="el" href="SemaLambda_8cpp_source.html">SemaLambda.cpp</a>.</p>

<p class="reference">References <a class="el" href="Type_8h_source.html#l07527">clang::Type::castAs()</a>, <a class="el" href="Sema_8h_source.html#l00407">clang::Sema::Context</a>, <a class="el" href="Type_8h_source.html#l04292">clang::FunctionProtoType::getExtProtoInfo()</a>, <a class="el" href="ASTContext_8h_source.html#l01539">clang::ASTContext::getFunctionType()</a>, <a class="el" href="Type_8h_source.html#l04288">clang::FunctionProtoType::getParamTypes()</a>, <a class="el" href="Type_8h_source.html#l03994">clang::FunctionType::getReturnType()</a>, <a class="el" href="Type_8h_source.html#l06666">clang::TypeSourceInfo::getType()</a>, <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>, and <a class="el" href="SemaTemplateDeduction_8cpp_source.html#l04941">clang::Sema::SubstAutoTypeDependent()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaLambda_8cpp_source.html#l00915">clang::Sema::CompleteLambdaCallOperator()</a>.</p>

</div>
</div>
<a id="a2a540de78270c8112f864ce68f36b42b" name="a2a540de78270c8112f864ce68f36b42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a540de78270c8112f864ce68f36b42b">&#9670;&#160;</a></span>findCommonEnumForBlockReturns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1EnumDecl.html">EnumDecl</a> * findCommonEnumForBlockReturns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ReturnStmt.html">ReturnStmt</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>returns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to find a common type T for which all of the returned expressions in a block are enumerator-like expressions of that type. </p>

<p class="definition">Definition at line <a class="el" href="SemaLambda_8cpp_source.html#l00568">568</a> of file <a class="el" href="SemaLambda_8cpp_source.html">SemaLambda.cpp</a>.</p>

<p class="reference">References <a class="el" href="SemaLambda_8cpp_source.html#l00496">findEnumForBlockReturn()</a>, and <a class="el" href="Decl_8h_source.html#l03691">clang::TagDecl::hasNameForLinkage()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaLambda_8cpp_source.html#l00616">clang::Sema::deduceClosureReturnType()</a>.</p>

</div>
</div>
<a id="a2a23bf214595570196cdf2cc5422717c" name="a2a23bf214595570196cdf2cc5422717c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a23bf214595570196cdf2cc5422717c">&#9670;&#160;</a></span>findEnumForBlockReturn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1EnumDecl.html">EnumDecl</a> * findEnumForBlockReturn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a> *</td>          <td class="paramname"><span class="paramname"><em>E</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this expression is an enumerator-like expression of some type T, return the type T; otherwise, return null. </p>
<p>Pointer comparisons on the result here should always work because it's derived from either the parent of an EnumConstantDecl (i.e. the definition) or the declaration returned by EnumType::getDecl() (i.e. the definition). </p>

<p class="definition">Definition at line <a class="el" href="SemaLambda_8cpp_source.html#l00496">496</a> of file <a class="el" href="SemaLambda_8cpp_source.html">SemaLambda.cpp</a>.</p>

<p class="reference">References <a class="el" href="Address_8h_source.html#l00152">clang::cast()</a>, <a class="el" href="SemaLambda_8cpp_source.html#l00496">findEnumForBlockReturn()</a>, <a class="el" href="Type_8h_source.html#l07460">clang::Type::getAs()</a>, <a class="el" href="Expr_8h_source.html#l00142">clang::Expr::getType()</a>, and <a class="el" href="Expr_8cpp_source.html#l03068">clang::Expr::IgnoreParens()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaLambda_8cpp_source.html#l00568">findCommonEnumForBlockReturns()</a>, <a class="el" href="SemaLambda_8cpp_source.html#l00496">findEnumForBlockReturn()</a>, and <a class="el" href="SemaLambda_8cpp_source.html#l00559">findEnumForBlockReturn()</a>.</p>

</div>
</div>
<a id="a22b8aa8060275afc6f6e88f64a2405ed" name="a22b8aa8060275afc6f6e88f64a2405ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b8aa8060275afc6f6e88f64a2405ed">&#9670;&#160;</a></span>findEnumForBlockReturn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1EnumDecl.html">EnumDecl</a> * findEnumForBlockReturn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ReturnStmt.html">ReturnStmt</a> *</td>          <td class="paramname"><span class="paramname"><em>ret</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to find a type T for which the returned expression of the given statement is an enumerator-like expression of that type. </p>

<p class="definition">Definition at line <a class="el" href="SemaLambda_8cpp_source.html#l00559">559</a> of file <a class="el" href="SemaLambda_8cpp_source.html">SemaLambda.cpp</a>.</p>

<p class="reference">References <a class="el" href="SemaLambda_8cpp_source.html#l00496">findEnumForBlockReturn()</a>, and <a class="el" href="Stmt_8h_source.html#l02871">clang::ReturnStmt::getRetValue()</a>.</p>

</div>
</div>
<a id="a4dd6401199e221c212d27e34bf2e0d79" name="a4dd6401199e221c212d27e34bf2e0d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd6401199e221c212d27e34bf2e0d79">&#9670;&#160;</a></span>getCurrentLambdaScopeUnsafe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1sema_1_1LambdaScopeInfo.html">LambdaScopeInfo</a> * getCurrentLambdaScopeUnsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>S</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SemaLambda_8cpp_source.html#l00810">810</a> of file <a class="el" href="SemaLambda_8cpp_source.html">SemaLambda.cpp</a>.</p>

<p class="reference">References <a class="el" href="Address_8h_source.html#l00152">clang::cast()</a>, and <a class="el" href="Sema_8h_source.html#l00821">clang::Sema::FunctionScopes</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaLambda_8cpp_source.html#l01249">clang::Sema::ActOnLambdaClosureParameters()</a>, <a class="el" href="SemaLambda_8cpp_source.html#l01223">clang::Sema::ActOnLambdaClosureQualifiers()</a>, <a class="el" href="SemaLambda_8cpp_source.html#l01264">clang::Sema::ActOnStartOfLambdaDefinition()</a>, and <a class="el" href="SemaLambda_8cpp_source.html#l00915">clang::Sema::CompleteLambdaCallOperator()</a>.</p>

</div>
</div>
<a id="aab32e2c5c4e3882fa28fcfb4537ff33d" name="aab32e2c5c4e3882fa28fcfb4537ff33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab32e2c5c4e3882fa28fcfb4537ff33d">&#9670;&#160;</a></span>getDummyLambdaType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1TypeSourceInfo.html">TypeSourceInfo</a> * getDummyLambdaType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>S</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>Loc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SemaLambda_8cpp_source.html#l00816">816</a> of file <a class="el" href="SemaLambda_8cpp_source.html">SemaLambda.cpp</a>.</p>

<p class="reference">References <a class="el" href="Type_8h_source.html#l00403">clang::Qualifiers::addAddressSpace()</a>, <a class="el" href="Type_8h_source.html#l00266">clang::Qualifiers::addConst()</a>, <a class="el" href="Sema_8h_source.html#l00407">clang::Sema::Context</a>, <a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793aa7a1920d61156abc05a60135aefe8bc67">clang::Default</a>, <a class="el" href="ASTContext_8h_source.html#l01105">clang::ASTContext::DependentTy</a>, <a class="el" href="ASTContext_8cpp_source.html#l05922">clang::ASTContext::getAutoDeductType()</a>, <a class="el" href="ASTContext_8cpp_source.html#l11976">clang::ASTContext::getDefaultCallingConvention()</a>, <a class="el" href="Sema_8cpp_source.html#l01494">clang::Sema::getDefaultCXXMethodAddrSpace()</a>, <a class="el" href="ASTContext_8h_source.html#l01539">clang::ASTContext::getFunctionType()</a>, <a class="el" href="Sema_8h_source.html#l01680">clang::Sema::getLangOpts()</a>, <a class="el" href="ASTContext_8cpp_source.html#l03005">clang::ASTContext::getTrivialTypeSourceInfo()</a>, <a class="el" href="Type_8h_source.html#l04156">clang::FunctionProtoType::ExtProtoInfo::HasTrailingReturn</a>, and <a class="el" href="Type_8h_source.html#l04157">clang::FunctionProtoType::ExtProtoInfo::TypeQuals</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaLambda_8cpp_source.html#l00842">getLambdaType()</a>.</p>

</div>
</div>
<a id="a628d675bca07496e0ef85b4efe340c25" name="a628d675bca07496e0ef85b4efe340c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628d675bca07496e0ef85b4efe340c25">&#9670;&#160;</a></span>getGenericLambdaTemplateParameterList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1TemplateParameterList.html">TemplateParameterList</a> * getGenericLambdaTemplateParameterList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1sema_1_1LambdaScopeInfo.html">LambdaScopeInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>LSI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SemaRef</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SemaLambda_8cpp_source.html#l00230">230</a> of file <a class="el" href="SemaLambda_8cpp_source.html">SemaLambda.cpp</a>.</p>

<p class="reference">References <a class="el" href="Sema_8h_source.html#l00407">clang::Sema::Context</a>, <a class="el" href="ScopeInfo_8h_source.html#l00878">clang::sema::LambdaScopeInfo::ExplicitTemplateParamsRange</a>, <a class="el" href="Ownership_8h_source.html#l00169">clang::ActionResult&lt; PtrTy, CompressInvalid &gt;::get()</a>, <a class="el" href="SourceLocation_8h_source.html#l00219">clang::SourceRange::getBegin()</a>, <a class="el" href="SourceLocation_8h_source.html#l00220">clang::SourceRange::getEnd()</a>, <a class="el" href="ScopeInfo_8h_source.html#l00888">clang::sema::LambdaScopeInfo::GLTemplateParameterList</a>, <a class="el" href="ScopeInfo_8h_source.html#l00883">clang::sema::LambdaScopeInfo::RequiresClause</a>, and <a class="el" href="DeclSpec_8h_source.html#l02813">clang::InventedTemplateParameterInfo::TemplateParams</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaLambda_8cpp_source.html#l01264">clang::Sema::ActOnStartOfLambdaDefinition()</a>, <a class="el" href="SemaLambda_8cpp_source.html#l00915">clang::Sema::CompleteLambdaCallOperator()</a>, and <a class="el" href="SemaLambda_8cpp_source.html#l00244">clang::Sema::createLambdaClosureType()</a>.</p>

</div>
</div>
<a id="a24320117e405b8e90f28df176290565d" name="a24320117e405b8e90f28df176290565d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24320117e405b8e90f28df176290565d">&#9670;&#160;</a></span>getLambdaConversionFunctionCallConv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceclang.html#ae6d16e133294b0b9c8c8d3108aadd25b">CallingConv</a> getLambdaConversionFunctionCallConv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>S</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FunctionProtoType.html">FunctionProtoType</a> *</td>          <td class="paramname"><span class="paramname"><em>CallOpProto</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SemaLambda_8cpp_source.html#l01502">1502</a> of file <a class="el" href="SemaLambda_8cpp_source.html">SemaLambda.cpp</a>.</p>

<p class="reference">References <a class="el" href="Sema_8h_source.html#l00407">clang::Sema::Context</a>, <a class="el" href="Type_8h_source.html#l04005">clang::FunctionType::getCallConv()</a>, <a class="el" href="ASTContext_8cpp_source.html#l11976">clang::ASTContext::getDefaultCallingConvention()</a>, and <a class="el" href="Type_8h_source.html#l04403">clang::FunctionProtoType::isVariadic()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaLambda_8cpp_source.html#l01723">addBlockPointerConversion()</a>.</p>

</div>
</div>
<a id="a2d75e06c21c1562afa7b4fb090a044e4" name="a2d75e06c21c1562afa7b4fb090a044e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d75e06c21c1562afa7b4fb090a044e4">&#9670;&#160;</a></span>getLambdaType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1TypeSourceInfo.html">TypeSourceInfo</a> * getLambdaType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>S</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1LambdaIntroducer.html">LambdaIntroducer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Intro</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Declarator.html">Declarator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ParamInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Scope.html">Scope</a> *</td>          <td class="paramname"><span class="paramname"><em>CurScope</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>Loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ExplicitResultType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SemaLambda_8cpp_source.html#l00842">842</a> of file <a class="el" href="SemaLambda_8cpp_source.html">SemaLambda.cpp</a>.</p>

<p class="reference">References <a class="el" href="Type_8h_source.html#l02017">clang::Type::containsUnexpandedParameterPack()</a>, <a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793aa7a1920d61156abc05a60135aefe8bc67">clang::Default</a>, <a class="el" href="Sema_8cpp_source.html#l01897">clang::Sema::Diag()</a>, <a class="el" href="SemaTemplateVariadic_8cpp_source.html#l00381">clang::Sema::DiagnoseUnexpandedParameterPack()</a>, <a class="el" href="Ownership_8h_source.html#l00080">clang::OpaquePtr&lt; PtrTy &gt;::get()</a>, <a class="el" href="Type_8h_source.html#l06809">clang::QualType::getAddressSpace()</a>, <a class="el" href="SourceLocation_8h_source.html#l00219">clang::SourceRange::getBegin()</a>, <a class="el" href="DeclSpec_8h_source.html#l01986">clang::Declarator::getDeclSpec()</a>, <a class="el" href="SemaLambda_8cpp_source.html#l00816">getDummyLambdaType()</a>, <a class="el" href="DeclSpec_8h_source.html#l02409">clang::Declarator::getFunctionTypeInfo()</a>, <a class="el" href="Sema_8h_source.html#l01680">clang::Sema::getLangOpts()</a>, <a class="el" href="DeclSpec_8h_source.html#l02316">clang::Declarator::getNumTypeObjects()</a>, <a class="el" href="DeclSpec_8h_source.html#l01448">clang::DeclaratorChunk::FunctionTypeInfo::getOrCreateMethodQualifiers()</a>, <a class="el" href="DeclSpec_8h_source.html#l00475">clang::DeclSpec::getStorageClassSpec()</a>, <a class="el" href="DeclSpec_8h_source.html#l01540">clang::DeclaratorChunk::FunctionTypeInfo::getTrailingReturnType()</a>, <a class="el" href="DeclSpec_8h_source.html#l01546">clang::DeclaratorChunk::FunctionTypeInfo::getTrailingReturnTypeLoc()</a>, <a class="el" href="Type_8h_source.html#l06666">clang::TypeSourceInfo::getType()</a>, <a class="el" href="SemaType_8cpp_source.html#l05992">clang::Sema::GetTypeForDeclarator()</a>, <a class="el" href="DeclSpec_8h_source.html#l01509">clang::DeclaratorChunk::FunctionTypeInfo::hasMutableQualifier()</a>, <a class="el" href="DeclSpec_8h_source.html#l01537">clang::DeclaratorChunk::FunctionTypeInfo::hasTrailingReturnType()</a>, <a class="el" href="Type_8h_source.html#l00803">clang::QualType::isNull()</a>, <a class="el" href="DeclSpec_8h_source.html#l02770">clang::LambdaIntroducer::Range</a>, <a class="el" href="DeclSpec_8h_source.html#l00254">clang::DeclSpec::SCS_static</a>, <a class="el" href="DeclSpec_8h_source.html#l00251">clang::DeclSpec::SCS_unspecified</a>, <a class="el" href="DeclSpec_8cpp_source.html#l00980">clang::DeclSpec::SetTypeQual()</a>, <a class="el" href="DeclSpec_8h_source.html#l00327">clang::DeclSpec::TQ_const</a>, and <a class="el" href="Sema_8h_source.html#l08695">clang::Sema::UPPC_DeclarationType</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaLambda_8cpp_source.html#l01264">clang::Sema::ActOnStartOfLambdaDefinition()</a>.</p>

</div>
</div>
<a id="a41725a12d87ce3093bd2295930a4ca3d" name="a41725a12d87ce3093bd2295930a4ca3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41725a12d87ce3093bd2295930a4ca3d">&#9670;&#160;</a></span>getStackIndexOfNearestEnclosingCaptureReadyLambda()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; getStackIndexOfNearestEnclosingCaptureReadyLambda </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classclang_1_1sema_1_1FunctionScopeInfo.html">clang::sema::FunctionScopeInfo</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>FunctionScopes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ValueDecl.html">ValueDecl</a> *</td>          <td class="paramname"><span class="paramname"><em>VarToCapture</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Examines the FunctionScopeInfo stack to determine the nearest enclosing lambda (to the current lambda) that is 'capture-ready' for the variable referenced in the current lambda (i.e. </p>
<p><code>VarToCapture</code>). If successful, returns the index into Sema's FunctionScopeInfo stack of the capture-ready lambda's LambdaScopeInfo.</p>
<p>Climbs down the stack of lambdas (deepest nested lambda - i.e. current lambda - is on top) to determine the index of the nearest enclosing/outer lambda that is ready to capture the <code>VarToCapture</code> being referenced in the current lambda. As we climb down the stack, we want the index of the first such lambda - that is the lambda with the highest index that is 'capture-ready'.</p>
<p>A lambda 'L' is capture-ready for 'V' (var or this) if:</p><ul>
<li>its enclosing context is non-dependent</li>
<li>and if the chain of lambdas between L and the lambda in which V is potentially used (i.e. the lambda at the top of the scope info stack), can all capture or have already captured V. If <code>VarToCapture</code> is 'null' then we are trying to capture 'this'.</li>
</ul>
<p>Note that a lambda that is deemed 'capture-ready' still needs to be checked for whether it is 'capture-capable' (see getStackIndexOfNearestEnclosingCaptureCapableLambda), before it can truly capture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FunctionScopes</td><td>- Sema's stack of nested FunctionScopeInfo's (which a LambdaScopeInfo inherits from). The current/deepest/innermost lambda is at the top of the stack and has the highest index. </td></tr>
    <tr><td class="paramname">VarToCapture</td><td>- the variable to capture. If NULL, capture 'this'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An std::optional&lt;unsigned&gt; Index that if evaluates to 'true' contains the index (into Sema's FunctionScopeInfo stack) of the innermost lambda which is capture-ready. If the return value evaluates to 'false' then no lambda is capture-ready for <code>VarToCapture</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SemaLambda_8cpp_source.html#l00064">64</a> of file <a class="el" href="SemaLambda_8cpp_source.html">SemaLambda.cpp</a>.</p>

<p class="reference">References <a class="el" href="Address_8h_source.html#l00152">clang::cast()</a>, <a class="el" href="DeclBase_8h_source.html#l02075">clang::DeclContext::Equals()</a>, <a class="el" href="DeclBase_8h_source.html#l00441">clang::Decl::getDeclContext()</a>, <a class="el" href="ASTLambda_8h_source.html#l00080">clang::getLambdaAwareParentOfDeclContext()</a>, <a class="el" href="ScopeInfo_8h_source.html#l00683">clang::sema::CapturingScopeInfo::ImpCaptureStyle</a>, <a class="el" href="ScopeInfo_8h_source.html#l00733">clang::sema::CapturingScopeInfo::isCaptured()</a>, <a class="el" href="ScopeInfo_8h_source.html#l00724">clang::sema::CapturingScopeInfo::isCXXThisCaptured()</a>, <a class="el" href="DeclBase_8cpp_source.html#l01209">clang::DeclContext::isDependentContext()</a>, <a class="el" href="ASTLambda_8h_source.html#l00027">clang::isLambdaCallOperator()</a>, and <a class="el" href="DeclBase_8h_source.html#l02026">clang::DeclContext::isTranslationUnit()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaLambda_8cpp_source.html#l00175">clang::getStackIndexOfNearestEnclosingCaptureCapableLambda()</a>.</p>

</div>
</div>
<a id="ac7a5afd241a6316c3b3f6103e6c706d3" name="ac7a5afd241a6316c3b3f6103e6c706d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a5afd241a6316c3b3f6103e6c706d3">&#9670;&#160;</a></span>isInInlineFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> isInInlineFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DeclContext.html">DeclContext</a> *</td>          <td class="paramname"><span class="paramname"><em>DC</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the given context is or is enclosed in an inline function. </p>

<p class="definition">Definition at line <a class="el" href="SemaLambda_8cpp_source.html#l00264">264</a> of file <a class="el" href="SemaLambda_8cpp_source.html">SemaLambda.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeclBase_8h_source.html#l01967">clang::DeclContext::getLexicalParent()</a>, and <a class="el" href="DeclBase_8h_source.html#l02021">clang::DeclContext::isFileContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaLambda_8cpp_source.html#l00277">clang::Sema::getCurrentMangleNumberContext()</a>.</p>

</div>
</div>
<a id="a19e166aa63cd320ad61588025f241c48" name="a19e166aa63cd320ad61588025f241c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e166aa63cd320ad61588025f241c48">&#9670;&#160;</a></span>mapImplicitCaptureStyle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceclang.html#ac25c19be513bebdca2ed5f8ea0599ff3">LambdaCaptureDefault</a> mapImplicitCaptureStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1sema_1_1CapturingScopeInfo.html#ac5dd383003c5fa015d574548c40621b4">CapturingScopeInfo::ImplicitCaptureStyle</a></td>          <td class="paramname"><span class="paramname"><em>ICS</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SemaLambda_8cpp_source.html#l01830">1830</a> of file <a class="el" href="SemaLambda_8cpp_source.html">SemaLambda.cpp</a>.</p>

<p class="reference">References <a class="el" href="ScopeInfo_8h_source.html#l00679">clang::sema::CapturingScopeInfo::ImpCap_Block</a>, <a class="el" href="ScopeInfo_8h_source.html#l00680">clang::sema::CapturingScopeInfo::ImpCap_CapturedRegion</a>, <a class="el" href="ScopeInfo_8h_source.html#l00679">clang::sema::CapturingScopeInfo::ImpCap_LambdaByref</a>, <a class="el" href="ScopeInfo_8h_source.html#l00679">clang::sema::CapturingScopeInfo::ImpCap_LambdaByval</a>, <a class="el" href="ScopeInfo_8h_source.html#l00679">clang::sema::CapturingScopeInfo::ImpCap_None</a>, <a class="el" href="Lambda_8h_source.html#l00024">clang::LCD_ByCopy</a>, <a class="el" href="Lambda_8h_source.html#l00025">clang::LCD_ByRef</a>, and <a class="el" href="Lambda_8h_source.html#l00023">clang::LCD_None</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaLambda_8cpp_source.html#l01938">clang::Sema::BuildLambdaExpr()</a>.</p>

</div>
</div>
<a id="ae2d2dcd4dca8ec258ca9964dfe21d0c4" name="ae2d2dcd4dca8ec258ca9964dfe21d0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d2dcd4dca8ec258ca9964dfe21d0c4">&#9670;&#160;</a></span>repeatForLambdaConversionFunctionCallingConvs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void repeatForLambdaConversionFunctionCallingConvs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Sema.html">Sema</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>S</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FunctionProtoType.html">FunctionProtoType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>CallOpProto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>F</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implement emitting a version of the operator for many of the calling conventions for MSVC, as described here: <a href="https://devblogs.microsoft.com/oldnewthing/20150220-00/?p=44623">https://devblogs.microsoft.com/oldnewthing/20150220-00/?p=44623</a>. Experimentally, we determined that cdecl, stdcall, fastcall, and vectorcall are generated by MSVC when it is supported by the target. Additionally, we are ensuring that the default-free/default-member and call-operator calling convention are generated as well. NOTE: We intentionally generate a 'thiscall' on Win32 implicitly from the 'member default', despite MSVC not doing so. We do this in order to ensure that someone who intentionally places 'thiscall' on the lambda call operator will still get that overload, since we don't have the a way of detecting the attribute by the time we get here.</p>

<p class="definition">Definition at line <a class="el" href="SemaLambda_8cpp_source.html#l01454">1454</a> of file <a class="el" href="SemaLambda_8cpp_source.html">SemaLambda.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a6f904bf7056cbce941d51eeebe3bfd5ca0d61f8370cad1d412f80b84d143e1257">clang::C</a>, <a class="el" href="Specifiers_8h_source.html#l00270">clang::CC_C</a>, <a class="el" href="Specifiers_8h_source.html#l00272">clang::CC_X86FastCall</a>, <a class="el" href="Specifiers_8h_source.html#l00271">clang::CC_X86StdCall</a>, <a class="el" href="Specifiers_8h_source.html#l00274">clang::CC_X86VectorCall</a>, <a class="el" href="include_2clang_2Basic_2TargetInfo_8h_source.html#l01584">clang::TargetInfo::CCCR_OK</a>, <a class="el" href="include_2clang_2Basic_2TargetInfo_8h_source.html#l01594">clang::TargetInfo::checkCallingConvention()</a>, <a class="el" href="Sema_8h_source.html#l00407">clang::Sema::Context</a>, <a class="el" href="Sema_8h_source.html#l01687">clang::Sema::getASTContext()</a>, <a class="el" href="Type_8h_source.html#l04005">clang::FunctionType::getCallConv()</a>, <a class="el" href="ASTContext_8cpp_source.html#l11976">clang::ASTContext::getDefaultCallingConvention()</a>, <a class="el" href="Sema_8h_source.html#l01680">clang::Sema::getLangOpts()</a>, <a class="el" href="ASTContext_8h_source.html#l00743">clang::ASTContext::getTargetInfo()</a>, and <a class="el" href="Type_8h_source.html#l04403">clang::FunctionProtoType::isVariadic()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaLambda_8cpp_source.html#l01707">addFunctionPointerConversions()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 8 2024 17:02:11 for clang by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
