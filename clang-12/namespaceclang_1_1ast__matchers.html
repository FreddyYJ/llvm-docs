<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: clang::ast_matchers Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">clang<span id="projectnumber">&#160;12.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceclang.html">clang</a></li><li class="navelem"><a class="el" href="namespaceclang_1_1ast__matchers.html">ast_matchers</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">clang::ast_matchers Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic.html">dynamic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps string IDs to AST nodes matched by parts of a matcher.  <a href="classclang_1_1ast__matchers_1_1BoundNodes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1MatchFinder.html">MatchFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to allow finding matches over the Clang AST.  <a href="classclang_1_1ast__matchers_1_1MatchFinder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1d77576823c6c764d94aca78ada0f5ad" id="r_a1d77576823c6c764d94aca78ada0f5ad"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d77576823c6c764d94aca78ada0f5ad">DeclarationMatcher</a> = internal::Matcher&lt;<a class="el" href="classclang_1_1Decl.html">Decl</a>&gt;</td></tr>
<tr class="memdesc:a1d77576823c6c764d94aca78ada0f5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of matchers for the top-level classes in the AST class hierarchy.  <br /></td></tr>
<tr class="separator:a1d77576823c6c764d94aca78ada0f5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85886610fb27988c71cb3d5134c2302d" id="r_a85886610fb27988c71cb3d5134c2302d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85886610fb27988c71cb3d5134c2302d">StatementMatcher</a> = internal::Matcher&lt;<a class="el" href="classclang_1_1Stmt.html">Stmt</a>&gt;</td></tr>
<tr class="separator:a85886610fb27988c71cb3d5134c2302d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ab01fccdd3cc9ddde2c6f7e46eadf9" id="r_a06ab01fccdd3cc9ddde2c6f7e46eadf9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06ab01fccdd3cc9ddde2c6f7e46eadf9">TypeMatcher</a> = internal::Matcher&lt;<a class="el" href="classclang_1_1QualType.html">QualType</a>&gt;</td></tr>
<tr class="separator:a06ab01fccdd3cc9ddde2c6f7e46eadf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39490ae02e4e117c2cbed029f651d52" id="r_af39490ae02e4e117c2cbed029f651d52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af39490ae02e4e117c2cbed029f651d52">TypeLocMatcher</a> = internal::Matcher&lt;<a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>&gt;</td></tr>
<tr class="separator:af39490ae02e4e117c2cbed029f651d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae372b9585fd8ebf144e729a1e9e16f86" id="r_ae372b9585fd8ebf144e729a1e9e16f86"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae372b9585fd8ebf144e729a1e9e16f86">NestedNameSpecifierMatcher</a> = internal::Matcher&lt;<a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a>&gt;</td></tr>
<tr class="separator:ae372b9585fd8ebf144e729a1e9e16f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df0d28652c188eeeb58c5ee89cc2804" id="r_a9df0d28652c188eeeb58c5ee89cc2804"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9df0d28652c188eeeb58c5ee89cc2804">NestedNameSpecifierLocMatcher</a> = internal::Matcher&lt;<a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>&gt;</td></tr>
<tr class="separator:a9df0d28652c188eeeb58c5ee89cc2804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678a244ce9fd8f09718bda612658099b" id="r_a678a244ce9fd8f09718bda612658099b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a678a244ce9fd8f09718bda612658099b">CXXCtorInitializerMatcher</a> = internal::Matcher&lt;<a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;</td></tr>
<tr class="separator:a678a244ce9fd8f09718bda612658099b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94019e3357b446783a76ce36fc898583" id="r_a94019e3357b446783a76ce36fc898583"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94019e3357b446783a76ce36fc898583">TemplateArgumentMatcher</a> = internal::Matcher&lt;<a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt;</td></tr>
<tr class="separator:a94019e3357b446783a76ce36fc898583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cb263a5dbe44a0deb43c2c7583c634" id="r_a88cb263a5dbe44a0deb43c2c7583c634"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88cb263a5dbe44a0deb43c2c7583c634">TemplateArgumentLocMatcher</a> = internal::Matcher&lt;<a class="el" href="classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;</td></tr>
<tr class="separator:a88cb263a5dbe44a0deb43c2c7583c634"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1c8d79365d495125b8c32aa08e15ae9d" id="r_a1c8d79365d495125b8c32aa08e15ae9d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a> { <br />
&#160;&#160;<a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9da3718b5ecf60aa0dba49e150e96cb1fc3">Eq</a>
, <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9da4dec99baa99738721da9c9b0c1a92498">Ne</a>
, <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9dac6a675552648c0becb8283f05c172483">Ge</a>
, <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9da086cb8308e5a36e7c4ed1f8873ad801f">Gt</a>
, <br />
&#160;&#160;<a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9dabccd5ec3ec8fd3a4471e71e9b407c60c">Le</a>
, <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9da50033c15af7795cd6617f117b29d6922">Lt</a>
<br />
 }</td></tr>
<tr class="memdesc:a1c8d79365d495125b8c32aa08e15ae9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gtest's comparison operations.  <a href="#a1c8d79365d495125b8c32aa08e15ae9d">More...</a><br /></td></tr>
<tr class="separator:a1c8d79365d495125b8c32aa08e15ae9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a652afe55bf376c9c0789d550409d90fe" id="r_a652afe55bf376c9c0789d550409d90fe"><td class="memItemLeft" align="right" valign="top">internal::TrueMatcher&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a652afe55bf376c9c0789d550409d90fe">anything</a> ()</td></tr>
<tr class="memdesc:a652afe55bf376c9c0789d550409d90fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any node.  <br /></td></tr>
<tr class="separator:a652afe55bf376c9c0789d550409d90fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968ac67c58589231ded255cfa8b7d70e" id="r_a968ac67c58589231ded255cfa8b7d70e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a968ac67c58589231ded255cfa8b7d70e">AST_POLYMORPHIC_MATCHER</a> (isExpansionInMainFile, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>))</td></tr>
<tr class="memdesc:a968ac67c58589231ded255cfa8b7d70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches AST nodes that were expanded within the main-file.  <br /></td></tr>
<tr class="separator:a968ac67c58589231ded255cfa8b7d70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac38e17b4f443550d465158fa148ec4" id="r_a5ac38e17b4f443550d465158fa148ec4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ac38e17b4f443550d465158fa148ec4">AST_POLYMORPHIC_MATCHER</a> (isExpansionInSystemHeader, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>))</td></tr>
<tr class="memdesc:a5ac38e17b4f443550d465158fa148ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches AST nodes that were expanded within system-header-files.  <br /></td></tr>
<tr class="separator:a5ac38e17b4f443550d465158fa148ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb873849aa797b4e9b6691b4d9fed736" id="r_acb873849aa797b4e9b6691b4d9fed736"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb873849aa797b4e9b6691b4d9fed736">AST_POLYMORPHIC_MATCHER_REGEX</a> (isExpansionInFileMatching, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>), RegExp)</td></tr>
<tr class="memdesc:acb873849aa797b4e9b6691b4d9fed736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches AST nodes that were expanded within files whose name is partially matching a given regex.  <br /></td></tr>
<tr class="separator:acb873849aa797b4e9b6691b4d9fed736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35486e436ae0dbb176252fc6b3cf62fd" id="r_a35486e436ae0dbb176252fc6b3cf62fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35486e436ae0dbb176252fc6b3cf62fd">AST_POLYMORPHIC_MATCHER_P</a> (isExpandedFromMacro, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>), std::string, MacroName)</td></tr>
<tr class="memdesc:a35486e436ae0dbb176252fc6b3cf62fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches statements that are (transitively) expanded from the named macro.  <br /></td></tr>
<tr class="separator:a35486e436ae0dbb176252fc6b3cf62fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26030464371cdda3687f2a9e71a6518" id="r_ae26030464371cdda3687f2a9e71a6518"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae26030464371cdda3687f2a9e71a6518">AST_POLYMORPHIC_MATCHER</a> (isPublic, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>))</td></tr>
<tr class="memdesc:ae26030464371cdda3687f2a9e71a6518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches public C++ declarations and C++ base specifers that specify public inheritance.  <br /></td></tr>
<tr class="separator:ae26030464371cdda3687f2a9e71a6518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70d182f0dc6e578582e680c791f0425" id="r_aa70d182f0dc6e578582e680c791f0425"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa70d182f0dc6e578582e680c791f0425">AST_POLYMORPHIC_MATCHER</a> (isProtected, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>))</td></tr>
<tr class="memdesc:aa70d182f0dc6e578582e680c791f0425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches protected C++ declarations and C++ base specifers that specify protected inheritance.  <br /></td></tr>
<tr class="separator:aa70d182f0dc6e578582e680c791f0425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2128e92dde14b184065a2c1aae5e23b" id="r_ad2128e92dde14b184065a2c1aae5e23b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2128e92dde14b184065a2c1aae5e23b">AST_POLYMORPHIC_MATCHER</a> (isPrivate, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>))</td></tr>
<tr class="memdesc:ad2128e92dde14b184065a2c1aae5e23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches private C++ declarations and C++ base specifers that specify private inheritance.  <br /></td></tr>
<tr class="separator:ad2128e92dde14b184065a2c1aae5e23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15b7c8db135d0ff9fb14a612faa14f3" id="r_ac15b7c8db135d0ff9fb14a612faa14f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac15b7c8db135d0ff9fb14a612faa14f3">AST_MATCHER</a> (<a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a>, isBitField)</td></tr>
<tr class="memdesc:ac15b7c8db135d0ff9fb14a612faa14f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches non-static data members that are bit-fields.  <br /></td></tr>
<tr class="separator:ac15b7c8db135d0ff9fb14a612faa14f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2e74bf00f236ab96f16fc7d3495f78" id="r_a3e2e74bf00f236ab96f16fc7d3495f78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e2e74bf00f236ab96f16fc7d3495f78">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a>, hasBitWidth, <a class="el" href="classunsigned.html">unsigned</a>, Width)</td></tr>
<tr class="memdesc:a3e2e74bf00f236ab96f16fc7d3495f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches non-static data members that are bit-fields of the specified bit width.  <br /></td></tr>
<tr class="separator:a3e2e74bf00f236ab96f16fc7d3495f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041bd134ecb46dcb809880b2588a1c19" id="r_a041bd134ecb46dcb809880b2588a1c19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a041bd134ecb46dcb809880b2588a1c19">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a>, hasInClassInitializer, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a041bd134ecb46dcb809880b2588a1c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches non-static data members that have an in-class initializer.  <br /></td></tr>
<tr class="separator:a041bd134ecb46dcb809880b2588a1c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cebfe9c6da04c2d9cfb13a038f0dde" id="r_ae5cebfe9c6da04c2d9cfb13a038f0dde"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5cebfe9c6da04c2d9cfb13a038f0dde">AST_MATCHER</a> (<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, isMain)</td></tr>
<tr class="memdesc:ae5cebfe9c6da04c2d9cfb13a038f0dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the function is "main", which is the entry point into an executable program.  <br /></td></tr>
<tr class="separator:ae5cebfe9c6da04c2d9cfb13a038f0dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b30a702681d01ead785188e04457f92" id="r_a7b30a702681d01ead785188e04457f92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b30a702681d01ead785188e04457f92">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>, hasSpecializedTemplate, internal::Matcher&lt; <a class="el" href="classclang_1_1ClassTemplateDecl.html">ClassTemplateDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a7b30a702681d01ead785188e04457f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the specialized template of a specialization declaration.  <br /></td></tr>
<tr class="separator:a7b30a702681d01ead785188e04457f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74dcbcb1679405feb5454798560ee342" id="r_a74dcbcb1679405feb5454798560ee342"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74dcbcb1679405feb5454798560ee342">AST_MATCHER</a> (<a class="el" href="classclang_1_1Decl.html">Decl</a>, isImplicit)</td></tr>
<tr class="memdesc:a74dcbcb1679405feb5454798560ee342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a declaration that has been implicitly added by the compiler (eg.  <br /></td></tr>
<tr class="separator:a74dcbcb1679405feb5454798560ee342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6b5c72b69ebf86c242f591b3a607cf" id="r_a2a6b5c72b69ebf86c242f591b3a607cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a6b5c72b69ebf86c242f591b3a607cf">AST_POLYMORPHIC_MATCHER_P</a> (hasAnyTemplateArgument, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>, <a class="el" href="classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a2a6b5c72b69ebf86c242f591b3a607cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches classTemplateSpecializations, templateSpecializationType and functionDecl that have at least one <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> matching the given InnerMatcher.  <br /></td></tr>
<tr class="separator:a2a6b5c72b69ebf86c242f591b3a607cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24cf70324e1c82a857cd095e2d535fc" id="r_ac24cf70324e1c82a857cd095e2d535fc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac24cf70324e1c82a857cd095e2d535fc"><td class="memTemplItemLeft" align="right" valign="top">internal::Matcher&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac24cf70324e1c82a857cd095e2d535fc">traverse</a> (<a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a> TK, const internal::Matcher&lt; T &gt; &amp;InnerMatcher)</td></tr>
<tr class="memdesc:ac24cf70324e1c82a857cd095e2d535fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes all nested matchers to be matched with the specified traversal kind.  <br /></td></tr>
<tr class="separator:ac24cf70324e1c82a857cd095e2d535fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebeafc3d90355e2bf42cdc4e882d16f" id="r_a9ebeafc3d90355e2bf42cdc4e882d16f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ebeafc3d90355e2bf42cdc4e882d16f"><td class="memTemplItemLeft" align="right" valign="top">internal::BindableMatcher&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ebeafc3d90355e2bf42cdc4e882d16f">traverse</a> (<a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a> TK, const internal::BindableMatcher&lt; T &gt; &amp;InnerMatcher)</td></tr>
<tr class="separator:a9ebeafc3d90355e2bf42cdc4e882d16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873ebf9fb40f9c5b2f2f51d3e4cd2ca1" id="r_a873ebf9fb40f9c5b2f2f51d3e4cd2ca1"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a873ebf9fb40f9c5b2f2f51d3e4cd2ca1"><td class="memTemplItemLeft" align="right" valign="top">internal::TraversalWrapper&lt; internal::VariadicOperatorMatcher&lt; T... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a873ebf9fb40f9c5b2f2f51d3e4cd2ca1">traverse</a> (<a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a> TK, const internal::VariadicOperatorMatcher&lt; T... &gt; &amp;InnerMatcher)</td></tr>
<tr class="separator:a873ebf9fb40f9c5b2f2f51d3e4cd2ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62500923b2d8d2cfa607f4c2526aec1c" id="r_a62500923b2d8d2cfa607f4c2526aec1c"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename ToArg, typename FromArg &gt; class ArgumentAdapterT, typename T , typename ToTypes &gt; </td></tr>
<tr class="memitem:a62500923b2d8d2cfa607f4c2526aec1c"><td class="memTemplItemLeft" align="right" valign="top">internal::TraversalWrapper&lt; internal::ArgumentAdaptingMatcherFuncAdaptor&lt; ArgumentAdapterT, T, ToTypes &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a62500923b2d8d2cfa607f4c2526aec1c">traverse</a> (<a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a> TK, const internal::ArgumentAdaptingMatcherFuncAdaptor&lt; ArgumentAdapterT, T, ToTypes &gt; &amp;InnerMatcher)</td></tr>
<tr class="separator:a62500923b2d8d2cfa607f4c2526aec1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301884494a34a99d91d8ed6b987d8ce6" id="r_a301884494a34a99d91d8ed6b987d8ce6"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T, typename P1 &gt; class MatcherT, typename P1 , typename ReturnTypesF &gt; </td></tr>
<tr class="memitem:a301884494a34a99d91d8ed6b987d8ce6"><td class="memTemplItemLeft" align="right" valign="top">internal::TraversalWrapper&lt; internal::PolymorphicMatcherWithParam1&lt; MatcherT, P1, ReturnTypesF &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a301884494a34a99d91d8ed6b987d8ce6">traverse</a> (<a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a> TK, const internal::PolymorphicMatcherWithParam1&lt; MatcherT, P1, ReturnTypesF &gt; &amp;InnerMatcher)</td></tr>
<tr class="separator:a301884494a34a99d91d8ed6b987d8ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a783f24f557b1ca228108ca71d10ad" id="r_a21a783f24f557b1ca228108ca71d10ad"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T, typename P1, typename P2 &gt; class MatcherT, typename P1 , typename P2 , typename ReturnTypesF &gt; </td></tr>
<tr class="memitem:a21a783f24f557b1ca228108ca71d10ad"><td class="memTemplItemLeft" align="right" valign="top">internal::TraversalWrapper&lt; internal::PolymorphicMatcherWithParam2&lt; MatcherT, P1, P2, ReturnTypesF &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21a783f24f557b1ca228108ca71d10ad">traverse</a> (<a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a> TK, const internal::PolymorphicMatcherWithParam2&lt; MatcherT, P1, P2, ReturnTypesF &gt; &amp;InnerMatcher)</td></tr>
<tr class="separator:a21a783f24f557b1ca228108ca71d10ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abceee755f615e6fc0cd081dfe7186810" id="r_abceee755f615e6fc0cd081dfe7186810"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:abceee755f615e6fc0cd081dfe7186810"><td class="memTemplItemLeft" align="right" valign="top">internal::Matcher&lt; typename internal::GetClade&lt; T... &gt;::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abceee755f615e6fc0cd081dfe7186810">traverse</a> (<a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a> TK, const internal::MapAnyOfHelper&lt; T... &gt; &amp;InnerMatcher)</td></tr>
<tr class="separator:abceee755f615e6fc0cd081dfe7186810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fc5ba0e3c7670df1211d78a0e8cd3b" id="r_a92fc5ba0e3c7670df1211d78a0e8cd3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92fc5ba0e3c7670df1211d78a0e8cd3b">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a>, ignoringImplicit, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a92fc5ba0e3c7670df1211d78a0e8cd3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions that match InnerMatcher after any implicit AST nodes are stripped off.  <br /></td></tr>
<tr class="separator:a92fc5ba0e3c7670df1211d78a0e8cd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d68be4dc7543bd7e54dfe60c7e77b30" id="r_a1d68be4dc7543bd7e54dfe60c7e77b30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d68be4dc7543bd7e54dfe60c7e77b30">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a>, ignoringImpCasts, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a1d68be4dc7543bd7e54dfe60c7e77b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions that match InnerMatcher after any implicit casts are stripped off.  <br /></td></tr>
<tr class="separator:a1d68be4dc7543bd7e54dfe60c7e77b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975436793549e3bf233afa633b959539" id="r_a975436793549e3bf233afa633b959539"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a975436793549e3bf233afa633b959539">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a>, ignoringParenCasts, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a975436793549e3bf233afa633b959539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions that match InnerMatcher after parentheses and casts are stripped off.  <br /></td></tr>
<tr class="separator:a975436793549e3bf233afa633b959539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c810b620cfe58f641cb695035984063" id="r_a5c810b620cfe58f641cb695035984063"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c810b620cfe58f641cb695035984063">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a>, ignoringParenImpCasts, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a5c810b620cfe58f641cb695035984063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions that match InnerMatcher after implicit casts and parentheses are stripped off.  <br /></td></tr>
<tr class="separator:a5c810b620cfe58f641cb695035984063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4045123f0a783a289d12aaa2f5dc8e7" id="r_af4045123f0a783a289d12aaa2f5dc8e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4045123f0a783a289d12aaa2f5dc8e7">AST_MATCHER_P_OVERLOAD</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, ignoringParens, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher, 0)</td></tr>
<tr class="memdesc:af4045123f0a783a289d12aaa2f5dc8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches types that match InnerMatcher after any parens are stripped.  <br /></td></tr>
<tr class="separator:af4045123f0a783a289d12aaa2f5dc8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fc7328f73d9bb7d7d88855195afb34" id="r_a07fc7328f73d9bb7d7d88855195afb34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07fc7328f73d9bb7d7d88855195afb34">AST_MATCHER_P_OVERLOAD</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a>, ignoringParens, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher, 1)</td></tr>
<tr class="memdesc:a07fc7328f73d9bb7d7d88855195afb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload <code>ignoringParens</code> for <code><a class="el" href="classclang_1_1Expr.html" title="This represents one expression.">Expr</a></code>.  <br /></td></tr>
<tr class="separator:a07fc7328f73d9bb7d7d88855195afb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833e412dcf7c56f98cd2f63b7ef6dc93" id="r_a833e412dcf7c56f98cd2f63b7ef6dc93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a833e412dcf7c56f98cd2f63b7ef6dc93">AST_MATCHER</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a>, isInstantiationDependent)</td></tr>
<tr class="memdesc:a833e412dcf7c56f98cd2f63b7ef6dc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions that are instantiation-dependent even if it is neither type- nor value-dependent.  <br /></td></tr>
<tr class="separator:a833e412dcf7c56f98cd2f63b7ef6dc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f22eb8aa38e1f695312a09764c34ef" id="r_a00f22eb8aa38e1f695312a09764c34ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00f22eb8aa38e1f695312a09764c34ef">AST_MATCHER</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a>, isTypeDependent)</td></tr>
<tr class="memdesc:a00f22eb8aa38e1f695312a09764c34ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions that are type-dependent because the template type is not yet instantiated.  <br /></td></tr>
<tr class="separator:a00f22eb8aa38e1f695312a09764c34ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d8919c5ecf8f9a9ab153ca646d3a6a" id="r_a02d8919c5ecf8f9a9ab153ca646d3a6a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02d8919c5ecf8f9a9ab153ca646d3a6a">AST_MATCHER</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a>, isValueDependent)</td></tr>
<tr class="memdesc:a02d8919c5ecf8f9a9ab153ca646d3a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expression that are value-dependent because they contain a non-type template parameter.  <br /></td></tr>
<tr class="separator:a02d8919c5ecf8f9a9ab153ca646d3a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ae808f2b4db9e59ead6b1695186d91" id="r_ac2ae808f2b4db9e59ead6b1695186d91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2ae808f2b4db9e59ead6b1695186d91">AST_POLYMORPHIC_MATCHER_P2</a> (hasTemplateArgument, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>, <a class="el" href="classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>), <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a>, internal::Matcher&lt; <a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ac2ae808f2b4db9e59ead6b1695186d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches classTemplateSpecializations, templateSpecializationType and functionDecl where the n'th <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> matches the given InnerMatcher.  <br /></td></tr>
<tr class="separator:ac2ae808f2b4db9e59ead6b1695186d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5bfa4d4498d0db062ebae29807b397" id="r_a8d5bfa4d4498d0db062ebae29807b397"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d5bfa4d4498d0db062ebae29807b397">AST_POLYMORPHIC_MATCHER_P</a> (templateArgumentCountIs, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>, <a class="el" href="classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>), <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a>)</td></tr>
<tr class="memdesc:a8d5bfa4d4498d0db062ebae29807b397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the number of template arguments equals <code>N</code>.  <br /></td></tr>
<tr class="separator:a8d5bfa4d4498d0db062ebae29807b397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af189946951ce7f935861b3943634e6d4" id="r_af189946951ce7f935861b3943634e6d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af189946951ce7f935861b3943634e6d4">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>, refersToType, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:af189946951ce7f935861b3943634e6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to a certain type.  <br /></td></tr>
<tr class="separator:af189946951ce7f935861b3943634e6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78151d2a32277bb385119910e537d58a" id="r_a78151d2a32277bb385119910e537d58a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78151d2a32277bb385119910e537d58a">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>, refersToTemplate, internal::Matcher&lt; <a class="el" href="classclang_1_1TemplateName.html">TemplateName</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a78151d2a32277bb385119910e537d58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to a certain template.  <br /></td></tr>
<tr class="separator:a78151d2a32277bb385119910e537d58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d66a056fa6763e89a41550a4468db2f" id="r_a0d66a056fa6763e89a41550a4468db2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d66a056fa6763e89a41550a4468db2f">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>, refersToDeclaration, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a0d66a056fa6763e89a41550a4468db2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a canonical <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to a certain declaration.  <br /></td></tr>
<tr class="separator:a0d66a056fa6763e89a41550a4468db2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8b99a0a4e189acdcdaf259c2290f3d" id="r_a0f8b99a0a4e189acdcdaf259c2290f3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f8b99a0a4e189acdcdaf259c2290f3d">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>, isExpr, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a0f8b99a0a4e189acdcdaf259c2290f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a sugar <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to a certain expression.  <br /></td></tr>
<tr class="separator:a0f8b99a0a4e189acdcdaf259c2290f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372ddae878809019381acb68314cb048" id="r_a372ddae878809019381acb68314cb048"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a372ddae878809019381acb68314cb048">AST_MATCHER</a> (<a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>, isIntegral)</td></tr>
<tr class="memdesc:a372ddae878809019381acb68314cb048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that is an integral value.  <br /></td></tr>
<tr class="separator:a372ddae878809019381acb68314cb048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911620ba71c61c54fcf02cd42d828e56" id="r_a911620ba71c61c54fcf02cd42d828e56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a911620ba71c61c54fcf02cd42d828e56">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>, refersToIntegralType, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a911620ba71c61c54fcf02cd42d828e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to an integral type.  <br /></td></tr>
<tr class="separator:a911620ba71c61c54fcf02cd42d828e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a50116e967de8dce02523cc01150f4d" id="r_a7a50116e967de8dce02523cc01150f4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a50116e967de8dce02523cc01150f4d">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>, equalsIntegralValue, std::string, <a class="el" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>)</td></tr>
<tr class="memdesc:a7a50116e967de8dce02523cc01150f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> of integral type with a given value.  <br /></td></tr>
<tr class="separator:a7a50116e967de8dce02523cc01150f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edfa6373df58e343d19f5d2679991d1" id="r_a0edfa6373df58e343d19f5d2679991d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0edfa6373df58e343d19f5d2679991d1">AST_MATCHER</a> (<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, usesADL)</td></tr>
<tr class="memdesc:a0edfa6373df58e343d19f5d2679991d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches call expressions which were resolved using ADL.  <br /></td></tr>
<tr class="separator:a0edfa6373df58e343d19f5d2679991d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246e4f4313edb67d25bdd6fb935746b4" id="r_a246e4f4313edb67d25bdd6fb935746b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a246e4f4313edb67d25bdd6fb935746b4">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1InitListExpr.html">InitListExpr</a>, hasSyntacticForm, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a246e4f4313edb67d25bdd6fb935746b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the syntactic form of init list expressions (if expression have it).  <br /></td></tr>
<tr class="separator:a246e4f4313edb67d25bdd6fb935746b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290e141c4140d565458b4eebab9fe706" id="r_a290e141c4140d565458b4eebab9fe706"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a290e141c4140d565458b4eebab9fe706">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ForStmt.html">ForStmt</a>, hasIncrement, internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a290e141c4140d565458b4eebab9fe706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the increment statement of a for loop.  <br /></td></tr>
<tr class="separator:a290e141c4140d565458b4eebab9fe706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25f93cc605e37bd0bb85673eb580a1e" id="r_ac25f93cc605e37bd0bb85673eb580a1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac25f93cc605e37bd0bb85673eb580a1e">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ForStmt.html">ForStmt</a>, hasLoopInit, internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ac25f93cc605e37bd0bb85673eb580a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the initialization statement of a for loop.  <br /></td></tr>
<tr class="separator:ac25f93cc605e37bd0bb85673eb580a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13417ea6d85e2bff1cadbf9f0969ae1d" id="r_a13417ea6d85e2bff1cadbf9f0969ae1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13417ea6d85e2bff1cadbf9f0969ae1d">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a>, hasLoopVariable, internal::Matcher&lt; <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a13417ea6d85e2bff1cadbf9f0969ae1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the initialization statement of a for loop.  <br /></td></tr>
<tr class="separator:a13417ea6d85e2bff1cadbf9f0969ae1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6716c3f117a63a7d60827379b4cc2a4" id="r_ad6716c3f117a63a7d60827379b4cc2a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6716c3f117a63a7d60827379b4cc2a4">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a>, hasRangeInit, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ad6716c3f117a63a7d60827379b4cc2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the range initialization statement of a for loop.  <br /></td></tr>
<tr class="separator:ad6716c3f117a63a7d60827379b4cc2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1b90fe605ed44735e799e76d0b4786" id="r_a0f1b90fe605ed44735e799e76d0b4786"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f1b90fe605ed44735e799e76d0b4786">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1DesignatedInitExpr.html">DesignatedInitExpr</a>, designatorCountIs, <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a>)</td></tr>
<tr class="memdesc:a0f1b90fe605ed44735e799e76d0b4786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches designated initializer expressions that contain a specific number of designators.  <br /></td></tr>
<tr class="separator:a0f1b90fe605ed44735e799e76d0b4786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d2caaa3c207f5b5f91216fe06f1158" id="r_a90d2caaa3c207f5b5f91216fe06f1158"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... U&gt; </td></tr>
<tr class="memitem:a90d2caaa3c207f5b5f91216fe06f1158"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a90d2caaa3c207f5b5f91216fe06f1158">mapAnyOf</a> (internal::VariadicDynCastAllOfMatcher&lt; T, <a class="el" href="classU.html">U</a> &gt; const &amp;...)</td></tr>
<tr class="memdesc:a90d2caaa3c207f5b5f91216fe06f1158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any of the <code>NodeMatchers</code> with InnerMatchers nested within.  <br /></td></tr>
<tr class="separator:a90d2caaa3c207f5b5f91216fe06f1158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda923705023b2e6030c83ffe359a5b1" id="r_afda923705023b2e6030c83ffe359a5b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afda923705023b2e6030c83ffe359a5b1">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a>, hasArgumentOfType, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:afda923705023b2e6030c83ffe359a5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches unary expressions that have a specific type of argument.  <br /></td></tr>
<tr class="separator:afda923705023b2e6030c83ffe359a5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364b968cdd1a5dd039ef4002d426e62c" id="r_a364b968cdd1a5dd039ef4002d426e62c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a364b968cdd1a5dd039ef4002d426e62c">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a>, ofKind, <a class="el" href="namespaceclang.html#a5d73f06594a5ccb763a726bed94a541f">UnaryExprOrTypeTrait</a>, Kind)</td></tr>
<tr class="memdesc:a364b968cdd1a5dd039ef4002d426e62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches unary expressions of a certain kind.  <br /></td></tr>
<tr class="separator:a364b968cdd1a5dd039ef4002d426e62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac990761bd6763c396e66b3359f098f72" id="r_ac990761bd6763c396e66b3359f098f72"><td class="memItemLeft" align="right" valign="top">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac990761bd6763c396e66b3359f098f72">alignOfExpr</a> (const internal::Matcher&lt; <a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a> &gt; &amp;InnerMatcher)</td></tr>
<tr class="memdesc:ac990761bd6763c396e66b3359f098f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as unaryExprOrTypeTraitExpr, but only matching alignof.  <br /></td></tr>
<tr class="separator:ac990761bd6763c396e66b3359f098f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b8656432877e43a7d14fc722c12383" id="r_a84b8656432877e43a7d14fc722c12383"><td class="memItemLeft" align="right" valign="top">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84b8656432877e43a7d14fc722c12383">sizeOfExpr</a> (const internal::Matcher&lt; <a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a> &gt; &amp;InnerMatcher)</td></tr>
<tr class="memdesc:a84b8656432877e43a7d14fc722c12383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as unaryExprOrTypeTraitExpr, but only matching sizeof.  <br /></td></tr>
<tr class="separator:a84b8656432877e43a7d14fc722c12383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4360554ed6340d60248b5d5930c44d49" id="r_a4360554ed6340d60248b5d5930c44d49"><td class="memItemLeft" align="right" valign="top">internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4360554ed6340d60248b5d5930c44d49">hasName</a> (StringRef Name)</td></tr>
<tr class="memdesc:a4360554ed6340d60248b5d5930c44d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <a class="el" href="classclang_1_1NamedDecl.html" title="This represents a decl that may have a name.">NamedDecl</a> nodes that have the specified name.  <br /></td></tr>
<tr class="separator:a4360554ed6340d60248b5d5930c44d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cb7556571e959aa00a7d5c8cdd9394" id="r_aa8cb7556571e959aa00a7d5c8cdd9394"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8cb7556571e959aa00a7d5c8cdd9394">AST_MATCHER_REGEX</a> (<a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a>, matchesName, RegExp)</td></tr>
<tr class="memdesc:aa8cb7556571e959aa00a7d5c8cdd9394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <a class="el" href="classclang_1_1NamedDecl.html" title="This represents a decl that may have a name.">NamedDecl</a> nodes whose fully qualified names contain a substring matched by the given RegExp.  <br /></td></tr>
<tr class="separator:aa8cb7556571e959aa00a7d5c8cdd9394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3fd9d0c1f652bb7cad8fb60730874e" id="r_aae3fd9d0c1f652bb7cad8fb60730874e"><td class="memItemLeft" align="right" valign="top">internal::PolymorphicMatcherWithParam1&lt; internal::HasOverloadedOperatorNameMatcher, std::vector&lt; std::string &gt;, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae3fd9d0c1f652bb7cad8fb60730874e">hasOverloadedOperatorName</a> (StringRef Name)</td></tr>
<tr class="memdesc:aae3fd9d0c1f652bb7cad8fb60730874e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches overloaded operator names.  <br /></td></tr>
<tr class="separator:aae3fd9d0c1f652bb7cad8fb60730874e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4754fedaf69686660d1d67816e610cd" id="r_ad4754fedaf69686660d1d67816e610cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4754fedaf69686660d1d67816e610cd">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a>, hasMemberName, std::string, <a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a>)</td></tr>
<tr class="memdesc:ad4754fedaf69686660d1d67816e610cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template-dependent, but known, member names.  <br /></td></tr>
<tr class="separator:ad4754fedaf69686660d1d67816e610cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1671534b91901a477c76a181b97e4111" id="r_a1671534b91901a477c76a181b97e4111"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1671534b91901a477c76a181b97e4111">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a>, memberHasSameNameAsBoundNode, std::string, BindingID)</td></tr>
<tr class="memdesc:a1671534b91901a477c76a181b97e4111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template-dependent, but known, member names against an already-bound node.  <br /></td></tr>
<tr class="separator:a1671534b91901a477c76a181b97e4111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aeb83f2ec21f29e79ce86e902ed8540" id="r_a7aeb83f2ec21f29e79ce86e902ed8540"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7aeb83f2ec21f29e79ce86e902ed8540">AST_POLYMORPHIC_MATCHER_P</a> (isDerivedFrom, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;, <a class="el" href="classBase.html">Base</a>)</td></tr>
<tr class="memdesc:a7aeb83f2ec21f29e79ce86e902ed8540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ classes that are directly or indirectly derived from a class matching <code><a class="el" href="classBase.html">Base</a></code>, or Objective-C classes that directly or indirectly subclass a class matching <code><a class="el" href="classBase.html">Base</a></code>.  <br /></td></tr>
<tr class="separator:a7aeb83f2ec21f29e79ce86e902ed8540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931d53d9c92b933394ca4e31fd3610db" id="r_a931d53d9c92b933394ca4e31fd3610db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a931d53d9c92b933394ca4e31fd3610db">AST_POLYMORPHIC_MATCHER_P_OVERLOAD</a> (isDerivedFrom, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>), std::string, BaseName, 1)</td></tr>
<tr class="memdesc:a931d53d9c92b933394ca4e31fd3610db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded method as shortcut for <code>isDerivedFrom(hasName(...))</code>.  <br /></td></tr>
<tr class="separator:a931d53d9c92b933394ca4e31fd3610db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d5ca0ebfe096ded3ced92d183b60a2" id="r_af8d5ca0ebfe096ded3ced92d183b60a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8d5ca0ebfe096ded3ced92d183b60a2">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, hasAnyBase, internal::Matcher&lt; <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a> &gt;, BaseSpecMatcher)</td></tr>
<tr class="memdesc:af8d5ca0ebfe096ded3ced92d183b60a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ classes that have a direct or indirect base matching <code>BaseSpecMatcher</code>.  <br /></td></tr>
<tr class="separator:af8d5ca0ebfe096ded3ced92d183b60a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a38d1fd2744bb4fa7264ce75e905ce" id="r_a18a38d1fd2744bb4fa7264ce75e905ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18a38d1fd2744bb4fa7264ce75e905ce">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, hasDirectBase, internal::Matcher&lt; <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a> &gt;, BaseSpecMatcher)</td></tr>
<tr class="memdesc:a18a38d1fd2744bb4fa7264ce75e905ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ classes that have a direct base matching <code>BaseSpecMatcher</code>.  <br /></td></tr>
<tr class="separator:a18a38d1fd2744bb4fa7264ce75e905ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbefa428d3a7d1641d6ac07a021cdcf" id="r_a2fbefa428d3a7d1641d6ac07a021cdcf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fbefa428d3a7d1641d6ac07a021cdcf">AST_POLYMORPHIC_MATCHER_P_OVERLOAD</a> (isSameOrDerivedFrom, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;, <a class="el" href="classBase.html">Base</a>, 0)</td></tr>
<tr class="memdesc:a2fbefa428d3a7d1641d6ac07a021cdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>isDerivedFrom()</code>, but also matches classes that directly match <code><a class="el" href="classBase.html">Base</a></code>.  <br /></td></tr>
<tr class="separator:a2fbefa428d3a7d1641d6ac07a021cdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9b17e996eb7d40a1b04ce7701a07db" id="r_afb9b17e996eb7d40a1b04ce7701a07db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb9b17e996eb7d40a1b04ce7701a07db">AST_POLYMORPHIC_MATCHER_P_OVERLOAD</a> (isSameOrDerivedFrom, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>), std::string, BaseName, 1)</td></tr>
<tr class="memdesc:afb9b17e996eb7d40a1b04ce7701a07db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded method as shortcut for <code>isSameOrDerivedFrom(hasName(...))</code>.  <br /></td></tr>
<tr class="separator:afb9b17e996eb7d40a1b04ce7701a07db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3046ab1a3310f7867a4c1e47c9bfff" id="r_a5e3046ab1a3310f7867a4c1e47c9bfff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e3046ab1a3310f7867a4c1e47c9bfff">AST_POLYMORPHIC_MATCHER_P_OVERLOAD</a> (isDirectlyDerivedFrom, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;, <a class="el" href="classBase.html">Base</a>, 0)</td></tr>
<tr class="memdesc:a5e3046ab1a3310f7867a4c1e47c9bfff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ or Objective-C classes that are directly derived from a class matching <code><a class="el" href="classBase.html">Base</a></code>.  <br /></td></tr>
<tr class="separator:a5e3046ab1a3310f7867a4c1e47c9bfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898b5ddf30c2409c36bdb3cc0abb789f" id="r_a898b5ddf30c2409c36bdb3cc0abb789f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a898b5ddf30c2409c36bdb3cc0abb789f">AST_POLYMORPHIC_MATCHER_P_OVERLOAD</a> (isDirectlyDerivedFrom, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>), std::string, BaseName, 1)</td></tr>
<tr class="memdesc:a898b5ddf30c2409c36bdb3cc0abb789f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded method as shortcut for <code>isDirectlyDerivedFrom(hasName(...))</code>.  <br /></td></tr>
<tr class="separator:a898b5ddf30c2409c36bdb3cc0abb789f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58c11d6864fd939f7c9e2bad80dde51" id="r_ae58c11d6864fd939f7c9e2bad80dde51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae58c11d6864fd939f7c9e2bad80dde51">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, hasMethod, internal::Matcher&lt; <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ae58c11d6864fd939f7c9e2bad80dde51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the first method of a class or struct that satisfies <code>InnerMatcher</code>.  <br /></td></tr>
<tr class="separator:ae58c11d6864fd939f7c9e2bad80dde51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b1b3c472ca3262e95b5a2eefa63b7e" id="r_ae1b1b3c472ca3262e95b5a2eefa63b7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1b1b3c472ca3262e95b5a2eefa63b7e">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, isLambda)</td></tr>
<tr class="memdesc:ae1b1b3c472ca3262e95b5a2eefa63b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the generated class of lambda expressions.  <br /></td></tr>
<tr class="separator:ae1b1b3c472ca3262e95b5a2eefa63b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d86a586c37bb32b5dff391714953ed" id="r_ad2d86a586c37bb32b5dff391714953ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2d86a586c37bb32b5dff391714953ed"><td class="memTemplItemLeft" align="right" valign="top">internal::Matcher&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2d86a586c37bb32b5dff391714953ed">findAll</a> (const internal::Matcher&lt; T &gt; &amp;Matcher)</td></tr>
<tr class="memdesc:ad2d86a586c37bb32b5dff391714953ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the node or any descendant matches.  <br /></td></tr>
<tr class="separator:ad2d86a586c37bb32b5dff391714953ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff2c5e99cdf0bc13af1e639d9249df2" id="r_a4ff2c5e99cdf0bc13af1e639d9249df2"><td class="memItemLeft" align="right" valign="top">internal::PolymorphicMatcherWithParam1&lt; internal::HasDeclarationMatcher, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, void(internal::HasDeclarationSupportedTypes)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ff2c5e99cdf0bc13af1e639d9249df2">hasDeclaration</a> (const internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt; &amp;InnerMatcher)</td></tr>
<tr class="memdesc:a4ff2c5e99cdf0bc13af1e639d9249df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a node if the declaration associated with that node matches the given matcher.  <br /></td></tr>
<tr class="separator:a4ff2c5e99cdf0bc13af1e639d9249df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af541323ee4a7cfcaa6032acb78ac3a86" id="r_af541323ee4a7cfcaa6032acb78ac3a86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af541323ee4a7cfcaa6032acb78ac3a86">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a>, hasUnderlyingDecl, internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:af541323ee4a7cfcaa6032acb78ac3a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a <code><a class="el" href="classclang_1_1NamedDecl.html" title="This represents a decl that may have a name.">NamedDecl</a></code> whose underlying declaration matches the given matcher.  <br /></td></tr>
<tr class="separator:af541323ee4a7cfcaa6032acb78ac3a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fc9646b82282913629cad30181a3a0" id="r_a99fc9646b82282913629cad30181a3a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99fc9646b82282913629cad30181a3a0">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a>, on, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a99fc9646b82282913629cad30181a3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches on the implicit object argument of a member call expression, after stripping off any parentheses or implicit casts.  <br /></td></tr>
<tr class="separator:a99fc9646b82282913629cad30181a3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eadcbb53864d57ff194cfb633fc783e" id="r_a2eadcbb53864d57ff194cfb633fc783e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2eadcbb53864d57ff194cfb633fc783e">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, hasReceiverType, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a2eadcbb53864d57ff194cfb633fc783e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches on the receiver of an ObjectiveC Message expression.  <br /></td></tr>
<tr class="separator:a2eadcbb53864d57ff194cfb633fc783e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed7081a3099b4c413dd177c4c00559c" id="r_abed7081a3099b4c413dd177c4c00559c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abed7081a3099b4c413dd177c4c00559c">AST_MATCHER</a> (<a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>, isClassMethod)</td></tr>
<tr class="memdesc:abed7081a3099b4c413dd177c4c00559c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the Objective-C method declaration is a class method.  <br /></td></tr>
<tr class="separator:abed7081a3099b4c413dd177c4c00559c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae407a60668f5aeb7fb497b64762b8d" id="r_adae407a60668f5aeb7fb497b64762b8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adae407a60668f5aeb7fb497b64762b8d">AST_MATCHER</a> (<a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>, <a class="el" href="SemaDeclAttr_8cpp.html#ad35282e02924165aae3b360b22ab028e">isInstanceMethod</a>)</td></tr>
<tr class="memdesc:adae407a60668f5aeb7fb497b64762b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the Objective-C method declaration is an instance method.  <br /></td></tr>
<tr class="separator:adae407a60668f5aeb7fb497b64762b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ccba02e6d782bd0ffda74eef632efc" id="r_a50ccba02e6d782bd0ffda74eef632efc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50ccba02e6d782bd0ffda74eef632efc">AST_MATCHER</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, isClassMessage)</td></tr>
<tr class="memdesc:a50ccba02e6d782bd0ffda74eef632efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the Objective-C message is sent to a class.  <br /></td></tr>
<tr class="separator:a50ccba02e6d782bd0ffda74eef632efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac3bec31f7eb8625530f52cf6f5a87f" id="r_a4ac3bec31f7eb8625530f52cf6f5a87f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ac3bec31f7eb8625530f52cf6f5a87f">AST_MATCHER</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, isInstanceMessage)</td></tr>
<tr class="memdesc:a4ac3bec31f7eb8625530f52cf6f5a87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the Objective-C message is sent to an instance.  <br /></td></tr>
<tr class="separator:a4ac3bec31f7eb8625530f52cf6f5a87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81978c4da301b92d8b05c2f29c73d86" id="r_aa81978c4da301b92d8b05c2f29c73d86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa81978c4da301b92d8b05c2f29c73d86">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, hasReceiver, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:aa81978c4da301b92d8b05c2f29c73d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the Objective-C message is sent to an instance, and the inner matcher matches on that instance.  <br /></td></tr>
<tr class="separator:aa81978c4da301b92d8b05c2f29c73d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c4492e391c4ebab66249547cbda68c" id="r_ae7c4492e391c4ebab66249547cbda68c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7c4492e391c4ebab66249547cbda68c">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, hasSelector, std::string, BaseName)</td></tr>
<tr class="memdesc:ae7c4492e391c4ebab66249547cbda68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches when BaseName == <a class="el" href="classclang_1_1Selector.html#a4fc5593940af968fa1187c3cb6a8ef8b" title="Derive the full selector name (e.g.">Selector.getAsString()</a>  <br /></td></tr>
<tr class="separator:ae7c4492e391c4ebab66249547cbda68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a26f57707ca1cc9c7c2f915bdef1dec" id="r_a1a26f57707ca1cc9c7c2f915bdef1dec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a26f57707ca1cc9c7c2f915bdef1dec">AST_MATCHER_REGEX</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, matchesSelector, RegExp)</td></tr>
<tr class="memdesc:a1a26f57707ca1cc9c7c2f915bdef1dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches ObjC selectors whose name contains a substring matched by the given RegExp.  <br /></td></tr>
<tr class="separator:a1a26f57707ca1cc9c7c2f915bdef1dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f55858b223a0e11066738f16c77a25" id="r_a38f55858b223a0e11066738f16c77a25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38f55858b223a0e11066738f16c77a25">AST_MATCHER</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, hasNullSelector)</td></tr>
<tr class="memdesc:a38f55858b223a0e11066738f16c77a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches when the selector is the empty selector.  <br /></td></tr>
<tr class="separator:a38f55858b223a0e11066738f16c77a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe17436c3837899bc7a1f07dd6c23f8" id="r_affe17436c3837899bc7a1f07dd6c23f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affe17436c3837899bc7a1f07dd6c23f8">AST_MATCHER</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, hasUnarySelector)</td></tr>
<tr class="memdesc:affe17436c3837899bc7a1f07dd6c23f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches when the selector is a Unary <a class="el" href="classclang_1_1Selector.html" title="Smart pointer class that efficiently represents Objective-C method names.">Selector</a>.  <br /></td></tr>
<tr class="separator:affe17436c3837899bc7a1f07dd6c23f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210ce15787ad4e0ef9f5f8bdd0b1b7b3" id="r_a210ce15787ad4e0ef9f5f8bdd0b1b7b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a210ce15787ad4e0ef9f5f8bdd0b1b7b3">AST_MATCHER</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, hasKeywordSelector)</td></tr>
<tr class="memdesc:a210ce15787ad4e0ef9f5f8bdd0b1b7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches when the selector is a keyword selector.  <br /></td></tr>
<tr class="separator:a210ce15787ad4e0ef9f5f8bdd0b1b7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b6b13e9f4c74054e742f1222a70a8c" id="r_a73b6b13e9f4c74054e742f1222a70a8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73b6b13e9f4c74054e742f1222a70a8c">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, numSelectorArgs, <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a>)</td></tr>
<tr class="memdesc:a73b6b13e9f4c74054e742f1222a70a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches when the selector has the specified number of arguments.  <br /></td></tr>
<tr class="separator:a73b6b13e9f4c74054e742f1222a70a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c658c5f5005a9159e4a74960fa3e0f" id="r_a09c658c5f5005a9159e4a74960fa3e0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09c658c5f5005a9159e4a74960fa3e0f">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, callee, internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a09c658c5f5005a9159e4a74960fa3e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the call expression's callee expression matches.  <br /></td></tr>
<tr class="separator:a09c658c5f5005a9159e4a74960fa3e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20927991ed40f5b7fc29095fa96e9c36" id="r_a20927991ed40f5b7fc29095fa96e9c36"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20927991ed40f5b7fc29095fa96e9c36">AST_MATCHER_P_OVERLOAD</a> (<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, callee, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher, 1)</td></tr>
<tr class="memdesc:a20927991ed40f5b7fc29095fa96e9c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the call expression's callee's declaration matches the given matcher.  <br /></td></tr>
<tr class="separator:a20927991ed40f5b7fc29095fa96e9c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0bd88ac6ae6bca91d3ae01966af957" id="r_a9c0bd88ac6ae6bca91d3ae01966af957"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c0bd88ac6ae6bca91d3ae01966af957">AST_POLYMORPHIC_MATCHER_P_OVERLOAD</a> (hasType, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Expr.html">Expr</a>, <a class="el" href="classclang_1_1FriendDecl.html">FriendDecl</a>, <a class="el" href="classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>, <a class="el" href="classclang_1_1ValueDecl.html">ValueDecl</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher, 0)</td></tr>
<tr class="memdesc:a9c0bd88ac6ae6bca91d3ae01966af957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the expression's or declaration's type matches a type matcher.  <br /></td></tr>
<tr class="separator:a9c0bd88ac6ae6bca91d3ae01966af957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3a094ff7ddc1b0328cb262bffc465b" id="r_ace3a094ff7ddc1b0328cb262bffc465b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace3a094ff7ddc1b0328cb262bffc465b">AST_POLYMORPHIC_MATCHER_P_OVERLOAD</a> (hasType, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Expr.html">Expr</a>, <a class="el" href="classclang_1_1FriendDecl.html">FriendDecl</a>, <a class="el" href="classclang_1_1ValueDecl.html">ValueDecl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher, 1)</td></tr>
<tr class="memdesc:ace3a094ff7ddc1b0328cb262bffc465b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded to match the declaration of the expression's or value declaration's type.  <br /></td></tr>
<tr class="separator:ace3a094ff7ddc1b0328cb262bffc465b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70221b7c61d02178a8b1bd7f4c051bf5" id="r_a70221b7c61d02178a8b1bd7f4c051bf5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70221b7c61d02178a8b1bd7f4c051bf5">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a>, hasTypeLoc, internal::Matcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;, Inner)</td></tr>
<tr class="memdesc:a70221b7c61d02178a8b1bd7f4c051bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the type location of the declarator decl's type matches the inner matcher.  <br /></td></tr>
<tr class="separator:a70221b7c61d02178a8b1bd7f4c051bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d441fb8797a726cc8f58469ea017523" id="r_a8d441fb8797a726cc8f58469ea017523"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d441fb8797a726cc8f58469ea017523">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, asString, std::string, Name)</td></tr>
<tr class="memdesc:a8d441fb8797a726cc8f58469ea017523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the matched type is represented by the given string.  <br /></td></tr>
<tr class="separator:a8d441fb8797a726cc8f58469ea017523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34619df672712c3c1b89e9556ea6fb5e" id="r_a34619df672712c3c1b89e9556ea6fb5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34619df672712c3c1b89e9556ea6fb5e">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, pointsTo, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a34619df672712c3c1b89e9556ea6fb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the matched type is a pointer type and the pointee type matches the specified matcher.  <br /></td></tr>
<tr class="separator:a34619df672712c3c1b89e9556ea6fb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6356d65a88dcac0fda65fd48fa0338" id="r_aac6356d65a88dcac0fda65fd48fa0338"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac6356d65a88dcac0fda65fd48fa0338">AST_MATCHER_P_OVERLOAD</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, pointsTo, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher, 1)</td></tr>
<tr class="memdesc:aac6356d65a88dcac0fda65fd48fa0338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded to match the pointee type's declaration.  <br /></td></tr>
<tr class="separator:aac6356d65a88dcac0fda65fd48fa0338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce9ed079b63bde07a29f118be67d998" id="r_a6ce9ed079b63bde07a29f118be67d998"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ce9ed079b63bde07a29f118be67d998">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1Type.html">Type</a>, hasUnqualifiedDesugaredType, internal::Matcher&lt; <a class="el" href="classclang_1_1Type.html">Type</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a6ce9ed079b63bde07a29f118be67d998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the matched type matches the unqualified desugared type of the matched node.  <br /></td></tr>
<tr class="separator:a6ce9ed079b63bde07a29f118be67d998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326c00e2c764f18193b0e2ba5050199a" id="r_a326c00e2c764f18193b0e2ba5050199a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a326c00e2c764f18193b0e2ba5050199a">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, references, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a326c00e2c764f18193b0e2ba5050199a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the matched type is a reference type and the referenced type matches the specified matcher.  <br /></td></tr>
<tr class="separator:a326c00e2c764f18193b0e2ba5050199a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0898cce8002e6e0db4a3e13b5e9d7ff" id="r_aa0898cce8002e6e0db4a3e13b5e9d7ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0898cce8002e6e0db4a3e13b5e9d7ff">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, hasCanonicalType, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:aa0898cce8002e6e0db4a3e13b5e9d7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches QualTypes whose canonical type matches InnerMatcher.  <br /></td></tr>
<tr class="separator:aa0898cce8002e6e0db4a3e13b5e9d7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee02e539525731a4811d4d33437b5ff7" id="r_aee02e539525731a4811d4d33437b5ff7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee02e539525731a4811d4d33437b5ff7">AST_MATCHER_P_OVERLOAD</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, references, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher, 1)</td></tr>
<tr class="memdesc:aee02e539525731a4811d4d33437b5ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded to match the referenced type's declaration.  <br /></td></tr>
<tr class="separator:aee02e539525731a4811d4d33437b5ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9312d37843a929bb3d5e3fc89f6582" id="r_a4d9312d37843a929bb3d5e3fc89f6582"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d9312d37843a929bb3d5e3fc89f6582">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a>, onImplicitObjectArgument, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a4d9312d37843a929bb3d5e3fc89f6582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches on the implicit object argument of a member call expression.  <br /></td></tr>
<tr class="separator:a4d9312d37843a929bb3d5e3fc89f6582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ef01849f0ca8c3b8b5222a4b8e0522" id="r_a86ef01849f0ca8c3b8b5222a4b8e0522"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86ef01849f0ca8c3b8b5222a4b8e0522">AST_MATCHER_P_OVERLOAD</a> (<a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a>, thisPointerType, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher, 0)</td></tr>
<tr class="memdesc:a86ef01849f0ca8c3b8b5222a4b8e0522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the type of the expression's implicit object argument either matches the InnerMatcher, or is a pointer to a type that matches the InnerMatcher.  <br /></td></tr>
<tr class="separator:a86ef01849f0ca8c3b8b5222a4b8e0522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8932ce498cc406f28f22149d1936c4b1" id="r_a8932ce498cc406f28f22149d1936c4b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8932ce498cc406f28f22149d1936c4b1">AST_MATCHER_P_OVERLOAD</a> (<a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a>, thisPointerType, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher, 1)</td></tr>
<tr class="memdesc:a8932ce498cc406f28f22149d1936c4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded to match the type's declaration.  <br /></td></tr>
<tr class="separator:a8932ce498cc406f28f22149d1936c4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae2d3c41e0c472fa618cfa95c73f17e" id="r_a2ae2d3c41e0c472fa618cfa95c73f17e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ae2d3c41e0c472fa618cfa95c73f17e">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1DeclRefExpr.html">DeclRefExpr</a>, to, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a2ae2d3c41e0c472fa618cfa95c73f17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a <a class="el" href="classclang_1_1DeclRefExpr.html" title="A reference to a declared variable, function, enum, etc.">DeclRefExpr</a> that refers to a declaration that matches the specified matcher.  <br /></td></tr>
<tr class="separator:a2ae2d3c41e0c472fa618cfa95c73f17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ec27f3345fc83828f6ad90a25a5ec6" id="r_a75ec27f3345fc83828f6ad90a25a5ec6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75ec27f3345fc83828f6ad90a25a5ec6">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1DeclRefExpr.html">DeclRefExpr</a>, throughUsingDecl, internal::Matcher&lt; <a class="el" href="classclang_1_1UsingShadowDecl.html">UsingShadowDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a75ec27f3345fc83828f6ad90a25a5ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a <code><a class="el" href="classclang_1_1DeclRefExpr.html" title="A reference to a declared variable, function, enum, etc.">DeclRefExpr</a></code> that refers to a declaration through a specific using shadow declaration.  <br /></td></tr>
<tr class="separator:a75ec27f3345fc83828f6ad90a25a5ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ee00dadd390e9911cdc64d2f0f0aa0" id="r_a19ee00dadd390e9911cdc64d2f0f0aa0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19ee00dadd390e9911cdc64d2f0f0aa0">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1OverloadExpr.html">OverloadExpr</a>, hasAnyDeclaration, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a19ee00dadd390e9911cdc64d2f0f0aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches an <code><a class="el" href="classclang_1_1OverloadExpr.html" title="A reference to an overloaded function set, either an UnresolvedLookupExpr or an UnresolvedMemberExpr.">OverloadExpr</a></code> if any of the declarations in the set of overloads matches the given matcher.  <br /></td></tr>
<tr class="separator:a19ee00dadd390e9911cdc64d2f0f0aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3490831f470cc4fa91a8e69e2b49cb92" id="r_a3490831f470cc4fa91a8e69e2b49cb92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3490831f470cc4fa91a8e69e2b49cb92">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1DeclStmt.html">DeclStmt</a>, hasSingleDecl, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a3490831f470cc4fa91a8e69e2b49cb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the <a class="el" href="classclang_1_1Decl.html" title="Decl - This represents one declaration (or definition), e.g.">Decl</a> of a <a class="el" href="classclang_1_1DeclStmt.html" title="DeclStmt - Adaptor class for mixing declarations with statements and expressions.">DeclStmt</a> which has a single declaration.  <br /></td></tr>
<tr class="separator:a3490831f470cc4fa91a8e69e2b49cb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17df7f136021603cccaee853f067429" id="r_af17df7f136021603cccaee853f067429"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af17df7f136021603cccaee853f067429">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, hasInitializer, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:af17df7f136021603cccaee853f067429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a variable declaration that has an initializer expression that matches the given matcher.  <br /></td></tr>
<tr class="separator:af17df7f136021603cccaee853f067429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b5af78266c07a51fc05b0340faa5f0" id="r_a40b5af78266c07a51fc05b0340faa5f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40b5af78266c07a51fc05b0340faa5f0">AST_MATCHER</a> (<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, isStaticLocal)</td></tr>
<tr class="memdesc:a40b5af78266c07a51fc05b0340faa5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a static variable with local scope.  <br /></td></tr>
<tr class="separator:a40b5af78266c07a51fc05b0340faa5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20615f964d0cc210125ba1a7030e1d99" id="r_a20615f964d0cc210125ba1a7030e1d99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20615f964d0cc210125ba1a7030e1d99">AST_MATCHER</a> (<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, hasLocalStorage)</td></tr>
<tr class="memdesc:a20615f964d0cc210125ba1a7030e1d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a variable declaration that has function scope and is a non-static local variable.  <br /></td></tr>
<tr class="separator:a20615f964d0cc210125ba1a7030e1d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb8c35f77273ca8c9d74d3ccd8115ee" id="r_a9fb8c35f77273ca8c9d74d3ccd8115ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fb8c35f77273ca8c9d74d3ccd8115ee">AST_MATCHER</a> (<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, hasGlobalStorage)</td></tr>
<tr class="memdesc:a9fb8c35f77273ca8c9d74d3ccd8115ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a variable declaration that does not have local storage.  <br /></td></tr>
<tr class="separator:a9fb8c35f77273ca8c9d74d3ccd8115ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1491a3107fcb1a9823b82f0e0d2c8f8b" id="r_a1491a3107fcb1a9823b82f0e0d2c8f8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1491a3107fcb1a9823b82f0e0d2c8f8b">AST_MATCHER</a> (<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, hasAutomaticStorageDuration)</td></tr>
<tr class="memdesc:a1491a3107fcb1a9823b82f0e0d2c8f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a variable declaration that has automatic storage duration.  <br /></td></tr>
<tr class="separator:a1491a3107fcb1a9823b82f0e0d2c8f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1c982b6814464ccb0e81ad49e5deb8" id="r_abe1c982b6814464ccb0e81ad49e5deb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe1c982b6814464ccb0e81ad49e5deb8">AST_MATCHER</a> (<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, hasStaticStorageDuration)</td></tr>
<tr class="memdesc:abe1c982b6814464ccb0e81ad49e5deb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a variable declaration that has static storage duration.  <br /></td></tr>
<tr class="separator:abe1c982b6814464ccb0e81ad49e5deb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea11fc4361920f652b8655a7fc1ce7a" id="r_abea11fc4361920f652b8655a7fc1ce7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abea11fc4361920f652b8655a7fc1ce7a">AST_MATCHER</a> (<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, hasThreadStorageDuration)</td></tr>
<tr class="memdesc:abea11fc4361920f652b8655a7fc1ce7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a variable declaration that has thread storage duration.  <br /></td></tr>
<tr class="separator:abea11fc4361920f652b8655a7fc1ce7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5663ab187f13ea8c1a0d3884a5837369" id="r_a5663ab187f13ea8c1a0d3884a5837369"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5663ab187f13ea8c1a0d3884a5837369">AST_MATCHER</a> (<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, isExceptionVariable)</td></tr>
<tr class="memdesc:a5663ab187f13ea8c1a0d3884a5837369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a variable declaration that is an exception variable from a C++ catch block, or an Objective-C @catch statement.  <br /></td></tr>
<tr class="separator:a5663ab187f13ea8c1a0d3884a5837369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a4ccd4bcea5a4e03c1a502b4febba3" id="r_a46a4ccd4bcea5a4e03c1a502b4febba3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46a4ccd4bcea5a4e03c1a502b4febba3">AST_POLYMORPHIC_MATCHER_P</a> (argumentCountIs, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>, <a class="el" href="classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>, <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>), <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a>)</td></tr>
<tr class="memdesc:a46a4ccd4bcea5a4e03c1a502b4febba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that a call expression or a constructor call expression has a specific number of arguments (including absent default arguments).  <br /></td></tr>
<tr class="separator:a46a4ccd4bcea5a4e03c1a502b4febba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47efa625b357d8576ddd7845b4d8a2e" id="r_ad47efa625b357d8576ddd7845b4d8a2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad47efa625b357d8576ddd7845b4d8a2e">AST_POLYMORPHIC_MATCHER_P2</a> (hasArgument, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>, <a class="el" href="classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>, <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>), <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a>, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ad47efa625b357d8576ddd7845b4d8a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the n'th argument of a call expression or a constructor call expression.  <br /></td></tr>
<tr class="separator:ad47efa625b357d8576ddd7845b4d8a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a44f1320d0ad1ade3dc82fc4730f17f" id="r_a0a44f1320d0ad1ade3dc82fc4730f17f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a44f1320d0ad1ade3dc82fc4730f17f">AST_MATCHER_P2</a> (<a class="el" href="classclang_1_1InitListExpr.html">InitListExpr</a>, hasInit, <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a>, ast_matchers::internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a0a44f1320d0ad1ade3dc82fc4730f17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the n'th item of an initializer list expression.  <br /></td></tr>
<tr class="separator:a0a44f1320d0ad1ade3dc82fc4730f17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3e9465ba62aea874dab861b34a2484" id="r_aad3e9465ba62aea874dab861b34a2484"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad3e9465ba62aea874dab861b34a2484">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1DeclStmt.html">DeclStmt</a>, declCountIs, <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a>)</td></tr>
<tr class="memdesc:aad3e9465ba62aea874dab861b34a2484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches declaration statements that contain a specific number of declarations.  <br /></td></tr>
<tr class="separator:aad3e9465ba62aea874dab861b34a2484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436242d922937081d26821317552407e" id="r_a436242d922937081d26821317552407e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a436242d922937081d26821317552407e">AST_MATCHER_P2</a> (<a class="el" href="classclang_1_1DeclStmt.html">DeclStmt</a>, containsDeclaration, <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a>, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a436242d922937081d26821317552407e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the n'th declaration of a declaration statement.  <br /></td></tr>
<tr class="separator:a436242d922937081d26821317552407e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75db3620648d58f6be5e799142f86a31" id="r_a75db3620648d58f6be5e799142f86a31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75db3620648d58f6be5e799142f86a31">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXCatchStmt.html">CXXCatchStmt</a>, isCatchAll)</td></tr>
<tr class="memdesc:a75db3620648d58f6be5e799142f86a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a C++ catch statement that has a catch-all handler.  <br /></td></tr>
<tr class="separator:a75db3620648d58f6be5e799142f86a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1706a42c87f0ca22a7ab5875eb6d074b" id="r_a1706a42c87f0ca22a7ab5875eb6d074b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1706a42c87f0ca22a7ab5875eb6d074b">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>, hasAnyConstructorInitializer, internal::Matcher&lt; <a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a1706a42c87f0ca22a7ab5875eb6d074b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constructor initializer.  <br /></td></tr>
<tr class="separator:a1706a42c87f0ca22a7ab5875eb6d074b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdaa82b53209463877c44d74dab03d4" id="r_a9bdaa82b53209463877c44d74dab03d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bdaa82b53209463877c44d74dab03d4">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>, forField, internal::Matcher&lt; <a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a9bdaa82b53209463877c44d74dab03d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the field declaration of a constructor initializer.  <br /></td></tr>
<tr class="separator:a9bdaa82b53209463877c44d74dab03d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc97227bc2ea23c497ac5c88111fcab7" id="r_abc97227bc2ea23c497ac5c88111fcab7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc97227bc2ea23c497ac5c88111fcab7">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>, withInitializer, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:abc97227bc2ea23c497ac5c88111fcab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the initializer expression of a constructor initializer.  <br /></td></tr>
<tr class="separator:abc97227bc2ea23c497ac5c88111fcab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f7a8a989c0ca1eaa26b3045b1ceaab" id="r_a03f7a8a989c0ca1eaa26b3045b1ceaab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03f7a8a989c0ca1eaa26b3045b1ceaab">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>, isWritten)</td></tr>
<tr class="memdesc:a03f7a8a989c0ca1eaa26b3045b1ceaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constructor initializer if it is explicitly written in code (as opposed to implicitly added by the compiler).  <br /></td></tr>
<tr class="separator:a03f7a8a989c0ca1eaa26b3045b1ceaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151df67d97404bc1b336c5dfc6d01951" id="r_a151df67d97404bc1b336c5dfc6d01951"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a151df67d97404bc1b336c5dfc6d01951">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>, isBaseInitializer)</td></tr>
<tr class="memdesc:a151df67d97404bc1b336c5dfc6d01951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constructor initializer if it is initializing a base, as opposed to a member.  <br /></td></tr>
<tr class="separator:a151df67d97404bc1b336c5dfc6d01951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4740b640dfb1653cfed5729b59331761" id="r_a4740b640dfb1653cfed5729b59331761"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4740b640dfb1653cfed5729b59331761">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>, isMemberInitializer)</td></tr>
<tr class="memdesc:a4740b640dfb1653cfed5729b59331761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constructor initializer if it is initializing a member, as opposed to a base.  <br /></td></tr>
<tr class="separator:a4740b640dfb1653cfed5729b59331761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33beb8112c5d3457aa00768aaafc89f2" id="r_a33beb8112c5d3457aa00768aaafc89f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33beb8112c5d3457aa00768aaafc89f2">AST_POLYMORPHIC_MATCHER_P</a> (hasAnyArgument, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>, <a class="el" href="classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>, <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a33beb8112c5d3457aa00768aaafc89f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any argument of a call expression or a constructor call expression, or an ObjC-message-send expression.  <br /></td></tr>
<tr class="separator:a33beb8112c5d3457aa00768aaafc89f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bfbea7f3e4c3dd22b5d24bd1fdaa28" id="r_a88bfbea7f3e4c3dd22b5d24bd1fdaa28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88bfbea7f3e4c3dd22b5d24bd1fdaa28">AST_MATCHER_P_OVERLOAD</a> (<a class="el" href="classclang_1_1LambdaExpr.html">LambdaExpr</a>, hasAnyCapture, internal::Matcher&lt; <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a> &gt;, InnerMatcher, 0)</td></tr>
<tr class="memdesc:a88bfbea7f3e4c3dd22b5d24bd1fdaa28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any capture of a lambda expression.  <br /></td></tr>
<tr class="separator:a88bfbea7f3e4c3dd22b5d24bd1fdaa28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438d656e0ac87b0ee046d8451594632e" id="r_a438d656e0ac87b0ee046d8451594632e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a438d656e0ac87b0ee046d8451594632e">AST_MATCHER_P_OVERLOAD</a> (<a class="el" href="classclang_1_1LambdaExpr.html">LambdaExpr</a>, hasAnyCapture, internal::Matcher&lt; <a class="el" href="classclang_1_1CXXThisExpr.html">CXXThisExpr</a> &gt;, InnerMatcher, 1)</td></tr>
<tr class="memdesc:a438d656e0ac87b0ee046d8451594632e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any capture of 'this' in a lambda expression.  <br /></td></tr>
<tr class="separator:a438d656e0ac87b0ee046d8451594632e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8113d0616cb8189881b650642e748512" id="r_a8113d0616cb8189881b650642e748512"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8113d0616cb8189881b650642e748512">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>, isListInitialization)</td></tr>
<tr class="memdesc:a8113d0616cb8189881b650642e748512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constructor call expression which uses list initialization.  <br /></td></tr>
<tr class="separator:a8113d0616cb8189881b650642e748512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5125c811ce3f78efc6ab3c5a1bf68362" id="r_a5125c811ce3f78efc6ab3c5a1bf68362"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5125c811ce3f78efc6ab3c5a1bf68362">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>, requiresZeroInitialization)</td></tr>
<tr class="memdesc:a5125c811ce3f78efc6ab3c5a1bf68362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constructor call expression which requires zero initialization.  <br /></td></tr>
<tr class="separator:a5125c811ce3f78efc6ab3c5a1bf68362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ebb293017dba39bb149d8faea59176" id="r_a79ebb293017dba39bb149d8faea59176"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79ebb293017dba39bb149d8faea59176">AST_POLYMORPHIC_MATCHER_P2</a> (hasParameter, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>, <a class="el" href="classclang_1_1BlockDecl.html">BlockDecl</a>), <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a>, internal::Matcher&lt; <a class="el" href="classclang_1_1ParmVarDecl.html">ParmVarDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a79ebb293017dba39bb149d8faea59176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the n'th parameter of a function or an ObjC method declaration or a block.  <br /></td></tr>
<tr class="separator:a79ebb293017dba39bb149d8faea59176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af575f4746ac9a3a887ba95055a0b98" id="r_a2af575f4746ac9a3a887ba95055a0b98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2af575f4746ac9a3a887ba95055a0b98">AST_POLYMORPHIC_MATCHER_P2</a> (forEachArgumentWithParam, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, ArgMatcher, internal::Matcher&lt; <a class="el" href="classclang_1_1ParmVarDecl.html">ParmVarDecl</a> &gt;, ParamMatcher)</td></tr>
<tr class="memdesc:a2af575f4746ac9a3a887ba95055a0b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches all arguments and their respective <a class="el" href="classclang_1_1ParmVarDecl.html" title="Represents a parameter to a function.">ParmVarDecl</a>.  <br /></td></tr>
<tr class="separator:a2af575f4746ac9a3a887ba95055a0b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7884898943337e06f5ab539e5b508b0" id="r_af7884898943337e06f5ab539e5b508b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7884898943337e06f5ab539e5b508b0">AST_POLYMORPHIC_MATCHER_P2</a> (forEachArgumentWithParamType, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, ArgMatcher, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, ParamMatcher)</td></tr>
<tr class="memdesc:af7884898943337e06f5ab539e5b508b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches all arguments and their respective types for a <code><a class="el" href="classclang_1_1CallExpr.html" title="CallExpr - Represents a function call (C99 6.5.2.2, C++ [expr.call]).">CallExpr</a></code> or <code><a class="el" href="classclang_1_1CXXConstructExpr.html" title="Represents a call to a C++ constructor.">CXXConstructExpr</a></code>.  <br /></td></tr>
<tr class="separator:af7884898943337e06f5ab539e5b508b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5713ebcfebb04bcfd89e6098999e65" id="r_aaa5713ebcfebb04bcfd89e6098999e65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa5713ebcfebb04bcfd89e6098999e65">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a>, isAllowedToContainClauseKind, <a class="el" href="namespaceclang.html#af4e75364acc81a070837a4344d437322">OpenMPClauseKind</a>, CKind)</td></tr>
<tr class="memdesc:aaa5713ebcfebb04bcfd89e6098999e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">/ Matches each case or default statement belonging to the given switch / statement.  <br /></td></tr>
<tr class="separator:aaa5713ebcfebb04bcfd89e6098999e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e076c5e724f5522f9c51ffdc6dddf89" id="r_a6e076c5e724f5522f9c51ffdc6dddf89"><td class="memTemplParams" colspan="2">template&lt;typename MatcherT &gt; </td></tr>
<tr class="memitem:a6e076c5e724f5522f9c51ffdc6dddf89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6e076c5e724f5522f9c51ffdc6dddf89">match</a> (MatcherT Matcher, <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;Context)</td></tr>
<tr class="memdesc:a6e076c5e724f5522f9c51ffdc6dddf89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the results of matching <code>Matcher</code> on the translation unit of <code>Context</code> and collects the <code><a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html" title="Maps string IDs to AST nodes matched by parts of a matcher.">BoundNodes</a></code> of all callback invocations.  <br /></td></tr>
<tr class="separator:a6e076c5e724f5522f9c51ffdc6dddf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89709e44a7ac7799bcec565b520b84d2" id="r_a89709e44a7ac7799bcec565b520b84d2"><td class="memTemplParams" colspan="2">template&lt;typename NodeT &gt; </td></tr>
<tr class="memitem:a89709e44a7ac7799bcec565b520b84d2"><td class="memTemplItemLeft" align="right" valign="top">const NodeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a89709e44a7ac7799bcec565b520b84d2">selectFirst</a> (StringRef BoundTo, const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a> &gt; &amp;Results)</td></tr>
<tr class="memdesc:a89709e44a7ac7799bcec565b520b84d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first result of type <code>NodeT</code> bound to <code>BoundTo</code>.  <br /></td></tr>
<tr class="separator:a89709e44a7ac7799bcec565b520b84d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab666f10013e666080d4e4e89a6f8720e" id="r_ab666f10013e666080d4e4e89a6f8720e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab666f10013e666080d4e4e89a6f8720e">matchDynamic</a> (internal::DynTypedMatcher Matcher, const <a class="el" href="classclang_1_1DynTypedNode.html">DynTypedNode</a> &amp;<a class="el" href="ASTMatchFinder_8cpp.html#a32ca2adfad3611927e87efc253e7b7b1">Node</a>, <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;Context)</td></tr>
<tr class="separator:ab666f10013e666080d4e4e89a6f8720e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50863fce9ec1a5a6825dcd61fc3e3b94" id="r_a50863fce9ec1a5a6825dcd61fc3e3b94"><td class="memTemplParams" colspan="2">template&lt;typename NodeT &gt; </td></tr>
<tr class="memitem:a50863fce9ec1a5a6825dcd61fc3e3b94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a50863fce9ec1a5a6825dcd61fc3e3b94">matchDynamic</a> (internal::DynTypedMatcher Matcher, const NodeT &amp;<a class="el" href="ASTMatchFinder_8cpp.html#a32ca2adfad3611927e87efc253e7b7b1">Node</a>, <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;Context)</td></tr>
<tr class="separator:a50863fce9ec1a5a6825dcd61fc3e3b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b18aa6615181bd14a336f56bef00a95" id="r_a9b18aa6615181bd14a336f56bef00a95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b18aa6615181bd14a336f56bef00a95">matchDynamic</a> (internal::DynTypedMatcher Matcher, <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;Context)</td></tr>
<tr class="separator:a9b18aa6615181bd14a336f56bef00a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03719ad642f4411e33d92b1081361f07" id="r_a03719ad642f4411e33d92b1081361f07"><td class="memItemLeft" align="right" valign="top">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03719ad642f4411e33d92b1081361f07">gtestAssert</a> (<a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a> Cmp, <a class="el" href="#a85886610fb27988c71cb3d5134c2302d">StatementMatcher</a> Left, <a class="el" href="#a85886610fb27988c71cb3d5134c2302d">StatementMatcher</a> Right)</td></tr>
<tr class="memdesc:a03719ad642f4411e33d92b1081361f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matcher for gtest's ASSERT_... macros.  <br /></td></tr>
<tr class="separator:a03719ad642f4411e33d92b1081361f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33afaf3f80e491354dc39625e4a6785b" id="r_a33afaf3f80e491354dc39625e4a6785b"><td class="memItemLeft" align="right" valign="top">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33afaf3f80e491354dc39625e4a6785b">gtestExpect</a> (<a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a> Cmp, <a class="el" href="#a85886610fb27988c71cb3d5134c2302d">StatementMatcher</a> Left, <a class="el" href="#a85886610fb27988c71cb3d5134c2302d">StatementMatcher</a> Right)</td></tr>
<tr class="memdesc:a33afaf3f80e491354dc39625e4a6785b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matcher for gtest's EXPECT_... macros.  <br /></td></tr>
<tr class="separator:a33afaf3f80e491354dc39625e4a6785b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ca863c3bc2d2bc5af99d90933d6e9c" id="r_ac1ca863c3bc2d2bc5af99d90933d6e9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1ca863c3bc2d2bc5af99d90933d6e9c">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, hasAnySelectorMatcher, std::vector&lt; std::string &gt;, Matches)</td></tr>
<tr class="separator:ac1ca863c3bc2d2bc5af99d90933d6e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e40f7a7120043b6e36077adcf44c9cd" id="r_a9e40f7a7120043b6e36077adcf44c9cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e40f7a7120043b6e36077adcf44c9cd">AST_TYPELOC_TRAVERSE_MATCHER_DEF</a> (hasElementType, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ArrayType.html">ArrayType</a>, <a class="el" href="classclang_1_1ComplexType.html">ComplexType</a>))</td></tr>
<tr class="separator:a9e40f7a7120043b6e36077adcf44c9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953d25fd07bb81ad8bf5a87a0068f13b" id="r_a953d25fd07bb81ad8bf5a87a0068f13b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a953d25fd07bb81ad8bf5a87a0068f13b">AST_TYPELOC_TRAVERSE_MATCHER_DEF</a> (hasValueType, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1AtomicType.html">AtomicType</a>))</td></tr>
<tr class="separator:a953d25fd07bb81ad8bf5a87a0068f13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3509e3798b4581a7a8cb59106aa6b73" id="r_ad3509e3798b4581a7a8cb59106aa6b73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3509e3798b4581a7a8cb59106aa6b73">AST_TYPELOC_TRAVERSE_MATCHER_DEF</a> (pointee, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BlockPointerType.html">BlockPointerType</a>, <a class="el" href="classclang_1_1MemberPointerType.html">MemberPointerType</a>, <a class="el" href="classclang_1_1PointerType.html">PointerType</a>, <a class="el" href="classclang_1_1ReferenceType.html">ReferenceType</a>))</td></tr>
<tr class="separator:ad3509e3798b4581a7a8cb59106aa6b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300e0f48793e28002e73a44d46dc3392" id="r_a300e0f48793e28002e73a44d46dc3392"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a1d77576823c6c764d94aca78ada0f5ad">DeclarationMatcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a300e0f48793e28002e73a44d46dc3392">getComparisonDecl</a> (<a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a> Cmp)</td></tr>
<tr class="separator:a300e0f48793e28002e73a44d46dc3392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3ba396d70c6dfae8235cfdb3f3c0db" id="r_a1f3ba396d70c6dfae8235cfdb3f3c0db"><td class="memItemLeft" align="right" valign="top">static llvm::StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f3ba396d70c6dfae8235cfdb3f3c0db">getAssertMacro</a> (<a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a> Cmp)</td></tr>
<tr class="separator:a1f3ba396d70c6dfae8235cfdb3f3c0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e74342ecb22e45bbbd89e08604e431c" id="r_a5e74342ecb22e45bbbd89e08604e431c"><td class="memItemLeft" align="right" valign="top">static llvm::StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e74342ecb22e45bbbd89e08604e431c">getExpectMacro</a> (<a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a> Cmp)</td></tr>
<tr class="separator:a5e74342ecb22e45bbbd89e08604e431c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a58409ce605d979d1d1e0a600ec417a0a" id="r_a58409ce605d979d1d1e0a600ec417a0a"><td class="memTemplParams" colspan="2">template&lt;typename MatcherT , typename NodeT &gt; </td></tr>
<tr class="memitem:a58409ce605d979d1d1e0a600ec417a0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a58409ce605d979d1d1e0a600ec417a0a">match</a> (MatcherT Matcher, const NodeT &amp;<a class="el" href="ASTMatchFinder_8cpp.html#a32ca2adfad3611927e87efc253e7b7b1">Node</a>, <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;Context)</td></tr>
<tr class="memdesc:a58409ce605d979d1d1e0a600ec417a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the results of matching <code>Matcher</code> on <code>Node</code>.  <br /></td></tr>
<tr class="separator:a58409ce605d979d1d1e0a600ec417a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eef98a03801d29f261611aef6b48f0f" id="r_a6eef98a03801d29f261611aef6b48f0f"><td class="memTemplParams" colspan="2">template&lt;typename MatcherT &gt; </td></tr>
<tr class="memitem:a6eef98a03801d29f261611aef6b48f0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6eef98a03801d29f261611aef6b48f0f">match</a> (MatcherT Matcher, const <a class="el" href="classclang_1_1DynTypedNode.html">DynTypedNode</a> &amp;<a class="el" href="ASTMatchFinder_8cpp.html#a32ca2adfad3611927e87efc253e7b7b1">Node</a>, <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;Context)</td></tr>
<tr class="separator:a6eef98a03801d29f261611aef6b48f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aaa73ed83faa263bfb5cface81d30ef91" id="r_aaa73ed83faa263bfb5cface81d30ef91"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TranslationUnitDecl.html">TranslationUnitDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa73ed83faa263bfb5cface81d30ef91">translationUnitDecl</a></td></tr>
<tr class="memdesc:aaa73ed83faa263bfb5cface81d30ef91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the top declaration context.  <br /></td></tr>
<tr class="separator:aaa73ed83faa263bfb5cface81d30ef91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8a234965f6e7ef273e30c9b19fd778" id="r_a3c8a234965f6e7ef273e30c9b19fd778"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TypedefDecl.html">TypedefDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c8a234965f6e7ef273e30c9b19fd778">typedefDecl</a></td></tr>
<tr class="memdesc:a3c8a234965f6e7ef273e30c9b19fd778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches typedef declarations.  <br /></td></tr>
<tr class="separator:a3c8a234965f6e7ef273e30c9b19fd778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e36abe1065caf311d087b0a24ce3b00" id="r_a0e36abe1065caf311d087b0a24ce3b00"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e36abe1065caf311d087b0a24ce3b00">typedefNameDecl</a></td></tr>
<tr class="memdesc:a0e36abe1065caf311d087b0a24ce3b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches typedef name declarations.  <br /></td></tr>
<tr class="separator:a0e36abe1065caf311d087b0a24ce3b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f1d727044894974cd023ecdd58c879" id="r_a13f1d727044894974cd023ecdd58c879"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TypeAliasDecl.html">TypeAliasDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13f1d727044894974cd023ecdd58c879">typeAliasDecl</a></td></tr>
<tr class="memdesc:a13f1d727044894974cd023ecdd58c879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches type alias declarations.  <br /></td></tr>
<tr class="separator:a13f1d727044894974cd023ecdd58c879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89576459aa43e2e320832d2221f6d405" id="r_a89576459aa43e2e320832d2221f6d405"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TypeAliasTemplateDecl.html">TypeAliasTemplateDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89576459aa43e2e320832d2221f6d405">typeAliasTemplateDecl</a></td></tr>
<tr class="memdesc:a89576459aa43e2e320832d2221f6d405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches type alias template declarations.  <br /></td></tr>
<tr class="separator:a89576459aa43e2e320832d2221f6d405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ccadfbea5e9e43c2153175afca6cac" id="r_ac5ccadfbea5e9e43c2153175afca6cac"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5ccadfbea5e9e43c2153175afca6cac">decl</a></td></tr>
<tr class="memdesc:ac5ccadfbea5e9e43c2153175afca6cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches declarations.  <br /></td></tr>
<tr class="separator:ac5ccadfbea5e9e43c2153175afca6cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c34f70634543e4f54c46ee7df6614f" id="r_ab8c34f70634543e4f54c46ee7df6614f"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1DecompositionDecl.html">DecompositionDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8c34f70634543e4f54c46ee7df6614f">decompositionDecl</a></td></tr>
<tr class="memdesc:ab8c34f70634543e4f54c46ee7df6614f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches decomposition-declarations.  <br /></td></tr>
<tr class="separator:ab8c34f70634543e4f54c46ee7df6614f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf8474301563772fb4c854671e4f33f" id="r_a7cf8474301563772fb4c854671e4f33f"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1LinkageSpecDecl.html">LinkageSpecDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cf8474301563772fb4c854671e4f33f">linkageSpecDecl</a></td></tr>
<tr class="memdesc:a7cf8474301563772fb4c854671e4f33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a declaration of a linkage specification.  <br /></td></tr>
<tr class="separator:a7cf8474301563772fb4c854671e4f33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f643ef24ff21b9fcedf8bca5c56a66" id="r_a58f643ef24ff21b9fcedf8bca5c56a66"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58f643ef24ff21b9fcedf8bca5c56a66">namedDecl</a></td></tr>
<tr class="memdesc:a58f643ef24ff21b9fcedf8bca5c56a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a declaration of anything that could have a name.  <br /></td></tr>
<tr class="separator:a58f643ef24ff21b9fcedf8bca5c56a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0e34720bac0bffb62007c39c84ba58" id="r_a6f0e34720bac0bffb62007c39c84ba58"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1LabelDecl.html">LabelDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f0e34720bac0bffb62007c39c84ba58">labelDecl</a></td></tr>
<tr class="memdesc:a6f0e34720bac0bffb62007c39c84ba58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a declaration of label.  <br /></td></tr>
<tr class="separator:a6f0e34720bac0bffb62007c39c84ba58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad499907435f5547a1f44215dd65c00a2" id="r_ad499907435f5547a1f44215dd65c00a2"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NamespaceDecl.html">NamespaceDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad499907435f5547a1f44215dd65c00a2">namespaceDecl</a></td></tr>
<tr class="memdesc:ad499907435f5547a1f44215dd65c00a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a declaration of a namespace.  <br /></td></tr>
<tr class="separator:ad499907435f5547a1f44215dd65c00a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75d519da08b712a2dbc687eb84bfafd" id="r_ab75d519da08b712a2dbc687eb84bfafd"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NamespaceAliasDecl.html">NamespaceAliasDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab75d519da08b712a2dbc687eb84bfafd">namespaceAliasDecl</a></td></tr>
<tr class="memdesc:ab75d519da08b712a2dbc687eb84bfafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a declaration of a namespace alias.  <br /></td></tr>
<tr class="separator:ab75d519da08b712a2dbc687eb84bfafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace97e34c0eac8c61ce7fe928633657c9" id="r_ace97e34c0eac8c61ce7fe928633657c9"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1RecordDecl.html">RecordDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace97e34c0eac8c61ce7fe928633657c9">recordDecl</a></td></tr>
<tr class="memdesc:ace97e34c0eac8c61ce7fe928633657c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches class, struct, and union declarations.  <br /></td></tr>
<tr class="separator:ace97e34c0eac8c61ce7fe928633657c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ef73826e6b83dd0e8fc4a4b7284c74" id="r_ac1ef73826e6b83dd0e8fc4a4b7284c74"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1ef73826e6b83dd0e8fc4a4b7284c74">cxxRecordDecl</a></td></tr>
<tr class="memdesc:ac1ef73826e6b83dd0e8fc4a4b7284c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ class declarations.  <br /></td></tr>
<tr class="separator:ac1ef73826e6b83dd0e8fc4a4b7284c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdb6ae259330bdf0876aba6e07c8710" id="r_afcdb6ae259330bdf0876aba6e07c8710"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ClassTemplateDecl.html">ClassTemplateDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcdb6ae259330bdf0876aba6e07c8710">classTemplateDecl</a></td></tr>
<tr class="memdesc:afcdb6ae259330bdf0876aba6e07c8710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ class template declarations.  <br /></td></tr>
<tr class="separator:afcdb6ae259330bdf0876aba6e07c8710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81538ee441769591ce912334397e6b7" id="r_ab81538ee441769591ce912334397e6b7"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab81538ee441769591ce912334397e6b7">classTemplateSpecializationDecl</a></td></tr>
<tr class="memdesc:ab81538ee441769591ce912334397e6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ class template specializations.  <br /></td></tr>
<tr class="separator:ab81538ee441769591ce912334397e6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614a4778ab8392430ee9a0a28b7e9693" id="r_a614a4778ab8392430ee9a0a28b7e9693"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ClassTemplatePartialSpecializationDecl.html">ClassTemplatePartialSpecializationDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a614a4778ab8392430ee9a0a28b7e9693">classTemplatePartialSpecializationDecl</a></td></tr>
<tr class="memdesc:a614a4778ab8392430ee9a0a28b7e9693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ class template partial specializations.  <br /></td></tr>
<tr class="separator:a614a4778ab8392430ee9a0a28b7e9693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cafc159defa3d1fdcbb28ec72ae418" id="r_a91cafc159defa3d1fdcbb28ec72ae418"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91cafc159defa3d1fdcbb28ec72ae418">declaratorDecl</a></td></tr>
<tr class="memdesc:a91cafc159defa3d1fdcbb28ec72ae418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches declarator declarations (field, variable, function and non-type template parameter declarations).  <br /></td></tr>
<tr class="separator:a91cafc159defa3d1fdcbb28ec72ae418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7539a5a5ad3112f453ffb3ab9a67c5" id="r_a3b7539a5a5ad3112f453ffb3ab9a67c5"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ParmVarDecl.html">ParmVarDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b7539a5a5ad3112f453ffb3ab9a67c5">parmVarDecl</a></td></tr>
<tr class="memdesc:a3b7539a5a5ad3112f453ffb3ab9a67c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches parameter variable declarations.  <br /></td></tr>
<tr class="separator:a3b7539a5a5ad3112f453ffb3ab9a67c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acfa3a6a57ccd2484a71e0f1bbe9c09" id="r_a7acfa3a6a57ccd2484a71e0f1bbe9c09"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1AccessSpecDecl.html">AccessSpecDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7acfa3a6a57ccd2484a71e0f1bbe9c09">accessSpecDecl</a></td></tr>
<tr class="memdesc:a7acfa3a6a57ccd2484a71e0f1bbe9c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ access specifier declarations.  <br /></td></tr>
<tr class="separator:a7acfa3a6a57ccd2484a71e0f1bbe9c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0414dac04ff22f5ebd022efd442d4e" id="r_a2d0414dac04ff22f5ebd022efd442d4e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d0414dac04ff22f5ebd022efd442d4e">cxxCtorInitializer</a></td></tr>
<tr class="memdesc:a2d0414dac04ff22f5ebd022efd442d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches constructor initializers.  <br /></td></tr>
<tr class="separator:a2d0414dac04ff22f5ebd022efd442d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c848824461ac59d9a1c7e7aeea9ec3" id="r_a56c848824461ac59d9a1c7e7aeea9ec3"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56c848824461ac59d9a1c7e7aeea9ec3">templateArgument</a></td></tr>
<tr class="memdesc:a56c848824461ac59d9a1c7e7aeea9ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template arguments.  <br /></td></tr>
<tr class="separator:a56c848824461ac59d9a1c7e7aeea9ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2354be35a4ff17fd80deade9753ea97" id="r_ac2354be35a4ff17fd80deade9753ea97"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2354be35a4ff17fd80deade9753ea97">templateArgumentLoc</a></td></tr>
<tr class="memdesc:ac2354be35a4ff17fd80deade9753ea97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template arguments (with location info).  <br /></td></tr>
<tr class="separator:ac2354be35a4ff17fd80deade9753ea97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2244dfcab0601fe79666d8a4a9dde4b9" id="r_a2244dfcab0601fe79666d8a4a9dde4b9"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1TemplateName.html">TemplateName</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2244dfcab0601fe79666d8a4a9dde4b9">templateName</a></td></tr>
<tr class="memdesc:a2244dfcab0601fe79666d8a4a9dde4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template name.  <br /></td></tr>
<tr class="separator:a2244dfcab0601fe79666d8a4a9dde4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c54a7bb3aa3ae9d1fdca749e1da10c6" id="r_a4c54a7bb3aa3ae9d1fdca749e1da10c6"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NonTypeTemplateParmDecl.html">NonTypeTemplateParmDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c54a7bb3aa3ae9d1fdca749e1da10c6">nonTypeTemplateParmDecl</a></td></tr>
<tr class="memdesc:a4c54a7bb3aa3ae9d1fdca749e1da10c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches non-type template parameter declarations.  <br /></td></tr>
<tr class="separator:a4c54a7bb3aa3ae9d1fdca749e1da10c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a6a300dc0c5bbfdcdc2af001c316f6" id="r_a95a6a300dc0c5bbfdcdc2af001c316f6"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TemplateTypeParmDecl.html">TemplateTypeParmDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95a6a300dc0c5bbfdcdc2af001c316f6">templateTypeParmDecl</a></td></tr>
<tr class="memdesc:a95a6a300dc0c5bbfdcdc2af001c316f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template type parameter declarations.  <br /></td></tr>
<tr class="separator:a95a6a300dc0c5bbfdcdc2af001c316f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab193711230649b28f6fd61cde737bed5" id="r_ab193711230649b28f6fd61cde737bed5"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TemplateTemplateParmDecl.html">TemplateTemplateParmDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab193711230649b28f6fd61cde737bed5">templateTemplateParmDecl</a></td></tr>
<tr class="memdesc:ab193711230649b28f6fd61cde737bed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template template parameter declarations.  <br /></td></tr>
<tr class="separator:ab193711230649b28f6fd61cde737bed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4d2e026596dc3bea52f83878ebc1a7" id="r_a4b4d2e026596dc3bea52f83878ebc1a7"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAutoreleasePoolStmt.html">ObjCAutoreleasePoolStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b4d2e026596dc3bea52f83878ebc1a7">autoreleasePoolStmt</a></td></tr>
<tr class="memdesc:a4b4d2e026596dc3bea52f83878ebc1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches an Objective-C autorelease pool statement.  <br /></td></tr>
<tr class="separator:a4b4d2e026596dc3bea52f83878ebc1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa27f54246f26b3989e97274e01a4c30" id="r_aaa27f54246f26b3989e97274e01a4c30"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ValueDecl.html">ValueDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa27f54246f26b3989e97274e01a4c30">valueDecl</a></td></tr>
<tr class="memdesc:aaa27f54246f26b3989e97274e01a4c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any value declaration.  <br /></td></tr>
<tr class="separator:aaa27f54246f26b3989e97274e01a4c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832104640e9b865d3d10cb779f59dbee" id="r_a832104640e9b865d3d10cb779f59dbee"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a832104640e9b865d3d10cb779f59dbee">cxxConstructorDecl</a></td></tr>
<tr class="memdesc:a832104640e9b865d3d10cb779f59dbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ constructor declarations.  <br /></td></tr>
<tr class="separator:a832104640e9b865d3d10cb779f59dbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac797cd3d7e0d85d5bd07773f1c9e2f7e" id="r_ac797cd3d7e0d85d5bd07773f1c9e2f7e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXDestructorDecl.html">CXXDestructorDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac797cd3d7e0d85d5bd07773f1c9e2f7e">cxxDestructorDecl</a></td></tr>
<tr class="memdesc:ac797cd3d7e0d85d5bd07773f1c9e2f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches explicit C++ destructor declarations.  <br /></td></tr>
<tr class="separator:ac797cd3d7e0d85d5bd07773f1c9e2f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e48dc9e0067b916df8f57d3d3bb72a" id="r_a31e48dc9e0067b916df8f57d3d3bb72a"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1EnumDecl.html">EnumDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31e48dc9e0067b916df8f57d3d3bb72a">enumDecl</a></td></tr>
<tr class="memdesc:a31e48dc9e0067b916df8f57d3d3bb72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches enum declarations.  <br /></td></tr>
<tr class="separator:a31e48dc9e0067b916df8f57d3d3bb72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcb1ffb5fb859e719d305b311baaeba" id="r_a8dcb1ffb5fb859e719d305b311baaeba"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1EnumConstantDecl.html">EnumConstantDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dcb1ffb5fb859e719d305b311baaeba">enumConstantDecl</a></td></tr>
<tr class="memdesc:a8dcb1ffb5fb859e719d305b311baaeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches enum constants.  <br /></td></tr>
<tr class="separator:a8dcb1ffb5fb859e719d305b311baaeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036eda5d1a6e83d02a2479799aa1e0ad" id="r_a036eda5d1a6e83d02a2479799aa1e0ad"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TagDecl.html">TagDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a036eda5d1a6e83d02a2479799aa1e0ad">tagDecl</a></td></tr>
<tr class="memdesc:a036eda5d1a6e83d02a2479799aa1e0ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches tag declarations.  <br /></td></tr>
<tr class="separator:a036eda5d1a6e83d02a2479799aa1e0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe825b22b86295d319b09c996fe78fd" id="r_aebe825b22b86295d319b09c996fe78fd"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebe825b22b86295d319b09c996fe78fd">cxxMethodDecl</a></td></tr>
<tr class="memdesc:aebe825b22b86295d319b09c996fe78fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches method declarations.  <br /></td></tr>
<tr class="separator:aebe825b22b86295d319b09c996fe78fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d2f76b0d40efafcb16d997b1928f5b" id="r_a67d2f76b0d40efafcb16d997b1928f5b"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXConversionDecl.html">CXXConversionDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67d2f76b0d40efafcb16d997b1928f5b">cxxConversionDecl</a></td></tr>
<tr class="memdesc:a67d2f76b0d40efafcb16d997b1928f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches conversion operator declarations.  <br /></td></tr>
<tr class="separator:a67d2f76b0d40efafcb16d997b1928f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400a7d8c9a439cb1c43dfa8ed4f6d5d7" id="r_a400a7d8c9a439cb1c43dfa8ed4f6d5d7"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXDeductionGuideDecl.html">CXXDeductionGuideDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a400a7d8c9a439cb1c43dfa8ed4f6d5d7">cxxDeductionGuideDecl</a></td></tr>
<tr class="memdesc:a400a7d8c9a439cb1c43dfa8ed4f6d5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches user-defined and implicitly generated deduction guide.  <br /></td></tr>
<tr class="separator:a400a7d8c9a439cb1c43dfa8ed4f6d5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056e81429237736b6458df18bb538c82" id="r_a056e81429237736b6458df18bb538c82"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a056e81429237736b6458df18bb538c82">varDecl</a></td></tr>
<tr class="memdesc:a056e81429237736b6458df18bb538c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches variable declarations.  <br /></td></tr>
<tr class="separator:a056e81429237736b6458df18bb538c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26f3ff62d6be975196efa86f3b15d82" id="r_ab26f3ff62d6be975196efa86f3b15d82"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab26f3ff62d6be975196efa86f3b15d82">fieldDecl</a></td></tr>
<tr class="memdesc:ab26f3ff62d6be975196efa86f3b15d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches field declarations.  <br /></td></tr>
<tr class="separator:ab26f3ff62d6be975196efa86f3b15d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb255b80ce8ca025df9e3d52ddbcfe9e" id="r_aeb255b80ce8ca025df9e3d52ddbcfe9e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1IndirectFieldDecl.html">IndirectFieldDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb255b80ce8ca025df9e3d52ddbcfe9e">indirectFieldDecl</a></td></tr>
<tr class="memdesc:aeb255b80ce8ca025df9e3d52ddbcfe9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches indirect field declarations.  <br /></td></tr>
<tr class="separator:aeb255b80ce8ca025df9e3d52ddbcfe9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95624c30888b0c7688e3a6171ed49cc" id="r_ab95624c30888b0c7688e3a6171ed49cc"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab95624c30888b0c7688e3a6171ed49cc">functionDecl</a></td></tr>
<tr class="memdesc:ab95624c30888b0c7688e3a6171ed49cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches function declarations.  <br /></td></tr>
<tr class="separator:ab95624c30888b0c7688e3a6171ed49cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973fc1ea542ea4bb3543d905e2ee1e11" id="r_a973fc1ea542ea4bb3543d905e2ee1e11"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1FunctionTemplateDecl.html">FunctionTemplateDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a973fc1ea542ea4bb3543d905e2ee1e11">functionTemplateDecl</a></td></tr>
<tr class="memdesc:a973fc1ea542ea4bb3543d905e2ee1e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ function template declarations.  <br /></td></tr>
<tr class="separator:a973fc1ea542ea4bb3543d905e2ee1e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded924f4ec88be994f9c255803e6075c" id="r_aded924f4ec88be994f9c255803e6075c"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1FriendDecl.html">FriendDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aded924f4ec88be994f9c255803e6075c">friendDecl</a></td></tr>
<tr class="memdesc:aded924f4ec88be994f9c255803e6075c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches friend declarations.  <br /></td></tr>
<tr class="separator:aded924f4ec88be994f9c255803e6075c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2304887c9dd0e9fad2e0ff35320739" id="r_ade2304887c9dd0e9fad2e0ff35320739"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade2304887c9dd0e9fad2e0ff35320739">stmt</a></td></tr>
<tr class="memdesc:ade2304887c9dd0e9fad2e0ff35320739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches statements.  <br /></td></tr>
<tr class="separator:ade2304887c9dd0e9fad2e0ff35320739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3d4ad0df1926038d75178efe06dcd8" id="r_adc3d4ad0df1926038d75178efe06dcd8"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DeclStmt.html">DeclStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc3d4ad0df1926038d75178efe06dcd8">declStmt</a></td></tr>
<tr class="memdesc:adc3d4ad0df1926038d75178efe06dcd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches declaration statements.  <br /></td></tr>
<tr class="separator:adc3d4ad0df1926038d75178efe06dcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11400493de87945dbc3c568ac8e4b08" id="r_ac11400493de87945dbc3c568ac8e4b08"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1MemberExpr.html">MemberExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac11400493de87945dbc3c568ac8e4b08">memberExpr</a></td></tr>
<tr class="memdesc:ac11400493de87945dbc3c568ac8e4b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches member expressions.  <br /></td></tr>
<tr class="separator:ac11400493de87945dbc3c568ac8e4b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f2cfd327a640154b61dc04b4dbe173" id="r_ab9f2cfd327a640154b61dc04b4dbe173"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UnresolvedMemberExpr.html">UnresolvedMemberExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9f2cfd327a640154b61dc04b4dbe173">unresolvedMemberExpr</a></td></tr>
<tr class="memdesc:ab9f2cfd327a640154b61dc04b4dbe173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches unresolved member expressions.  <br /></td></tr>
<tr class="separator:ab9f2cfd327a640154b61dc04b4dbe173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3285794ef7314a9b8ca5c18ed2744c13" id="r_a3285794ef7314a9b8ca5c18ed2744c13"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3285794ef7314a9b8ca5c18ed2744c13">cxxDependentScopeMemberExpr</a></td></tr>
<tr class="memdesc:a3285794ef7314a9b8ca5c18ed2744c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches member expressions where the actual member referenced could not be resolved because the base expression or the member name was dependent.  <br /></td></tr>
<tr class="separator:a3285794ef7314a9b8ca5c18ed2744c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460801cda670b9a3ccc3d42f51f3bd5c" id="r_a460801cda670b9a3ccc3d42f51f3bd5c"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CallExpr.html">CallExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a460801cda670b9a3ccc3d42f51f3bd5c">callExpr</a></td></tr>
<tr class="memdesc:a460801cda670b9a3ccc3d42f51f3bd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches call expressions.  <br /></td></tr>
<tr class="separator:a460801cda670b9a3ccc3d42f51f3bd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479809a0ad129df8390412a37ba54462" id="r_a479809a0ad129df8390412a37ba54462"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1LambdaExpr.html">LambdaExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a479809a0ad129df8390412a37ba54462">lambdaExpr</a></td></tr>
<tr class="memdesc:a479809a0ad129df8390412a37ba54462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches lambda expressions.  <br /></td></tr>
<tr class="separator:a479809a0ad129df8390412a37ba54462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831e164251478f3b38b3685d4d330cff" id="r_a831e164251478f3b38b3685d4d330cff"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a831e164251478f3b38b3685d4d330cff">cxxMemberCallExpr</a></td></tr>
<tr class="memdesc:a831e164251478f3b38b3685d4d330cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches member call expressions.  <br /></td></tr>
<tr class="separator:a831e164251478f3b38b3685d4d330cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e430a6b71305865cc46c57a9465c84" id="r_a76e430a6b71305865cc46c57a9465c84"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76e430a6b71305865cc46c57a9465c84">objcMessageExpr</a></td></tr>
<tr class="memdesc:a76e430a6b71305865cc46c57a9465c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches ObjectiveC Message invocation expressions.  <br /></td></tr>
<tr class="separator:a76e430a6b71305865cc46c57a9465c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10a69694c50b6e017fbe02072e7115e" id="r_ab10a69694c50b6e017fbe02072e7115e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab10a69694c50b6e017fbe02072e7115e">objcInterfaceDecl</a></td></tr>
<tr class="memdesc:ab10a69694c50b6e017fbe02072e7115e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C interface declarations.  <br /></td></tr>
<tr class="separator:ab10a69694c50b6e017fbe02072e7115e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd07286ab423090b73a60717e8ccf5a7" id="r_acd07286ab423090b73a60717e8ccf5a7"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCImplementationDecl.html">ObjCImplementationDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd07286ab423090b73a60717e8ccf5a7">objcImplementationDecl</a></td></tr>
<tr class="memdesc:acd07286ab423090b73a60717e8ccf5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C implementation declarations.  <br /></td></tr>
<tr class="separator:acd07286ab423090b73a60717e8ccf5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b140b9aeec980b173418f5b4490c8e" id="r_a27b140b9aeec980b173418f5b4490c8e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCProtocolDecl.html">ObjCProtocolDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27b140b9aeec980b173418f5b4490c8e">objcProtocolDecl</a></td></tr>
<tr class="memdesc:a27b140b9aeec980b173418f5b4490c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C protocol declarations.  <br /></td></tr>
<tr class="separator:a27b140b9aeec980b173418f5b4490c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d992911b288aaba2ba96ecc5e1e33c" id="r_a64d992911b288aaba2ba96ecc5e1e33c"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCCategoryDecl.html">ObjCCategoryDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64d992911b288aaba2ba96ecc5e1e33c">objcCategoryDecl</a></td></tr>
<tr class="memdesc:a64d992911b288aaba2ba96ecc5e1e33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C category declarations.  <br /></td></tr>
<tr class="separator:a64d992911b288aaba2ba96ecc5e1e33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8d9b5d54b3ed41d0b2d03e776af90e" id="r_a9a8d9b5d54b3ed41d0b2d03e776af90e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCCategoryImplDecl.html">ObjCCategoryImplDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a8d9b5d54b3ed41d0b2d03e776af90e">objcCategoryImplDecl</a></td></tr>
<tr class="memdesc:a9a8d9b5d54b3ed41d0b2d03e776af90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C category definitions.  <br /></td></tr>
<tr class="separator:a9a8d9b5d54b3ed41d0b2d03e776af90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a90eb6eeec44cfb79ef98129ad90ec1" id="r_a3a90eb6eeec44cfb79ef98129ad90ec1"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a90eb6eeec44cfb79ef98129ad90ec1">objcMethodDecl</a></td></tr>
<tr class="memdesc:a3a90eb6eeec44cfb79ef98129ad90ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C method declarations.  <br /></td></tr>
<tr class="separator:a3a90eb6eeec44cfb79ef98129ad90ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba4cdc11e5f93571b6b2107d4a9030e" id="r_aeba4cdc11e5f93571b6b2107d4a9030e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1BlockDecl.html">BlockDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeba4cdc11e5f93571b6b2107d4a9030e">blockDecl</a></td></tr>
<tr class="memdesc:aeba4cdc11e5f93571b6b2107d4a9030e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches block declarations.  <br /></td></tr>
<tr class="separator:aeba4cdc11e5f93571b6b2107d4a9030e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b9991e6e90b4ca132af940b11b4339" id="r_a10b9991e6e90b4ca132af940b11b4339"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCIvarDecl.html">ObjCIvarDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10b9991e6e90b4ca132af940b11b4339">objcIvarDecl</a></td></tr>
<tr class="memdesc:a10b9991e6e90b4ca132af940b11b4339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C instance variable declarations.  <br /></td></tr>
<tr class="separator:a10b9991e6e90b4ca132af940b11b4339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfb6ad7b935550af24feaa79d757eca" id="r_a2bfb6ad7b935550af24feaa79d757eca"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bfb6ad7b935550af24feaa79d757eca">objcPropertyDecl</a></td></tr>
<tr class="memdesc:a2bfb6ad7b935550af24feaa79d757eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C property declarations.  <br /></td></tr>
<tr class="separator:a2bfb6ad7b935550af24feaa79d757eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb294df9fab76f0f4677ccc500d94f26" id="r_abb294df9fab76f0f4677ccc500d94f26"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAtThrowStmt.html">ObjCAtThrowStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb294df9fab76f0f4677ccc500d94f26">objcThrowStmt</a></td></tr>
<tr class="memdesc:abb294df9fab76f0f4677ccc500d94f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C @throw statements.  <br /></td></tr>
<tr class="separator:abb294df9fab76f0f4677ccc500d94f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54c79304345729b9a3b5f1abf9dc5a8" id="r_aa54c79304345729b9a3b5f1abf9dc5a8"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAtTryStmt.html">ObjCAtTryStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa54c79304345729b9a3b5f1abf9dc5a8">objcTryStmt</a></td></tr>
<tr class="memdesc:aa54c79304345729b9a3b5f1abf9dc5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C @try statements.  <br /></td></tr>
<tr class="separator:aa54c79304345729b9a3b5f1abf9dc5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928d07f25f82fdf52ca6b480e0aca4d5" id="r_a928d07f25f82fdf52ca6b480e0aca4d5"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAtCatchStmt.html">ObjCAtCatchStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a928d07f25f82fdf52ca6b480e0aca4d5">objcCatchStmt</a></td></tr>
<tr class="memdesc:a928d07f25f82fdf52ca6b480e0aca4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C @catch statements.  <br /></td></tr>
<tr class="separator:a928d07f25f82fdf52ca6b480e0aca4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d463a0af3ae121edc9b41d14c0706a7" id="r_a2d463a0af3ae121edc9b41d14c0706a7"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAtFinallyStmt.html">ObjCAtFinallyStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d463a0af3ae121edc9b41d14c0706a7">objcFinallyStmt</a></td></tr>
<tr class="memdesc:a2d463a0af3ae121edc9b41d14c0706a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C @finally statements.  <br /></td></tr>
<tr class="separator:a2d463a0af3ae121edc9b41d14c0706a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071d31bd81eb28a0b2db583b181cfc01" id="r_a071d31bd81eb28a0b2db583b181cfc01"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ExprWithCleanups.html">ExprWithCleanups</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a071d31bd81eb28a0b2db583b181cfc01">exprWithCleanups</a></td></tr>
<tr class="memdesc:a071d31bd81eb28a0b2db583b181cfc01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions that introduce cleanups to be run at the end of the sub-expression's evaluation.  <br /></td></tr>
<tr class="separator:a071d31bd81eb28a0b2db583b181cfc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8514475a0724042d82b5323d5a7710f6" id="r_a8514475a0724042d82b5323d5a7710f6"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1InitListExpr.html">InitListExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8514475a0724042d82b5323d5a7710f6">initListExpr</a></td></tr>
<tr class="memdesc:a8514475a0724042d82b5323d5a7710f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches init list expressions.  <br /></td></tr>
<tr class="separator:a8514475a0724042d82b5323d5a7710f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cf0cd73005c114b30400dc613baa59" id="r_ae4cf0cd73005c114b30400dc613baa59"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXStdInitializerListExpr.html">CXXStdInitializerListExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4cf0cd73005c114b30400dc613baa59">cxxStdInitializerListExpr</a></td></tr>
<tr class="memdesc:ae4cf0cd73005c114b30400dc613baa59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ initializer list expressions.  <br /></td></tr>
<tr class="separator:ae4cf0cd73005c114b30400dc613baa59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3014baa2a35a9fa076ae72bcedd48ad" id="r_ad3014baa2a35a9fa076ae72bcedd48ad"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ImplicitValueInitExpr.html">ImplicitValueInitExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3014baa2a35a9fa076ae72bcedd48ad">implicitValueInitExpr</a></td></tr>
<tr class="memdesc:ad3014baa2a35a9fa076ae72bcedd48ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches implicit initializers of init list expressions.  <br /></td></tr>
<tr class="separator:ad3014baa2a35a9fa076ae72bcedd48ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6137ba1734e9c2499cefdac0ad7474de" id="r_a6137ba1734e9c2499cefdac0ad7474de"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ParenListExpr.html">ParenListExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6137ba1734e9c2499cefdac0ad7474de">parenListExpr</a></td></tr>
<tr class="memdesc:a6137ba1734e9c2499cefdac0ad7474de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches paren list expressions.  <br /></td></tr>
<tr class="separator:a6137ba1734e9c2499cefdac0ad7474de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06b6e50f8eb6094020ec5bf89a746a4" id="r_af06b6e50f8eb6094020ec5bf89a746a4"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1SubstNonTypeTemplateParmExpr.html">SubstNonTypeTemplateParmExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af06b6e50f8eb6094020ec5bf89a746a4">substNonTypeTemplateParmExpr</a></td></tr>
<tr class="memdesc:af06b6e50f8eb6094020ec5bf89a746a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches substitutions of non-type template parameters.  <br /></td></tr>
<tr class="separator:af06b6e50f8eb6094020ec5bf89a746a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9d64e967b6707c36254647d2bc4155" id="r_a2a9d64e967b6707c36254647d2bc4155"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1UsingDecl.html">UsingDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a9d64e967b6707c36254647d2bc4155">usingDecl</a></td></tr>
<tr class="memdesc:a2a9d64e967b6707c36254647d2bc4155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches using declarations.  <br /></td></tr>
<tr class="separator:a2a9d64e967b6707c36254647d2bc4155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b5096b155587486eb932cc3a86c481" id="r_af0b5096b155587486eb932cc3a86c481"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1UsingDirectiveDecl.html">UsingDirectiveDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0b5096b155587486eb932cc3a86c481">usingDirectiveDecl</a></td></tr>
<tr class="memdesc:af0b5096b155587486eb932cc3a86c481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches using namespace declarations.  <br /></td></tr>
<tr class="separator:af0b5096b155587486eb932cc3a86c481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3721288207aea6b68f442b2d752e78d0" id="r_a3721288207aea6b68f442b2d752e78d0"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UnresolvedLookupExpr.html">UnresolvedLookupExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3721288207aea6b68f442b2d752e78d0">unresolvedLookupExpr</a></td></tr>
<tr class="memdesc:a3721288207aea6b68f442b2d752e78d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches reference to a name that can be looked up during parsing but could not be resolved to a specific declaration.  <br /></td></tr>
<tr class="separator:a3721288207aea6b68f442b2d752e78d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fcb7fd463685d9e37e8f31637ed45f" id="r_af2fcb7fd463685d9e37e8f31637ed45f"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1UnresolvedUsingValueDecl.html">UnresolvedUsingValueDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2fcb7fd463685d9e37e8f31637ed45f">unresolvedUsingValueDecl</a></td></tr>
<tr class="memdesc:af2fcb7fd463685d9e37e8f31637ed45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches unresolved using value declarations.  <br /></td></tr>
<tr class="separator:af2fcb7fd463685d9e37e8f31637ed45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebfdb4a7578a482a07cefc8e5907c85" id="r_a5ebfdb4a7578a482a07cefc8e5907c85"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1UnresolvedUsingTypenameDecl.html">UnresolvedUsingTypenameDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ebfdb4a7578a482a07cefc8e5907c85">unresolvedUsingTypenameDecl</a></td></tr>
<tr class="memdesc:a5ebfdb4a7578a482a07cefc8e5907c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches unresolved using value declarations that involve the typename.  <br /></td></tr>
<tr class="separator:a5ebfdb4a7578a482a07cefc8e5907c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1636090af19685070c1f5183bce08909" id="r_a1636090af19685070c1f5183bce08909"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ConstantExpr.html">ConstantExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1636090af19685070c1f5183bce08909">constantExpr</a></td></tr>
<tr class="memdesc:a1636090af19685070c1f5183bce08909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant expression wrapper.  <br /></td></tr>
<tr class="separator:a1636090af19685070c1f5183bce08909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ef12437e36922d96bea2cb8f762b9a" id="r_a97ef12437e36922d96bea2cb8f762b9a"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ParenExpr.html">ParenExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97ef12437e36922d96bea2cb8f762b9a">parenExpr</a></td></tr>
<tr class="memdesc:a97ef12437e36922d96bea2cb8f762b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches parentheses used in expressions.  <br /></td></tr>
<tr class="separator:a97ef12437e36922d96bea2cb8f762b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0da198b76c77bfd4737a339d5a78e33" id="r_ab0da198b76c77bfd4737a339d5a78e33"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0da198b76c77bfd4737a339d5a78e33">cxxConstructExpr</a></td></tr>
<tr class="memdesc:ab0da198b76c77bfd4737a339d5a78e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches constructor call expressions (including implicit ones).  <br /></td></tr>
<tr class="separator:ab0da198b76c77bfd4737a339d5a78e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfe2da9177520906d97d82833577922" id="r_accfe2da9177520906d97d82833577922"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accfe2da9177520906d97d82833577922">cxxUnresolvedConstructExpr</a></td></tr>
<tr class="memdesc:accfe2da9177520906d97d82833577922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches unresolved constructor call expressions.  <br /></td></tr>
<tr class="separator:accfe2da9177520906d97d82833577922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af636f476cad8054e282b42e8ea613987" id="r_af636f476cad8054e282b42e8ea613987"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXThisExpr.html">CXXThisExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af636f476cad8054e282b42e8ea613987">cxxThisExpr</a></td></tr>
<tr class="memdesc:af636f476cad8054e282b42e8ea613987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches implicit and explicit this expressions.  <br /></td></tr>
<tr class="separator:af636f476cad8054e282b42e8ea613987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78d0ccf6cfdd2460d9c4d5f7847605d" id="r_ab78d0ccf6cfdd2460d9c4d5f7847605d"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXBindTemporaryExpr.html">CXXBindTemporaryExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab78d0ccf6cfdd2460d9c4d5f7847605d">cxxBindTemporaryExpr</a></td></tr>
<tr class="memdesc:ab78d0ccf6cfdd2460d9c4d5f7847605d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches nodes where temporaries are created.  <br /></td></tr>
<tr class="separator:ab78d0ccf6cfdd2460d9c4d5f7847605d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa051954c84b4df94040c842186dc7af7" id="r_aa051954c84b4df94040c842186dc7af7"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1MaterializeTemporaryExpr.html">MaterializeTemporaryExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa051954c84b4df94040c842186dc7af7">materializeTemporaryExpr</a></td></tr>
<tr class="memdesc:aa051954c84b4df94040c842186dc7af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches nodes where temporaries are materialized.  <br /></td></tr>
<tr class="separator:aa051954c84b4df94040c842186dc7af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c90fa40e809e57f174ef162b26bb7d9" id="r_a8c90fa40e809e57f174ef162b26bb7d9"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXNewExpr.html">CXXNewExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c90fa40e809e57f174ef162b26bb7d9">cxxNewExpr</a></td></tr>
<tr class="memdesc:a8c90fa40e809e57f174ef162b26bb7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches new expressions.  <br /></td></tr>
<tr class="separator:a8c90fa40e809e57f174ef162b26bb7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c9455ba631c516e4e7818a0f7f8eff" id="r_a21c9455ba631c516e4e7818a0f7f8eff"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXDeleteExpr.html">CXXDeleteExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21c9455ba631c516e4e7818a0f7f8eff">cxxDeleteExpr</a></td></tr>
<tr class="memdesc:a21c9455ba631c516e4e7818a0f7f8eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches delete expressions.  <br /></td></tr>
<tr class="separator:a21c9455ba631c516e4e7818a0f7f8eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896f97c027b999f18752148a0921a19c" id="r_a896f97c027b999f18752148a0921a19c"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXNoexceptExpr.html">CXXNoexceptExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a896f97c027b999f18752148a0921a19c">cxxNoexceptExpr</a></td></tr>
<tr class="memdesc:a896f97c027b999f18752148a0921a19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches noexcept expressions.  <br /></td></tr>
<tr class="separator:a896f97c027b999f18752148a0921a19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770b1eeabaf13b5ab1547634f8fef742" id="r_a770b1eeabaf13b5ab1547634f8fef742"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ArraySubscriptExpr.html">ArraySubscriptExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a770b1eeabaf13b5ab1547634f8fef742">arraySubscriptExpr</a></td></tr>
<tr class="memdesc:a770b1eeabaf13b5ab1547634f8fef742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches array subscript expressions.  <br /></td></tr>
<tr class="separator:a770b1eeabaf13b5ab1547634f8fef742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5505ee16ebcb2b7ee272e91d709849ee" id="r_a5505ee16ebcb2b7ee272e91d709849ee"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXDefaultArgExpr.html">CXXDefaultArgExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5505ee16ebcb2b7ee272e91d709849ee">cxxDefaultArgExpr</a></td></tr>
<tr class="memdesc:a5505ee16ebcb2b7ee272e91d709849ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the value of a default argument at the call site.  <br /></td></tr>
<tr class="separator:a5505ee16ebcb2b7ee272e91d709849ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab422b5e5502151463a9d2d6ad04350e4" id="r_ab422b5e5502151463a9d2d6ad04350e4"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab422b5e5502151463a9d2d6ad04350e4">cxxOperatorCallExpr</a></td></tr>
<tr class="memdesc:ab422b5e5502151463a9d2d6ad04350e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches overloaded operator calls.  <br /></td></tr>
<tr class="separator:ab422b5e5502151463a9d2d6ad04350e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9e9197127c18de63db7a43256f1aff" id="r_a3b9e9197127c18de63db7a43256f1aff"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b9e9197127c18de63db7a43256f1aff">cxxRewrittenBinaryOperator</a></td></tr>
<tr class="memdesc:a3b9e9197127c18de63db7a43256f1aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches rewritten binary operators.  <br /></td></tr>
<tr class="separator:a3b9e9197127c18de63db7a43256f1aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc0ccd398780d345e2c541cc716cc66" id="r_adfc0ccd398780d345e2c541cc716cc66"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfc0ccd398780d345e2c541cc716cc66">expr</a></td></tr>
<tr class="memdesc:adfc0ccd398780d345e2c541cc716cc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions.  <br /></td></tr>
<tr class="separator:adfc0ccd398780d345e2c541cc716cc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0781cbe6d50bd620cb6f8f0627378be6" id="r_a0781cbe6d50bd620cb6f8f0627378be6"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DeclRefExpr.html">DeclRefExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0781cbe6d50bd620cb6f8f0627378be6">declRefExpr</a></td></tr>
<tr class="memdesc:a0781cbe6d50bd620cb6f8f0627378be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions that refer to declarations.  <br /></td></tr>
<tr class="separator:a0781cbe6d50bd620cb6f8f0627378be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1691aa67fc4125c0978aa73995001aa8" id="r_a1691aa67fc4125c0978aa73995001aa8"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCIvarRefExpr.html">ObjCIvarRefExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1691aa67fc4125c0978aa73995001aa8">objcIvarRefExpr</a></td></tr>
<tr class="memdesc:a1691aa67fc4125c0978aa73995001aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a reference to an ObjCIvar.  <br /></td></tr>
<tr class="separator:a1691aa67fc4125c0978aa73995001aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9731ff0864f46a3fb06e34554ae54cb8" id="r_a9731ff0864f46a3fb06e34554ae54cb8"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1BlockExpr.html">BlockExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9731ff0864f46a3fb06e34554ae54cb8">blockExpr</a></td></tr>
<tr class="memdesc:a9731ff0864f46a3fb06e34554ae54cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a reference to a block.  <br /></td></tr>
<tr class="separator:a9731ff0864f46a3fb06e34554ae54cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cd72a6718872ac996d48de9a80bf81" id="r_af5cd72a6718872ac996d48de9a80bf81"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1IfStmt.html">IfStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5cd72a6718872ac996d48de9a80bf81">ifStmt</a></td></tr>
<tr class="memdesc:af5cd72a6718872ac996d48de9a80bf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if statements.  <br /></td></tr>
<tr class="separator:af5cd72a6718872ac996d48de9a80bf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6f109ac0734990e8ae974d36e76c7e" id="r_a8e6f109ac0734990e8ae974d36e76c7e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ForStmt.html">ForStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e6f109ac0734990e8ae974d36e76c7e">forStmt</a></td></tr>
<tr class="memdesc:a8e6f109ac0734990e8ae974d36e76c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches for statements.  <br /></td></tr>
<tr class="separator:a8e6f109ac0734990e8ae974d36e76c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8270a8d8f21ce50af2f56e4bcdd31eba" id="r_a8270a8d8f21ce50af2f56e4bcdd31eba"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8270a8d8f21ce50af2f56e4bcdd31eba">cxxForRangeStmt</a></td></tr>
<tr class="memdesc:a8270a8d8f21ce50af2f56e4bcdd31eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches range-based for statements.  <br /></td></tr>
<tr class="separator:a8270a8d8f21ce50af2f56e4bcdd31eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fb772f53dc8076440090557a4bb388" id="r_a63fb772f53dc8076440090557a4bb388"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1WhileStmt.html">WhileStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63fb772f53dc8076440090557a4bb388">whileStmt</a></td></tr>
<tr class="memdesc:a63fb772f53dc8076440090557a4bb388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches while statements.  <br /></td></tr>
<tr class="separator:a63fb772f53dc8076440090557a4bb388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35f9309e910ba3399781cc30baa2439" id="r_ad35f9309e910ba3399781cc30baa2439"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DoStmt.html">DoStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad35f9309e910ba3399781cc30baa2439">doStmt</a></td></tr>
<tr class="memdesc:ad35f9309e910ba3399781cc30baa2439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches do statements.  <br /></td></tr>
<tr class="separator:ad35f9309e910ba3399781cc30baa2439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3570a0e97bc3258e6b063729994e791f" id="r_a3570a0e97bc3258e6b063729994e791f"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1BreakStmt.html">BreakStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3570a0e97bc3258e6b063729994e791f">breakStmt</a></td></tr>
<tr class="memdesc:a3570a0e97bc3258e6b063729994e791f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches break statements.  <br /></td></tr>
<tr class="separator:a3570a0e97bc3258e6b063729994e791f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af901ad829d7e589a44f983a327351ebf" id="r_af901ad829d7e589a44f983a327351ebf"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ContinueStmt.html">ContinueStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af901ad829d7e589a44f983a327351ebf">continueStmt</a></td></tr>
<tr class="memdesc:af901ad829d7e589a44f983a327351ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches continue statements.  <br /></td></tr>
<tr class="separator:af901ad829d7e589a44f983a327351ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e8f0ff0127b0536c53a76dbf5f28a7" id="r_a42e8f0ff0127b0536c53a76dbf5f28a7"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ReturnStmt.html">ReturnStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42e8f0ff0127b0536c53a76dbf5f28a7">returnStmt</a></td></tr>
<tr class="memdesc:a42e8f0ff0127b0536c53a76dbf5f28a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches return statements.  <br /></td></tr>
<tr class="separator:a42e8f0ff0127b0536c53a76dbf5f28a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f07c79fb3acf3af34be21d41010648a" id="r_a8f07c79fb3acf3af34be21d41010648a"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1GotoStmt.html">GotoStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f07c79fb3acf3af34be21d41010648a">gotoStmt</a></td></tr>
<tr class="memdesc:a8f07c79fb3acf3af34be21d41010648a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches goto statements.  <br /></td></tr>
<tr class="separator:a8f07c79fb3acf3af34be21d41010648a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add73462f8d3fac6fc366163c4665447b" id="r_add73462f8d3fac6fc366163c4665447b"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1LabelStmt.html">LabelStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add73462f8d3fac6fc366163c4665447b">labelStmt</a></td></tr>
<tr class="memdesc:add73462f8d3fac6fc366163c4665447b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches label statements.  <br /></td></tr>
<tr class="separator:add73462f8d3fac6fc366163c4665447b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32844cb1d9bb3605e13b8bed8092cc14" id="r_a32844cb1d9bb3605e13b8bed8092cc14"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32844cb1d9bb3605e13b8bed8092cc14">addrLabelExpr</a></td></tr>
<tr class="memdesc:a32844cb1d9bb3605e13b8bed8092cc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches address of label statements (GNU extension).  <br /></td></tr>
<tr class="separator:a32844cb1d9bb3605e13b8bed8092cc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf04346715336de0dfc10dac8ed114d9" id="r_abf04346715336de0dfc10dac8ed114d9"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1SwitchStmt.html">SwitchStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf04346715336de0dfc10dac8ed114d9">switchStmt</a></td></tr>
<tr class="memdesc:abf04346715336de0dfc10dac8ed114d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches switch statements.  <br /></td></tr>
<tr class="separator:abf04346715336de0dfc10dac8ed114d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7abc89804682f83816d2323cdc718cf" id="r_ab7abc89804682f83816d2323cdc718cf"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1SwitchCase.html">SwitchCase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7abc89804682f83816d2323cdc718cf">switchCase</a></td></tr>
<tr class="memdesc:ab7abc89804682f83816d2323cdc718cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches case and default statements inside switch statements.  <br /></td></tr>
<tr class="separator:ab7abc89804682f83816d2323cdc718cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5725bf80823feea320c27f79c712e8f6" id="r_a5725bf80823feea320c27f79c712e8f6"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CaseStmt.html">CaseStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5725bf80823feea320c27f79c712e8f6">caseStmt</a></td></tr>
<tr class="memdesc:a5725bf80823feea320c27f79c712e8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches case statements inside switch statements.  <br /></td></tr>
<tr class="separator:a5725bf80823feea320c27f79c712e8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cc259a084492c93e3053e78ea9d088" id="r_ab7cc259a084492c93e3053e78ea9d088"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DefaultStmt.html">DefaultStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7cc259a084492c93e3053e78ea9d088">defaultStmt</a></td></tr>
<tr class="memdesc:ab7cc259a084492c93e3053e78ea9d088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches default statements inside switch statements.  <br /></td></tr>
<tr class="separator:ab7cc259a084492c93e3053e78ea9d088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496a3f466a3f754041e8a1cfd3aaf749" id="r_a496a3f466a3f754041e8a1cfd3aaf749"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CompoundStmt.html">CompoundStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a496a3f466a3f754041e8a1cfd3aaf749">compoundStmt</a></td></tr>
<tr class="memdesc:a496a3f466a3f754041e8a1cfd3aaf749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches compound statements.  <br /></td></tr>
<tr class="separator:a496a3f466a3f754041e8a1cfd3aaf749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed73db7e4f5258557e39edc7fc5168d0" id="r_aed73db7e4f5258557e39edc7fc5168d0"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXCatchStmt.html">CXXCatchStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed73db7e4f5258557e39edc7fc5168d0">cxxCatchStmt</a></td></tr>
<tr class="memdesc:aed73db7e4f5258557e39edc7fc5168d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches catch statements.  <br /></td></tr>
<tr class="separator:aed73db7e4f5258557e39edc7fc5168d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0002878ac1dc163307befba0daa2b17" id="r_af0002878ac1dc163307befba0daa2b17"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXTryStmt.html">CXXTryStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0002878ac1dc163307befba0daa2b17">cxxTryStmt</a></td></tr>
<tr class="memdesc:af0002878ac1dc163307befba0daa2b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches try statements.  <br /></td></tr>
<tr class="separator:af0002878ac1dc163307befba0daa2b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc856098ca748d9cff1734ff8fe3bd56" id="r_abc856098ca748d9cff1734ff8fe3bd56"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXThrowExpr.html">CXXThrowExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc856098ca748d9cff1734ff8fe3bd56">cxxThrowExpr</a></td></tr>
<tr class="memdesc:abc856098ca748d9cff1734ff8fe3bd56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches throw expressions.  <br /></td></tr>
<tr class="separator:abc856098ca748d9cff1734ff8fe3bd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e85f3028bc3d2d590878c3587d43f5c" id="r_a4e85f3028bc3d2d590878c3587d43f5c"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1NullStmt.html">NullStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e85f3028bc3d2d590878c3587d43f5c">nullStmt</a></td></tr>
<tr class="memdesc:a4e85f3028bc3d2d590878c3587d43f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches null statements.  <br /></td></tr>
<tr class="separator:a4e85f3028bc3d2d590878c3587d43f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4329ae4c7c6f153f7529aab870ffec8b" id="r_a4329ae4c7c6f153f7529aab870ffec8b"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1AsmStmt.html">AsmStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4329ae4c7c6f153f7529aab870ffec8b">asmStmt</a></td></tr>
<tr class="memdesc:a4329ae4c7c6f153f7529aab870ffec8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches asm statements.  <br /></td></tr>
<tr class="separator:a4329ae4c7c6f153f7529aab870ffec8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409ccd26dc35075d52eef632d86bbf33" id="r_a409ccd26dc35075d52eef632d86bbf33"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a409ccd26dc35075d52eef632d86bbf33">cxxBoolLiteral</a></td></tr>
<tr class="memdesc:a409ccd26dc35075d52eef632d86bbf33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches bool literals.  <br /></td></tr>
<tr class="separator:a409ccd26dc35075d52eef632d86bbf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9fffe33e90bbb4b8f099caf377d7b1" id="r_a2c9fffe33e90bbb4b8f099caf377d7b1"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1StringLiteral.html">StringLiteral</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c9fffe33e90bbb4b8f099caf377d7b1">stringLiteral</a></td></tr>
<tr class="memdesc:a2c9fffe33e90bbb4b8f099caf377d7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches string literals (also matches wide string literals).  <br /></td></tr>
<tr class="separator:a2c9fffe33e90bbb4b8f099caf377d7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2752fd9ce2d1e53440035178d4a0feb" id="r_ae2752fd9ce2d1e53440035178d4a0feb"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CharacterLiteral.html">CharacterLiteral</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2752fd9ce2d1e53440035178d4a0feb">characterLiteral</a></td></tr>
<tr class="memdesc:ae2752fd9ce2d1e53440035178d4a0feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches character literals (also matches wchar_t).  <br /></td></tr>
<tr class="separator:ae2752fd9ce2d1e53440035178d4a0feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2109e16a4a151dc8f6416a66a750eac" id="r_ad2109e16a4a151dc8f6416a66a750eac"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1IntegerLiteral.html">IntegerLiteral</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2109e16a4a151dc8f6416a66a750eac">integerLiteral</a></td></tr>
<tr class="memdesc:ad2109e16a4a151dc8f6416a66a750eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches integer literals of all sizes / encodings, e.g.  <br /></td></tr>
<tr class="separator:ad2109e16a4a151dc8f6416a66a750eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4e38c6224c16252040dc697a6af832" id="r_a4a4e38c6224c16252040dc697a6af832"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1FloatingLiteral.html">FloatingLiteral</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a4e38c6224c16252040dc697a6af832">floatLiteral</a></td></tr>
<tr class="memdesc:a4a4e38c6224c16252040dc697a6af832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches float literals of all sizes / encodings, e.g.  <br /></td></tr>
<tr class="separator:a4a4e38c6224c16252040dc697a6af832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b21c26d322030721227bd877344452" id="r_af7b21c26d322030721227bd877344452"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ImaginaryLiteral.html">ImaginaryLiteral</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7b21c26d322030721227bd877344452">imaginaryLiteral</a></td></tr>
<tr class="memdesc:af7b21c26d322030721227bd877344452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches imaginary literals, which are based on integer and floating point literals e.g.: 1i, 1.0i.  <br /></td></tr>
<tr class="separator:af7b21c26d322030721227bd877344452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0045003e9bc57bbe8c8f5e32a64c9533" id="r_a0045003e9bc57bbe8c8f5e32a64c9533"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1FixedPointLiteral.html">FixedPointLiteral</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0045003e9bc57bbe8c8f5e32a64c9533">fixedPointLiteral</a></td></tr>
<tr class="memdesc:a0045003e9bc57bbe8c8f5e32a64c9533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches fixed point literals.  <br /></td></tr>
<tr class="separator:a0045003e9bc57bbe8c8f5e32a64c9533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f2a941709daf18c1eb096bdde38868" id="r_ab2f2a941709daf18c1eb096bdde38868"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UserDefinedLiteral.html">UserDefinedLiteral</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2f2a941709daf18c1eb096bdde38868">userDefinedLiteral</a></td></tr>
<tr class="memdesc:ab2f2a941709daf18c1eb096bdde38868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches user defined literal operator call.  <br /></td></tr>
<tr class="separator:ab2f2a941709daf18c1eb096bdde38868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcac5ffe32ca0150ad183cbdc3d0f6c1" id="r_adcac5ffe32ca0150ad183cbdc3d0f6c1"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcac5ffe32ca0150ad183cbdc3d0f6c1">compoundLiteralExpr</a></td></tr>
<tr class="memdesc:adcac5ffe32ca0150ad183cbdc3d0f6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches compound (i.e.  <br /></td></tr>
<tr class="separator:adcac5ffe32ca0150ad183cbdc3d0f6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74cde61d132689b56daab21db683425" id="r_ad74cde61d132689b56daab21db683425"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXNullPtrLiteralExpr.html">CXXNullPtrLiteralExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad74cde61d132689b56daab21db683425">cxxNullPtrLiteralExpr</a></td></tr>
<tr class="memdesc:ad74cde61d132689b56daab21db683425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches nullptr literal.  <br /></td></tr>
<tr class="separator:ad74cde61d132689b56daab21db683425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d6075693f8e67b1a952da3fe26acaf" id="r_ab3d6075693f8e67b1a952da3fe26acaf"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ChooseExpr.html">ChooseExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3d6075693f8e67b1a952da3fe26acaf">chooseExpr</a></td></tr>
<tr class="memdesc:ab3d6075693f8e67b1a952da3fe26acaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches GNU __builtin_choose_expr.  <br /></td></tr>
<tr class="separator:ab3d6075693f8e67b1a952da3fe26acaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80570a2d56d8d2d1788318a946a68a05" id="r_a80570a2d56d8d2d1788318a946a68a05"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1GNUNullExpr.html">GNUNullExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80570a2d56d8d2d1788318a946a68a05">gnuNullExpr</a></td></tr>
<tr class="memdesc:a80570a2d56d8d2d1788318a946a68a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches GNU __null expression.  <br /></td></tr>
<tr class="separator:a80570a2d56d8d2d1788318a946a68a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f42e20a3d2500bbee1741d7f8bc04f3" id="r_a3f42e20a3d2500bbee1741d7f8bc04f3"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1GenericSelectionExpr.html">GenericSelectionExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f42e20a3d2500bbee1741d7f8bc04f3">genericSelectionExpr</a></td></tr>
<tr class="memdesc:a3f42e20a3d2500bbee1741d7f8bc04f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C11 _Generic expression.  <br /></td></tr>
<tr class="separator:a3f42e20a3d2500bbee1741d7f8bc04f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc5672f38513ca660c5c383e958cec0" id="r_a2fc5672f38513ca660c5c383e958cec0"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1AtomicExpr.html">AtomicExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fc5672f38513ca660c5c383e958cec0">atomicExpr</a></td></tr>
<tr class="memdesc:a2fc5672f38513ca660c5c383e958cec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches atomic builtins.  <br /></td></tr>
<tr class="separator:a2fc5672f38513ca660c5c383e958cec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07128394c216b2d373a8ee39956e7689" id="r_a07128394c216b2d373a8ee39956e7689"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1StmtExpr.html">StmtExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07128394c216b2d373a8ee39956e7689">stmtExpr</a></td></tr>
<tr class="memdesc:a07128394c216b2d373a8ee39956e7689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches statement expression (GNU extension).  <br /></td></tr>
<tr class="separator:a07128394c216b2d373a8ee39956e7689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d236ec1064f604664b1e9123249e01" id="r_a92d236ec1064f604664b1e9123249e01"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92d236ec1064f604664b1e9123249e01">binaryOperator</a></td></tr>
<tr class="memdesc:a92d236ec1064f604664b1e9123249e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches binary operator expressions.  <br /></td></tr>
<tr class="separator:a92d236ec1064f604664b1e9123249e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ac1ea4304cca5a3d773782c45e3a9d" id="r_a71ac1ea4304cca5a3d773782c45e3a9d"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UnaryOperator.html">UnaryOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71ac1ea4304cca5a3d773782c45e3a9d">unaryOperator</a></td></tr>
<tr class="memdesc:a71ac1ea4304cca5a3d773782c45e3a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches unary operator expressions.  <br /></td></tr>
<tr class="separator:a71ac1ea4304cca5a3d773782c45e3a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae471648f1de66bdde248ef4b1edae5e5" id="r_ae471648f1de66bdde248ef4b1edae5e5"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ConditionalOperator.html">ConditionalOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae471648f1de66bdde248ef4b1edae5e5">conditionalOperator</a></td></tr>
<tr class="memdesc:ae471648f1de66bdde248ef4b1edae5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches conditional operator expressions.  <br /></td></tr>
<tr class="separator:ae471648f1de66bdde248ef4b1edae5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa466a1e59dbf5a8785b2561a308ae4fb" id="r_aa466a1e59dbf5a8785b2561a308ae4fb"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1BinaryConditionalOperator.html">BinaryConditionalOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa466a1e59dbf5a8785b2561a308ae4fb">binaryConditionalOperator</a></td></tr>
<tr class="memdesc:aa466a1e59dbf5a8785b2561a308ae4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches binary conditional operator expressions (GNU extension).  <br /></td></tr>
<tr class="separator:aa466a1e59dbf5a8785b2561a308ae4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7160bb2f02400b2152dc7e0b10d763a" id="r_ae7160bb2f02400b2152dc7e0b10d763a"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1OpaqueValueExpr.html">OpaqueValueExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7160bb2f02400b2152dc7e0b10d763a">opaqueValueExpr</a></td></tr>
<tr class="memdesc:ae7160bb2f02400b2152dc7e0b10d763a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches opaque value expressions.  <br /></td></tr>
<tr class="separator:ae7160bb2f02400b2152dc7e0b10d763a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ab1f66ff6c5a790900ae8f625e9a09" id="r_a99ab1f66ff6c5a790900ae8f625e9a09"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1StaticAssertDecl.html">StaticAssertDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99ab1f66ff6c5a790900ae8f625e9a09">staticAssertDecl</a></td></tr>
<tr class="memdesc:a99ab1f66ff6c5a790900ae8f625e9a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a C++ static_assert declaration.  <br /></td></tr>
<tr class="separator:a99ab1f66ff6c5a790900ae8f625e9a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dc23e7233bd6aa6c8cd1240dfc71de" id="r_a04dc23e7233bd6aa6c8cd1240dfc71de"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXReinterpretCastExpr.html">CXXReinterpretCastExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04dc23e7233bd6aa6c8cd1240dfc71de">cxxReinterpretCastExpr</a></td></tr>
<tr class="memdesc:a04dc23e7233bd6aa6c8cd1240dfc71de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a reinterpret_cast expression.  <br /></td></tr>
<tr class="separator:a04dc23e7233bd6aa6c8cd1240dfc71de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83203112fbb0fc35646465509fce105" id="r_aa83203112fbb0fc35646465509fce105"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXStaticCastExpr.html">CXXStaticCastExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa83203112fbb0fc35646465509fce105">cxxStaticCastExpr</a></td></tr>
<tr class="memdesc:aa83203112fbb0fc35646465509fce105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a C++ static_cast expression.  <br /></td></tr>
<tr class="separator:aa83203112fbb0fc35646465509fce105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446ee71422a19b825dd23d6dde2c0551" id="r_a446ee71422a19b825dd23d6dde2c0551"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXDynamicCastExpr.html">CXXDynamicCastExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a446ee71422a19b825dd23d6dde2c0551">cxxDynamicCastExpr</a></td></tr>
<tr class="memdesc:a446ee71422a19b825dd23d6dde2c0551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a dynamic_cast expression.  <br /></td></tr>
<tr class="separator:a446ee71422a19b825dd23d6dde2c0551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704390715c62f500730acc8eb8133ee0" id="r_a704390715c62f500730acc8eb8133ee0"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXConstCastExpr.html">CXXConstCastExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a704390715c62f500730acc8eb8133ee0">cxxConstCastExpr</a></td></tr>
<tr class="memdesc:a704390715c62f500730acc8eb8133ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a const_cast expression.  <br /></td></tr>
<tr class="separator:a704390715c62f500730acc8eb8133ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0262eb3971f2f7649d0354cbddaaec73" id="r_a0262eb3971f2f7649d0354cbddaaec73"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CStyleCastExpr.html">CStyleCastExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0262eb3971f2f7649d0354cbddaaec73">cStyleCastExpr</a></td></tr>
<tr class="memdesc:a0262eb3971f2f7649d0354cbddaaec73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a C-style cast expression.  <br /></td></tr>
<tr class="separator:a0262eb3971f2f7649d0354cbddaaec73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64f0fe0351af4d0e37f7838e6385d3c" id="r_aa64f0fe0351af4d0e37f7838e6385d3c"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa64f0fe0351af4d0e37f7838e6385d3c">explicitCastExpr</a></td></tr>
<tr class="memdesc:aa64f0fe0351af4d0e37f7838e6385d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches explicit cast expressions.  <br /></td></tr>
<tr class="separator:aa64f0fe0351af4d0e37f7838e6385d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b1bdd70cca95686345d5a96d97071a" id="r_a28b1bdd70cca95686345d5a96d97071a"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ImplicitCastExpr.html">ImplicitCastExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28b1bdd70cca95686345d5a96d97071a">implicitCastExpr</a></td></tr>
<tr class="memdesc:a28b1bdd70cca95686345d5a96d97071a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the implicit cast nodes of Clang's AST.  <br /></td></tr>
<tr class="separator:a28b1bdd70cca95686345d5a96d97071a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0910ccb567ed2465a935d7bd6831ed" id="r_aee0910ccb567ed2465a935d7bd6831ed"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CastExpr.html">CastExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee0910ccb567ed2465a935d7bd6831ed">castExpr</a></td></tr>
<tr class="memdesc:aee0910ccb567ed2465a935d7bd6831ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any cast nodes of Clang's AST.  <br /></td></tr>
<tr class="separator:aee0910ccb567ed2465a935d7bd6831ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701d2c84173a8709dcb4a221ad478e1e" id="r_a701d2c84173a8709dcb4a221ad478e1e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a701d2c84173a8709dcb4a221ad478e1e">cxxFunctionalCastExpr</a></td></tr>
<tr class="memdesc:a701d2c84173a8709dcb4a221ad478e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches functional cast expressions.  <br /></td></tr>
<tr class="separator:a701d2c84173a8709dcb4a221ad478e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704e8b0c7519edb6b05d1663a4266b6d" id="r_a704e8b0c7519edb6b05d1663a4266b6d"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a704e8b0c7519edb6b05d1663a4266b6d">cxxTemporaryObjectExpr</a></td></tr>
<tr class="memdesc:a704e8b0c7519edb6b05d1663a4266b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches functional cast expressions having N != 1 arguments.  <br /></td></tr>
<tr class="separator:a704e8b0c7519edb6b05d1663a4266b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b52666b405fc2bf1a28120d488488c" id="r_a33b52666b405fc2bf1a28120d488488c"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1PredefinedExpr.html">PredefinedExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33b52666b405fc2bf1a28120d488488c">predefinedExpr</a></td></tr>
<tr class="memdesc:a33b52666b405fc2bf1a28120d488488c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches predefined identifier expressions [C99 6.4.2.2].  <br /></td></tr>
<tr class="separator:a33b52666b405fc2bf1a28120d488488c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5af767c2d681ddb0122fec2e3ab43a5" id="r_ac5af767c2d681ddb0122fec2e3ab43a5"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DesignatedInitExpr.html">DesignatedInitExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5af767c2d681ddb0122fec2e3ab43a5">designatedInitExpr</a></td></tr>
<tr class="memdesc:ac5af767c2d681ddb0122fec2e3ab43a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C99 designated initializer expressions [C99 6.7.8].  <br /></td></tr>
<tr class="separator:ac5af767c2d681ddb0122fec2e3ab43a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc28b8bf75f10413691d11b9c371116" id="r_aefc28b8bf75f10413691d11b9c371116"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefc28b8bf75f10413691d11b9c371116">qualType</a></td></tr>
<tr class="memdesc:aefc28b8bf75f10413691d11b9c371116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code>QualTypes</code> in the clang AST.  <br /></td></tr>
<tr class="separator:aefc28b8bf75f10413691d11b9c371116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600679c157b5bd05c4bfb940fb2511dd" id="r_a600679c157b5bd05c4bfb940fb2511dd"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1Type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a600679c157b5bd05c4bfb940fb2511dd">type</a></td></tr>
<tr class="memdesc:a600679c157b5bd05c4bfb940fb2511dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code>Types</code> in the clang AST.  <br /></td></tr>
<tr class="separator:a600679c157b5bd05c4bfb940fb2511dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605961d8a647c2ec766b2417552393a2" id="r_a605961d8a647c2ec766b2417552393a2"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a605961d8a647c2ec766b2417552393a2">typeLoc</a></td></tr>
<tr class="memdesc:a605961d8a647c2ec766b2417552393a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code>TypeLocs</code> in the clang AST.  <br /></td></tr>
<tr class="separator:a605961d8a647c2ec766b2417552393a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c3c535f34a336b4e966342d44a631d" id="r_ab0c3c535f34a336b4e966342d44a631d"><td class="memItemLeft" align="right" valign="top">const internal::VariadicOperatorMatcherFunc&lt; 2, std::numeric_limits&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;<a class="el" href="____clang__cuda__math_8h.html#ae6bb573e13e3bd5738c8faa552b6a129">::max</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0c3c535f34a336b4e966342d44a631d">eachOf</a> = {internal::DynTypedMatcher::VO_EachOf}</td></tr>
<tr class="memdesc:ab0c3c535f34a336b4e966342d44a631d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if any of the given matchers matches.  <br /></td></tr>
<tr class="separator:ab0c3c535f34a336b4e966342d44a631d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56a1974283c9a2cb2410008e32fe3f1" id="r_ae56a1974283c9a2cb2410008e32fe3f1"><td class="memItemLeft" align="right" valign="top">const internal::VariadicOperatorMatcherFunc&lt; 2, std::numeric_limits&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;<a class="el" href="____clang__cuda__math_8h.html#ae6bb573e13e3bd5738c8faa552b6a129">::max</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae56a1974283c9a2cb2410008e32fe3f1">anyOf</a> = {internal::DynTypedMatcher::VO_AnyOf}</td></tr>
<tr class="memdesc:ae56a1974283c9a2cb2410008e32fe3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if any of the given matchers matches.  <br /></td></tr>
<tr class="separator:ae56a1974283c9a2cb2410008e32fe3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f7f0b785ca07327256931286ebc99f" id="r_ab7f7f0b785ca07327256931286ebc99f"><td class="memItemLeft" align="right" valign="top">const internal::VariadicOperatorMatcherFunc&lt; 2, std::numeric_limits&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;<a class="el" href="____clang__cuda__math_8h.html#ae6bb573e13e3bd5738c8faa552b6a129">::max</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7f7f0b785ca07327256931286ebc99f">allOf</a> = {internal::DynTypedMatcher::VO_AllOf}</td></tr>
<tr class="memdesc:ab7f7f0b785ca07327256931286ebc99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if all given matchers match.  <br /></td></tr>
<tr class="separator:ab7f7f0b785ca07327256931286ebc99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a07934509f8d264c16974bbe0c15ac7" id="r_a2a07934509f8d264c16974bbe0c15ac7"><td class="memItemLeft" align="right" valign="top">const internal::VariadicOperatorMatcherFunc&lt; 1, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a07934509f8d264c16974bbe0c15ac7">optionally</a></td></tr>
<tr class="memdesc:a2a07934509f8d264c16974bbe0c15ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any node regardless of the submatcher.  <br /></td></tr>
<tr class="separator:a2a07934509f8d264c16974bbe0c15ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6f1fbd69a5f3bd0b1f7c81f30ba547" id="r_a4e6f1fbd69a5f3bd0b1f7c81f30ba547"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e6f1fbd69a5f3bd0b1f7c81f30ba547">unaryExprOrTypeTraitExpr</a></td></tr>
<tr class="memdesc:a4e6f1fbd69a5f3bd0b1f7c81f30ba547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches sizeof (C99), alignof (C++11) and vec_step (OpenCL)  <br /></td></tr>
<tr class="separator:a4e6f1fbd69a5f3bd0b1f7c81f30ba547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76efced611335bad85d3da6fe6ae790e" id="r_a76efced611335bad85d3da6fe6ae790e"><td class="memItemLeft" align="right" valign="top">const internal::MapAnyOfMatcher&lt; <a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76efced611335bad85d3da6fe6ae790e">binaryOperation</a></td></tr>
<tr class="memdesc:a76efced611335bad85d3da6fe6ae790e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches nodes which can be used with binary operators.  <br /></td></tr>
<tr class="separator:a76efced611335bad85d3da6fe6ae790e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75176e564329aea08a65d667d019d9f8" id="r_a75176e564329aea08a65d667d019d9f8"><td class="memItemLeft" align="right" valign="top">const internal::VariadicFunction&lt; internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;, StringRef, <a class="el" href="namespaceclang_1_1ast__matchers_1_1internal.html#a98699ed64da2a4f207680ab1d26934ac">internal::hasAnyNameFunc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75176e564329aea08a65d667d019d9f8">hasAnyName</a> = {}</td></tr>
<tr class="memdesc:a75176e564329aea08a65d667d019d9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <a class="el" href="classclang_1_1NamedDecl.html" title="This represents a decl that may have a name.">NamedDecl</a> nodes that have any of the specified names.  <br /></td></tr>
<tr class="separator:a75176e564329aea08a65d667d019d9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4baa5862611b82aa132a5ab534b63e9b" id="r_a4baa5862611b82aa132a5ab534b63e9b"><td class="memItemLeft" align="right" valign="top">const internal::VariadicFunction&lt; internal::PolymorphicMatcherWithParam1&lt; internal::HasOverloadedOperatorNameMatcher, std::vector&lt; std::string &gt;, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>)&gt;, StringRef, <a class="el" href="namespaceclang_1_1ast__matchers_1_1internal.html#a1e5b2642d58cd1ce19c81f4c4335fc80">internal::hasAnyOverloadedOperatorNameFunc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4baa5862611b82aa132a5ab534b63e9b">hasAnyOverloadedOperatorName</a> = {}</td></tr>
<tr class="memdesc:a4baa5862611b82aa132a5ab534b63e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches overloaded operator names.  <br /></td></tr>
<tr class="separator:a4baa5862611b82aa132a5ab534b63e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a14e1788aad32c318543405b5ec5962" id="r_a9a14e1788aad32c318543405b5ec5962"><td class="memItemLeft" align="right" valign="top">const internal::ArgumentAdaptingMatcherFunc&lt; internal::HasMatcher &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a14e1788aad32c318543405b5ec5962">has</a> = {}</td></tr>
<tr class="memdesc:a9a14e1788aad32c318543405b5ec5962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches AST nodes that have child AST nodes that match the provided matcher.  <br /></td></tr>
<tr class="separator:a9a14e1788aad32c318543405b5ec5962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b133847db656cf51934b25cde311b8e" id="r_a2b133847db656cf51934b25cde311b8e"><td class="memItemLeft" align="right" valign="top">const internal::ArgumentAdaptingMatcherFunc&lt; internal::HasDescendantMatcher &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b133847db656cf51934b25cde311b8e">hasDescendant</a> = {}</td></tr>
<tr class="memdesc:a2b133847db656cf51934b25cde311b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches AST nodes that have descendant AST nodes that match the provided matcher.  <br /></td></tr>
<tr class="separator:a2b133847db656cf51934b25cde311b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e1d83c63172816c6678224f6d73fb8" id="r_a56e1d83c63172816c6678224f6d73fb8"><td class="memItemLeft" align="right" valign="top">const internal::ArgumentAdaptingMatcherFunc&lt; internal::ForEachMatcher &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56e1d83c63172816c6678224f6d73fb8">forEach</a></td></tr>
<tr class="memdesc:a56e1d83c63172816c6678224f6d73fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches AST nodes that have child AST nodes that match the provided matcher.  <br /></td></tr>
<tr class="separator:a56e1d83c63172816c6678224f6d73fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5114cdbe34bca53c82f6304894904740" id="r_a5114cdbe34bca53c82f6304894904740"><td class="memItemLeft" align="right" valign="top">const internal::ArgumentAdaptingMatcherFunc&lt; internal::ForEachDescendantMatcher &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5114cdbe34bca53c82f6304894904740">forEachDescendant</a> = {}</td></tr>
<tr class="memdesc:a5114cdbe34bca53c82f6304894904740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches AST nodes that have descendant AST nodes that match the provided matcher.  <br /></td></tr>
<tr class="separator:a5114cdbe34bca53c82f6304894904740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b510ddadcc0a313193fff2c1f18817" id="r_af6b510ddadcc0a313193fff2c1f18817"><td class="memItemLeft" align="right" valign="top">const internal::ArgumentAdaptingMatcherFunc&lt; internal::HasParentMatcher, internal::TypeList&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;, internal::TypeList&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6b510ddadcc0a313193fff2c1f18817">hasParent</a> = {}</td></tr>
<tr class="memdesc:af6b510ddadcc0a313193fff2c1f18817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches AST nodes that have a parent that matches the provided matcher.  <br /></td></tr>
<tr class="separator:af6b510ddadcc0a313193fff2c1f18817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634196d2ad98165151a6e005f192bcdb" id="r_a634196d2ad98165151a6e005f192bcdb"><td class="memItemLeft" align="right" valign="top">const internal::ArgumentAdaptingMatcherFunc&lt; internal::HasAncestorMatcher, internal::TypeList&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;, internal::TypeList&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a634196d2ad98165151a6e005f192bcdb">hasAncestor</a> = {}</td></tr>
<tr class="memdesc:a634196d2ad98165151a6e005f192bcdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches AST nodes that have an ancestor that matches the provided matcher.  <br /></td></tr>
<tr class="separator:a634196d2ad98165151a6e005f192bcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183ba07d4205e38e5d960a99062722dc" id="r_a183ba07d4205e38e5d960a99062722dc"><td class="memItemLeft" align="right" valign="top">const internal::VariadicOperatorMatcherFunc&lt; 1, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a183ba07d4205e38e5d960a99062722dc">unless</a></td></tr>
<tr class="memdesc:a183ba07d4205e38e5d960a99062722dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the provided matcher does not match.  <br /></td></tr>
<tr class="separator:a183ba07d4205e38e5d960a99062722dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6568b14e2ddad80f141bc0f81958f12b" id="r_a6568b14e2ddad80f141bc0f81958f12b"><td class="memItemLeft" align="right" valign="top">const internal::VariadicFunction&lt; internal::Matcher&lt; <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a> &gt;, StringRef, <a class="el" href="namespaceclang_1_1ast__matchers_1_1internal.html#a4fc6adb553977462ad8c1c98e6df506f">internal::hasAnySelectorFunc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6568b14e2ddad80f141bc0f81958f12b">hasAnySelector</a> = {}</td></tr>
<tr class="memdesc:a6568b14e2ddad80f141bc0f81958f12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches when at least one of the supplied string equals to the <a class="el" href="classclang_1_1Selector.html#a4fc5593940af968fa1187c3cb6a8ef8b" title="Derive the full selector name (e.g.">Selector.getAsString()</a>  <br /></td></tr>
<tr class="separator:a6568b14e2ddad80f141bc0f81958f12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7b689114837a79d0df0d9eeff59b1b" id="r_a5c7b689114837a79d0df0d9eeff59b1b"><td class="memItemLeft" align="right" valign="top">const internal::VariadicFunction&lt; internal::HasOpNameMatcher, StringRef, <a class="el" href="namespaceclang_1_1ast__matchers_1_1internal.html#aa6c82af4b9087769a26b4e80ff53d5e0">internal::hasAnyOperatorNameFunc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c7b689114837a79d0df0d9eeff59b1b">hasAnyOperatorName</a> = {}</td></tr>
<tr class="separator:a5c7b689114837a79d0df0d9eeff59b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426e811c0ed2c4e2fa0ad0491f3ac54f" id="r_a426e811c0ed2c4e2fa0ad0491f3ac54f"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a426e811c0ed2c4e2fa0ad0491f3ac54f">nestedNameSpecifier</a></td></tr>
<tr class="separator:a426e811c0ed2c4e2fa0ad0491f3ac54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5b4f5e6d4a60a21d2d08d000dc4fde" id="r_afc5b4f5e6d4a60a21d2d08d000dc4fde"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc5b4f5e6d4a60a21d2d08d000dc4fde">nestedNameSpecifierLoc</a></td></tr>
<tr class="separator:afc5b4f5e6d4a60a21d2d08d000dc4fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c320ec420f6590934c1a21e16d71ee" id="r_ab3c320ec420f6590934c1a21e16d71ee"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CUDAKernelCallExpr.html">CUDAKernelCallExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3c320ec420f6590934c1a21e16d71ee">cudaKernelCallExpr</a></td></tr>
<tr class="separator:ab3c320ec420f6590934c1a21e16d71ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be6a43ee3ebdf93d13af0c726f1d739" id="r_a2be6a43ee3ebdf93d13af0c726f1d739"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1BuiltinType.html">BuiltinType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2be6a43ee3ebdf93d13af0c726f1d739">builtinType</a></td></tr>
<tr class="separator:a2be6a43ee3ebdf93d13af0c726f1d739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718f2e541f79e142d30c8f2911b5ef97" id="r_a718f2e541f79e142d30c8f2911b5ef97"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1ArrayType.html">ArrayType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a718f2e541f79e142d30c8f2911b5ef97">arrayType</a></td></tr>
<tr class="separator:a718f2e541f79e142d30c8f2911b5ef97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf430f5b184451f864b0536db3494f0" id="r_a7bf430f5b184451f864b0536db3494f0"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1ComplexType.html">ComplexType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bf430f5b184451f864b0536db3494f0">complexType</a></td></tr>
<tr class="separator:a7bf430f5b184451f864b0536db3494f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71a954e32d97f8e6824bae9051b7853" id="r_aa71a954e32d97f8e6824bae9051b7853"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1ConstantArrayType.html">ConstantArrayType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa71a954e32d97f8e6824bae9051b7853">constantArrayType</a></td></tr>
<tr class="separator:aa71a954e32d97f8e6824bae9051b7853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba73ea27d54608e9c8762cb68d2152e1" id="r_aba73ea27d54608e9c8762cb68d2152e1"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1DeducedTemplateSpecializationType.html">DeducedTemplateSpecializationType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba73ea27d54608e9c8762cb68d2152e1">deducedTemplateSpecializationType</a></td></tr>
<tr class="separator:aba73ea27d54608e9c8762cb68d2152e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20405c2c252045def43f9fb8a66e3e9e" id="r_a20405c2c252045def43f9fb8a66e3e9e"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1DependentSizedArrayType.html">DependentSizedArrayType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20405c2c252045def43f9fb8a66e3e9e">dependentSizedArrayType</a></td></tr>
<tr class="separator:a20405c2c252045def43f9fb8a66e3e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49449307e3153888acf37c38d6d3fae8" id="r_a49449307e3153888acf37c38d6d3fae8"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1IncompleteArrayType.html">IncompleteArrayType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49449307e3153888acf37c38d6d3fae8">incompleteArrayType</a></td></tr>
<tr class="separator:a49449307e3153888acf37c38d6d3fae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4b5ef3a0104b7fcf7b3e2e4eeee0df" id="r_a3c4b5ef3a0104b7fcf7b3e2e4eeee0df"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1VariableArrayType.html">VariableArrayType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c4b5ef3a0104b7fcf7b3e2e4eeee0df">variableArrayType</a></td></tr>
<tr class="separator:a3c4b5ef3a0104b7fcf7b3e2e4eeee0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4fec1590628a5b59ac12297cdf44de" id="r_acc4fec1590628a5b59ac12297cdf44de"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1AtomicType.html">AtomicType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc4fec1590628a5b59ac12297cdf44de">atomicType</a></td></tr>
<tr class="separator:acc4fec1590628a5b59ac12297cdf44de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900caa094a8fe83b37dd058e73246c67" id="r_a900caa094a8fe83b37dd058e73246c67"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1AutoType.html">AutoType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a900caa094a8fe83b37dd058e73246c67">autoType</a></td></tr>
<tr class="separator:a900caa094a8fe83b37dd058e73246c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4b20199a79ce79c9d781bc6e207337" id="r_aca4b20199a79ce79c9d781bc6e207337"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1DecltypeType.html">DecltypeType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca4b20199a79ce79c9d781bc6e207337">decltypeType</a></td></tr>
<tr class="separator:aca4b20199a79ce79c9d781bc6e207337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bdb41bba221f74825ffc014afcdc79" id="r_a76bdb41bba221f74825ffc014afcdc79"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1FunctionType.html">FunctionType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76bdb41bba221f74825ffc014afcdc79">functionType</a></td></tr>
<tr class="separator:a76bdb41bba221f74825ffc014afcdc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b417110dc9fa37bc246638349aea1b" id="r_a92b417110dc9fa37bc246638349aea1b"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1FunctionProtoType.html">FunctionProtoType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92b417110dc9fa37bc246638349aea1b">functionProtoType</a></td></tr>
<tr class="separator:a92b417110dc9fa37bc246638349aea1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f014abb752de135c866b75515997918" id="r_a6f014abb752de135c866b75515997918"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1ParenType.html">ParenType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f014abb752de135c866b75515997918">parenType</a></td></tr>
<tr class="separator:a6f014abb752de135c866b75515997918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c675c1451aa325c70a5608b974c96ae" id="r_a4c675c1451aa325c70a5608b974c96ae"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1BlockPointerType.html">BlockPointerType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c675c1451aa325c70a5608b974c96ae">blockPointerType</a></td></tr>
<tr class="separator:a4c675c1451aa325c70a5608b974c96ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ba9a33f85183fb53caeab41d583eb4" id="r_a90ba9a33f85183fb53caeab41d583eb4"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1MemberPointerType.html">MemberPointerType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90ba9a33f85183fb53caeab41d583eb4">memberPointerType</a></td></tr>
<tr class="separator:a90ba9a33f85183fb53caeab41d583eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54c06461d2b15cc9701a1f8a5507daf" id="r_ab54c06461d2b15cc9701a1f8a5507daf"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1PointerType.html">PointerType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab54c06461d2b15cc9701a1f8a5507daf">pointerType</a></td></tr>
<tr class="separator:ab54c06461d2b15cc9701a1f8a5507daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c474e1c9e9c11c0699a97cc0c617d90" id="r_a1c474e1c9e9c11c0699a97cc0c617d90"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1ObjCObjectPointerType.html">ObjCObjectPointerType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c474e1c9e9c11c0699a97cc0c617d90">objcObjectPointerType</a></td></tr>
<tr class="separator:a1c474e1c9e9c11c0699a97cc0c617d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af815f75b8b46c51b83b9a63fd65ac7e9" id="r_af815f75b8b46c51b83b9a63fd65ac7e9"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1ReferenceType.html">ReferenceType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af815f75b8b46c51b83b9a63fd65ac7e9">referenceType</a></td></tr>
<tr class="separator:af815f75b8b46c51b83b9a63fd65ac7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5bc758921dbbbe367f4940d4ee43c8" id="r_a7c5bc758921dbbbe367f4940d4ee43c8"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1LValueReferenceType.html">LValueReferenceType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c5bc758921dbbbe367f4940d4ee43c8">lValueReferenceType</a></td></tr>
<tr class="separator:a7c5bc758921dbbbe367f4940d4ee43c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0914bea7f6abd63ad8a6e823a608bf92" id="r_a0914bea7f6abd63ad8a6e823a608bf92"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1RValueReferenceType.html">RValueReferenceType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0914bea7f6abd63ad8a6e823a608bf92">rValueReferenceType</a></td></tr>
<tr class="separator:a0914bea7f6abd63ad8a6e823a608bf92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab6fe99e4ce4c0c2d6d7d6a7f38194e" id="r_adab6fe99e4ce4c0c2d6d7d6a7f38194e"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1TypedefType.html">TypedefType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adab6fe99e4ce4c0c2d6d7d6a7f38194e">typedefType</a></td></tr>
<tr class="separator:adab6fe99e4ce4c0c2d6d7d6a7f38194e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0b65ac213d164ac0367dfa7aa95c80" id="r_add0b65ac213d164ac0367dfa7aa95c80"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1EnumType.html">EnumType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add0b65ac213d164ac0367dfa7aa95c80">enumType</a></td></tr>
<tr class="separator:add0b65ac213d164ac0367dfa7aa95c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35e48d050bc59b7a1cf9f428753e937" id="r_af35e48d050bc59b7a1cf9f428753e937"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af35e48d050bc59b7a1cf9f428753e937">templateSpecializationType</a></td></tr>
<tr class="separator:af35e48d050bc59b7a1cf9f428753e937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac495193c61151ba0fa6d6a3d8963e32c" id="r_ac495193c61151ba0fa6d6a3d8963e32c"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1UnaryTransformType.html">UnaryTransformType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac495193c61151ba0fa6d6a3d8963e32c">unaryTransformType</a></td></tr>
<tr class="separator:ac495193c61151ba0fa6d6a3d8963e32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba33a83216073984c1a929a28f3091d3" id="r_aba33a83216073984c1a929a28f3091d3"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1RecordType.html">RecordType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba33a83216073984c1a929a28f3091d3">recordType</a></td></tr>
<tr class="separator:aba33a83216073984c1a929a28f3091d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46559546a6a5dbdb21f04e377ddb0baf" id="r_a46559546a6a5dbdb21f04e377ddb0baf"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1TagType.html">TagType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46559546a6a5dbdb21f04e377ddb0baf">tagType</a></td></tr>
<tr class="separator:a46559546a6a5dbdb21f04e377ddb0baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ebd6b87d8af5808b5f789a530ba9ae" id="r_ae7ebd6b87d8af5808b5f789a530ba9ae"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1ElaboratedType.html">ElaboratedType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7ebd6b87d8af5808b5f789a530ba9ae">elaboratedType</a></td></tr>
<tr class="separator:ae7ebd6b87d8af5808b5f789a530ba9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220e5a0250d5fdc7cad9d0da256132fe" id="r_a220e5a0250d5fdc7cad9d0da256132fe"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1SubstTemplateTypeParmType.html">SubstTemplateTypeParmType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a220e5a0250d5fdc7cad9d0da256132fe">substTemplateTypeParmType</a></td></tr>
<tr class="separator:a220e5a0250d5fdc7cad9d0da256132fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f7f721802fd12747c14f2b45dc06c0" id="r_a93f7f721802fd12747c14f2b45dc06c0"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93f7f721802fd12747c14f2b45dc06c0">templateTypeParmType</a></td></tr>
<tr class="separator:a93f7f721802fd12747c14f2b45dc06c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdc08b97af264df7f9a8cf2091ec679" id="r_aecdc08b97af264df7f9a8cf2091ec679"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecdc08b97af264df7f9a8cf2091ec679">injectedClassNameType</a></td></tr>
<tr class="separator:aecdc08b97af264df7f9a8cf2091ec679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bd085c51befd42c27944d815f2429b" id="r_a38bd085c51befd42c27944d815f2429b"><td class="memItemLeft" align="right" valign="top">const AstTypeMatcher&lt; <a class="el" href="classclang_1_1DecayedType.html">DecayedType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38bd085c51befd42c27944d815f2429b">decayedType</a></td></tr>
<tr class="separator:a38bd085c51befd42c27944d815f2429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46c78f9e0d25b95959055d0265dedd8" id="r_aa46c78f9e0d25b95959055d0265dedd8"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa46c78f9e0d25b95959055d0265dedd8">ompExecutableDirective</a></td></tr>
<tr class="separator:aa46c78f9e0d25b95959055d0265dedd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381bce396b06bba5e9bd658b76caa2cd" id="r_a381bce396b06bba5e9bd658b76caa2cd"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1OMPClause.html">OMPClause</a>, <a class="el" href="classclang_1_1OMPDefaultClause.html">OMPDefaultClause</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a381bce396b06bba5e9bd658b76caa2cd">ompDefaultClause</a></td></tr>
<tr class="separator:a381bce396b06bba5e9bd658b76caa2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a678a244ce9fd8f09718bda612658099b" name="a678a244ce9fd8f09718bda612658099b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678a244ce9fd8f09718bda612658099b">&#9670;&#160;</a></span>CXXCtorInitializerMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a678a244ce9fd8f09718bda612658099b">clang::ast_matchers::CXXCtorInitializerMatcher</a> = internal::Matcher&lt;<a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00147">147</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a1d77576823c6c764d94aca78ada0f5ad" name="a1d77576823c6c764d94aca78ada0f5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d77576823c6c764d94aca78ada0f5ad">&#9670;&#160;</a></span>DeclarationMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1d77576823c6c764d94aca78ada0f5ad">clang::ast_matchers::DeclarationMatcher</a> = internal::Matcher&lt;<a class="el" href="classclang_1_1Decl.html">Decl</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of matchers for the top-level classes in the AST class hierarchy. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00141">141</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a9df0d28652c188eeeb58c5ee89cc2804" name="a9df0d28652c188eeeb58c5ee89cc2804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df0d28652c188eeeb58c5ee89cc2804">&#9670;&#160;</a></span>NestedNameSpecifierLocMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9df0d28652c188eeeb58c5ee89cc2804">clang::ast_matchers::NestedNameSpecifierLocMatcher</a> = internal::Matcher&lt;<a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00146">146</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ae372b9585fd8ebf144e729a1e9e16f86" name="ae372b9585fd8ebf144e729a1e9e16f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae372b9585fd8ebf144e729a1e9e16f86">&#9670;&#160;</a></span>NestedNameSpecifierMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae372b9585fd8ebf144e729a1e9e16f86">clang::ast_matchers::NestedNameSpecifierMatcher</a> = internal::Matcher&lt;<a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00145">145</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a85886610fb27988c71cb3d5134c2302d" name="a85886610fb27988c71cb3d5134c2302d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85886610fb27988c71cb3d5134c2302d">&#9670;&#160;</a></span>StatementMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a85886610fb27988c71cb3d5134c2302d">clang::ast_matchers::StatementMatcher</a> = internal::Matcher&lt;<a class="el" href="classclang_1_1Stmt.html">Stmt</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00142">142</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a88cb263a5dbe44a0deb43c2c7583c634" name="a88cb263a5dbe44a0deb43c2c7583c634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cb263a5dbe44a0deb43c2c7583c634">&#9670;&#160;</a></span>TemplateArgumentLocMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a88cb263a5dbe44a0deb43c2c7583c634">clang::ast_matchers::TemplateArgumentLocMatcher</a> = internal::Matcher&lt;<a class="el" href="classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00149">149</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a94019e3357b446783a76ce36fc898583" name="a94019e3357b446783a76ce36fc898583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94019e3357b446783a76ce36fc898583">&#9670;&#160;</a></span>TemplateArgumentMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a94019e3357b446783a76ce36fc898583">clang::ast_matchers::TemplateArgumentMatcher</a> = internal::Matcher&lt;<a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00148">148</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="af39490ae02e4e117c2cbed029f651d52" name="af39490ae02e4e117c2cbed029f651d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39490ae02e4e117c2cbed029f651d52">&#9670;&#160;</a></span>TypeLocMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af39490ae02e4e117c2cbed029f651d52">clang::ast_matchers::TypeLocMatcher</a> = internal::Matcher&lt;<a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00144">144</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a06ab01fccdd3cc9ddde2c6f7e46eadf9" name="a06ab01fccdd3cc9ddde2c6f7e46eadf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ab01fccdd3cc9ddde2c6f7e46eadf9">&#9670;&#160;</a></span>TypeMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a06ab01fccdd3cc9ddde2c6f7e46eadf9">clang::ast_matchers::TypeMatcher</a> = internal::Matcher&lt;<a class="el" href="classclang_1_1QualType.html">QualType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00143">143</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1c8d79365d495125b8c32aa08e15ae9d" name="a1c8d79365d495125b8c32aa08e15ae9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8d79365d495125b8c32aa08e15ae9d">&#9670;&#160;</a></span>GtestCmp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9d">clang::ast_matchers::GtestCmp</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gtest's comparison operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1c8d79365d495125b8c32aa08e15ae9da3718b5ecf60aa0dba49e150e96cb1fc3" name="a1c8d79365d495125b8c32aa08e15ae9da3718b5ecf60aa0dba49e150e96cb1fc3"></a>Eq&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1c8d79365d495125b8c32aa08e15ae9da4dec99baa99738721da9c9b0c1a92498" name="a1c8d79365d495125b8c32aa08e15ae9da4dec99baa99738721da9c9b0c1a92498"></a>Ne&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1c8d79365d495125b8c32aa08e15ae9dac6a675552648c0becb8283f05c172483" name="a1c8d79365d495125b8c32aa08e15ae9dac6a675552648c0becb8283f05c172483"></a>Ge&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1c8d79365d495125b8c32aa08e15ae9da086cb8308e5a36e7c4ed1f8873ad801f" name="a1c8d79365d495125b8c32aa08e15ae9da086cb8308e5a36e7c4ed1f8873ad801f"></a>Gt&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1c8d79365d495125b8c32aa08e15ae9dabccd5ec3ec8fd3a4471e71e9b407c60c" name="a1c8d79365d495125b8c32aa08e15ae9dabccd5ec3ec8fd3a4471e71e9b407c60c"></a>Le&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1c8d79365d495125b8c32aa08e15ae9da50033c15af7795cd6617f117b29d6922" name="a1c8d79365d495125b8c32aa08e15ae9da50033c15af7795cd6617f117b29d6922"></a>Lt&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8h_source.html#l00024">24</a> of file <a class="el" href="GtestMatchers_8h_source.html">GtestMatchers.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac990761bd6763c396e66b3359f098f72" name="ac990761bd6763c396e66b3359f098f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac990761bd6763c396e66b3359f098f72">&#9670;&#160;</a></span>alignOfExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt; clang::ast_matchers::alignOfExpr </td>
          <td>(</td>
          <td class="paramtype">const internal::Matcher&lt; <a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InnerMatcher</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as unaryExprOrTypeTraitExpr, but only matching alignof. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02864">2864</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00967">allOf</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00964">anyOf</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00794">stmt</a>, and <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00773">unaryExprOrTypeTraitExpr</a>.</p>

</div>
</div>
<a id="a652afe55bf376c9c0789d550409d90fe" name="a652afe55bf376c9c0789d550409d90fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652afe55bf376c9c0789d550409d90fe">&#9670;&#160;</a></span>anything()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::TrueMatcher clang::ast_matchers::anything </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches any node. </p>
<p>Useful when another matcher requires a child matcher, but there's no additional constraint. This will often be used with an explicit conversion to an <code>internal::Matcher&lt;&gt;</code> type such as <code>TypeMatcher</code>.</p>
<p>Example: <code><a class="el" href="#a1d77576823c6c764d94aca78ada0f5ad" title="Types of matchers for the top-level classes in the AST class hierarchy.">DeclarationMatcher(anything())</a></code> matches all declarations, e.g., </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;int* p&quot;</span> <a class="code hl_define" href="iso646_8h.html#aa3d7d535cf450b91b9cb6d9cee2edbb9">and</a> <span class="stringliteral">&quot;void f()&quot;</span> in</div>
<div class="line">  <span class="keywordtype">int</span>* p;</div>
<div class="line">  <span class="keywordtype">void</span> f();</div>
<div class="ttc" id="aiso646_8h_html_aa3d7d535cf450b91b9cb6d9cee2edbb9"><div class="ttname"><a href="iso646_8h.html#aa3d7d535cf450b91b9cb6d9cee2edbb9">and</a></div><div class="ttdeci">#define and</div><div class="ttdef"><b>Definition</b> <a href="iso646_8h_source.html#l00014">iso646.h:14</a></div></div>
</div><!-- fragment --><p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00166">166</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a0edfa6373df58e343d19f5d2679991d1" name="a0edfa6373df58e343d19f5d2679991d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edfa6373df58e343d19f5d2679991d1">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[1/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CallExpr.html">CallExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usesADL</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches call expressions which were resolved using ADL. </p>
<p>Example matches y(x) but not y(42) or NS::y(x). </p><div class="fragment"><div class="line">      <span class="keyword">namespace </span>NS {</div>
<div class="line">        <span class="keyword">struct </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {};</div>
<div class="line">        <span class="keywordtype">void</span> y(<a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>);</div>
<div class="line">      }</div>
<div class="line">   </div>
<div class="line">      <span class="keywordtype">void</span> y(...);</div>
<div class="line">   </div>
<div class="line">      <span class="keywordtype">void</span> test() {</div>
<div class="line">        NS::X x;</div>
<div class="line">        y(x); <span class="comment">// Matches</span></div>
<div class="line">        NS::y(x); <span class="comment">// Doesn&#39;t match</span></div>
<div class="line">        y(42); <span class="comment">// Doesn&#39;t match</span></div>
<div class="line">        <span class="keyword">using </span>NS::y;</div>
<div class="line">        y(x); <span class="comment">// Found by both unqualified lookup and ADL, doesn&#39;t match</span></div>
<div class="line"><span class="comment">//    }</span></div>
<div class="ttc" id="aCompilationDatabase_8cpp_html_a9a49441f73fccd3c5a00b729ac1dc56c"><div class="ttname"><a href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a></div><div class="ttdeci">static CompilationDatabasePluginRegistry::Add&lt; FixedCompilationDatabasePlugin &gt; X(&quot;fixed-compilation-database&quot;, &quot;Reads plain-text flags file&quot;)</div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01472">1472</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a75db3620648d58f6be5e799142f86a31" name="a75db3620648d58f6be5e799142f86a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75db3620648d58f6be5e799142f86a31">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[2/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXCatchStmt.html">CXXCatchStmt</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isCatchAll</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a C++ catch statement that has a catch-all handler. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keywordtype">int</span>) {</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">} <span class="keywordflow">catch</span> (...) {</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="el" href="#aed73db7e4f5258557e39edc7fc5168d0" title="Matches catch statements.">cxxCatchStmt(isCatchAll())</a> matches catch(...) but not catch(int). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04296">4296</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a8113d0616cb8189881b650642e748512" name="a8113d0616cb8189881b650642e748512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8113d0616cb8189881b650642e748512">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[3/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isListInitialization</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a constructor call expression which uses list initialization. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04501">4501</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a5125c811ce3f78efc6ab3c5a1bf68362" name="a5125c811ce3f78efc6ab3c5a1bf68362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5125c811ce3f78efc6ab3c5a1bf68362">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[4/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">requiresZeroInitialization</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a constructor call expression which requires zero initialization. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo() {</div>
<div class="line">  <span class="keyword">struct </span>point { <span class="keywordtype">double</span> x; <span class="keywordtype">double</span> y; };</div>
<div class="line">  point pt[2] = { { 1.0, 2.0 } };</div>
<div class="line">}</div>
</div><!-- fragment --><p> initListExpr(has(<a class="el" href="#ab0da198b76c77bfd4737a339d5a78e33" title="Matches constructor call expressions (including implicit ones).">cxxConstructExpr(requiresZeroInitialization())</a>) will match the implicit array filler for pt[1]. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04517">4517</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a151df67d97404bc1b336c5dfc6d01951" name="a151df67d97404bc1b336c5dfc6d01951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151df67d97404bc1b336c5dfc6d01951">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[5/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isBaseInitializer</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a constructor initializer if it is initializing a base, as opposed to a member. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>B {};</div>
<div class="line"><span class="keyword">struct </span>D : B {</div>
<div class="line">  <span class="keywordtype">int</span> I;</div>
<div class="line">  D(<span class="keywordtype">int</span> i) : I(i) {}</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>E : B {</div>
<div class="line">  E() : B() {}</div>
<div class="line">};</div>
</div><!-- fragment --><p> cxxConstructorDecl(hasAnyConstructorInitializer(isBaseInitializer())) will match E(), but not match D(int). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04395">4395</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a4740b640dfb1653cfed5729b59331761" name="a4740b640dfb1653cfed5729b59331761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4740b640dfb1653cfed5729b59331761">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[6/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isMemberInitializer</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a constructor initializer if it is initializing a member, as opposed to a base. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>B {};</div>
<div class="line"><span class="keyword">struct </span>D : B {</div>
<div class="line">  <span class="keywordtype">int</span> I;</div>
<div class="line">  D(<span class="keywordtype">int</span> i) : I(i) {}</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>E : B {</div>
<div class="line">  E() : B() {}</div>
<div class="line">};</div>
</div><!-- fragment --><p> cxxConstructorDecl(hasAnyConstructorInitializer(isMemberInitializer())) will match D(int), but not match E(). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04415">4415</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a03f7a8a989c0ca1eaa26b3045b1ceaab" name="a03f7a8a989c0ca1eaa26b3045b1ceaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f7a8a989c0ca1eaa26b3045b1ceaab">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[7/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isWritten</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a constructor initializer if it is explicitly written in code (as opposed to implicitly added by the compiler). </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  Foo() { }</div>
<div class="line">  Foo(<span class="keywordtype">int</span>) : foo_(<span class="stringliteral">&quot;A&quot;</span>) { }</div>
<div class="line">  <span class="keywordtype">string</span> foo_;</div>
<div class="line">};</div>
</div><!-- fragment --><p> cxxConstructorDecl(hasAnyConstructorInitializer(isWritten())) will match Foo(int), but not Foo() </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04375">4375</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="ae1b1b3c472ca3262e95b5a2eefa63b7e" name="ae1b1b3c472ca3262e95b5a2eefa63b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b1b3c472ca3262e95b5a2eefa63b7e">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[8/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isLambda</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the generated class of lambda expressions. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> x = []{};</div>
</div><!-- fragment --><p><code><a class="el" href="#ac1ef73826e6b83dd0e8fc4a4b7284c74" title="Matches C++ class declarations.">cxxRecordDecl(isLambda())</a></code> matches the implicit class declaration of <code>decltype(x)</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03270">3270</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a74dcbcb1679405feb5454798560ee342" name="a74dcbcb1679405feb5454798560ee342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74dcbcb1679405feb5454798560ee342">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[9/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Decl.html">Decl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isImplicit</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a declaration that has been implicitly added by the compiler (eg. </p>
<p>implicit default/copy constructors). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00737">737</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a833e412dcf7c56f98cd2f63b7ef6dc93" name="a833e412dcf7c56f98cd2f63b7ef6dc93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833e412dcf7c56f98cd2f63b7ef6dc93">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[10/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isInstantiationDependent</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions that are instantiation-dependent even if it is neither type- nor value-dependent. </p>
<p>In the following example, the expression sizeof(sizeof(T() + T())) is instantiation-dependent (since it involves a template parameter T), but is neither type- nor value-dependent, since the type of the inner sizeof is known (std::size_t) and therefore the size of the outer sizeof is known. </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> f(T x, T y) { <span class="keyword">sizeof</span>(<span class="keyword">sizeof</span>(T() + T()); }</div>
</div><!-- fragment --><p> <a class="el" href="#adfc0ccd398780d345e2c541cc716cc66" title="Matches expressions.">expr(isInstantiationDependent())</a> matches sizeof(sizeof(T() + T()) </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01005">1005</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a00f22eb8aa38e1f695312a09764c34ef" name="a00f22eb8aa38e1f695312a09764c34ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f22eb8aa38e1f695312a09764c34ef">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[11/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isTypeDependent</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions that are type-dependent because the template type is not yet instantiated. </p>
<p>For example, the expressions "x" and "x + y" are type-dependent in the following code, but "y" is not type-dependent: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> add(T x, <span class="keywordtype">int</span> y) {</div>
<div class="line">  x + y;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="el" href="#adfc0ccd398780d345e2c541cc716cc66" title="Matches expressions.">expr(isTypeDependent())</a> matches x + y </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01021">1021</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a02d8919c5ecf8f9a9ab153ca646d3a6a" name="a02d8919c5ecf8f9a9ab153ca646d3a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d8919c5ecf8f9a9ab153ca646d3a6a">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[12/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isValueDependent</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expression that are value-dependent because they contain a non-type template parameter. </p>
<p>For example, the array bound of "Chars" in the following example is value-dependent. </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Size&gt; <span class="keywordtype">int</span> f() { <span class="keywordflow">return</span> Size; }</div>
</div><!-- fragment --><p> <a class="el" href="#adfc0ccd398780d345e2c541cc716cc66" title="Matches expressions.">expr(isValueDependent())</a> matches return Size </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01032">1032</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="ac15b7c8db135d0ff9fb14a612faa14f3" name="ac15b7c8db135d0ff9fb14a612faa14f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15b7c8db135d0ff9fb14a612faa14f3">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[13/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isBitField</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches non-static data members that are bit-fields. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {</div>
<div class="line">  <span class="keywordtype">int</span> a : 2;</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">};</div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_a373e9fc646873cd20f2c9fdb7125a207"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a></div><div class="ttdeci">__device__ __2f16 b</div><div class="ttdef"><b>Definition</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00302">__clang_hip_libdevice_declares.h:302</a></div></div>
<div class="ttc" id="anamespaceclang_html_af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257"><div class="ttname"><a href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">clang::AttrSyntax::C</a></div><div class="ttdeci">@ C</div></div>
</div><!-- fragment --><p> <a class="el" href="#ab26f3ff62d6be975196efa86f3b15d82" title="Matches field declarations.">fieldDecl(isBitField())</a> matches 'int a;' but not 'int b;'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00669">669</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="ae5cebfe9c6da04c2d9cfb13a038f0dde" name="ae5cebfe9c6da04c2d9cfb13a038f0dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cebfe9c6da04c2d9cfb13a038f0dde">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[14/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isMain</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the function is "main", which is the entry point into an executable program. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00714">714</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a210ce15787ad4e0ef9f5f8bdd0b1b7b3" name="a210ce15787ad4e0ef9f5f8bdd0b1b7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210ce15787ad4e0ef9f5f8bdd0b1b7b3">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[15/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasKeywordSelector</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches when the selector is a keyword selector. </p>
<p>objCMessageExpr(hasKeywordSelector()) matches the generated setFrame message expression in</p>
<div class="fragment"><div class="line">UIWebView *webView = ...;</div>
<div class="line">CGRect bodyFrame = webView.frame;</div>
<div class="line">bodyFrame.size.height = self.bodyContentHeight;</div>
<div class="line">webView.frame = bodyFrame;</div>
<div class="line"><span class="comment">//     ^---- matches here</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03691">3691</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a38f55858b223a0e11066738f16c77a25" name="a38f55858b223a0e11066738f16c77a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f55858b223a0e11066738f16c77a25">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[16/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasNullSelector</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches when the selector is the empty selector. </p>
<p>Matches only when the selector of the objCMessageExpr is NULL. This may represent an error condition in the tree! </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03663">3663</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="affe17436c3837899bc7a1f07dd6c23f8" name="affe17436c3837899bc7a1f07dd6c23f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe17436c3837899bc7a1f07dd6c23f8">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[17/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasUnarySelector</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches when the selector is a Unary <a class="el" href="classclang_1_1Selector.html" title="Smart pointer class that efficiently represents Objective-C method names.">Selector</a>. </p>
<p>matcher = objCMessageExpr(matchesSelector(hasUnarySelector()); matches self.bodyView in the code below, but NOT the outer message invocation of "loadHTMLString:baseURL:". </p><div class="fragment"><div class="line">[self.bodyView loadHTMLString:html baseURL:<a class="code hl_define" href="opencl-c-base_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>];</div>
<div class="ttc" id="aopencl-c-base_8h_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="opencl-c-base_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition</b> <a href="opencl-c-base_8h_source.html#l00145">opencl-c-base.h:145</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03675">3675</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a50ccba02e6d782bd0ffda74eef632efc" name="a50ccba02e6d782bd0ffda74eef632efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ccba02e6d782bd0ffda74eef632efc">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[18/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isClassMessage</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true when the Objective-C message is sent to a class. </p>
<p>Example matcher = <a class="el" href="#a76e430a6b71305865cc46c57a9465c84" title="Matches ObjectiveC Message invocation expressions.">objcMessageExpr(isClassMessage())</a> matches </p><div class="fragment"><div class="line">[NSString stringWithFormat:<span class="stringliteral">@&quot;format&quot;</span>];</div>
</div><!-- fragment --><p> but not </p><div class="fragment"><div class="line">NSString *x = <span class="stringliteral">@&quot;hello&quot;</span>;</div>
<div class="line">[x containsString:<span class="stringliteral">@&quot;h&quot;</span>];</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03579">3579</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a4ac3bec31f7eb8625530f52cf6f5a87f" name="a4ac3bec31f7eb8625530f52cf6f5a87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac3bec31f7eb8625530f52cf6f5a87f">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[19/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isInstanceMessage</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true when the Objective-C message is sent to an instance. </p>
<p>Example matcher = <a class="el" href="#a76e430a6b71305865cc46c57a9465c84" title="Matches ObjectiveC Message invocation expressions.">objcMessageExpr(isInstanceMessage())</a> matches </p><div class="fragment"><div class="line">NSString *x = <span class="stringliteral">@&quot;hello&quot;</span>;</div>
<div class="line">[x containsString:<span class="stringliteral">@&quot;h&quot;</span>];</div>
</div><!-- fragment --><p> but not </p><div class="fragment"><div class="line">[NSString stringWithFormat:<span class="stringliteral">@&quot;format&quot;</span>];</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03596">3596</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="abed7081a3099b4c413dd177c4c00559c" name="abed7081a3099b4c413dd177c4c00559c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed7081a3099b4c413dd177c4c00559c">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[20/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isClassMethod</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true when the Objective-C method declaration is a class method. </p>
<p>Example matcher = <a class="el" href="#a3a90eb6eeec44cfb79ef98129ad90ec1" title="Matches Objective-C method declarations.">objcMethodDecl(isClassMethod())</a> matches </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>I + (void)foo; <span class="keyword">@end</span></div>
</div><!-- fragment --><p> but not </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>I - (void)bar; <span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03546">3546</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="adae407a60668f5aeb7fb497b64762b8d" name="adae407a60668f5aeb7fb497b64762b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae407a60668f5aeb7fb497b64762b8d">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[21/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SemaDeclAttr_8cpp.html#ad35282e02924165aae3b360b22ab028e">isInstanceMethod</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true when the Objective-C method declaration is an instance method. </p>
<p>Example matcher = <a class="el" href="#a3a90eb6eeec44cfb79ef98129ad90ec1" title="Matches Objective-C method declarations.">objcMethodDecl(isInstanceMethod())</a> matches </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>I - (void)bar; <span class="keyword">@end</span></div>
</div><!-- fragment --><p> but not </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>I + (void)foo; <span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03562">3562</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a372ddae878809019381acb68314cb048" name="a372ddae878809019381acb68314cb048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372ddae878809019381acb68314cb048">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[22/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isIntegral</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that is an integral value. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> T&gt; <span class="keyword">struct </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {};</div>
<div class="line"><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C&lt;42&gt;</a> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_ad55181c98da0de5b29a5afc3060fc6d0"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a></div><div class="ttdeci">__device__ __2f16 float c</div><div class="ttdef"><b>Definition</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00303">__clang_hip_libdevice_declares.h:303</a></div></div>
</div><!-- fragment --><p> classTemplateSpecializationDecl( hasAnyTemplateArgument(isIntegral())) matches the implicit instantiation of C in C&lt;42&gt; with isIntegral() matching 42. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01167">1167</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="TemplateBase_8h_source.html#l00083">clang::TemplateArgument::Integral</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a1491a3107fcb1a9823b82f0e0d2c8f8b" name="a1491a3107fcb1a9823b82f0e0d2c8f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1491a3107fcb1a9823b82f0e0d2c8f8b">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[23/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VarDecl.html">VarDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAutomaticStorageDuration</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a variable declaration that has automatic storage duration. </p>
<p>Example matches x, but not y, z, or a. (matcher = <a class="el" href="#a056e81429237736b6458df18bb538c82" title="Matches variable declarations.">varDecl(hasAutomaticStorageDuration())</a> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  <span class="keywordtype">int</span> x;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> y;</div>
<div class="line">  <span class="keyword">thread_local</span> <span class="keywordtype">int</span> z;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> a;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04126">4126</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>, and <a class="el" href="Specifiers_8h_source.html#l00296">clang::SD_Automatic</a>.</p>

</div>
</div>
<a id="a9fb8c35f77273ca8c9d74d3ccd8115ee" name="a9fb8c35f77273ca8c9d74d3ccd8115ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb8c35f77273ca8c9d74d3ccd8115ee">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[24/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VarDecl.html">VarDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasGlobalStorage</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a variable declaration that does not have local storage. </p>
<p>Example matches y and z (matcher = <a class="el" href="#a056e81429237736b6458df18bb538c82" title="Matches variable declarations.">varDecl(hasGlobalStorage())</a> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  <span class="keywordtype">int</span> x;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> y;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> z;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04110">4110</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a20615f964d0cc210125ba1a7030e1d99" name="a20615f964d0cc210125ba1a7030e1d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20615f964d0cc210125ba1a7030e1d99">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[25/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VarDecl.html">VarDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasLocalStorage</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a variable declaration that has function scope and is a non-static local variable. </p>
<p>Example matches x (matcher = <a class="el" href="#a056e81429237736b6458df18bb538c82" title="Matches variable declarations.">varDecl(hasLocalStorage())</a> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  <span class="keywordtype">int</span> x;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> y;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> z;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04096">4096</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="abe1c982b6814464ccb0e81ad49e5deb8" name="abe1c982b6814464ccb0e81ad49e5deb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1c982b6814464ccb0e81ad49e5deb8">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[26/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VarDecl.html">VarDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasStaticStorageDuration</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a variable declaration that has static storage duration. </p>
<p>It includes the variable declared at namespace scope and those declared with "static" and "extern" storage class specifiers.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  <span class="keywordtype">int</span> x;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> y;</div>
<div class="line">  <span class="keyword">thread_local</span> <span class="keywordtype">int</span> z;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> a;</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line"><a class="code hl_variable" href="#a056e81429237736b6458df18bb538c82">varDecl</a>(hasStaticStorageDuration())</div>
<div class="line">  matches the function declaration y, a, <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> <a class="code hl_define" href="iso646_8h.html#aa3d7d535cf450b91b9cb6d9cee2edbb9">and</a> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>.</div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a056e81429237736b6458df18bb538c82"><div class="ttname"><a href="#a056e81429237736b6458df18bb538c82">clang::ast_matchers::varDecl</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Decl, VarDecl &gt; varDecl</div><div class="ttdoc">Matches variable declarations.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00786">ASTMatchersInternal.cpp:786</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04146">4146</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>, and <a class="el" href="Specifiers_8h_source.html#l00298">clang::SD_Static</a>.</p>

</div>
</div>
<a id="abea11fc4361920f652b8655a7fc1ce7a" name="abea11fc4361920f652b8655a7fc1ce7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea11fc4361920f652b8655a7fc1ce7a">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[27/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VarDecl.html">VarDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasThreadStorageDuration</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a variable declaration that has thread storage duration. </p>
<p>Example matches z, but not x, z, or a. (matcher = <a class="el" href="#a056e81429237736b6458df18bb538c82" title="Matches variable declarations.">varDecl(hasThreadStorageDuration())</a> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  <span class="keywordtype">int</span> x;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> y;</div>
<div class="line">  <span class="keyword">thread_local</span> <span class="keywordtype">int</span> z;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> a;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04162">4162</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>, and <a class="el" href="Specifiers_8h_source.html#l00297">clang::SD_Thread</a>.</p>

</div>
</div>
<a id="a5663ab187f13ea8c1a0d3884a5837369" name="a5663ab187f13ea8c1a0d3884a5837369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5663ab187f13ea8c1a0d3884a5837369">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[28/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VarDecl.html">VarDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isExceptionVariable</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a variable declaration that is an exception variable from a C++ catch block, or an Objective-C @catch statement. </p>
<p>Example matches x (matcher = <a class="el" href="#a056e81429237736b6458df18bb538c82" title="Matches variable declarations.">varDecl(isExceptionVariable())</a> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> y) {</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">  } <span class="keywordflow">catch</span> (<span class="keywordtype">int</span> x) {</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04177">4177</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a40b5af78266c07a51fc05b0340faa5f0" name="a40b5af78266c07a51fc05b0340faa5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b5af78266c07a51fc05b0340faa5f0">&#9670;&#160;</a></span>AST_MATCHER() <span class="overload">[29/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VarDecl.html">VarDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isStaticLocal</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a static variable with local scope. </p>
<p>Example matches y (matcher = <a class="el" href="#a056e81429237736b6458df18bb538c82" title="Matches variable declarations.">varDecl(isStaticLocal())</a>) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  <span class="keywordtype">int</span> x;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> y;</div>
<div class="line">}</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> z;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04081">4081</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a09c658c5f5005a9159e4a74960fa3e0f" name="a09c658c5f5005a9159e4a74960fa3e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c658c5f5005a9159e4a74960fa3e0f">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[1/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CallExpr.html">CallExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callee</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the call expression's callee expression matches. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y { <span class="keywordtype">void</span> x() { this-&gt;x(); x(); Y y; y.x(); } };</div>
<div class="line"><span class="keywordtype">void</span> f() { f(); }</div>
</div><!-- fragment --><p> callExpr(callee(expr())) matches this-&gt;x(), x(), y.x(), f() with callee(...) matching this-&gt;x, x, y.x, f respectively</p>
<p>Note: Callee cannot take the more general internal::Matcher&lt;Expr&gt; because this introduces ambiguous overloads with calls to Callee taking a internal::Matcher&lt;Decl&gt;, as the matcher hierarchy is purely implemented in terms of implicit casts. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03726">3726</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a7b30a702681d01ead785188e04457f92" name="a7b30a702681d01ead785188e04457f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b30a702681d01ead785188e04457f92">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[2/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasSpecializedTemplate</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1ClassTemplateDecl.html">ClassTemplateDecl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the specialized template of a specialization declaration. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>A {}; #1</div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class </span>A&lt;int&gt; {}; #2</div>
</div><!-- fragment --><p> classTemplateSpecializationDecl(hasSpecializedTemplate(classTemplateDecl())) matches '#2' with <a class="el" href="#afcdb6ae259330bdf0876aba6e07c8710" title="Matches C++ class template declarations.">classTemplateDecl()</a> matching the class template declaration of 'A' at #1. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00728">728</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a1706a42c87f0ca22a7ab5875eb6d074b" name="a1706a42c87f0ca22a7ab5875eb6d074b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1706a42c87f0ca22a7ab5875eb6d074b">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[3/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAnyConstructorInitializer</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a constructor initializer. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  Foo() : foo_(1) { }</div>
<div class="line">  <span class="keywordtype">int</span> foo_;</div>
<div class="line">};</div>
</div><!-- fragment --><p> cxxRecordDecl(has(cxxConstructorDecl( hasAnyConstructorInitializer(anything()) ))) record matches Foo, hasAnyConstructorInitializer matches foo_(1) </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04313">4313</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a9bdaa82b53209463877c44d74dab03d4" name="a9bdaa82b53209463877c44d74dab03d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdaa82b53209463877c44d74dab03d4">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[4/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">forField</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the field declaration of a constructor initializer. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  Foo() : foo_(1) { }</div>
<div class="line">  <span class="keywordtype">int</span> foo_;</div>
<div class="line">};</div>
</div><!-- fragment --><p> cxxRecordDecl(has(cxxConstructorDecl(hasAnyConstructorInitializer( forField(hasName("foo_")))))) matches Foo with forField matching foo_ </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04335">4335</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="abc97227bc2ea23c497ac5c88111fcab7" name="abc97227bc2ea23c497ac5c88111fcab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc97227bc2ea23c497ac5c88111fcab7">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[5/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">withInitializer</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the initializer expression of a constructor initializer. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  Foo() : foo_(1) { }</div>
<div class="line">  <span class="keywordtype">int</span> foo_;</div>
<div class="line">};</div>
</div><!-- fragment --><p> cxxRecordDecl(has(cxxConstructorDecl(hasAnyConstructorInitializer( withInitializer(<a class="el" href="#ad2109e16a4a151dc8f6416a66a750eac" title="Matches integer literals of all sizes / encodings, e.g.">integerLiteral(equals(1))</a>))))) matches Foo with withInitializer matching (1) </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04355">4355</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="ad4754fedaf69686660d1d67816e610cd" name="ad4754fedaf69686660d1d67816e610cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4754fedaf69686660d1d67816e610cd">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[6/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasMemberName</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template-dependent, but known, member names. </p>
<p>In template declarations, dependent members are not resolved and so can not be matched to particular named declarations.</p>
<p>This matcher allows to match on the known name of members.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">    <span class="keywordtype">void</span> mem();</div>
<div class="line">};</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> x() {</div>
<div class="line">    S&lt;T&gt; <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a>;</div>
<div class="line">    <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a>.mem();</div>
<div class="line">}</div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_aeec2d21816235dac201bf39185a3e86f"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a></div><div class="ttdeci">__device__ __2f16 float bool s</div><div class="ttdef"><b>Definition</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00303">__clang_hip_libdevice_declares.h:303</a></div></div>
</div><!-- fragment --><p> <code>cxxDependentScopeMemberExpr</code>(hasMemberName("mem")) matches <code>s.mem()</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02998">2998</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="BuildTree_8cpp_source.html#l01562">N</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a1671534b91901a477c76a181b97e4111" name="a1671534b91901a477c76a181b97e4111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1671534b91901a477c76a181b97e4111">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[7/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memberHasSameNameAsBoundNode</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BindingID</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template-dependent, but known, member names against an already-bound node. </p>
<p>In template declarations, dependent members are not resolved and so can not be matched to particular named declarations.</p>
<p>This matcher allows to match on the name of already-bound <a class="el" href="classclang_1_1VarDecl.html" title="Represents a variable declaration or definition.">VarDecl</a>, <a class="el" href="classclang_1_1FieldDecl.html" title="Represents a member of a struct/union/class.">FieldDecl</a> and <a class="el" href="classclang_1_1CXXMethodDecl.html" title="Represents a static or instance method of a struct/union/class.">CXXMethodDecl</a> nodes.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">    <span class="keywordtype">void</span> mem();</div>
<div class="line">};</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> x() {</div>
<div class="line">    S&lt;T&gt; <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a>;</div>
<div class="line">    <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a>.mem();</div>
<div class="line">}</div>
</div><!-- fragment --><p> The matcher </p><div class="fragment"><div class="line">\<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> <a class="code hl_variable" href="#a3285794ef7314a9b8ca5c18ed2744c13">cxxDependentScopeMemberExpr</a>(</div>
<div class="line">  hasObjectExpression(<a class="code hl_variable" href="#a0781cbe6d50bd620cb6f8f0627378be6">declRefExpr</a>(hasType(<a class="code hl_variable" href="#af35e48d050bc59b7a1cf9f428753e937">templateSpecializationType</a>(</div>
<div class="line">      <a class="code hl_function" href="#a4ff2c5e99cdf0bc13af1e639d9249df2">hasDeclaration</a>(<a class="code hl_variable" href="#afcdb6ae259330bdf0876aba6e07c8710">classTemplateDecl</a>(<a class="code hl_variable" href="#a9a14e1788aad32c318543405b5ec5962">has</a>(<a class="code hl_variable" href="#ac1ef73826e6b83dd0e8fc4a4b7284c74">cxxRecordDecl</a>(<a class="code hl_variable" href="#a9a14e1788aad32c318543405b5ec5962">has</a>(</div>
<div class="line">          <a class="code hl_variable" href="#aebe825b22b86295d319b09c996fe78fd">cxxMethodDecl</a>(<a class="code hl_function" href="#a4360554ed6340d60248b5d5930c44d49">hasName</a>(<span class="stringliteral">&quot;mem&quot;</span>)).bind(<span class="stringliteral">&quot;templMem&quot;</span>)</div>
<div class="line">          )))))</div>
<div class="line">      )))),</div>
<div class="line">  memberHasSameNameAsBoundNode(<span class="stringliteral">&quot;templMem&quot;</span>)</div>
<div class="line">  )</div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a0781cbe6d50bd620cb6f8f0627378be6"><div class="ttname"><a href="#a0781cbe6d50bd620cb6f8f0627378be6">clang::ast_matchers::declRefExpr</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, DeclRefExpr &gt; declRefExpr</div><div class="ttdoc">Matches expressions that refer to declarations.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00874">ASTMatchersInternal.cpp:874</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a3285794ef7314a9b8ca5c18ed2744c13"><div class="ttname"><a href="#a3285794ef7314a9b8ca5c18ed2744c13">clang::ast_matchers::cxxDependentScopeMemberExpr</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, CXXDependentScopeMemberExpr &gt; cxxDependentScopeMemberExpr</div><div class="ttdoc">Matches member expressions where the actual member referenced could not be resolved because the base ...</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00800">ASTMatchersInternal.cpp:800</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a4360554ed6340d60248b5d5930c44d49"><div class="ttname"><a href="#a4360554ed6340d60248b5d5930c44d49">clang::ast_matchers::hasName</a></div><div class="ttdeci">internal::Matcher&lt; NamedDecl &gt; hasName(StringRef Name)</div><div class="ttdoc">Matches NamedDecl nodes that have the specified name.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchers_8h_source.html#l02894">ASTMatchers.h:2894</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a4ff2c5e99cdf0bc13af1e639d9249df2"><div class="ttname"><a href="#a4ff2c5e99cdf0bc13af1e639d9249df2">clang::ast_matchers::hasDeclaration</a></div><div class="ttdeci">internal::PolymorphicMatcherWithParam1&lt; internal::HasDeclarationMatcher, internal::Matcher&lt; Decl &gt;, void(internal::HasDeclarationSupportedTypes)&gt; hasDeclaration(const internal::Matcher&lt; Decl &gt; &amp;InnerMatcher)</div><div class="ttdoc">Matches a node if the declaration associated with that node matches the given matcher.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchers_8h_source.html#l03466">ASTMatchers.h:3466</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a9a14e1788aad32c318543405b5ec5962"><div class="ttname"><a href="#a9a14e1788aad32c318543405b5ec5962">clang::ast_matchers::has</a></div><div class="ttdeci">const internal::ArgumentAdaptingMatcherFunc&lt; internal::HasMatcher &gt; has</div><div class="ttdoc">Matches AST nodes that have child AST nodes that match the provided matcher.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00983">ASTMatchersInternal.cpp:983</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ac1ef73826e6b83dd0e8fc4a4b7284c74"><div class="ttname"><a href="#ac1ef73826e6b83dd0e8fc4a4b7284c74">clang::ast_matchers::cxxRecordDecl</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Decl, CXXRecordDecl &gt; cxxRecordDecl</div><div class="ttdoc">Matches C++ class declarations.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00744">ASTMatchersInternal.cpp:744</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_aebe825b22b86295d319b09c996fe78fd"><div class="ttname"><a href="#aebe825b22b86295d319b09c996fe78fd">clang::ast_matchers::cxxMethodDecl</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Decl, CXXMethodDecl &gt; cxxMethodDecl</div><div class="ttdoc">Matches method declarations.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00783">ASTMatchersInternal.cpp:783</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_af35e48d050bc59b7a1cf9f428753e937"><div class="ttname"><a href="#af35e48d050bc59b7a1cf9f428753e937">clang::ast_matchers::templateSpecializationType</a></div><div class="ttdeci">const AstTypeMatcher&lt; TemplateSpecializationType &gt; templateSpecializationType</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l01031">ASTMatchersInternal.cpp:1031</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_afcdb6ae259330bdf0876aba6e07c8710"><div class="ttname"><a href="#afcdb6ae259330bdf0876aba6e07c8710">clang::ast_matchers::classTemplateDecl</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Decl, ClassTemplateDecl &gt; classTemplateDecl</div><div class="ttdoc">Matches C++ class template declarations.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00746">ASTMatchersInternal.cpp:746</a></div></div>
</div><!-- fragment --><p> first matches and binds the <code>mem</code> member of the <code>S</code> template, then compares its name to the usage in <code>s.mem()</code> in the <code>x</code> function template </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03036">3036</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00082">Nodes</a>.</p>

</div>
</div>
<a id="a13417ea6d85e2bff1cadbf9f0969ae1d" name="a13417ea6d85e2bff1cadbf9f0969ae1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13417ea6d85e2bff1cadbf9f0969ae1d">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[8/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasLoopVariable</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the initialization statement of a for loop. </p>
<p>Example: forStmt(hasLoopVariable(anything())) matches 'int x' in </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> x : a) { }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02104">2104</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="ad6716c3f117a63a7d60827379b4cc2a4" name="ad6716c3f117a63a7d60827379b4cc2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6716c3f117a63a7d60827379b4cc2a4">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[9/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasRangeInit</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the range initialization statement of a for loop. </p>
<p>Example: forStmt(hasRangeInit(anything())) matches 'a' in </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> x : a) { }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02118">2118</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a99fc9646b82282913629cad30181a3a0" name="a99fc9646b82282913629cad30181a3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fc9646b82282913629cad30181a3a0">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[10/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">on</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches on the implicit object argument of a member call expression, after stripping off any parentheses or implicit casts. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y { <span class="keyword">public</span>: <span class="keywordtype">void</span> m(); };</div>
<div class="line">Y g();</div>
<div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> : <span class="keyword">public</span> Y {};</div>
<div class="line"><span class="keywordtype">void</span> z(Y y, <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> x) { y.m(); (g()).m(); x.m(); }</div>
</div><!-- fragment --><p> cxxMemberCallExpr(on(hasType(cxxRecordDecl(hasName("Y"))))) matches <code>y.m()</code> and <code>(g()).m()</code>. cxxMemberCallExpr(on(hasType(cxxRecordDecl(hasName("X"))))) matches <code>x.m()</code>. cxxMemberCallExpr(on(callExpr())) matches <code>(g()).m()</code>.</p>
<p>FIXME: Overload to allow directly matching types? </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03509">3509</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a4d9312d37843a929bb3d5e3fc89f6582" name="a4d9312d37843a929bb3d5e3fc89f6582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9312d37843a929bb3d5e3fc89f6582">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[11/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">onImplicitObjectArgument</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches on the implicit object argument of a member call expression. </p>
<p>Unlike <code>on</code>, matches the argument directly without stripping away anything.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y { <span class="keyword">public</span>: <span class="keywordtype">void</span> m(); };</div>
<div class="line">Y g();</div>
<div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> : <span class="keyword">public</span> Y { <span class="keywordtype">void</span> g(); };</div>
<div class="line"><span class="keywordtype">void</span> z(Y y, <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> x) { y.m(); x.m(); x.g(); (g()).m(); }</div>
</div><!-- fragment --><p> cxxMemberCallExpr(onImplicitObjectArgument(hasType( cxxRecordDecl(hasName("Y"))))) matches <code>y.m()</code>, <code>x.m()</code> and (g()).m(), but not <code>x.g()</code>. cxxMemberCallExpr(on(callExpr())) does not match <code>(g()).m()</code>, because the parens are not ignored.</p>
<p>FIXME: Overload to allow directly matching types? </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03940">3940</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="af8d5ca0ebfe096ded3ced92d183b60a2" name="af8d5ca0ebfe096ded3ced92d183b60a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d5ca0ebfe096ded3ced92d183b60a2">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[12/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAnyBase</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseSpecMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ classes that have a direct or indirect base matching <code>BaseSpecMatcher</code>. </p>
<p>Example: matcher hasAnyBase(hasType(cxxRecordDecl(hasName("SpecialBase")))) </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo;</div>
<div class="line"><span class="keyword">class </span>Bar : Foo {};</div>
<div class="line"><span class="keyword">class </span>Baz : Bar {};</div>
<div class="line"><span class="keyword">class </span>SpecialBase;</div>
<div class="line"><span class="keyword">class </span>Proxy : SpecialBase {};  <span class="comment">// matches Proxy</span></div>
<div class="line"><span class="keyword">class </span>IndirectlyDerived : Proxy {};  <span class="comment">//matches IndirectlyDerived</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03128">3128</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00077">clang::ast_matchers::internal::matchesAnyBase()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a18a38d1fd2744bb4fa7264ce75e905ce" name="a18a38d1fd2744bb4fa7264ce75e905ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a38d1fd2744bb4fa7264ce75e905ce">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[13/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasDirectBase</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseSpecMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ classes that have a direct base matching <code>BaseSpecMatcher</code>. </p>
<p>Example: matcher hasDirectBase(hasType(cxxRecordDecl(hasName("SpecialBase")))) </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo;</div>
<div class="line"><span class="keyword">class </span>Bar : Foo {};</div>
<div class="line"><span class="keyword">class </span>Baz : Bar {};</div>
<div class="line"><span class="keyword">class </span>SpecialBase;</div>
<div class="line"><span class="keyword">class </span>Proxy : SpecialBase {};  <span class="comment">// matches Proxy</span></div>
<div class="line"><span class="keyword">class </span>IndirectlyDerived : Proxy {};  <span class="comment">// doesn&#39;t match</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03145">3145</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="ae58c11d6864fd939f7c9e2bad80dde51" name="ae58c11d6864fd939f7c9e2bad80dde51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58c11d6864fd939f7c9e2bad80dde51">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[14/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasMethod</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the first method of a class or struct that satisfies <code>InnerMatcher</code>. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keyword">class </span>A { <span class="keywordtype">void</span> func(); };</div>
<div class="line"><span class="keyword">class </span>B { <span class="keywordtype">void</span> member(); };</div>
</div><!-- fragment --><p><code>cxxRecordDecl</code>(hasMethod(hasName("func"))) matches the declaration of <code>A</code> but not <code>B</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03247">3247</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="a70221b7c61d02178a8b1bd7f4c051bf5" name="a70221b7c61d02178a8b1bd7f4c051bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70221b7c61d02178a8b1bd7f4c051bf5">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[15/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasTypeLoc</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Inner</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the type location of the declarator decl's type matches the inner matcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> x;</div>
</div><!-- fragment --><p> declaratorDecl(hasTypeLoc(loc(asString("int")))) matches int x </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03818">3818</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a75ec27f3345fc83828f6ad90a25a5ec6" name="a75ec27f3345fc83828f6ad90a25a5ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ec27f3345fc83828f6ad90a25a5ec6">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[16/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DeclRefExpr.html">DeclRefExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">throughUsingDecl</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1UsingShadowDecl.html">UsingShadowDecl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a <code><a class="el" href="classclang_1_1DeclRefExpr.html" title="A reference to a declared variable, function, enum, etc.">DeclRefExpr</a></code> that refers to a declaration through a specific using shadow declaration. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>a { <span class="keywordtype">void</span> f() {} }</div>
<div class="line"><span class="keyword">using </span>a::f;</div>
<div class="line"><span class="keywordtype">void</span> g() {</div>
<div class="line">  f();     <span class="comment">// Matches this ..</span></div>
<div class="line">  a::f();  <span class="comment">// .. but not this.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> declRefExpr(throughUsingDecl(anything())) matches <code>f()</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04008">4008</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a2ae2d3c41e0c472fa618cfa95c73f17e" name="a2ae2d3c41e0c472fa618cfa95c73f17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae2d3c41e0c472fa618cfa95c73f17e">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[17/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DeclRefExpr.html">DeclRefExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">to</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a <a class="el" href="classclang_1_1DeclRefExpr.html" title="A reference to a declared variable, function, enum, etc.">DeclRefExpr</a> that refers to a declaration that matches the specified matcher. </p>
<p>Example matches x in if(x) (matcher = declRefExpr(to(varDecl(hasName("x"))))) </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> x;</div>
<div class="line"><span class="keywordflow">if</span> (x) {}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03987">3987</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="aad3e9465ba62aea874dab861b34a2484" name="aad3e9465ba62aea874dab861b34a2484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3e9465ba62aea874dab861b34a2484">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[18/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DeclStmt.html">DeclStmt</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">declCountIs</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches declaration statements that contain a specific number of declarations. </p>
<p>Example: Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a, <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line"><span class="keywordtype">int</span> d = 2, e;</div>
</div><!-- fragment --><p> declCountIs(2) matches 'int a, b;' and 'int d = 2, e;', but not 'int c;'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04250">4250</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="BuildTree_8cpp_source.html#l01562">N</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a3490831f470cc4fa91a8e69e2b49cb92" name="a3490831f470cc4fa91a8e69e2b49cb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3490831f470cc4fa91a8e69e2b49cb92">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[19/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DeclStmt.html">DeclStmt</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasSingleDecl</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the <a class="el" href="classclang_1_1Decl.html" title="Decl - This represents one declaration (or definition), e.g.">Decl</a> of a <a class="el" href="classclang_1_1DeclStmt.html" title="DeclStmt - Adaptor class for mixing declarations with statements and expressions.">DeclStmt</a> which has a single declaration. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a, <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> declStmt(hasSingleDecl(anything())) matches 'int c;' but not 'int a, b;'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04047">4047</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a0f1b90fe605ed44735e799e76d0b4786" name="a0f1b90fe605ed44735e799e76d0b4786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1b90fe605ed44735e799e76d0b4786">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[20/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DesignatedInitExpr.html">DesignatedInitExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">designatorCountIs</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches designated initializer expressions that contain a specific number of designators. </p>
<p>Example: Given </p><div class="fragment"><div class="line">point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };</div>
<div class="line">point ptarray2[10] = { [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 };</div>
</div><!-- fragment --><p> designatorCountIs(2) matches '{ [2].y = 1.0, [0].x = 1.0 }', but not '{ [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 }'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02637">2637</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="BuildTree_8cpp_source.html#l01562">N</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a1d68be4dc7543bd7e54dfe60c7e77b30" name="a1d68be4dc7543bd7e54dfe60c7e77b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d68be4dc7543bd7e54dfe60c7e77b30">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[21/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignoringImpCasts</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions that match InnerMatcher after any implicit casts are stripped off. </p>
<p>Parentheses and explicit casts are not discarded. Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> arr[5];</div>
<div class="line"><span class="keywordtype">int</span> a = 0;</div>
<div class="line"><span class="keywordtype">char</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = 0;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> = a;</div>
<div class="line"><span class="keywordtype">int</span> *d = arr;</div>
<div class="line"><span class="keywordtype">long</span> e = (long) 0l;</div>
</div><!-- fragment --><p> The matchers </p><div class="fragment"><div class="line"><a class="code hl_variable" href="#a056e81429237736b6458df18bb538c82">varDecl</a>(hasInitializer(ignoringImpCasts(<a class="code hl_variable" href="#ad2109e16a4a151dc8f6416a66a750eac">integerLiteral</a>())))</div>
<div class="line"><a class="code hl_variable" href="#a056e81429237736b6458df18bb538c82">varDecl</a>(hasInitializer(ignoringImpCasts(<a class="code hl_variable" href="#a0781cbe6d50bd620cb6f8f0627378be6">declRefExpr</a>())))</div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ad2109e16a4a151dc8f6416a66a750eac"><div class="ttname"><a href="#ad2109e16a4a151dc8f6416a66a750eac">clang::ast_matchers::integerLiteral</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, IntegerLiteral &gt; integerLiteral</div><div class="ttdoc">Matches integer literals of all sizes / encodings, e.g.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00905">ASTMatchersInternal.cpp:905</a></div></div>
</div><!-- fragment --><p> would match the declarations for a, b, c, and d, but not e. While </p><div class="fragment"><div class="line"><a class="code hl_variable" href="#a056e81429237736b6458df18bb538c82">varDecl</a>(hasInitializer(<a class="code hl_variable" href="#ad2109e16a4a151dc8f6416a66a750eac">integerLiteral</a>()))</div>
<div class="line"><a class="code hl_variable" href="#a056e81429237736b6458df18bb538c82">varDecl</a>(hasInitializer(<a class="code hl_variable" href="#a0781cbe6d50bd620cb6f8f0627378be6">declRefExpr</a>()))</div>
</div><!-- fragment --><p> only match the declarations for b, c, and d. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00907">907</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a92fc5ba0e3c7670df1211d78a0e8cd3b" name="a92fc5ba0e3c7670df1211d78a0e8cd3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92fc5ba0e3c7670df1211d78a0e8cd3b">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[22/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignoringImplicit</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions that match InnerMatcher after any implicit AST nodes are stripped off. </p>
<p>Parentheses and explicit casts are not discarded. Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {};</div>
<div class="line"><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> a = <a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a>();</div>
<div class="line"><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line"><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> = <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
</div><!-- fragment --><p> The matchers </p><div class="fragment"><div class="line"><a class="code hl_variable" href="#a056e81429237736b6458df18bb538c82">varDecl</a>(hasInitializer(ignoringImplicit(<a class="code hl_variable" href="#ab0da198b76c77bfd4737a339d5a78e33">cxxConstructExpr</a>())))</div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ab0da198b76c77bfd4737a339d5a78e33"><div class="ttname"><a href="#ab0da198b76c77bfd4737a339d5a78e33">clang::ast_matchers::cxxConstructExpr</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, CXXConstructExpr &gt; cxxConstructExpr</div><div class="ttdoc">Matches constructor call expressions (including implicit ones).</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00853">ASTMatchersInternal.cpp:853</a></div></div>
</div><!-- fragment --><p> would match the declarations for a, b, and c. While </p><div class="fragment"><div class="line"><a class="code hl_variable" href="#a056e81429237736b6458df18bb538c82">varDecl</a>(hasInitializer(<a class="code hl_variable" href="#ab0da198b76c77bfd4737a339d5a78e33">cxxConstructExpr</a>()))</div>
</div><!-- fragment --><p> only match the declarations for b and c. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00877">877</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a975436793549e3bf233afa633b959539" name="a975436793549e3bf233afa633b959539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975436793549e3bf233afa633b959539">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[23/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignoringParenCasts</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions that match InnerMatcher after parentheses and casts are stripped off. </p>
<p>Implicit and non-C Style casts are also discarded. Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a = 0;</div>
<div class="line"><span class="keywordtype">char</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = (0);</div>
<div class="line"><span class="keywordtype">void</span>* <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(0);</div>
<div class="line"><span class="keywordtype">char</span> d = char(0);</div>
</div><!-- fragment --><p> The matcher varDecl(hasInitializer(ignoringParenCasts(integerLiteral()))) would match the declarations for a, b, c, and d. while varDecl(hasInitializer(integerLiteral())) only match the declaration for a. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00929">929</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a5c810b620cfe58f641cb695035984063" name="a5c810b620cfe58f641cb695035984063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c810b620cfe58f641cb695035984063">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[24/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignoringParenImpCasts</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions that match InnerMatcher after implicit casts and parentheses are stripped off. </p>
<p>Explicit casts are not discarded. Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> arr[5];</div>
<div class="line"><span class="keywordtype">int</span> a = 0;</div>
<div class="line"><span class="keywordtype">char</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = (0);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> = a;</div>
<div class="line"><span class="keywordtype">int</span> *d = (arr);</div>
<div class="line"><span class="keywordtype">long</span> e = ((long) 0l);</div>
</div><!-- fragment --><p> The matchers varDecl(hasInitializer(ignoringParenImpCasts(integerLiteral()))) varDecl(hasInitializer(ignoringParenImpCasts(declRefExpr()))) would match the declarations for a, b, c, and d, but not e. while varDecl(hasInitializer(integerLiteral())) varDecl(hasInitializer(declRefExpr())) would only match the declaration for a. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00954">954</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a3e2e74bf00f236ab96f16fc7d3495f78" name="a3e2e74bf00f236ab96f16fc7d3495f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2e74bf00f236ab96f16fc7d3495f78">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[25/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasBitWidth</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Width</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches non-static data members that are bit-fields of the specified bit width. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {</div>
<div class="line">  <span class="keywordtype">int</span> a : 2;</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> : 4;</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> : 2;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <a class="el" href="#ab26f3ff62d6be975196efa86f3b15d82" title="Matches field declarations.">fieldDecl(hasBitWidth(2))</a> matches 'int a;' and 'int c;' but not 'int b;'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00686">686</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a041bd134ecb46dcb809880b2588a1c19" name="a041bd134ecb46dcb809880b2588a1c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041bd134ecb46dcb809880b2588a1c19">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[26/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasInClassInitializer</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches non-static data members that have an in-class initializer. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {</div>
<div class="line">  <span class="keywordtype">int</span> a = 2;</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = 3;</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> fieldDecl(hasInClassInitializer(<a class="el" href="#ad2109e16a4a151dc8f6416a66a750eac" title="Matches integer literals of all sizes / encodings, e.g.">integerLiteral(equals(2))</a>)) matches 'int a;' but not 'int b;'. fieldDecl(hasInClassInitializer(anything())) matches 'int a;' and 'int b;' but not 'int c;'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00705">705</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a8cde5fea3e993010e91c2ede956271e1ae807e61ca16dbec95fce00d4e542b9cd">clang::Initializer</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a290e141c4140d565458b4eebab9fe706" name="a290e141c4140d565458b4eebab9fe706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290e141c4140d565458b4eebab9fe706">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[27/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ForStmt.html">ForStmt</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasIncrement</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the increment statement of a for loop. </p>
<p>Example: forStmt(hasIncrement(unaryOperator(hasOperatorName("++")))) matches '++x' in </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (x; x &lt; <a class="code hl_variable" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a>; ++x) { }</div>
<div class="ttc" id="aBuildTree_8cpp_html_ab409187cd8023f701425d74753612d6b"><div class="ttname"><a href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a></div><div class="ttdeci">auto * N</div><div class="ttdef"><b>Definition</b> <a href="BuildTree_8cpp_source.html#l01562">BuildTree.cpp:1562</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02065">2065</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="ac25f93cc605e37bd0bb85673eb580a1e" name="ac25f93cc605e37bd0bb85673eb580a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25f93cc605e37bd0bb85673eb580a1e">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[28/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ForStmt.html">ForStmt</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasLoopInit</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the initialization statement of a for loop. </p>
<p>Example: forStmt(hasLoopInit(declStmt())) matches 'int x = 0' in </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; <a class="code hl_variable" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a>; ++x) { }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02080">2080</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a246e4f4313edb67d25bdd6fb935746b4" name="a246e4f4313edb67d25bdd6fb935746b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246e4f4313edb67d25bdd6fb935746b4">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[29/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1InitListExpr.html">InitListExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasSyntacticForm</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the syntactic form of init list expressions (if expression have it). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01669">1669</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="af541323ee4a7cfcaa6032acb78ac3a86" name="af541323ee4a7cfcaa6032acb78ac3a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af541323ee4a7cfcaa6032acb78ac3a86">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[30/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasUnderlyingDecl</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a <code><a class="el" href="classclang_1_1NamedDecl.html" title="This represents a decl that may have a name.">NamedDecl</a></code> whose underlying declaration matches the given matcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_variable" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a> { <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> f(T t); }</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> g() { <span class="keyword">using </span>N::f; f(T()); }</div>
</div><!-- fragment --><p> <code>unresolvedLookupExpr</code>(hasAnyDeclaration( namedDecl(hasUnderlyingDecl(hasName("::N::f"))))) matches the use of <code>f</code> in <code>g()</code> . </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03483">3483</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="ac1ca863c3bc2d2bc5af99d90933d6e9c" name="ac1ca863c3bc2d2bc5af99d90933d6e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ca863c3bc2d2bc5af99d90933d6e9c">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[31/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAnySelectorMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matches</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00045">45</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="aa81978c4da301b92d8b05c2f29c73d86" name="aa81978c4da301b92d8b05c2f29c73d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81978c4da301b92d8b05c2f29c73d86">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[32/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasReceiver</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the Objective-C message is sent to an instance, and the inner matcher matches on that instance. </p>
<p>For example the method call in </p><div class="fragment"><div class="line">NSString *x = <span class="stringliteral">@&quot;hello&quot;</span>;</div>
<div class="line">[x containsString:<span class="stringliteral">@&quot;h&quot;</span>];</div>
</div><!-- fragment --><p> is matched by objcMessageExpr(hasReceiver(declRefExpr(to(varDecl(hasName("x")))))) </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03610">3610</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="Expr_8cpp_source.html#l02775">clang::Expr::IgnoreParenImpCasts()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a2eadcbb53864d57ff194cfb633fc783e" name="a2eadcbb53864d57ff194cfb633fc783e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eadcbb53864d57ff194cfb633fc783e">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[33/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasReceiverType</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches on the receiver of an ObjectiveC Message expression. </p>
<p>Example matcher = objCMessageExpr(hasReceiverType(asString("UIWebView *"))); matches the [webView ...] message invocation. </p><div class="fragment"><div class="line">NSString *webViewJavaScript = ...</div>
<div class="line">UIWebView *webView = ...</div>
<div class="line">[webView stringByEvaluatingJavaScriptFromString:webViewJavascript];</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03528">3528</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="ae7c4492e391c4ebab66249547cbda68c" name="ae7c4492e391c4ebab66249547cbda68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c4492e391c4ebab66249547cbda68c">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[34/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasSelector</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseName</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches when BaseName == <a class="el" href="classclang_1_1Selector.html#a4fc5593940af968fa1187c3cb6a8ef8b" title="Derive the full selector name (e.g.">Selector.getAsString()</a> </p>
<p>matcher = objCMessageExpr(hasSelector("loadHTMLString:baseURL:")); matches the outer message expr in the code below, but NOT the message invocation for self.bodyView. </p><div class="fragment"><div class="line">[self.bodyView loadHTMLString:html baseURL:<a class="code hl_define" href="opencl-c-base_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>];</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03626">3626</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="IdentifierTable_8cpp_source.html#l00478">clang::Selector::getAsString()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a73b6b13e9f4c74054e742f1222a70a8c" name="a73b6b13e9f4c74054e742f1222a70a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b6b13e9f4c74054e742f1222a70a8c">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[35/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">numSelectorArgs</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches when the selector has the specified number of arguments. </p>
<p>matcher = objCMessageExpr(numSelectorArgs(0)); matches self.bodyView in the code below</p>
<p>matcher = objCMessageExpr(numSelectorArgs(2)); matches the invocation of "loadHTMLString:baseURL:" but not that of self.bodyView </p><div class="fragment"><div class="line">[self.bodyView loadHTMLString:html baseURL:<a class="code hl_define" href="opencl-c-base_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>];</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03706">3706</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="BuildTree_8cpp_source.html#l01562">N</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="aaa5713ebcfebb04bcfd89e6098999e65" name="aaa5713ebcfebb04bcfd89e6098999e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5713ebcfebb04bcfd89e6098999e65">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[36/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isAllowedToContainClauseKind</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#af4e75364acc81a070837a4344d437322">OpenMPClauseKind</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CKind</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>/ Matches each case or default statement belonging to the given switch / statement. </p>
<p>This matcher may produce multiple matches. / / Given / </p><div class="fragment"><div class="line"><span class="comment">///   switch (1) { case 1: case 2: default: switch (2) { case 3: case 4: ; } }</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> / switchStmt(forEachSwitchCase(<a class="el" href="#a5725bf80823feea320c27f79c712e8f6" title="Matches case statements inside switch statements.">caseStmt()</a>.bind("c"))).bind("s") / matches four times, with "c" binding each of "case 1:", "case 2:", / "case 3:" and "case 4:", and "s" respectively binding "switch (1)", / "switch (1)", "switch (2)" and "switch (2)". <a class="el" href="ASTMatchersMacros_8h.html#ae9c7f3955d5fdd516853af78dea0ac9c" title="AST_MATCHER_P(Type, DefineMatcher, ParamType, Param) { ... } defines a single-parameter function name...">AST_MATCHER_P(SwitchStmt, forEachSwitchCase, internal::Matcher&lt;SwitchCase&gt;,
              InnerMatcher)</a> { BoundNodesTreeBuilder Result; FIXME: getSwitchCaseList() does not necessarily guarantee a stable iteration order. We should use the more general iterating matchers once they are capable of expressing this matcher (for example, it should ignore case statements belonging to nested switch statements). bool Matched = false; for (const <a class="el" href="classclang_1_1SwitchCase.html">SwitchCase</a> *SC = Node.getSwitchCaseList(); SC; SC = SC-&gt;getNextSwitchCase()) { BoundNodesTreeBuilder CaseBuilder(*Builder); bool CaseMatched = InnerMatcher.matches(*SC, Finder, &amp;CaseBuilder); if (CaseMatched) { Matched = true; Result.addMatch(CaseBuilder); } } Builder = std::move(Result); return Matched; }</p>
<p>/ Matches each constructor initializer in a constructor definition. / / Given / </p><div class="fragment"><div class="line"><span class="comment">///   class A { A() : i(42), j(42) {} int i; int j; };</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> / cxxConstructorDecl(forEachConstructorInitializer( / forField(<a class="el" href="#ac5ccadfbea5e9e43c2153175afca6cac" title="Matches declarations.">decl()</a>.bind("x")) / )) / will trigger two matches, binding for 'i' and 'j' respectively. <a class="el" href="ASTMatchersMacros_8h.html#ae9c7f3955d5fdd516853af78dea0ac9c" title="AST_MATCHER_P(Type, DefineMatcher, ParamType, Param) { ... } defines a single-parameter function name...">AST_MATCHER_P(CXXConstructorDecl, forEachConstructorInitializer,
              internal::Matcher&lt;CXXCtorInitializer&gt;, InnerMatcher)</a> { BoundNodesTreeBuilder Result; bool Matched = false; for (const auto *I : Node.inits()) { if (Finder-&gt;isTraversalIgnoringImplicitNodes() &amp;&amp; !I-&gt;isWritten()) continue; BoundNodesTreeBuilder InitBuilder(*Builder); if (InnerMatcher.matches(*I, Finder, &amp;InitBuilder)) { Matched = true; Result.addMatch(InitBuilder); } } Builder = std::move(Result); return Matched; }</p>
<p>/ Matches constructor declarations that are copy constructors. / / Given / </p><div class="fragment"><div class="line"><span class="comment">///   struct S {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     S(); // #1</span></div>
<div class="line"><span class="comment">///     S(const S &amp;); // #2</span></div>
<div class="line"><span class="comment">///     S(S &amp;&amp;); // #3</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / <a class="el" href="#a832104640e9b865d3d10cb779f59dbee" title="Matches C++ constructor declarations.">cxxConstructorDecl(isCopyConstructor())</a> will match #2, but not #1 or #3. <a class="el" href="ASTMatchersMacros_8h.html#a9d99c6e46e700f1c85f6cc078038c2ed" title="AST_MATCHER(Type, DefineMatcher) { ... } defines a zero parameter function named DefineMatcher() that...">AST_MATCHER(CXXConstructorDecl, isCopyConstructor)</a> { return Node.isCopyConstructor(); }</p>
<p>/ Matches constructor declarations that are move constructors. / / Given / </p><div class="fragment"><div class="line"><span class="comment">///   struct S {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     S(); // #1</span></div>
<div class="line"><span class="comment">///     S(const S &amp;); // #2</span></div>
<div class="line"><span class="comment">///     S(S &amp;&amp;); // #3</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / <a class="el" href="#a832104640e9b865d3d10cb779f59dbee" title="Matches C++ constructor declarations.">cxxConstructorDecl(isMoveConstructor())</a> will match #3, but not #1 or #2. <a class="el" href="ASTMatchersMacros_8h.html#a9d99c6e46e700f1c85f6cc078038c2ed" title="AST_MATCHER(Type, DefineMatcher) { ... } defines a zero parameter function named DefineMatcher() that...">AST_MATCHER(CXXConstructorDecl, isMoveConstructor)</a> { return Node.isMoveConstructor(); }</p>
<p>/ Matches constructor declarations that are default constructors. / / Given / </p><div class="fragment"><div class="line"><span class="comment">///   struct S {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     S(); // #1</span></div>
<div class="line"><span class="comment">///     S(const S &amp;); // #2</span></div>
<div class="line"><span class="comment">///     S(S &amp;&amp;); // #3</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / <a class="el" href="#a832104640e9b865d3d10cb779f59dbee" title="Matches C++ constructor declarations.">cxxConstructorDecl(isDefaultConstructor())</a> will match #1, but not #2 or #3. <a class="el" href="ASTMatchersMacros_8h.html#a9d99c6e46e700f1c85f6cc078038c2ed" title="AST_MATCHER(Type, DefineMatcher) { ... } defines a zero parameter function named DefineMatcher() that...">AST_MATCHER(CXXConstructorDecl, isDefaultConstructor)</a> { return Node.isDefaultConstructor(); }</p>
<p>/ Matches constructors that delegate to another constructor. / / Given / </p><div class="fragment"><div class="line"><span class="comment">///   struct S {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     S(); // #1</span></div>
<div class="line"><span class="comment">///     S(int) {} // #2</span></div>
<div class="line"><span class="comment">///     S(S &amp;&amp;) : S() {} // #3</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///   S::S() : S(0) {} // #4</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / <a class="el" href="#a832104640e9b865d3d10cb779f59dbee" title="Matches C++ constructor declarations.">cxxConstructorDecl(isDelegatingConstructor())</a> will match #3 and #4, but not / #1 or #2. <a class="el" href="ASTMatchersMacros_8h.html#a9d99c6e46e700f1c85f6cc078038c2ed" title="AST_MATCHER(Type, DefineMatcher) { ... } defines a zero parameter function named DefineMatcher() that...">AST_MATCHER(CXXConstructorDecl, isDelegatingConstructor)</a> { return Node.isDelegatingConstructor(); }</p>
<p>/ Matches constructor, conversion function, and deduction guide declarations / that have an explicit specifier if this explicit specifier is resolved to / true. / / Given / </p><div class="fragment"><div class="line"><span class="comment">///   template&lt;bool b&gt;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   struct S {</span></div>
<div class="line"><span class="comment">///     S(int); // #1</span></div>
<div class="line"><span class="comment">///     explicit S(double); // #2</span></div>
<div class="line"><span class="comment">///     operator int(); // #3</span></div>
<div class="line"><span class="comment">///     explicit operator bool(); // #4</span></div>
<div class="line"><span class="comment">///     explicit(false) S(bool) // # 7</span></div>
<div class="line"><span class="comment">///     explicit(true) S(char) // # 8</span></div>
<div class="line"><span class="comment">///     explicit(b) S(S) // # 9</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///   S(int) -&gt; S&lt;true&gt; // #5</span></div>
<div class="line"><span class="comment">///   explicit S(double) -&gt; S&lt;false&gt; // #6</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / <a class="el" href="#a832104640e9b865d3d10cb779f59dbee" title="Matches C++ constructor declarations.">cxxConstructorDecl(isExplicit())</a> will match #2 and #8, but not #1, #7 or #9. / <a class="el" href="#a67d2f76b0d40efafcb16d997b1928f5b" title="Matches conversion operator declarations.">cxxConversionDecl(isExplicit())</a> will match #4, but not #3. / <a class="el" href="#a400a7d8c9a439cb1c43dfa8ed4f6d5d7" title="Matches user-defined and implicitly generated deduction guide.">cxxDeductionGuideDecl(isExplicit())</a> will match #6, but not #5. <a class="el" href="ASTMatchersMacros_8h.html#a3d1b3ed734779c26fb7e25a6b262898e" title="AST_POLYMORPHIC_MATCHER(DefineMatcher) { ... } defines a single-parameter function named DefineMatche...">AST_POLYMORPHIC_MATCHER(isExplicit, AST_POLYMORPHIC_SUPPORTED_TYPES(
                                        CXXConstructorDecl, CXXConversionDecl,
                                        CXXDeductionGuideDecl))</a> { return Node.isExplicit(); }</p>
<p>/ Matches the expression in an explicit specifier if present in the given / declaration. / / Given / </p><div class="fragment"><div class="line"><span class="comment">///   template&lt;bool b&gt;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   struct S {</span></div>
<div class="line"><span class="comment">///     S(int); // #1</span></div>
<div class="line"><span class="comment">///     explicit S(double); // #2</span></div>
<div class="line"><span class="comment">///     operator int(); // #3</span></div>
<div class="line"><span class="comment">///     explicit operator bool(); // #4</span></div>
<div class="line"><span class="comment">///     explicit(false) S(bool) // # 7</span></div>
<div class="line"><span class="comment">///     explicit(true) S(char) // # 8</span></div>
<div class="line"><span class="comment">///     explicit(b) S(S) // # 9</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///   S(int) -&gt; S&lt;true&gt; // #5</span></div>
<div class="line"><span class="comment">///   explicit S(double) -&gt; S&lt;false&gt; // #6</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / cxxConstructorDecl(hasExplicitSpecifier(constantExpr())) will match #7, #8 and #9, but not #1 or #2. / cxxConversionDecl(hasExplicitSpecifier(constantExpr())) will not match #3 or #4. / cxxDeductionGuideDecl(hasExplicitSpecifier(constantExpr())) will not match #5 or #6. <a class="el" href="ASTMatchersMacros_8h.html#ae9c7f3955d5fdd516853af78dea0ac9c" title="AST_MATCHER_P(Type, DefineMatcher, ParamType, Param) { ... } defines a single-parameter function name...">AST_MATCHER_P(FunctionDecl, hasExplicitSpecifier, internal::Matcher&lt;Expr&gt;,
              InnerMatcher)</a> { <a class="el" href="classclang_1_1ExplicitSpecifier.html" title="Store information needed for an explicit specifier.">ExplicitSpecifier</a> ES = ExplicitSpecifier::getFromDecl(&amp;Node); if (!ES.getExpr()) return false;</p>
<p>ASTChildrenNotSpelledInSourceScope RAII(Finder, false);</p>
<p>return InnerMatcher.matches(*ES.getExpr(), Finder, Builder); }</p>
<p>/ Matches function and namespace declarations that are marked with / the inline keyword. / / Given / </p><div class="fragment"><div class="line"><span class="comment">///   inline void f();</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   void g();</span></div>
<div class="line"><span class="comment">///   namespace n {</span></div>
<div class="line"><span class="comment">///   inline namespace m {}</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / <a class="el" href="#ab95624c30888b0c7688e3a6171ed49cc" title="Matches function declarations.">functionDecl(isInline())</a> will match ::f(). / <a class="el" href="#ad499907435f5547a1f44215dd65c00a2" title="Matches a declaration of a namespace.">namespaceDecl(isInline())</a> will match n::m. <a class="el" href="ASTMatchersMacros_8h.html#a3d1b3ed734779c26fb7e25a6b262898e" title="AST_POLYMORPHIC_MATCHER(DefineMatcher) { ... } defines a single-parameter function named DefineMatche...">AST_POLYMORPHIC_MATCHER(isInline,
                        AST_POLYMORPHIC_SUPPORTED_TYPES(NamespaceDecl,
                                                        FunctionDecl))</a> { This is required because the spelling of the function used to determine whether inline is specified or not differs between the polymorphic types. if (const auto *FD = dyn_cast&lt;FunctionDecl&gt;(&amp;Node)) return FD-&gt;isInlineSpecified(); else if (const auto *NSD = dyn_cast&lt;NamespaceDecl&gt;(&amp;Node)) return NSD-&gt;isInline(); llvm_unreachable("Not a valid polymorphic type"); }</p>
<p>/ Matches anonymous namespace declarations. / / Given / </p><div class="fragment"><div class="line"><span class="comment">///   namespace n {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   namespace {} // #1</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / <a class="el" href="#ad499907435f5547a1f44215dd65c00a2" title="Matches a declaration of a namespace.">namespaceDecl(isAnonymous())</a> will match #1 but not ::n. <a class="el" href="ASTMatchersMacros_8h.html#a9d99c6e46e700f1c85f6cc078038c2ed" title="AST_MATCHER(Type, DefineMatcher) { ... } defines a zero parameter function named DefineMatcher() that...">AST_MATCHER(NamespaceDecl, isAnonymous)</a> { return Node.isAnonymousNamespace(); }</p>
<p>/ Matches declarations in the namespace <code>std</code>, but not in nested namespaces. / / Given / </p><div class="fragment"><div class="line"><span class="comment">///   class vector {};</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   namespace foo {</span></div>
<div class="line"><span class="comment">///     class vector {};</span></div>
<div class="line"><span class="comment">///     namespace std {</span></div>
<div class="line"><span class="comment">///       class vector {};</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///   namespace std {</span></div>
<div class="line"><span class="comment">///     inline namespace __1 {</span></div>
<div class="line"><span class="comment">///       class vector {}; // #1</span></div>
<div class="line"><span class="comment">///       namespace experimental {</span></div>
<div class="line"><span class="comment">///         class vector {};</span></div>
<div class="line"><span class="comment">///       }</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / cxxRecordDecl(hasName("vector"), isInStdNamespace()) will match only #1. <a class="el" href="ASTMatchersMacros_8h.html#a9d99c6e46e700f1c85f6cc078038c2ed" title="AST_MATCHER(Type, DefineMatcher) { ... } defines a zero parameter function named DefineMatcher() that...">AST_MATCHER(Decl, isInStdNamespace)</a> { return Node.isInStdNamespace(); }</p>
<p>/ If the given case statement does not use the GNU case range / extension, matches the constant given in the statement. / / Given / </p><div class="fragment"><div class="line"><span class="comment">///   switch (1) { case 1: case 1+1: case 3 ... 4: ; }</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> / caseStmt(hasCaseConstant(integerLiteral())) / matches "case 1:" <a class="el" href="ASTMatchersMacros_8h.html#ae9c7f3955d5fdd516853af78dea0ac9c" title="AST_MATCHER_P(Type, DefineMatcher, ParamType, Param) { ... } defines a single-parameter function name...">AST_MATCHER_P(CaseStmt, hasCaseConstant, internal::Matcher&lt;Expr&gt;,
              InnerMatcher)</a> { if (Node.getRHS()) return false;</p>
<p>return InnerMatcher.matches(*Node.getLHS(), Finder, Builder); }</p>
<p>/ Matches declaration that has a given attribute. / / Given / </p><div class="fragment"><div class="line"><span class="comment">///   __attribute__((device)) void f() { ... }</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> / <a class="el" href="#ac5ccadfbea5e9e43c2153175afca6cac" title="Matches declarations.">decl(hasAttr(clang::attr::CUDADevice))</a> matches the function declaration of / f. If the matcher is used from clang-query, <a class="el" href="namespaceclang_1_1attr.html#ac160b7b7240633e6932ebb177d0f03ef">attr::Kind</a> parameter should be / passed as a quoted string. e.g., hasAttr("attr::CUDADevice"). <a class="el" href="ASTMatchersMacros_8h.html#ae9c7f3955d5fdd516853af78dea0ac9c" title="AST_MATCHER_P(Type, DefineMatcher, ParamType, Param) { ... } defines a single-parameter function name...">AST_MATCHER_P(Decl, hasAttr, attr::Kind, AttrKind)</a> { for (const auto *Attr : Node.attrs()) { if (Attr-&gt;<a class="el" href="DeclBase_8cpp.html#a37d13911f1772d0ed90b6b2e89cf3c60">getKind()</a> == AttrKind) return true; } return false; }</p>
<p>/ Matches the return value expression of a return statement / / Given / </p><div class="fragment"><div class="line"><span class="comment">///   return a + b;</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> / hasReturnValue(binaryOperator()) / matches 'return a + b' / with <a class="el" href="#a92d236ec1064f604664b1e9123249e01" title="Matches binary operator expressions.">binaryOperator()</a> / matching 'a + b' <a class="el" href="ASTMatchersMacros_8h.html#ae9c7f3955d5fdd516853af78dea0ac9c" title="AST_MATCHER_P(Type, DefineMatcher, ParamType, Param) { ... } defines a single-parameter function name...">AST_MATCHER_P(ReturnStmt, hasReturnValue, internal::Matcher&lt;Expr&gt;,
              InnerMatcher)</a> { if (const auto *RetValue = Node.getRetValue()) return InnerMatcher.matches(*RetValue, Finder, Builder); return false; }</p>
<p>/ Matches CUDA kernel call expression. / / Example matches, / </p><div class="fragment"><div class="line"><span class="comment">///   kernel&lt;&lt;&lt;i,j&gt;&gt;&gt;();</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt, CUDAKernelCallExpr&gt; cudaKernelCallExpr;</p>
<p>/ Matches expressions that resolve to a null pointer constant, such as / GNU's __null, C++11's nullptr, or C's NULL macro. / / Given: / </p><div class="fragment"><div class="line"><span class="comment">///   void *v1 = NULL;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   void *v2 = nullptr;</span></div>
<div class="line"><span class="comment">///   void *v3 = __null; // GNU extension</span></div>
<div class="line"><span class="comment">///   char *cp = (char *)0;</span></div>
<div class="line"><span class="comment">///   int *ip = 0;</span></div>
<div class="line"><span class="comment">///   int i = 0;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / <a class="el" href="#adfc0ccd398780d345e2c541cc716cc66" title="Matches expressions.">expr(nullPointerConstant())</a> / matches the initializer for v1, v2, v3, cp, and ip. Does not match the / initializer for i. <a class="el" href="ASTMatchersMacros_8h.html#a9d99c6e46e700f1c85f6cc078038c2ed" title="AST_MATCHER(Type, DefineMatcher) { ... } defines a zero parameter function named DefineMatcher() that...">AST_MATCHER(Expr, nullPointerConstant)</a> { return Node.isNullPointerConstant(Finder-&gt;getASTContext(), <a class="el" href="classclang_1_1Expr.html#a8542d93f28013fb0866693834b04ff67a06279741aa9bc21d0a6d5be7aa7f06e7" title="Specifies that a value-dependent expression of integral or dependent type should be considered a null...">Expr::NPC_ValueDependentIsNull</a>); }</p>
<p>/ Matches declaration of the function the statement belongs to / / Given: / </p><div class="fragment"><div class="line"><span class="comment">/// F&amp; operator=(const F&amp; o) {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   std::copy_if(o.begin(), o.end(), begin(), [](V v) { return v &gt; 0; });</span></div>
<div class="line"><span class="comment">///   return *this;</span></div>
<div class="line"><span class="comment">/// }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / returnStmt(forFunction(hasName("operator="))) / matches 'return *this' / but does not match 'return v &gt; 0' <a class="el" href="ASTMatchersMacros_8h.html#ae9c7f3955d5fdd516853af78dea0ac9c" title="AST_MATCHER_P(Type, DefineMatcher, ParamType, Param) { ... } defines a single-parameter function name...">AST_MATCHER_P(Stmt, forFunction, internal::Matcher&lt;FunctionDecl&gt;,
              InnerMatcher)</a> { const auto &amp;Parents = Finder-&gt;getASTContext().getParents(Node);</p>
<p>llvm::SmallVector&lt;DynTypedNode, 8&gt; Stack(Parents.begin(), Parents.end()); while(!Stack.empty()) { const auto &amp;CurNode = Stack.back(); Stack.pop_back(); if(const auto *FuncDeclNode = CurNode.get&lt;FunctionDecl&gt;()) { if(InnerMatcher.matches(*FuncDeclNode, Finder, Builder)) { return true; } } else if(const auto *LambdaExprNode = CurNode.get&lt;LambdaExpr&gt;()) { if(InnerMatcher.matches(*LambdaExprNode-&gt;getCallOperator(), Finder, Builder)) { return true; } } else { for(const auto &amp;Parent: Finder-&gt;getASTContext().getParents(CurNode)) Stack.push_back(Parent); } } return false; }</p>
<p>/ Matches a declaration that has external formal linkage. / / Example matches only z (matcher = <a class="el" href="#a056e81429237736b6458df18bb538c82" title="Matches variable declarations.">varDecl(hasExternalFormalLinkage())</a>) / </p><div class="fragment"><div class="line"><span class="comment">/// void f() {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   int x;</span></div>
<div class="line"><span class="comment">///   static int y;</span></div>
<div class="line"><span class="comment">/// }</span></div>
<div class="line"><span class="comment">/// int z;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / Example matches f() because it has external formal linkage despite being / unique to the translation unit as though it has internal likage / (matcher = <a class="el" href="#ab95624c30888b0c7688e3a6171ed49cc" title="Matches function declarations.">functionDecl(hasExternalFormalLinkage())</a>) / / </p><div class="fragment"><div class="line"><span class="comment">/// namespace {</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// void f() {}</span></div>
<div class="line"><span class="comment">/// }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> <a class="el" href="ASTMatchersMacros_8h.html#a9d99c6e46e700f1c85f6cc078038c2ed" title="AST_MATCHER(Type, DefineMatcher) { ... } defines a zero parameter function named DefineMatcher() that...">AST_MATCHER(NamedDecl, hasExternalFormalLinkage)</a> { return Node.hasExternalFormalLinkage(); }</p>
<p>/ Matches a declaration that has default arguments. / / Example matches y (matcher = <a class="el" href="#a3b7539a5a5ad3112f453ffb3ab9a67c5" title="Matches parameter variable declarations.">parmVarDecl(hasDefaultArgument())</a>) / </p><div class="fragment"><div class="line"><span class="comment">/// void x(int val) {}</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// void y(int val = 0) {}</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / Deprecated. Use hasInitializer() instead to be able to / match on the contents of the default argument. For example: / / </p><div class="fragment"><div class="line"><span class="comment">/// void x(int val = 7) {}</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// void y(int val = 42) {}</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / parmVarDecl(hasInitializer(<a class="el" href="#ad2109e16a4a151dc8f6416a66a750eac" title="Matches integer literals of all sizes / encodings, e.g.">integerLiteral(equals(42))</a>)) / matches the parameter of y / / A matcher such as / parmVarDecl(hasInitializer(anything())) / is equivalent to <a class="el" href="#a3b7539a5a5ad3112f453ffb3ab9a67c5" title="Matches parameter variable declarations.">parmVarDecl(hasDefaultArgument())</a>. <a class="el" href="ASTMatchersMacros_8h.html#a9d99c6e46e700f1c85f6cc078038c2ed" title="AST_MATCHER(Type, DefineMatcher) { ... } defines a zero parameter function named DefineMatcher() that...">AST_MATCHER(ParmVarDecl, hasDefaultArgument)</a> { return Node.hasDefaultArg(); }</p>
<p>/ Matches array new expressions. / / Given: / </p><div class="fragment"><div class="line"><span class="comment">///   MyClass *p1 = new MyClass[10];</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> / <a class="el" href="#a8c90fa40e809e57f174ef162b26bb7d9" title="Matches new expressions.">cxxNewExpr(isArray())</a> / matches the expression 'new MyClass[10]'. <a class="el" href="ASTMatchersMacros_8h.html#a9d99c6e46e700f1c85f6cc078038c2ed" title="AST_MATCHER(Type, DefineMatcher) { ... } defines a zero parameter function named DefineMatcher() that...">AST_MATCHER(CXXNewExpr, isArray)</a> { return Node.isArray(); }</p>
<p>/ Matches placement new expression arguments. / / Given: / </p><div class="fragment"><div class="line"><span class="comment">///   MyClass *p1 = new (Storage, 16) MyClass();</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> / cxxNewExpr(hasPlacementArg(1, <a class="el" href="#ad2109e16a4a151dc8f6416a66a750eac" title="Matches integer literals of all sizes / encodings, e.g.">integerLiteral(equals(16))</a>)) / matches the expression 'new (Storage, 16) MyClass()'. <a class="el" href="ASTMatchersMacros_8h.html#aa3d710416d27639ec98bd011a41a5f06" title="AST_MATCHER_P2(    Type, DefineMatcher, ParamType1, Param1, ParamType2, Param2) { ....">AST_MATCHER_P2(CXXNewExpr, hasPlacementArg, unsigned, Index,
               internal::Matcher&lt;Expr&gt;, InnerMatcher)</a> { return Node.getNumPlacementArgs() &gt; Index &amp;&amp; InnerMatcher.matches(*Node.getPlacementArg(Index), Finder, Builder); }</p>
<p>/ Matches any placement new expression arguments. / / Given: / </p><div class="fragment"><div class="line"><span class="comment">///   MyClass *p1 = new (Storage) MyClass();</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> / cxxNewExpr(hasAnyPlacementArg(anything())) / matches the expression 'new (Storage, 16) MyClass()'. <a class="el" href="ASTMatchersMacros_8h.html#ae9c7f3955d5fdd516853af78dea0ac9c" title="AST_MATCHER_P(Type, DefineMatcher, ParamType, Param) { ... } defines a single-parameter function name...">AST_MATCHER_P(CXXNewExpr, hasAnyPlacementArg, internal::Matcher&lt;Expr&gt;,
              InnerMatcher)</a> { return llvm::any_of(Node.placement_arguments(), [&amp;](const <a class="el" href="classclang_1_1Expr.html" title="This represents one expression.">Expr</a> *Arg) { return InnerMatcher.matches(*Arg, Finder, Builder); }); }</p>
<p>/ Matches array new expressions with a given array size. / / Given: / </p><div class="fragment"><div class="line"><span class="comment">///   MyClass *p1 = new MyClass[10];</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> / cxxNewExpr(hasArraySize(<a class="el" href="#ad2109e16a4a151dc8f6416a66a750eac" title="Matches integer literals of all sizes / encodings, e.g.">integerLiteral(equals(10))</a>)) / matches the expression 'new MyClass[10]'. <a class="el" href="ASTMatchersMacros_8h.html#ae9c7f3955d5fdd516853af78dea0ac9c" title="AST_MATCHER_P(Type, DefineMatcher, ParamType, Param) { ... } defines a single-parameter function name...">AST_MATCHER_P(CXXNewExpr, hasArraySize, internal::Matcher&lt;Expr&gt;, InnerMatcher)</a> { return Node.isArray() &amp;&amp; *Node.getArraySize() &amp;&amp; InnerMatcher.matches(**Node.getArraySize(), Finder, Builder); }</p>
<p>/ Matches a class declaration that is defined. / / Example matches x (matcher = <a class="el" href="#ac1ef73826e6b83dd0e8fc4a4b7284c74" title="Matches C++ class declarations.">cxxRecordDecl(hasDefinition())</a>) / </p><div class="fragment"><div class="line"><span class="comment">/// class x {};</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// class y;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> <a class="el" href="ASTMatchersMacros_8h.html#a9d99c6e46e700f1c85f6cc078038c2ed" title="AST_MATCHER(Type, DefineMatcher) { ... } defines a zero parameter function named DefineMatcher() that...">AST_MATCHER(CXXRecordDecl, hasDefinition)</a> { return Node.hasDefinition(); }</p>
<p>/ Matches C++11 scoped enum declaration. / / Example matches Y (matcher = <a class="el" href="#a31e48dc9e0067b916df8f57d3d3bb72a" title="Matches enum declarations.">enumDecl(isScoped())</a>) / </p><div class="fragment"><div class="line"><span class="comment">/// enum X {};</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// enum class Y {};</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> <a class="el" href="ASTMatchersMacros_8h.html#a9d99c6e46e700f1c85f6cc078038c2ed" title="AST_MATCHER(Type, DefineMatcher) { ... } defines a zero parameter function named DefineMatcher() that...">AST_MATCHER(EnumDecl, isScoped)</a> { return Node.isScoped(); }</p>
<p>/ Matches a function declared with a trailing return type. / / Example matches Y (matcher = <a class="el" href="#ab95624c30888b0c7688e3a6171ed49cc" title="Matches function declarations.">functionDecl(hasTrailingReturn())</a>) / </p><div class="fragment"><div class="line"><span class="comment">/// int X() {}</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// auto Y() -&gt; int {}</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> <a class="el" href="ASTMatchersMacros_8h.html#a9d99c6e46e700f1c85f6cc078038c2ed" title="AST_MATCHER(Type, DefineMatcher) { ... } defines a zero parameter function named DefineMatcher() that...">AST_MATCHER(FunctionDecl, hasTrailingReturn)</a> { if (const auto *F = Node.getType()-&gt;getAs&lt;FunctionProtoType&gt;()) return F-&gt;hasTrailingReturn(); return false; }</p>
<p>/ Matches expressions that match InnerMatcher that are possibly wrapped in an / elidable constructor and other corresponding bookkeeping nodes. / / In C++17, elidable copy constructors are no longer being generated in the / AST as it is not permitted by the standard. They are, however, part of the / AST in C++14 and earlier. So, a matcher must abstract over these differences / to work in all language modes. This matcher skips elidable constructor-call / AST nodes, <code><a class="el" href="classclang_1_1ExprWithCleanups.html" title="Represents an expression – generally a full-expression – that introduces cleanups to be run at the en...">ExprWithCleanups</a></code> nodes wrapping elidable constructor-calls and / various implicit nodes inside the constructor calls, all of which will not / appear in the C++17 AST. / / Given / / </p><div class="fragment"><div class="line"><span class="comment">/// struct H {};</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// H G();</span></div>
<div class="line"><span class="comment">/// void f() {</span></div>
<div class="line"><span class="comment">///   H D = G();</span></div>
<div class="line"><span class="comment">/// }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / <code>varDecl(hasInitializer(ignoringElidableConstructorCall(callExpr())))</code> / matches <code>H D = G()</code> in C++11 through C++17 (and beyond). <a class="el" href="ASTMatchersMacros_8h.html#ae9c7f3955d5fdd516853af78dea0ac9c" title="AST_MATCHER_P(Type, DefineMatcher, ParamType, Param) { ... } defines a single-parameter function name...">AST_MATCHER_P(Expr, ignoringElidableConstructorCall,
              ast_matchers::internal::Matcher&lt;Expr&gt;, InnerMatcher)</a> { E tracks the node that we are examining. const <a class="el" href="classclang_1_1Expr.html" title="This represents one expression.">Expr</a> *E = &amp;Node; If present, remove an outer <code><a class="el" href="classclang_1_1ExprWithCleanups.html" title="Represents an expression – generally a full-expression – that introduces cleanups to be run at the en...">ExprWithCleanups</a></code> corresponding to the underlying <code><a class="el" href="classclang_1_1CXXConstructExpr.html" title="Represents a call to a C++ constructor.">CXXConstructExpr</a></code>. This check won't cover all cases of added <code><a class="el" href="classclang_1_1ExprWithCleanups.html" title="Represents an expression – generally a full-expression – that introduces cleanups to be run at the en...">ExprWithCleanups</a></code> corresponding to <code><a class="el" href="classclang_1_1CXXConstructExpr.html" title="Represents a call to a C++ constructor.">CXXConstructExpr</a></code> nodes (because the EWC is placed on the outermost node of the expression, which this may not be), but, it still improves the coverage of this matcher. if (const auto *CleanupsExpr = dyn_cast&lt;ExprWithCleanups&gt;(&amp;Node)) E = CleanupsExpr-&gt;getSubExpr(); if (const auto *CtorExpr = dyn_cast&lt;CXXConstructExpr&gt;(E)) { if (CtorExpr-&gt;isElidable()) { if (const auto *MaterializeTemp = dyn_cast&lt;MaterializeTemporaryExpr&gt;(CtorExpr-&gt;getArg(0))) { return InnerMatcher.matches(*MaterializeTemp-&gt;getSubExpr(), Finder, Builder); } } } return InnerMatcher.matches(Node, Finder, Builder); }</p>
<p>-------------------------------------------------------------------------&mdash;// OpenMP handling. -------------------------------------------------------------------------&mdash;//</p>
<p>/ Matches any <code>#pragma omp</code> executable directive. / / Given / / </p><div class="fragment"><div class="line"><span class="comment">///   #pragma omp parallel</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   #pragma omp parallel default(none)</span></div>
<div class="line"><span class="comment">///   #pragma omp taskyield</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / <code><a class="el" href="#aa46c78f9e0d25b95959055d0265dedd8">ompExecutableDirective()</a></code> matches <code>omp parallel</code>, / <code>omp parallel default(none)</code> and <code>omp taskyield</code>. extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt, OMPExecutableDirective&gt; ompExecutableDirective;</p>
<p>/ Matches standalone OpenMP directives, / i.e., directives that can't have a structured block. / / Given / / </p><div class="fragment"><div class="line"><span class="comment">///   #pragma omp parallel</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   {}</span></div>
<div class="line"><span class="comment">///   #pragma omp taskyield</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / <code><a class="el" href="#aa46c78f9e0d25b95959055d0265dedd8">ompExecutableDirective(isStandaloneDirective())</a>)</code> matches / <code>omp taskyield</code>. <a class="el" href="ASTMatchersMacros_8h.html#a9d99c6e46e700f1c85f6cc078038c2ed" title="AST_MATCHER(Type, DefineMatcher) { ... } defines a zero parameter function named DefineMatcher() that...">AST_MATCHER(OMPExecutableDirective, isStandaloneDirective)</a> { return Node.isStandaloneDirective(); }</p>
<p>/ Matches the structured-block of the OpenMP executable directive / / Prerequisite: the executable directive must not be standalone directive. / If it is, it will never match. / / Given / / </p><div class="fragment"><div class="line"><span class="comment">///    #pragma omp parallel</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    ;</span></div>
<div class="line"><span class="comment">///    #pragma omp parallel</span></div>
<div class="line"><span class="comment">///    {}</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / <code>ompExecutableDirective(hasStructuredBlock(nullStmt()))</code> will match <code>;</code> <a class="el" href="ASTMatchersMacros_8h.html#ae9c7f3955d5fdd516853af78dea0ac9c" title="AST_MATCHER_P(Type, DefineMatcher, ParamType, Param) { ... } defines a single-parameter function name...">AST_MATCHER_P(OMPExecutableDirective, hasStructuredBlock,
              internal::Matcher&lt;Stmt&gt;, InnerMatcher)</a> { if (Node.isStandaloneDirective()) return false; // Standalone directives have no structured blocks. return InnerMatcher.matches(*Node.getStructuredBlock(), Finder, Builder); }</p>
<p>/ Matches any clause in an OpenMP directive. / / Given / / </p><div class="fragment"><div class="line"><span class="comment">///   #pragma omp parallel</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   #pragma omp parallel default(none)</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / <code>ompExecutableDirective(hasAnyClause(anything()))</code> matches / <code>omp parallel default(none)</code>. <a class="el" href="ASTMatchersMacros_8h.html#ae9c7f3955d5fdd516853af78dea0ac9c" title="AST_MATCHER_P(Type, DefineMatcher, ParamType, Param) { ... } defines a single-parameter function name...">AST_MATCHER_P(OMPExecutableDirective, hasAnyClause,
              internal::Matcher&lt;OMPClause&gt;, InnerMatcher)</a> { ArrayRef&lt;OMPClause *&gt; Clauses = Node.clauses(); return matchesFirstInPointerRange(InnerMatcher, Clauses.begin(), Clauses.end(), Finder, Builder) != Clauses.end(); }</p>
<p>/ Matches OpenMP <code>default</code> clause. / / Given / / </p><div class="fragment"><div class="line"><span class="comment">///   #pragma omp parallel default(none)</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   #pragma omp parallel default(shared)</span></div>
<div class="line"><span class="comment">///   #pragma omp parallel default(firstprivate)</span></div>
<div class="line"><span class="comment">///   #pragma omp parallel</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / <code><a class="el" href="#a381bce396b06bba5e9bd658b76caa2cd">ompDefaultClause()</a></code> matches <code>default(none)</code>, <code>default(shared)</code>, and / <code>default(firstprivate)</code> extern const internal::VariadicDynCastAllOfMatcher&lt;OMPClause, OMPDefaultClause&gt; ompDefaultClause;</p>
<p>/ Matches if the OpenMP <code>default</code> clause has <code>none</code> kind specified. / / Given / / </p><div class="fragment"><div class="line"><span class="comment">///   #pragma omp parallel</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   #pragma omp parallel default(none)</span></div>
<div class="line"><span class="comment">///   #pragma omp parallel default(shared)</span></div>
<div class="line"><span class="comment">///   #pragma omp parallel default(firstprivate)</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / <code><a class="el" href="#a381bce396b06bba5e9bd658b76caa2cd">ompDefaultClause(isNoneKind())</a></code> matches only <code>default(none)</code>. <a class="el" href="ASTMatchersMacros_8h.html#a9d99c6e46e700f1c85f6cc078038c2ed" title="AST_MATCHER(Type, DefineMatcher) { ... } defines a zero parameter function named DefineMatcher() that...">AST_MATCHER(OMPDefaultClause, isNoneKind)</a> { return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_none; }</p>
<p>/ Matches if the OpenMP <code>default</code> clause has <code>shared</code> kind specified. / / Given / / </p><div class="fragment"><div class="line"><span class="comment">///   #pragma omp parallel</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   #pragma omp parallel default(none)</span></div>
<div class="line"><span class="comment">///   #pragma omp parallel default(shared)</span></div>
<div class="line"><span class="comment">///   #pragma omp parallel default(firstprivate)</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / <code><a class="el" href="#a381bce396b06bba5e9bd658b76caa2cd">ompDefaultClause(isSharedKind())</a></code> matches only <code>default(shared)</code>. <a class="el" href="ASTMatchersMacros_8h.html#a9d99c6e46e700f1c85f6cc078038c2ed" title="AST_MATCHER(Type, DefineMatcher) { ... } defines a zero parameter function named DefineMatcher() that...">AST_MATCHER(OMPDefaultClause, isSharedKind)</a> { return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_shared; }</p>
<p>/ Matches if the OpenMP <code>default</code> clause has <code>firstprivate</code> kind / specified. / / Given / / </p><div class="fragment"><div class="line"><span class="comment">///   #pragma omp parallel</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   #pragma omp parallel default(none)</span></div>
<div class="line"><span class="comment">///   #pragma omp parallel default(shared)</span></div>
<div class="line"><span class="comment">///   #pragma omp parallel default(firstprivate)</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / <code><a class="el" href="#a381bce396b06bba5e9bd658b76caa2cd">ompDefaultClause(isFirstPrivateKind())</a></code> matches only / <code>default(firstprivate)</code>. <a class="el" href="ASTMatchersMacros_8h.html#a9d99c6e46e700f1c85f6cc078038c2ed" title="AST_MATCHER(Type, DefineMatcher) { ... } defines a zero parameter function named DefineMatcher() that...">AST_MATCHER(OMPDefaultClause, isFirstPrivateKind)</a> { return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_firstprivate; }</p>
<p>/ Matches if the OpenMP directive is allowed to contain the specified OpenMP / clause kind. / / Given / / </p><div class="fragment"><div class="line"><span class="comment">///   #pragma omp parallel</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   #pragma omp parallel for</span></div>
<div class="line"><span class="comment">///   #pragma omp          for</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / <code><a class="el" href="#aa46c78f9e0d25b95959055d0265dedd8">ompExecutableDirective(isAllowedToContainClause(OMPC_default))</a></code><code>matches /</code><code>omp parallel</code><code>and</code><code>omp parallel for</code><code>. / / If the matcher is use from clang-query,</code><code>OpenMPClauseKind</code><code>parameter / should be passed as a quoted string. e.g., /</code><code>isAllowedToContainClauseKind("OMPC_default").</code>` </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07727">7727</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a19ee00dadd390e9911cdc64d2f0f0aa0" name="a19ee00dadd390e9911cdc64d2f0f0aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ee00dadd390e9911cdc64d2f0f0aa0">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[37/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1OverloadExpr.html">OverloadExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAnyDeclaration</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches an <code><a class="el" href="classclang_1_1OverloadExpr.html" title="A reference to an overloaded function set, either an UnresolvedLookupExpr or an UnresolvedMemberExpr.">OverloadExpr</a></code> if any of the declarations in the set of overloads matches the given matcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> foo(T);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> bar(T);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> baz(T t) {</div>
<div class="line">  foo(t);</div>
<div class="line">  bar(t);</div>
<div class="line">}</div>
</div><!-- fragment --><p> unresolvedLookupExpr(hasAnyDeclaration( functionTemplateDecl(hasName("foo")))) matches <code>foo</code> in <code>foo(t)</code>; but not <code>bar</code> in <code>bar(t)</code>; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04031">4031</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a8d441fb8797a726cc8f58469ea017523" name="a8d441fb8797a726cc8f58469ea017523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d441fb8797a726cc8f58469ea017523">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[38/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asString</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Name</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the matched type is represented by the given string. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y { <span class="keyword">public</span>: <span class="keywordtype">void</span> x(); };</div>
<div class="line"><span class="keywordtype">void</span> z() { Y* y; y-&gt;x(); }</div>
</div><!-- fragment --><p> cxxMemberCallExpr(on(hasType(asString("class Y *")))) matches y-&gt;x() </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03834">3834</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="aa0898cce8002e6e0db4a3e13b5e9d7ff" name="aa0898cce8002e6e0db4a3e13b5e9d7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0898cce8002e6e0db4a3e13b5e9d7ff">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[39/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasCanonicalType</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches QualTypes whose canonical type matches InnerMatcher. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> &amp;int_ref;</div>
<div class="line"><span class="keywordtype">int</span> a;</div>
<div class="line">int_ref <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = a;</div>
</div><!-- fragment --><p><code>varDecl</code>(hasType(<a class="el" href="#aefc28b8bf75f10413691d11b9c371116" title="Matches QualTypes in the clang AST.">qualType(referenceType())</a>)))) will not match the declaration of b but <code>varDecl</code>(hasType(qualType(hasCanonicalType(referenceType())))))) does. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03909">3909</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a34619df672712c3c1b89e9556ea6fb5e" name="a34619df672712c3c1b89e9556ea6fb5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34619df672712c3c1b89e9556ea6fb5e">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[40/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pointsTo</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the matched type is a pointer type and the pointee type matches the specified matcher. </p>
<p>Example matches y-&gt;x() (matcher = cxxMemberCallExpr(on(hasType(pointsTo cxxRecordDecl(hasName("Y"))))))) </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y { <span class="keyword">public</span>: <span class="keywordtype">void</span> x(); };</div>
<div class="line"><span class="keywordtype">void</span> z() { Y *y; y-&gt;x(); }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03848">3848</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a326c00e2c764f18193b0e2ba5050199a" name="a326c00e2c764f18193b0e2ba5050199a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326c00e2c764f18193b0e2ba5050199a">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[41/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">references</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the matched type is a reference type and the referenced type matches the specified matcher. </p>
<p>Example matches X &amp;x and const X &amp;y (matcher = varDecl(hasType(references(cxxRecordDecl(hasName("X")))))) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {</div>
<div class="line">  <span class="keywordtype">void</span> a(<a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) {</div>
<div class="line">    <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> &amp;x = <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> &amp;y = <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03891">3891</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a7a50116e967de8dce02523cc01150f4d" name="a7a50116e967de8dce02523cc01150f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a50116e967de8dce02523cc01150f4d">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[42/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">equalsIntegralValue</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> of integral type with a given value. </p>
<p>Note that 'Value' is a string as the template argument's value is an arbitrary precision integer. 'Value' must be euqal to the canonical representation of that integral value in base 10.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> T&gt; <span class="keyword">struct </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {};</div>
<div class="line"><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C&lt;42&gt;</a> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> classTemplateSpecializationDecl( hasAnyTemplateArgument(equalsIntegralValue("42"))) matches the implicit instantiation of C in C&lt;42&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01202">1202</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="TemplateBase_8h_source.html#l00083">clang::TemplateArgument::Integral</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a0f8b99a0a4e189acdcdaf259c2290f3d" name="a0f8b99a0a4e189acdcdaf259c2290f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8b99a0a4e189acdcdaf259c2290f3d">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[43/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isExpr</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a sugar <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to a certain expression. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>B { <span class="keywordtype">int</span> next; };</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span>(B::*next_ptr)&gt; <span class="keyword">struct </span>A {};</div>
<div class="line">A&lt;&amp;B::next&gt; a;</div>
</div><!-- fragment --><p> templateSpecializationType(hasAnyTemplateArgument( isExpr(hasDescendant(declRefExpr(to(fieldDecl(hasName("next")))))))) matches the specialization <code>A&lt;&amp;B::next&gt;</code> with <code><a class="el" href="#ab26f3ff62d6be975196efa86f3b15d82" title="Matches field declarations.">fieldDecl(...)</a></code> matching <code>B::next</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01150">1150</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="TemplateBase_8h_source.html#l00097">clang::TemplateArgument::Expression</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a0d66a056fa6763e89a41550a4468db2f" name="a0d66a056fa6763e89a41550a4468db2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d66a056fa6763e89a41550a4468db2f">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[44/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">refersToDeclaration</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a canonical <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to a certain declaration. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>B { <span class="keywordtype">int</span> next; };</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span>(B::*next_ptr)&gt; <span class="keyword">struct </span>A {};</div>
<div class="line">A&lt;&amp;B::next&gt; a;</div>
</div><!-- fragment --><p> classTemplateSpecializationDecl(hasAnyTemplateArgument( refersToDeclaration(fieldDecl(hasName("next"))))) matches the specialization <code>A&lt;&amp;B::next&gt;</code> with <code><a class="el" href="#ab26f3ff62d6be975196efa86f3b15d82" title="Matches field declarations.">fieldDecl(...)</a></code> matching <code>B::next</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01131">1131</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="TemplateBase_8h_source.html#l00075">clang::TemplateArgument::Declaration</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a911620ba71c61c54fcf02cd42d828e56" name="a911620ba71c61c54fcf02cd42d828e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911620ba71c61c54fcf02cd42d828e56">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[45/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">refersToIntegralType</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to an integral type. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> T&gt; <span class="keyword">struct </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {};</div>
<div class="line"><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C&lt;42&gt;</a> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> classTemplateSpecializationDecl( hasAnyTemplateArgument(refersToIntegralType(asString("int")))) matches the implicit instantiation of C in C&lt;42&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01181">1181</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="TemplateBase_8h_source.html#l00083">clang::TemplateArgument::Integral</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a78151d2a32277bb385119910e537d58a" name="a78151d2a32277bb385119910e537d58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78151d2a32277bb385119910e537d58a">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[46/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">refersToTemplate</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1TemplateName.html">TemplateName</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to a certain template. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>S&gt; <span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {};</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>Y {};</div>
<div class="line"><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X&lt;Y&gt;</a> xi;</div>
</div><!-- fragment --><p> classTemplateSpecializationDecl(hasAnyTemplateArgument( refersToTemplate(templateName()))) matches the specialization <code>X&lt;Y&gt;</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01111">1111</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>, and <a class="el" href="TemplateBase_8h_source.html#l00087">clang::TemplateArgument::Template</a>.</p>

</div>
</div>
<a id="af189946951ce7f935861b3943634e6d4" name="af189946951ce7f935861b3943634e6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af189946951ce7f935861b3943634e6d4">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[47/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">refersToType</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to a certain type. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {};</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>A {};</div>
<div class="line">A&lt;X&gt; a;</div>
</div><!-- fragment --><p> classTemplateSpecializationDecl(hasAnyTemplateArgument( refersToType(class(hasName("X"))))) matches the specialization <code>A&lt;X&gt;</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01093">1093</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>, and <a class="el" href="TemplateBase_8h_source.html#l00071">clang::TemplateArgument::Type</a>.</p>

</div>
</div>
<a id="a6ce9ed079b63bde07a29f118be67d998" name="a6ce9ed079b63bde07a29f118be67d998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce9ed079b63bde07a29f118be67d998">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[48/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasUnqualifiedDesugaredType</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Type.html">Type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the matched type matches the unqualified desugared type of the matched node. </p>
<p>For example, in: </p><div class="fragment"><div class="line"><span class="keyword">class </span>A {};</div>
<div class="line"><span class="keyword">using </span>B = A;</div>
</div><!-- fragment --><p> The matcher type(hasUnqualifiedDesugaredType(recordType())) matches both B and A. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03872">3872</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="afda923705023b2e6030c83ffe359a5b1" name="afda923705023b2e6030c83ffe359a5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda923705023b2e6030c83ffe359a5b1">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[49/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasArgumentOfType</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches unary expressions that have a specific type of argument. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a, <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>; <span class="keywordtype">float</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>; <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a> = <span class="keyword">sizeof</span>(a) + <span class="keyword">sizeof</span>(<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) + <span class="keyword">alignof</span>(<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>);</div>
</div><!-- fragment --><p> unaryExprOrTypeTraitExpr(hasArgumentOfType(asString("int")) matches <code>sizeof(a)</code> and <code><a class="el" href="stdalign_8h.html#abb241e4f00c28465643e1010172aef04">alignof(c)</a></code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02840">2840</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a364b968cdd1a5dd039ef4002d426e62c" name="a364b968cdd1a5dd039ef4002d426e62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364b968cdd1a5dd039ef4002d426e62c">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[50/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ofKind</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#a5d73f06594a5ccb763a726bed94a541f">UnaryExprOrTypeTrait</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kind</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches unary expressions of a certain kind. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> x;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a> = <span class="keyword">sizeof</span>(x) + <span class="keyword">alignof</span>(x)</div>
</div><!-- fragment --><p> <a class="el" href="#a4e6f1fbd69a5f3bd0b1f7c81f30ba547" title="Matches sizeof (C99), alignof (C++11) and vec_step (OpenCL)">unaryExprOrTypeTraitExpr(ofKind(UETT_SizeOf))</a> matches <code>sizeof(x)</code> </p>
<p>If the matcher is use from clang-query, UnaryExprOrTypeTrait parameter should be passed as a quoted string. e.g., ofKind("UETT_SizeOf"). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02858">2858</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="af17df7f136021603cccaee853f067429" name="af17df7f136021603cccaee853f067429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17df7f136021603cccaee853f067429">&#9670;&#160;</a></span>AST_MATCHER_P() <span class="overload">[51/51]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VarDecl.html">VarDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasInitializer</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a variable declaration that has an initializer expression that matches the given matcher. </p>
<p>Example matches x (matcher = varDecl(hasInitializer(callExpr()))) </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> y() { <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line"><span class="keywordtype">bool</span> x = y();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04063">4063</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a8cde5fea3e993010e91c2ede956271e1ae807e61ca16dbec95fce00d4e542b9cd">clang::Initializer</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a436242d922937081d26821317552407e" name="a436242d922937081d26821317552407e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436242d922937081d26821317552407e">&#9670;&#160;</a></span>AST_MATCHER_P2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DeclStmt.html">DeclStmt</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">containsDeclaration</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the n'th declaration of a declaration statement. </p>
<p>Note that this does not work for global declarations because the AST breaks up multiple-declaration <a class="el" href="classclang_1_1DeclStmt.html" title="DeclStmt - Adaptor class for mixing declarations with statements and expressions.">DeclStmt</a>'s into multiple single-declaration <a class="el" href="classclang_1_1DeclStmt.html" title="DeclStmt - Adaptor class for mixing declarations with statements and expressions.">DeclStmt</a>'s. Example: Given non-global declarations </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a, <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = 0;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line"><span class="keywordtype">int</span> d = 2, e;</div>
</div><!-- fragment --><p> declStmt(containsDeclaration( 0, varDecl(hasInitializer(anything())))) matches only 'int d = 2, e;', and declStmt(containsDeclaration(1, varDecl())) </p><div class="fragment"><div class="line">matches <span class="stringliteral">&#39;int a, b = 0&#39;</span> as well as <span class="stringliteral">&#39;int d = 2, e;&#39;</span></div>
<div class="line">but <span class="stringliteral">&#39;int c;&#39;</span> <a class="code hl_function" href="FormatToken_8h.html#af4ab7d556047786b30ddf2bd58a55e57">is</a> <a class="code hl_define" href="iso646_8h.html#a31739c27bdcfdac9faae7bf7a5df49e4">not</a> matched.</div>
<div class="ttc" id="aFormatToken_8h_html_af4ab7d556047786b30ddf2bd58a55e57"><div class="ttname"><a href="FormatToken_8h.html#af4ab7d556047786b30ddf2bd58a55e57">is</a></div><div class="ttdeci">bool is(tok::TokenKind Kind) const</div><div class="ttdef"><b>Definition</b> <a href="FormatToken_8h_source.html#l00865">FormatToken.h:865</a></div></div>
<div class="ttc" id="aiso646_8h_html_a31739c27bdcfdac9faae7bf7a5df49e4"><div class="ttname"><a href="iso646_8h.html#a31739c27bdcfdac9faae7bf7a5df49e4">not</a></div><div class="ttdeci">#define not</div><div class="ttdef"><b>Definition</b> <a href="iso646_8h_source.html#l00019">iso646.h:19</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04273">4273</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="BuildTree_8cpp_source.html#l01562">N</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a0a44f1320d0ad1ade3dc82fc4730f17f" name="a0a44f1320d0ad1ade3dc82fc4730f17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a44f1320d0ad1ade3dc82fc4730f17f">&#9670;&#160;</a></span>AST_MATCHER_P2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1InitListExpr.html">InitListExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasInit</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ast_matchers::internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the n'th item of an initializer list expression. </p>
<p>Example matches y. (matcher = initListExpr(hasInit(0, expr()))) </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> x{y}.</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04233">4233</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="BuildTree_8cpp_source.html#l01562">N</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a20927991ed40f5b7fc29095fa96e9c36" name="a20927991ed40f5b7fc29095fa96e9c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20927991ed40f5b7fc29095fa96e9c36">&#9670;&#160;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CallExpr.html">CallExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callee</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the call expression's callee's declaration matches the given matcher. </p>
<p>Example matches y.x() (matcher = callExpr(callee( cxxMethodDecl(hasName("x"))))) </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y { <span class="keyword">public</span>: <span class="keywordtype">void</span> x(); };</div>
<div class="line"><span class="keywordtype">void</span> z() { Y y; y.x(); }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03742">3742</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00801">callExpr</a>, <a class="el" href="ASTMatchers_8h_source.html#l03466">hasDeclaration()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a8932ce498cc406f28f22149d1936c4b1" name="a8932ce498cc406f28f22149d1936c4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8932ce498cc406f28f22149d1936c4b1">&#9670;&#160;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thisPointerType</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded to match the type's declaration. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03971">3971</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00964">anyOf</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a86ef01849f0ca8c3b8b5222a4b8e0522" name="a86ef01849f0ca8c3b8b5222a4b8e0522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ef01849f0ca8c3b8b5222a4b8e0522">&#9670;&#160;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thisPointerType</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the type of the expression's implicit object argument either matches the InnerMatcher, or is a pointer to a type that matches the InnerMatcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y { <span class="keyword">public</span>: <span class="keywordtype">void</span> m(); };</div>
<div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> : <span class="keyword">public</span> Y { <span class="keywordtype">void</span> g(); };</div>
<div class="line"><span class="keywordtype">void</span> z() { Y y; y.m(); Y *p; p-&gt;m(); <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> x; x.m(); x.g(); }</div>
</div><!-- fragment --><p> cxxMemberCallExpr(thisPointerType(hasDeclaration( cxxRecordDecl(hasName("Y"))))) matches <code>y.m()</code>, <code>p-&gt;m()</code> and <code>x.m()</code>. cxxMemberCallExpr(thisPointerType(hasDeclaration( cxxRecordDecl(hasName("X"))))) matches <code>x.g()</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03963">3963</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00964">anyOf</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a07fc7328f73d9bb7d7d88855195afb34" name="a07fc7328f73d9bb7d7d88855195afb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07fc7328f73d9bb7d7d88855195afb34">&#9670;&#160;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignoringParens</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload <code>ignoringParens</code> for <code><a class="el" href="classclang_1_1Expr.html" title="This represents one expression.">Expr</a></code>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* str = (<span class="stringliteral">&quot;my-string&quot;</span>);</div>
</div><!-- fragment --><p> The matcher </p><div class="fragment"><div class="line"><a class="code hl_variable" href="#a28b1bdd70cca95686345d5a96d97071a">implicitCastExpr</a>(hasSourceExpression(ignoringParens(<a class="code hl_variable" href="#a2c9fffe33e90bbb4b8f099caf377d7b1">stringLiteral</a>())))</div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a28b1bdd70cca95686345d5a96d97071a"><div class="ttname"><a href="#a28b1bdd70cca95686345d5a96d97071a">clang::ast_matchers::implicitCastExpr</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, ImplicitCastExpr &gt; implicitCastExpr</div><div class="ttdoc">Matches the implicit cast nodes of Clang's AST.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00949">ASTMatchersInternal.cpp:949</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a2c9fffe33e90bbb4b8f099caf377d7b1"><div class="ttname"><a href="#a2c9fffe33e90bbb4b8f099caf377d7b1">clang::ast_matchers::stringLiteral</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, StringLiteral &gt; stringLiteral</div><div class="ttdoc">Matches string literals (also matches wide string literals).</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00901">ASTMatchersInternal.cpp:901</a></div></div>
</div><!-- fragment --><p> would match the implicit cast resulting from the assignment. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00986">986</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a438d656e0ac87b0ee046d8451594632e" name="a438d656e0ac87b0ee046d8451594632e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438d656e0ac87b0ee046d8451594632e">&#9670;&#160;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1LambdaExpr.html">LambdaExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAnyCapture</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1CXXThisExpr.html">CXXThisExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches any capture of 'this' in a lambda expression. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>foo {</div>
<div class="line">  <span class="keywordtype">void</span> bar() {</div>
<div class="line">    <span class="keyword">auto</span> f = [<span class="keyword">this</span>](){};</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> lambdaExpr(hasAnyCapture(cxxThisExpr())) matches [this](){}; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04493">4493</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a88bfbea7f3e4c3dd22b5d24bd1fdaa28" name="a88bfbea7f3e4c3dd22b5d24bd1fdaa28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bfbea7f3e4c3dd22b5d24bd1fdaa28">&#9670;&#160;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1LambdaExpr.html">LambdaExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAnyCapture</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches any capture of a lambda expression. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo() {</div>
<div class="line">  <span class="keywordtype">int</span> x;</div>
<div class="line">  <span class="keyword">auto</span> f = [x](){};</div>
<div class="line">}</div>
</div><!-- fragment --><p> lambdaExpr(hasAnyCapture(anything())) matches [x](){}; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04467">4467</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="af4045123f0a783a289d12aaa2f5dc8e7" name="af4045123f0a783a289d12aaa2f5dc8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4045123f0a783a289d12aaa2f5dc8e7">&#9670;&#160;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignoringParens</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches types that match InnerMatcher after any parens are stripped. </p>
<p>Given </p><div class="fragment"><div class="line">void (*fp)(void);</div>
</div><!-- fragment --><p> The matcher </p><div class="fragment"><div class="line"><a class="code hl_variable" href="#a056e81429237736b6458df18bb538c82">varDecl</a>(hasType(<a class="code hl_variable" href="#ab54c06461d2b15cc9701a1f8a5507daf">pointerType</a>(pointee(ignoringParens(<a class="code hl_variable" href="#a76bdb41bba221f74825ffc014afcdc79">functionType</a>())))))</div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a76bdb41bba221f74825ffc014afcdc79"><div class="ttname"><a href="#a76bdb41bba221f74825ffc014afcdc79">clang::ast_matchers::functionType</a></div><div class="ttdeci">const AstTypeMatcher&lt; FunctionType &gt; functionType</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l01019">ASTMatchersInternal.cpp:1019</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ab54c06461d2b15cc9701a1f8a5507daf"><div class="ttname"><a href="#ab54c06461d2b15cc9701a1f8a5507daf">clang::ast_matchers::pointerType</a></div><div class="ttdeci">const AstTypeMatcher&lt; PointerType &gt; pointerType</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l01024">ASTMatchersInternal.cpp:1024</a></div></div>
</div><!-- fragment --><p> would match the declaration for fp. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00970">970</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="aac6356d65a88dcac0fda65fd48fa0338" name="aac6356d65a88dcac0fda65fd48fa0338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6356d65a88dcac0fda65fd48fa0338">&#9670;&#160;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pointsTo</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded to match the pointee type's declaration. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03856">3856</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchers_8h_source.html#l03466">hasDeclaration()</a>, <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>, and <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00769">qualType</a>.</p>

</div>
</div>
<a id="aee02e539525731a4811d4d33437b5ff7" name="aee02e539525731a4811d4d33437b5ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee02e539525731a4811d4d33437b5ff7">&#9670;&#160;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">references</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded to match the referenced type's declaration. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03917">3917</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchers_8h_source.html#l03466">hasDeclaration()</a>, <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>, and <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00769">qualType</a>.</p>

</div>
</div>
<a id="aa8cb7556571e959aa00a7d5c8cdd9394" name="aa8cb7556571e959aa00a7d5c8cdd9394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cb7556571e959aa00a7d5c8cdd9394">&#9670;&#160;</a></span>AST_MATCHER_REGEX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_REGEX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matchesName</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RegExp</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <a class="el" href="classclang_1_1NamedDecl.html" title="This represents a decl that may have a name.">NamedDecl</a> nodes whose fully qualified names contain a substring matched by the given RegExp. </p>
<p>Supports specifying enclosing namespaces or classes by prefixing the name with '&lt;enclosing&gt;::'. Does not match typedefs of an underlying type with the given name.</p>
<p>Example matches X (regexp == "::X") </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>;</div>
</div><!-- fragment --><p>Example matches X (regexp is one of "::X", "^foo::.*X", among others) </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>foo { <span class="keyword">namespace </span>bar { <span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>; } }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02929">2929</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a1a26f57707ca1cc9c7c2f915bdef1dec" name="a1a26f57707ca1cc9c7c2f915bdef1dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a26f57707ca1cc9c7c2f915bdef1dec">&#9670;&#160;</a></span>AST_MATCHER_REGEX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_REGEX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matchesSelector</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RegExp</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches ObjC selectors whose name contains a substring matched by the given RegExp. </p>
<p>matcher = objCMessageExpr(matchesSelector("loadHTMLString\:baseURL?")); matches the outer message expr in the code below, but NOT the message invocation for self.bodyView. </p><div class="fragment"><div class="line">[self.bodyView loadHTMLString:html baseURL:<a class="code hl_define" href="opencl-c-base_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>];</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03654">3654</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a968ac67c58589231ded255cfa8b7d70e" name="a968ac67c58589231ded255cfa8b7d70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968ac67c58589231ded255cfa8b7d70e">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isExpansionInMainFile</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches AST nodes that were expanded within the main-file. </p>
<p>Example matches X but not Y (matcher = <a class="el" href="#ac1ef73826e6b83dd0e8fc4a4b7284c74" title="Matches C++ class declarations.">cxxRecordDecl(isExpansionInMainFile())</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Y.h&gt;</span></div>
<div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {};</div>
</div><!-- fragment --><p> Y.h: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y {};</div>
</div><!-- fragment --><p>Usable as: Matcher&lt;Decl&gt;, Matcher&lt;Stmt&gt;, Matcher&lt;TypeLoc&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00242">242</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="SourceManager_8h_source.html#l01155">clang::SourceManager::getExpansionLoc()</a>, <a class="el" href="SourceManager_8cpp_source.html#l01545">clang::SourceManager::isInMainFile()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a5ac38e17b4f443550d465158fa148ec4" name="a5ac38e17b4f443550d465158fa148ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac38e17b4f443550d465158fa148ec4">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isExpansionInSystemHeader</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches AST nodes that were expanded within system-header-files. </p>
<p>Example matches Y but not X (matcher = <a class="el" href="#ac1ef73826e6b83dd0e8fc4a4b7284c74" title="Matches C++ class declarations.">cxxRecordDecl(isExpansionInSystemHeader())</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;SystemHeader.h&gt;</span></div>
<div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {};</div>
</div><!-- fragment --><p> SystemHeader.h: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y {};</div>
</div><!-- fragment --><p>Usable as: Matcher&lt;Decl&gt;, Matcher&lt;Stmt&gt;, Matcher&lt;TypeLoc&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00263">263</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="SourceManager_8h_source.html#l01155">clang::SourceManager::getExpansionLoc()</a>, <a class="el" href="SourceManager_8h_source.html#l01485">clang::SourceManager::isInSystemHeader()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="ad2128e92dde14b184065a2c1aae5e23b" name="ad2128e92dde14b184065a2c1aae5e23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2128e92dde14b184065a2c1aae5e23b">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isPrivate</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches private C++ declarations and C++ base specifers that specify private inheritance. </p>
<p>Examples: </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {</div>
<div class="line"><span class="keyword">public</span>:    <span class="keywordtype">int</span> a;</div>
<div class="line"><span class="keyword">protected</span>: <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line"><span class="keyword">private</span>:   <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>; <span class="comment">// fieldDecl(isPrivate()) matches &#39;c&#39;</span></div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_class" href="classBase.html">Base</a> {};</div>
<div class="line"><span class="keyword">struct </span>Derived1 : <span class="keyword">private</span> <a class="code hl_class" href="classBase.html">Base</a> {}; <span class="comment">// matches &#39;Base&#39;</span></div>
<div class="line"><span class="keyword">class </span>Derived2 : <a class="code hl_class" href="classBase.html">Base</a> {}; <span class="comment">// matches &#39;Base&#39;</span></div>
<div class="ttc" id="aclassBase_html"><div class="ttname"><a href="classBase.html">Base</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00652">652</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="Specifiers_8h_source.html#l00101">clang::AS_private</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="aa70d182f0dc6e578582e680c791f0425" name="aa70d182f0dc6e578582e680c791f0425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70d182f0dc6e578582e680c791f0425">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isProtected</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches protected C++ declarations and C++ base specifers that specify protected inheritance. </p>
<p>Examples: </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {</div>
<div class="line"><span class="keyword">public</span>:    <span class="keywordtype">int</span> a;</div>
<div class="line"><span class="keyword">protected</span>: <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>; <span class="comment">// fieldDecl(isProtected()) matches &#39;b&#39;</span></div>
<div class="line"><span class="keyword">private</span>:   <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="classBase.html">Base</a> {};</div>
<div class="line"><span class="keyword">class </span>Derived : <span class="keyword">protected</span> <a class="code hl_class" href="classBase.html">Base</a> {}; <span class="comment">// matches &#39;Base&#39;</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00629">629</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="Specifiers_8h_source.html#l00100">clang::AS_protected</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="ae26030464371cdda3687f2a9e71a6518" name="ae26030464371cdda3687f2a9e71a6518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26030464371cdda3687f2a9e71a6518">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isPublic</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches public C++ declarations and C++ base specifers that specify public inheritance. </p>
<p>Examples: </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {</div>
<div class="line"><span class="keyword">public</span>:    <span class="keywordtype">int</span> a; <span class="comment">// fieldDecl(isPublic()) matches &#39;a&#39;</span></div>
<div class="line"><span class="keyword">protected</span>: <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line"><span class="keyword">private</span>:   <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="classBase.html">Base</a> {};</div>
<div class="line"><span class="keyword">class </span>Derived1 : <span class="keyword">public</span> <a class="code hl_class" href="classBase.html">Base</a> {}; <span class="comment">// matches &#39;Base&#39;</span></div>
<div class="line"><span class="keyword">struct </span>Derived2 : <a class="code hl_class" href="classBase.html">Base</a> {}; <span class="comment">// matches &#39;Base&#39;</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00607">607</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="Specifiers_8h_source.html#l00099">clang::AS_public</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a46a4ccd4bcea5a4e03c1a502b4febba3" name="a46a4ccd4bcea5a4e03c1a502b4febba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a4ccd4bcea5a4e03c1a502b4febba3">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">argumentCountIs</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>( <a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>, <a class="el" href="classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>, <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that a call expression or a constructor call expression has a specific number of arguments (including absent default arguments). </p>
<p>Example matches f(0, 0) (matcher = <a class="el" href="#a460801cda670b9a3ccc3d42f51f3bd5c" title="Matches call expressions.">callExpr(argumentCountIs(2))</a>) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y);</div>
<div class="line">f(0, 0);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04189">4189</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="BuildTree_8cpp_source.html#l01562">N</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a33beb8112c5d3457aa00768aaafc89f2" name="a33beb8112c5d3457aa00768aaafc89f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33beb8112c5d3457aa00768aaafc89f2">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">hasAnyArgument</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>( <a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>, <a class="el" href="classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>, <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches any argument of a call expression or a constructor call expression, or an ObjC-message-send expression. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> x(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>) { <span class="keywordtype">int</span> y; x(1, y, 42); }</div>
</div><!-- fragment --><p> callExpr(hasAnyArgument(declRefExpr())) matches x(1, y, 42) with hasAnyArgument(...) matching y</p>
<p>For ObjectiveC, given </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>I - (void) f:(<span class="keywordtype">int</span>) y; <span class="keyword">@end</span></div>
<div class="line"><span class="keywordtype">void</span> foo(I *i) { [i f:12]; }</div>
</div><!-- fragment --><p> objcMessageExpr(hasAnyArgument(<a class="el" href="#ad2109e16a4a151dc8f6416a66a750eac" title="Matches integer literals of all sizes / encodings, e.g.">integerLiteral(equals(12))</a>)) matches [i f:12] </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04438">4438</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="a2a6b5c72b69ebf86c242f591b3a607cf" name="a2a6b5c72b69ebf86c242f591b3a607cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6b5c72b69ebf86c242f591b3a607cf">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">hasAnyTemplateArgument</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>, <a class="el" href="classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches classTemplateSpecializations, templateSpecializationType and functionDecl that have at least one <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> matching the given InnerMatcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>A {};</div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class </span>A&lt;double&gt; {};</div>
<div class="line">A&lt;int&gt; a;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; f() {};</div>
<div class="line"><span class="keywordtype">void</span> func() { f&lt;int&gt;(); };</div>
</div><!-- fragment --><p>classTemplateSpecializationDecl(hasAnyTemplateArgument( refersToType(asString("int")))) matches the specialization <code>A&lt;int&gt;</code> </p>
<p>functionDecl(hasAnyTemplateArgument(refersToType(asString("int")))) matches the specialization <code>f&lt;int&gt;</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00762">762</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a7aeb83f2ec21f29e79ce86e902ed8540" name="a7aeb83f2ec21f29e79ce86e902ed8540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aeb83f2ec21f29e79ce86e902ed8540">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">isDerivedFrom</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBase.html">Base</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ classes that are directly or indirectly derived from a class matching <code><a class="el" href="classBase.html">Base</a></code>, or Objective-C classes that directly or indirectly subclass a class matching <code><a class="el" href="classBase.html">Base</a></code>. </p>
<p>Note that a class is not considered to be derived from itself.</p>
<p>Example matches Y, Z, C (<a class="el" href="classBase.html">Base</a> == hasName("X")) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>;</div>
<div class="line"><span class="keyword">class </span>Y : <span class="keyword">public</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {};  <span class="comment">// directly derived</span></div>
<div class="line"><span class="keyword">class </span>Z : <span class="keyword">public</span> Y {};  <span class="comment">// indirectly derived</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> A;</div>
<div class="line"><span class="keyword">typedef</span> A B;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> : <span class="keyword">public</span> B {};  <span class="comment">// derived from a typedef of X</span></div>
</div><!-- fragment --><p>In the following example, Bar matches isDerivedFrom(hasName("X")): </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo;</div>
<div class="line"><span class="keyword">typedef</span> Foo <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>;</div>
<div class="line"><span class="keyword">class </span>Bar : <span class="keyword">public</span> Foo {};  <span class="comment">// derived from a type that X is a typedef of</span></div>
</div><!-- fragment --><p>In the following example, Bar matches isDerivedFrom(hasName("NSObject")) </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>NSObject <span class="keyword">@end</span></div>
<div class="line"><span class="keyword">@interface </span>Bar : NSObject @end</div>
</div><!-- fragment --><p>Usable as: Matcher&lt;CXXRecordDecl&gt;, Matcher&lt;ObjCInterfaceDecl&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03082">3082</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="Address_8h_source.html#l00108">clang::cast()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a35486e436ae0dbb176252fc6b3cf62fd" name="a35486e436ae0dbb176252fc6b3cf62fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35486e436ae0dbb176252fc6b3cf62fd">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">isExpandedFromMacro</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MacroName</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches statements that are (transitively) expanded from the named macro. </p>
<p>Does not match if only part of the statement is expanded from that macro or if different parts of the the statement are expanded from different appearances of the macro. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00311">311</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00689">clang::ast_matchers::internal::getExpansionLocOfMacro()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a8d5bfa4d4498d0db062ebae29807b397" name="a8d5bfa4d4498d0db062ebae29807b397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5bfa4d4498d0db062ebae29807b397">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">templateArgumentCountIs</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>, <a class="el" href="classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the number of template arguments equals <code>N</code>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {};</div>
<div class="line"><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C&lt;int&gt;</a> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> <a class="el" href="#ab81538ee441769591ce912334397e6b7" title="Matches C++ class template specializations.">classTemplateSpecializationDecl(templateArgumentCountIs(1))</a> matches C&lt;int&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01074">1074</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="BuildTree_8cpp_source.html#l01562">N</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a2af575f4746ac9a3a887ba95055a0b98" name="a2af575f4746ac9a3a887ba95055a0b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af575f4746ac9a3a887ba95055a0b98">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_P2() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P2 </td>
          <td>(</td>
          <td class="paramtype">forEachArgumentWithParam</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1ParmVarDecl.html">ParmVarDecl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParamMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches all arguments and their respective <a class="el" href="classclang_1_1ParmVarDecl.html" title="Represents a parameter to a function.">ParmVarDecl</a>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> i);</div>
<div class="line"><span class="keywordtype">int</span> y;</div>
<div class="line">f(y);</div>
</div><!-- fragment --><p> callExpr( forEachArgumentWithParam( declRefExpr(to(varDecl(hasName("y")))), parmVarDecl(hasType(isInteger())) )) matches f(y); with <a class="el" href="#a0781cbe6d50bd620cb6f8f0627378be6" title="Matches expressions that refer to declarations.">declRefExpr(...)</a> matching int y and <a class="el" href="#a3b7539a5a5ad3112f453ffb3ab9a67c5" title="Matches parameter variable declarations.">parmVarDecl(...)</a> matching int i </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04569">4569</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00964">anyOf</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00801">callExpr</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00853">cxxConstructExpr</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00776">cxxConstructorDecl</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00783">cxxMethodDecl</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00870">cxxOperatorCallExpr</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00873">expr</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00790">functionDecl</a>, <a class="el" href="ASTMatchers_8h_source.html#l03466">hasDeclaration()</a>, <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="af7884898943337e06f5ab539e5b508b0" name="af7884898943337e06f5ab539e5b508b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7884898943337e06f5ab539e5b508b0">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_P2() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P2 </td>
          <td>(</td>
          <td class="paramtype">forEachArgumentWithParamType</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParamMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches all arguments and their respective types for a <code><a class="el" href="classclang_1_1CallExpr.html" title="CallExpr - Represents a function call (C99 6.5.2.2, C++ [expr.call]).">CallExpr</a></code> or <code><a class="el" href="classclang_1_1CXXConstructExpr.html" title="Represents a call to a C++ constructor.">CXXConstructExpr</a></code>. </p>
<p>It is very similar to <code>forEachArgumentWithParam</code> but it works on calls through function pointers as well.</p>
<p>The difference is, that function pointers do not provide access to a <code><a class="el" href="classclang_1_1ParmVarDecl.html" title="Represents a parameter to a function.">ParmVarDecl</a></code>, but only the <code><a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a></code> for each argument.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> i);</div>
<div class="line"><span class="keywordtype">int</span> y;</div>
<div class="line">f(y);</div>
<div class="line">void (*f_ptr)(<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>) = f;</div>
<div class="line">f_ptr(y);</div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_aa7b8984e16daeff79f73e22b4e040334"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a></div><div class="ttdeci">__device__ int</div><div class="ttdef"><b>Definition</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00063">__clang_hip_libdevice_declares.h:63</a></div></div>
</div><!-- fragment --><p> callExpr( forEachArgumentWithParamType( declRefExpr(to(varDecl(hasName("y")))), <a class="el" href="#aefc28b8bf75f10413691d11b9c371116" title="Matches QualTypes in the clang AST.">qualType(isInteger())</a>.bind("type) )) matches f(y) and f_ptr(y) with <a class="el" href="#a0781cbe6d50bd620cb6f8f0627378be6" title="Matches expressions that refer to declarations.">declRefExpr(...)</a> matching int y and <a class="el" href="#aefc28b8bf75f10413691d11b9c371116" title="Matches QualTypes in the clang AST.">qualType(...)</a> matching int </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04630">4630</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00964">anyOf</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00801">callExpr</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00853">cxxConstructExpr</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00776">cxxConstructorDecl</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00783">cxxMethodDecl</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00870">cxxOperatorCallExpr</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00873">expr</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00790">functionDecl</a>, <a class="el" href="Type_8h_source.html#l07145">clang::Type::getAs()</a>, <a class="el" href="Type_8h_source.html#l04089">clang::FunctionProtoType::getParamType()</a>, <a class="el" href="Type_8cpp_source.html#l00625">clang::Type::getPointeeType()</a>, <a class="el" href="ASTMatchers_8h_source.html#l03466">hasDeclaration()</a>, <a class="el" href="Type_8h_source.html#l06694">clang::Type::isFunctionPointerType()</a>, <a class="el" href="Type_8h_source.html#l06712">clang::Type::isMemberFunctionPointerType()</a>, <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="ad47efa625b357d8576ddd7845b4d8a2e" name="ad47efa625b357d8576ddd7845b4d8a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47efa625b357d8576ddd7845b4d8a2e">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_P2() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P2 </td>
          <td>(</td>
          <td class="paramtype">hasArgument</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>( <a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>, <a class="el" href="classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>, <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the n'th argument of a call expression or a constructor call expression. </p>
<p>Example matches y in x(y) (matcher = callExpr(hasArgument(0, declRefExpr()))) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> x(<span class="keywordtype">int</span>) { <span class="keywordtype">int</span> y; x(y); }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04213">4213</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="Expr_8cpp_source.html#l02775">clang::Expr::IgnoreParenImpCasts()</a>, <a class="el" href="BuildTree_8cpp_source.html#l01562">N</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a79ebb293017dba39bb149d8faea59176" name="a79ebb293017dba39bb149d8faea59176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ebb293017dba39bb149d8faea59176">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_P2() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P2 </td>
          <td>(</td>
          <td class="paramtype">hasParameter</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>, <a class="el" href="classclang_1_1BlockDecl.html">BlockDecl</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1ParmVarDecl.html">ParmVarDecl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the n'th parameter of a function or an ObjC method declaration or a block. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> { <span class="keywordtype">void</span> f(<span class="keywordtype">int</span> x) {} };</div>
</div><!-- fragment --><p> cxxMethodDecl(hasParameter(0, hasType(varDecl()))) matches f(int x) {} with hasParameter(...) matching int x</p>
<p>For ObjectiveC, given </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>I - (void) f:(<span class="keywordtype">int</span>) y; <span class="keyword">@end</span></div>
</div><!-- fragment --><p> the matcher objcMethodDecl(hasParameter(0, hasName("y"))) matches the declaration of method f with hasParameter matching y. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04541">4541</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="BuildTree_8cpp_source.html#l01562">N</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="ac2ae808f2b4db9e59ead6b1695186d91" name="ac2ae808f2b4db9e59ead6b1695186d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ae808f2b4db9e59ead6b1695186d91">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_P2() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P2 </td>
          <td>(</td>
          <td class="paramtype">hasTemplateArgument</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>, <a class="el" href="classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches classTemplateSpecializations, templateSpecializationType and functionDecl where the n'th <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> matches the given InnerMatcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">class </span>A {};</div>
<div class="line">A&lt;bool, int&gt; <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">A&lt;int, bool&gt; <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> f() {}</div>
<div class="line"><span class="keywordtype">void</span> func() { f&lt;int&gt;(); };</div>
</div><!-- fragment --><p> classTemplateSpecializationDecl(hasTemplateArgument( 1, refersToType(asString("int")))) matches the specialization <code>A&lt;bool, int&gt;</code> </p>
<p>functionDecl(hasTemplateArgument(0, refersToType(asString("int")))) matches the specialization <code>f&lt;int&gt;</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01052">1052</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="BuildTree_8cpp_source.html#l01562">N</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a9c0bd88ac6ae6bca91d3ae01966af957" name="a9c0bd88ac6ae6bca91d3ae01966af957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0bd88ac6ae6bca91d3ae01966af957">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_P_OVERLOAD() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype">hasType</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Expr.html">Expr</a>, <a class="el" href="classclang_1_1FriendDecl.html">FriendDecl</a>, <a class="el" href="classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>, <a class="el" href="classclang_1_1ValueDecl.html">ValueDecl</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the expression's or declaration's type matches a type matcher. </p>
<p>Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName("X"))))) and z (matcher = varDecl(hasType(cxxRecordDecl(hasName("X"))))) and <a class="el" href="classU.html">U</a> (matcher = typedefDecl(hasType(asString("int"))) and friend class X (matcher = friendDecl(hasType("X")) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {};</div>
<div class="line"><span class="keywordtype">void</span> y(<a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> &amp;x) { x; <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> z; }</div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code hl_class" href="classU.html">U</a>;</div>
<div class="line"><span class="keyword">class </span>Y { <span class="keyword">friend</span> <span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>; };</div>
<div class="ttc" id="aclassU_html"><div class="ttname"><a href="classU.html">U</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03760">3760</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="Type_8h_source.html#l00726">clang::QualType::isNull()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="ace3a094ff7ddc1b0328cb262bffc465b" name="ace3a094ff7ddc1b0328cb262bffc465b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3a094ff7ddc1b0328cb262bffc465b">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_P_OVERLOAD() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype">hasType</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Expr.html">Expr</a>, <a class="el" href="classclang_1_1FriendDecl.html">FriendDecl</a>, <a class="el" href="classclang_1_1ValueDecl.html">ValueDecl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded to match the declaration of the expression's or value declaration's type. </p>
<p>In case of a value declaration (for example a variable declaration), this resolves one layer of indirection. For example, in the value declaration "X x;", cxxRecordDecl(hasName("X")) matches the declaration of X, while varDecl(hasType(cxxRecordDecl(hasName("X")))) matches the declaration of x.</p>
<p>Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName("X"))))) and z (matcher = varDecl(hasType(cxxRecordDecl(hasName("X"))))) and friend class X (matcher = friendDecl(hasType("X")) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {};</div>
<div class="line"><span class="keywordtype">void</span> y(<a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> &amp;x) { x; <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> z; }</div>
<div class="line"><span class="keyword">class </span>Y { <span class="keyword">friend</span> <span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>; };</div>
</div><!-- fragment --><p>Example matches class Derived (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName("Base")))))) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="classBase.html">Base</a> {};</div>
<div class="line"><span class="keyword">class </span>Derived : <a class="code hl_class" href="classBase.html">Base</a> {};</div>
</div><!-- fragment --><p>Usable as: Matcher&lt;Expr&gt;, Matcher&lt;FriendDecl&gt;, Matcher&lt;ValueDecl&gt;, Matcher&lt;CXXBaseSpecifier&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03798">3798</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchers_8h_source.html#l03466">hasDeclaration()</a>, <a class="el" href="Type_8h_source.html#l00726">clang::QualType::isNull()</a>, <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>, and <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00769">qualType</a>.</p>

</div>
</div>
<a id="a931d53d9c92b933394ca4e31fd3610db" name="a931d53d9c92b933394ca4e31fd3610db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931d53d9c92b933394ca4e31fd3610db">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_P_OVERLOAD() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype">isDerivedFrom</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseName</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded method as shortcut for <code>isDerivedFrom(hasName(...))</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03097">3097</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="Address_8h_source.html#l00108">clang::cast()</a>, <a class="el" href="ASTMatchers_8h_source.html#l02894">hasName()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a5e3046ab1a3310f7867a4c1e47c9bfff" name="a5e3046ab1a3310f7867a4c1e47c9bfff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3046ab1a3310f7867a4c1e47c9bfff">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_P_OVERLOAD() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype">isDirectlyDerivedFrom</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBase.html">Base</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ or Objective-C classes that are directly derived from a class matching <code><a class="el" href="classBase.html">Base</a></code>. </p>
<p>Note that a class is not considered to be derived from itself.</p>
<p>Example matches Y, C (<a class="el" href="classBase.html">Base</a> == hasName("X")) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>;</div>
<div class="line"><span class="keyword">class </span>Y : <span class="keyword">public</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {};  <span class="comment">// directly derived</span></div>
<div class="line"><span class="keyword">class </span>Z : <span class="keyword">public</span> Y {};  <span class="comment">// indirectly derived</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> A;</div>
<div class="line"><span class="keyword">typedef</span> A B;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> : <span class="keyword">public</span> B {};  <span class="comment">// derived from a typedef of X</span></div>
</div><!-- fragment --><p>In the following example, Bar matches isDerivedFrom(hasName("X")): </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo;</div>
<div class="line"><span class="keyword">typedef</span> Foo <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>;</div>
<div class="line"><span class="keyword">class </span>Bar : <span class="keyword">public</span> Foo {};  <span class="comment">// derived from a type that X is a typedef of</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03207">3207</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="Address_8h_source.html#l00108">clang::cast()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a898b5ddf30c2409c36bdb3cc0abb789f" name="a898b5ddf30c2409c36bdb3cc0abb789f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898b5ddf30c2409c36bdb3cc0abb789f">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_P_OVERLOAD() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype">isDirectlyDerivedFrom</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseName</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded method as shortcut for <code>isDirectlyDerivedFrom(hasName(...))</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03222">3222</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="Address_8h_source.html#l00108">clang::cast()</a>, <a class="el" href="ASTMatchers_8h_source.html#l02894">hasName()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a2fbefa428d3a7d1641d6ac07a021cdcf" name="a2fbefa428d3a7d1641d6ac07a021cdcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbefa428d3a7d1641d6ac07a021cdcf">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_P_OVERLOAD() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype">isSameOrDerivedFrom</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBase.html">Base</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <code>isDerivedFrom()</code>, but also matches classes that directly match <code><a class="el" href="classBase.html">Base</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03155">3155</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00964">anyOf</a>, <a class="el" href="Address_8h_source.html#l00108">clang::cast()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="afb9b17e996eb7d40a1b04ce7701a07db" name="afb9b17e996eb7d40a1b04ce7701a07db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9b17e996eb7d40a1b04ce7701a07db">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_P_OVERLOAD() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype">isSameOrDerivedFrom</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseName</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded method as shortcut for <code>isSameOrDerivedFrom(hasName(...))</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03170">3170</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="Address_8h_source.html#l00108">clang::cast()</a>, <a class="el" href="ASTMatchers_8h_source.html#l02894">hasName()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="acb873849aa797b4e9b6691b4d9fed736" name="acb873849aa797b4e9b6691b4d9fed736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb873849aa797b4e9b6691b4d9fed736">&#9670;&#160;</a></span>AST_POLYMORPHIC_MATCHER_REGEX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_REGEX </td>
          <td>(</td>
          <td class="paramtype">isExpansionInFileMatching</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RegExp</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches AST nodes that were expanded within files whose name is partially matching a given regex. </p>
<p>Example matches Y but not X (matcher = cxxRecordDecl(isExpansionInFileMatching("AST.*")) </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;ASTMatcher.h&quot;</span></div>
<div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {};</div>
</div><!-- fragment --><p> ASTMatcher.h: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y {};</div>
</div><!-- fragment --><p>Usable as: Matcher&lt;Decl&gt;, Matcher&lt;Stmt&gt;, Matcher&lt;TypeLoc&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00288">288</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l02111">Filename</a>, <a class="el" href="SourceManager_8h_source.html#l01155">clang::SourceManager::getExpansionLoc()</a>, <a class="el" href="SourceManager_8h_source.html#l01027">clang::SourceManager::getFileEntryForID()</a>, <a class="el" href="SourceManager_8h_source.html#l01100">clang::SourceManager::getFileID()</a>, <a class="el" href="FileEntry_8h_source.html#l00364">clang::FileEntry::getName()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a9e40f7a7120043b6e36077adcf44c9cd" name="a9e40f7a7120043b6e36077adcf44c9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e40f7a7120043b6e36077adcf44c9cd">&#9670;&#160;</a></span>AST_TYPELOC_TRAVERSE_MATCHER_DEF() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_TYPELOC_TRAVERSE_MATCHER_DEF </td>
          <td>(</td>
          <td class="paramtype">hasElementType</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ArrayType.html">ArrayType</a>, <a class="el" href="classclang_1_1ComplexType.html">ComplexType</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a953d25fd07bb81ad8bf5a87a0068f13b" name="a953d25fd07bb81ad8bf5a87a0068f13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953d25fd07bb81ad8bf5a87a0068f13b">&#9670;&#160;</a></span>AST_TYPELOC_TRAVERSE_MATCHER_DEF() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_TYPELOC_TRAVERSE_MATCHER_DEF </td>
          <td>(</td>
          <td class="paramtype">hasValueType</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1AtomicType.html">AtomicType</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3509e3798b4581a7a8cb59106aa6b73" name="ad3509e3798b4581a7a8cb59106aa6b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3509e3798b4581a7a8cb59106aa6b73">&#9670;&#160;</a></span>AST_TYPELOC_TRAVERSE_MATCHER_DEF() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_TYPELOC_TRAVERSE_MATCHER_DEF </td>
          <td>(</td>
          <td class="paramtype">pointee</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BlockPointerType.html">BlockPointerType</a>, <a class="el" href="classclang_1_1MemberPointerType.html">MemberPointerType</a>, <a class="el" href="classclang_1_1PointerType.html">PointerType</a>, <a class="el" href="classclang_1_1ReferenceType.html">ReferenceType</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2d86a586c37bb32b5dff391714953ed" name="ad2d86a586c37bb32b5dff391714953ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d86a586c37bb32b5dff391714953ed">&#9670;&#160;</a></span>findAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::Matcher&lt; T &gt; clang::ast_matchers::findAll </td>
          <td>(</td>
          <td class="paramtype">const internal::Matcher&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Matcher</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the node or any descendant matches. </p>
<p>Generates results for each match.</p>
<p>For example, in: </p><div class="fragment"><div class="line"><span class="keyword">class </span>A { <span class="keyword">class </span>B {}; <span class="keyword">class </span>C {}; };</div>
</div><!-- fragment --><p> The matcher: </p><div class="fragment"><div class="line"><a class="code hl_variable" href="#ac1ef73826e6b83dd0e8fc4a4b7284c74">cxxRecordDecl</a>(<a class="code hl_function" href="#a4360554ed6340d60248b5d5930c44d49">hasName</a>(<span class="stringliteral">&quot;::A&quot;</span>),</div>
<div class="line">              <a class="code hl_function" href="#ad2d86a586c37bb32b5dff391714953ed">findAll</a>(<a class="code hl_variable" href="#ac1ef73826e6b83dd0e8fc4a4b7284c74">cxxRecordDecl</a>(isDefinition()).bind(<span class="stringliteral">&quot;m&quot;</span>)))</div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ad2d86a586c37bb32b5dff391714953ed"><div class="ttname"><a href="#ad2d86a586c37bb32b5dff391714953ed">clang::ast_matchers::findAll</a></div><div class="ttdeci">internal::Matcher&lt; T &gt; findAll(const internal::Matcher&lt; T &gt; &amp;Matcher)</div><div class="ttdoc">Matches if the node or any descendant matches.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchers_8h_source.html#l03381">ASTMatchers.h:3381</a></div></div>
</div><!-- fragment --><p> will generate results for <code>A</code>, <code>B</code> and <code>C</code>.</p>
<p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03381">3381</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00961">eachOf</a>, and <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00989">forEachDescendant</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopWidening_8cpp_source.html#l00044">clang::ento::getWidenedLoopState()</a>.</p>

</div>
</div>
<a id="a1f3ba396d70c6dfae8235cfdb3f3c0db" name="a1f3ba396d70c6dfae8235cfdb3f3c0db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3ba396d70c6dfae8235cfdb3f3c0db">&#9670;&#160;</a></span>getAssertMacro()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::StringRef clang::ast_matchers::getAssertMacro </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a></td>          <td class="paramname"><span class="paramname"><em>Cmp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00044">44</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9da3718b5ecf60aa0dba49e150e96cb1fc3">Eq</a>, <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9dac6a675552648c0becb8283f05c172483">Ge</a>, <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9da086cb8308e5a36e7c4ed1f8873ad801f">Gt</a>, <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9dabccd5ec3ec8fd3a4471e71e9b407c60c">Le</a>, <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9da50033c15af7795cd6617f117b29d6922">Lt</a>, and <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9da4dec99baa99738721da9c9b0c1a92498">Ne</a>.</p>

<p class="reference">Referenced by <a class="el" href="GtestMatchers_8cpp_source.html#l00089">gtestAssert()</a>.</p>

</div>
</div>
<a id="a300e0f48793e28002e73a44d46dc3392" name="a300e0f48793e28002e73a44d46dc3392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300e0f48793e28002e73a44d46dc3392">&#9670;&#160;</a></span>getComparisonDecl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#a1d77576823c6c764d94aca78ada0f5ad">DeclarationMatcher</a> clang::ast_matchers::getComparisonDecl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a></td>          <td class="paramname"><span class="paramname"><em>Cmp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00024">24</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00783">cxxMethodDecl</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00744">cxxRecordDecl</a>, <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9da3718b5ecf60aa0dba49e150e96cb1fc3">Eq</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00790">functionDecl</a>, <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9dac6a675552648c0becb8283f05c172483">Ge</a>, <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9da086cb8308e5a36e7c4ed1f8873ad801f">Gt</a>, <a class="el" href="ASTMatchers_8h_source.html#l02894">hasName()</a>, <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9dabccd5ec3ec8fd3a4471e71e9b407c60c">Le</a>, <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9da50033c15af7795cd6617f117b29d6922">Lt</a>, and <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9da4dec99baa99738721da9c9b0c1a92498">Ne</a>.</p>

<p class="reference">Referenced by <a class="el" href="GtestMatchers_8cpp_source.html#l00089">gtestAssert()</a>, and <a class="el" href="GtestMatchers_8cpp_source.html#l00096">gtestExpect()</a>.</p>

</div>
</div>
<a id="a5e74342ecb22e45bbbd89e08604e431c" name="a5e74342ecb22e45bbbd89e08604e431c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e74342ecb22e45bbbd89e08604e431c">&#9670;&#160;</a></span>getExpectMacro()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::StringRef clang::ast_matchers::getExpectMacro </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a></td>          <td class="paramname"><span class="paramname"><em>Cmp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00062">62</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9da3718b5ecf60aa0dba49e150e96cb1fc3">Eq</a>, <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9dac6a675552648c0becb8283f05c172483">Ge</a>, <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9da086cb8308e5a36e7c4ed1f8873ad801f">Gt</a>, <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9dabccd5ec3ec8fd3a4471e71e9b407c60c">Le</a>, <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9da50033c15af7795cd6617f117b29d6922">Lt</a>, and <a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9da4dec99baa99738721da9c9b0c1a92498">Ne</a>.</p>

<p class="reference">Referenced by <a class="el" href="GtestMatchers_8cpp_source.html#l00096">gtestExpect()</a>.</p>

</div>
</div>
<a id="a03719ad642f4411e33d92b1081361f07" name="a03719ad642f4411e33d92b1081361f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03719ad642f4411e33d92b1081361f07">&#9670;&#160;</a></span>gtestAssert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt; clang::ast_matchers::gtestAssert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a></td>          <td class="paramname"><span class="paramname"><em>Cmp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a85886610fb27988c71cb3d5134c2302d">StatementMatcher</a></td>          <td class="paramname"><span class="paramname"><em>Left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a85886610fb27988c71cb3d5134c2302d">StatementMatcher</a></td>          <td class="paramname"><span class="paramname"><em>Right</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matcher for gtest's ASSERT_... macros. </p>

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00089">89</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00801">callExpr</a>, <a class="el" href="GtestMatchers_8cpp_source.html#l00044">getAssertMacro()</a>, and <a class="el" href="GtestMatchers_8cpp_source.html#l00024">getComparisonDecl()</a>.</p>

</div>
</div>
<a id="a33afaf3f80e491354dc39625e4a6785b" name="a33afaf3f80e491354dc39625e4a6785b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33afaf3f80e491354dc39625e4a6785b">&#9670;&#160;</a></span>gtestExpect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt; clang::ast_matchers::gtestExpect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a></td>          <td class="paramname"><span class="paramname"><em>Cmp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a85886610fb27988c71cb3d5134c2302d">StatementMatcher</a></td>          <td class="paramname"><span class="paramname"><em>Left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a85886610fb27988c71cb3d5134c2302d">StatementMatcher</a></td>          <td class="paramname"><span class="paramname"><em>Right</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matcher for gtest's EXPECT_... macros. </p>

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00096">96</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00801">callExpr</a>, <a class="el" href="GtestMatchers_8cpp_source.html#l00024">getComparisonDecl()</a>, and <a class="el" href="GtestMatchers_8cpp_source.html#l00062">getExpectMacro()</a>.</p>

</div>
</div>
<a id="a4ff2c5e99cdf0bc13af1e639d9249df2" name="a4ff2c5e99cdf0bc13af1e639d9249df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff2c5e99cdf0bc13af1e639d9249df2">&#9670;&#160;</a></span>hasDeclaration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::PolymorphicMatcherWithParam1&lt; internal::HasDeclarationMatcher, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, void(internal::HasDeclarationSupportedTypes)&gt; clang::ast_matchers::hasDeclaration </td>
          <td>(</td>
          <td class="paramtype">const internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InnerMatcher</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a node if the declaration associated with that node matches the given matcher. </p>
<p>The associated declaration is:</p><ul>
<li>for type nodes, the declaration of the underlying type</li>
<li>for <a class="el" href="classclang_1_1CallExpr.html" title="CallExpr - Represents a function call (C99 6.5.2.2, C++ [expr.call]).">CallExpr</a>, the declaration of the callee</li>
<li>for <a class="el" href="classclang_1_1MemberExpr.html" title="MemberExpr - [C99 6.5.2.3] Structure and Union Members.">MemberExpr</a>, the declaration of the referenced member</li>
<li>for <a class="el" href="classclang_1_1CXXConstructExpr.html" title="Represents a call to a C++ constructor.">CXXConstructExpr</a>, the declaration of the constructor</li>
<li>for <a class="el" href="classclang_1_1CXXNewExpr.html" title="Represents a new-expression for memory allocation and constructor calls, e.g: &quot;new CXXNewExpr(foo)&quot;.">CXXNewExpr</a>, the declaration of the operator new</li>
<li>for ObjCIvarExpr, the declaration of the ivar</li>
</ul>
<p>For type nodes, hasDeclaration will generally match the declaration of the sugared type. Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {};</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> Y;</div>
<div class="line">Y y;</div>
</div><!-- fragment --><p> in varDecl(hasType(hasDeclaration(decl()))) the decl will match the typedefDecl. A common use case is to match the underlying, desugared type. This can be achieved by using the hasUnqualifiedDesugaredType matcher: </p><div class="fragment"><div class="line"><a class="code hl_variable" href="#a056e81429237736b6458df18bb538c82">varDecl</a>(hasType(hasUnqualifiedDesugaredType(</div>
<div class="line">    <a class="code hl_variable" href="#aba33a83216073984c1a929a28f3091d3">recordType</a>(<a class="code hl_function" href="#a4ff2c5e99cdf0bc13af1e639d9249df2">hasDeclaration</a>(<a class="code hl_variable" href="#ac5ccadfbea5e9e43c2153175afca6cac">decl</a>())))))</div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_aba33a83216073984c1a929a28f3091d3"><div class="ttname"><a href="#aba33a83216073984c1a929a28f3091d3">clang::ast_matchers::recordType</a></div><div class="ttdeci">const AstTypeMatcher&lt; RecordType &gt; recordType</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l01033">ASTMatchersInternal.cpp:1033</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ac5ccadfbea5e9e43c2153175afca6cac"><div class="ttname"><a href="#ac5ccadfbea5e9e43c2153175afca6cac">clang::ast_matchers::decl</a></div><div class="ttdeci">const internal::VariadicAllOfMatcher&lt; Decl &gt; decl</div><div class="ttdoc">Matches declarations.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00734">ASTMatchersInternal.cpp:734</a></div></div>
</div><!-- fragment --><p> In this matcher, the decl will match the <a class="el" href="classclang_1_1CXXRecordDecl.html" title="Represents a C++ struct/union/class.">CXXRecordDecl</a> of class X.</p>
<p>Usable as: Matcher&lt;AddrLabelExpr&gt;, Matcher&lt;CallExpr&gt;, Matcher&lt;CXXConstructExpr&gt;, Matcher&lt;CXXNewExpr&gt;, Matcher&lt;DeclRefExpr&gt;, Matcher&lt;EnumType&gt;, Matcher&lt;InjectedClassNameType&gt;, Matcher&lt;LabelStmt&gt;, Matcher&lt;MemberExpr&gt;, Matcher&lt;QualType&gt;, Matcher&lt;RecordType&gt;, Matcher&lt;TagType&gt;, Matcher&lt;TemplateSpecializationType&gt;, Matcher&lt;TemplateTypeParmType&gt;, Matcher&lt;TypedefType&gt;, Matcher&lt;UnresolvedUsingType&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03466">3466</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l03742">AST_MATCHER_P_OVERLOAD()</a>, <a class="el" href="ASTMatchers_8h_source.html#l03856">AST_MATCHER_P_OVERLOAD()</a>, <a class="el" href="ASTMatchers_8h_source.html#l03917">AST_MATCHER_P_OVERLOAD()</a>, <a class="el" href="ASTMatchers_8h_source.html#l04569">AST_POLYMORPHIC_MATCHER_P2()</a>, <a class="el" href="ASTMatchers_8h_source.html#l04630">AST_POLYMORPHIC_MATCHER_P2()</a>, <a class="el" href="ASTMatchers_8h_source.html#l03798">AST_POLYMORPHIC_MATCHER_P_OVERLOAD()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00121">clang::ento::getAddrTo()</a>, <a class="el" href="OSObjectCStyleCast_8cpp_source.html#l00062">hasTypePointingTo()</a>, <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>, and <a class="el" href="BugReporterVisitors_8cpp_source.html#l00435">potentiallyWritesIntoIvar()</a>.</p>

</div>
</div>
<a id="a4360554ed6340d60248b5d5930c44d49" name="a4360554ed6340d60248b5d5930c44d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4360554ed6340d60248b5d5930c44d49">&#9670;&#160;</a></span>hasName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt; clang::ast_matchers::hasName </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches <a class="el" href="classclang_1_1NamedDecl.html" title="This represents a decl that may have a name.">NamedDecl</a> nodes that have the specified name. </p>
<p>Supports specifying enclosing namespaces or classes by prefixing the name with '&lt;enclosing&gt;::'. Does not match typedefs of an underlying type with the given name.</p>
<p>Example matches X (Name == "X") </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>;</div>
</div><!-- fragment --><p>Example matches X (Name is one of "::a::b::X", "a::b::X", "b::X", "X") </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>a { <span class="keyword">namespace </span><a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> { <span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>; } }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02894">2894</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l03097">AST_POLYMORPHIC_MATCHER_P_OVERLOAD()</a>, <a class="el" href="ASTMatchers_8h_source.html#l03222">AST_POLYMORPHIC_MATCHER_P_OVERLOAD()</a>, <a class="el" href="ASTMatchers_8h_source.html#l03170">AST_POLYMORPHIC_MATCHER_P_OVERLOAD()</a>, and <a class="el" href="GtestMatchers_8cpp_source.html#l00024">getComparisonDecl()</a>.</p>

</div>
</div>
<a id="aae3fd9d0c1f652bb7cad8fb60730874e" name="aae3fd9d0c1f652bb7cad8fb60730874e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3fd9d0c1f652bb7cad8fb60730874e">&#9670;&#160;</a></span>hasOverloadedOperatorName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::PolymorphicMatcherWithParam1&lt; internal::HasOverloadedOperatorNameMatcher, std::vector&lt; std::string &gt;, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>)&gt; clang::ast_matchers::hasOverloadedOperatorName </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches overloaded operator names. </p>
<p>Matches overloaded operator names specified in strings without the "operator" prefix: e.g. "&lt;&lt;".</p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keyword">class </span>A { <span class="keywordtype">int</span> <a class="code hl_function" href="CharUnits_8h.html#a30c408b1824dd612b35a6b4e20ed423f">operator*</a>(); };</div>
<div class="line"><span class="keyword">const</span> A &amp;<a class="code hl_function" href="namespaceclang.html#a60ee2b234598aa6e46b20012d281f701">operator&lt;&lt;</a>(<span class="keyword">const</span> A &amp;a, <span class="keyword">const</span> A &amp;<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>);</div>
<div class="line">A a;</div>
<div class="line">a &lt;&lt; a;   <span class="comment">// &lt;-- This matches</span></div>
<div class="ttc" id="aCharUnits_8h_html_a30c408b1824dd612b35a6b4e20ed423f"><div class="ttname"><a href="CharUnits_8h.html#a30c408b1824dd612b35a6b4e20ed423f">operator*</a></div><div class="ttdeci">clang::CharUnits operator*(clang::CharUnits::QuantityType Scale, const clang::CharUnits &amp;CU)</div><div class="ttdef"><b>Definition</b> <a href="CharUnits_8h_source.html#l00212">CharUnits.h:212</a></div></div>
<div class="ttc" id="anamespaceclang_html_a60ee2b234598aa6e46b20012d281f701"><div class="ttname"><a href="namespaceclang.html#a60ee2b234598aa6e46b20012d281f701">clang::operator&lt;&lt;</a></div><div class="ttdeci">const StreamingDiagnostic &amp; operator&lt;&lt;(const StreamingDiagnostic &amp;DB, const ASTContext::SectionInfo &amp;Section)</div><div class="ttdoc">Insertion operator for diagnostics.</div><div class="ttdef"><b>Definition</b> <a href="ASTContext_8cpp_source.html#l11430">ASTContext.cpp:11431</a></div></div>
</div><!-- fragment --><p><code>cxxOperatorCallExpr</code>(hasOverloadedOperatorName("&lt;&lt;"))) matches the specified line and <code>cxxRecordDecl</code>(hasMethod(hasOverloadedOperatorName("*"))) matches the declaration of <code>A</code>.</p>
<p>Usable as: Matcher&lt;CXXOperatorCallExpr&gt;, Matcher&lt;FunctionDecl&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02956">2956</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersMacros_8h_source.html#l00221">AST_POLYMORPHIC_SUPPORTED_TYPES</a>.</p>

</div>
</div>
<a id="a90d2caaa3c207f5b5f91216fe06f1158" name="a90d2caaa3c207f5b5f91216fe06f1158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d2caaa3c207f5b5f91216fe06f1158">&#9670;&#160;</a></span>mapAnyOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto clang::ast_matchers::mapAnyOf </td>
          <td>(</td>
          <td class="paramtype">internal::VariadicDynCastAllOfMatcher&lt; T, <a class="el" href="classU.html">U</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>...</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches any of the <code>NodeMatchers</code> with InnerMatchers nested within. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<span class="keyword">true</span>);</div>
<div class="line"><span class="keywordflow">for</span> (; <span class="keyword">true</span>; );</div>
</div><!-- fragment --><p> with the matcher </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a90d2caaa3c207f5b5f91216fe06f1158">mapAnyOf</a>(<a class="code hl_variable" href="#af5cd72a6718872ac996d48de9a80bf81">ifStmt</a>, <a class="code hl_variable" href="#a8e6f109ac0734990e8ae974d36e76c7e">forStmt</a>).with(</div>
<div class="line">  hasCondition(cxxBoolLiteralExpr(equals(<span class="keyword">true</span>)))</div>
<div class="line">  ).bind(<span class="stringliteral">&quot;trueCond&quot;</span>)</div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a8e6f109ac0734990e8ae974d36e76c7e"><div class="ttname"><a href="#a8e6f109ac0734990e8ae974d36e76c7e">clang::ast_matchers::forStmt</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, ForStmt &gt; forStmt</div><div class="ttdoc">Matches for statements.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00878">ASTMatchersInternal.cpp:878</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a90d2caaa3c207f5b5f91216fe06f1158"><div class="ttname"><a href="#a90d2caaa3c207f5b5f91216fe06f1158">clang::ast_matchers::mapAnyOf</a></div><div class="ttdeci">auto mapAnyOf(internal::VariadicDynCastAllOfMatcher&lt; T, U &gt; const &amp;...)</div><div class="ttdoc">Matches any of the NodeMatchers with InnerMatchers nested within.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchers_8h_source.html#l02752">ASTMatchers.h:2752</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_af5cd72a6718872ac996d48de9a80bf81"><div class="ttname"><a href="#af5cd72a6718872ac996d48de9a80bf81">clang::ast_matchers::ifStmt</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, IfStmt &gt; ifStmt</div><div class="ttdoc">Matches if statements.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00877">ASTMatchersInternal.cpp:877</a></div></div>
</div><!-- fragment --><p> matches the <code>if</code> and the <code>for</code>. It is equivalent to: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> trueCond = hasCondition(cxxBoolLiteralExpr(equals(<span class="keyword">true</span>)));</div>
<div class="line"><a class="code hl_variable" href="#ae56a1974283c9a2cb2410008e32fe3f1">anyOf</a>(</div>
<div class="line">  <a class="code hl_variable" href="#af5cd72a6718872ac996d48de9a80bf81">ifStmt</a>(trueCond).bind(<span class="stringliteral">&quot;trueCond&quot;</span>),</div>
<div class="line">  <a class="code hl_variable" href="#a8e6f109ac0734990e8ae974d36e76c7e">forStmt</a>(trueCond).bind(<span class="stringliteral">&quot;trueCond&quot;</span>)</div>
<div class="line">  );</div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ae56a1974283c9a2cb2410008e32fe3f1"><div class="ttname"><a href="#ae56a1974283c9a2cb2410008e32fe3f1">clang::ast_matchers::anyOf</a></div><div class="ttdeci">const internal::VariadicOperatorMatcherFunc&lt; 2, std::numeric_limits&lt; unsigned &gt;::max()&gt; anyOf</div><div class="ttdoc">Matches if any of the given matchers matches.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00964">ASTMatchersInternal.cpp:964</a></div></div>
</div><!-- fragment --><p>The with() chain-call accepts zero or more matchers which are combined as-if with <a class="el" href="#ab7f7f0b785ca07327256931286ebc99f" title="Matches if all given matchers match.">allOf()</a> in each of the node matchers. Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02752">2752</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a6e076c5e724f5522f9c51ffdc6dddf89" name="a6e076c5e724f5522f9c51ffdc6dddf89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e076c5e724f5522f9c51ffdc6dddf89">&#9670;&#160;</a></span>match() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatcherT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt; clang::ast_matchers::match </td>
          <td>(</td>
          <td class="paramtype">MatcherT</td>          <td class="paramname"><span class="paramname"><em>Matcher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the results of matching <code>Matcher</code> on the translation unit of <code>Context</code> and collects the <code><a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html" title="Maps string IDs to AST nodes matched by parts of a matcher.">BoundNodes</a></code> of all callback invocations. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchFinder_8h_source.html#l00305">305</a> of file <a class="el" href="ASTMatchFinder_8h_source.html">ASTMatchFinder.h</a>.</p>

</div>
</div>
<a id="a6eef98a03801d29f261611aef6b48f0f" name="a6eef98a03801d29f261611aef6b48f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eef98a03801d29f261611aef6b48f0f">&#9670;&#160;</a></span>match() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatcherT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt; clang::ast_matchers::match </td>
          <td>(</td>
          <td class="paramtype">MatcherT</td>          <td class="paramname"><span class="paramname"><em>Matcher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DynTypedNode.html">DynTypedNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchFinder_8h_source.html#l00288">288</a> of file <a class="el" href="ASTMatchFinder_8h_source.html">ASTMatchFinder.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a58409ce605d979d1d1e0a600ec417a0a" name="a58409ce605d979d1d1e0a600ec417a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58409ce605d979d1d1e0a600ec417a0a">&#9670;&#160;</a></span>match() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatcherT , typename NodeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt; clang::ast_matchers::match </td>
          <td>(</td>
          <td class="paramtype">MatcherT</td>          <td class="paramname"><span class="paramname"><em>Matcher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeT &amp;</td>          <td class="paramname"><span class="paramname"><em>Node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the results of matching <code>Matcher</code> on <code>Node</code>. </p>
<p>Collects the <code><a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html" title="Maps string IDs to AST nodes matched by parts of a matcher.">BoundNodes</a></code> of all callback invocations when matching <code>Matcher</code> on <code>Node</code> and returns the collected results.</p>
<p>Multiple results occur when using matchers like <code>forEachDescendant</code>, which generate a result for each sub-match.</p>
<p>If you want to find all matches on the sub-tree rooted at <code>Node</code> (rather than only the matches on <code>Node</code> itself), surround the <code>Matcher</code> with a <code><a class="el" href="#ad2d86a586c37bb32b5dff391714953ed" title="Matches if the node or any descendant matches.">findAll()</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a89709e44a7ac7799bcec565b520b84d2" title="Returns the first result of type NodeT bound to BoundTo.">selectFirst</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ASTMatchFinder_8h_source.html#l00299">299</a> of file <a class="el" href="ASTMatchFinder_8h_source.html">ASTMatchFinder.h</a>.</p>

<p class="reference">References <a class="el" href="ASTTypeTraits_8h_source.html#l00237">clang::DynTypedNode::create()</a>, <a class="el" href="ASTMatchFinder_8h_source.html#l00299">match()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaDeclObjC_8cpp_source.html#l03965">clang::Sema::ActOnAtEnd()</a>, <a class="el" href="SemaExprCXX_8cpp_source.html#l03409">clang::Sema::ActOnCXXDelete()</a>, <a class="el" href="ObjCMT_8cpp_source.html#l01132">AttributesMatch()</a>, <a class="el" href="ObjCMT_8cpp_source.html#l00602">ClassImplementsAllMethodsAndProperties()</a>, <a class="el" href="HeaderIncludes_8cpp_source.html#l00208">clang::tooling::IncludeCategoryManager::getIncludePriority()</a>, <a class="el" href="HeaderIncludes_8cpp_source.html#l00221">clang::tooling::IncludeCategoryManager::getSortIncludePriority()</a>, <a class="el" href="LoopWidening_8cpp_source.html#l00044">clang::ento::getWidenedLoopState()</a>, <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00162">clang::ento::isPossiblyEscaped()</a>, <a class="el" href="RetainSummaryManager_8cpp_source.html#l00140">isSubclass()</a>, <a class="el" href="ASTMatchFinder_8h_source.html#l00299">match()</a>, <a class="el" href="ObjCMT_8cpp_source.html#l01103">MatchTwoAttributeLists()</a>, <a class="el" href="ASTContext_8cpp_source.html#l08664">clang::ASTContext::ObjCQualifiedClassTypesAreCompatible()</a>, <a class="el" href="ASTContext_8cpp_source.html#l08682">clang::ASTContext::ObjCQualifiedIdTypesAreCompatible()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l00435">potentiallyWritesIntoIvar()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00209">clang::ento::shouldCompletelyUnroll()</a>, and <a class="el" href="SemaDeclObjC_8cpp_source.html#l02608">clang::Sema::WarnExactTypedMethods()</a>.</p>

</div>
</div>
<a id="a9b18aa6615181bd14a336f56bef00a95" name="a9b18aa6615181bd14a336f56bef00a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b18aa6615181bd14a336f56bef00a95">&#9670;&#160;</a></span>matchDynamic() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt; clang::ast_matchers::matchDynamic </td>
          <td>(</td>
          <td class="paramtype">internal::DynTypedMatcher</td>          <td class="paramname"><span class="paramname"><em>Matcher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Context</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchFinder_8h_source.html#l00331">331</a> of file <a class="el" href="ASTMatchFinder_8h_source.html">ASTMatchFinder.h</a>.</p>

</div>
</div>
<a id="ab666f10013e666080d4e4e89a6f8720e" name="ab666f10013e666080d4e4e89a6f8720e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab666f10013e666080d4e4e89a6f8720e">&#9670;&#160;</a></span>matchDynamic() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt; clang::ast_matchers::matchDynamic </td>
          <td>(</td>
          <td class="paramtype">internal::DynTypedMatcher</td>          <td class="paramname"><span class="paramname"><em>Matcher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DynTypedNode.html">DynTypedNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Context</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchFinder_8h_source.html#l00314">314</a> of file <a class="el" href="ASTMatchFinder_8h_source.html">ASTMatchFinder.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchFinder_8h_source.html#l00324">matchDynamic()</a>.</p>

</div>
</div>
<a id="a50863fce9ec1a5a6825dcd61fc3e3b94" name="a50863fce9ec1a5a6825dcd61fc3e3b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50863fce9ec1a5a6825dcd61fc3e3b94">&#9670;&#160;</a></span>matchDynamic() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt; clang::ast_matchers::matchDynamic </td>
          <td>(</td>
          <td class="paramtype">internal::DynTypedMatcher</td>          <td class="paramname"><span class="paramname"><em>Matcher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeT &amp;</td>          <td class="paramname"><span class="paramname"><em>Node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchFinder_8h_source.html#l00324">324</a> of file <a class="el" href="ASTMatchFinder_8h_source.html">ASTMatchFinder.h</a>.</p>

<p class="reference">References <a class="el" href="ASTTypeTraits_8h_source.html#l00237">clang::DynTypedNode::create()</a>, <a class="el" href="ASTMatchFinder_8h_source.html#l00314">matchDynamic()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a89709e44a7ac7799bcec565b520b84d2" name="a89709e44a7ac7799bcec565b520b84d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89709e44a7ac7799bcec565b520b84d2">&#9670;&#160;</a></span>selectFirst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const NodeT * clang::ast_matchers::selectFirst </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>BoundTo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Results</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first result of type <code>NodeT</code> bound to <code>BoundTo</code>. </p>
<p>Returns <code>NULL</code> if there is no match, or if the matching node cannot be casted to <code>NodeT</code>.</p>
<p>This is useful in combanation with <code><a class="el" href="#a58409ce605d979d1d1e0a600ec417a0a" title="Returns the results of matching Matcher on Node.">match()</a></code>: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classclang_1_1Decl.html">Decl</a> *D = <a class="code hl_function" href="#a89709e44a7ac7799bcec565b520b84d2">selectFirst&lt;Decl&gt;</a>(<span class="stringliteral">&quot;id&quot;</span>, <a class="code hl_function" href="#a58409ce605d979d1d1e0a600ec417a0a">match</a>(Matcher.bind(<span class="stringliteral">&quot;id&quot;</span>),</div>
<div class="line">                                              <a class="code hl_variable" href="ASTMatchFinder_8cpp.html#a32ca2adfad3611927e87efc253e7b7b1">Node</a>, Context));</div>
<div class="ttc" id="aASTMatchFinder_8cpp_html_a32ca2adfad3611927e87efc253e7b7b1"><div class="ttname"><a href="ASTMatchFinder_8cpp.html#a32ca2adfad3611927e87efc253e7b7b1">Node</a></div><div class="ttdeci">DynTypedNode Node</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchFinder_8cpp_source.html#l00067">ASTMatchFinder.cpp:67</a></div></div>
<div class="ttc" id="aclassclang_1_1Decl_html"><div class="ttname"><a href="classclang_1_1Decl.html">clang::Decl</a></div><div class="ttdoc">Decl - This represents one declaration (or definition), e.g.</div><div class="ttdef"><b>Definition</b> <a href="DeclBase_8h_source.html#l00089">DeclBase.h:89</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a58409ce605d979d1d1e0a600ec417a0a"><div class="ttname"><a href="#a58409ce605d979d1d1e0a600ec417a0a">clang::ast_matchers::match</a></div><div class="ttdeci">SmallVector&lt; BoundNodes, 1 &gt; match(MatcherT Matcher, const NodeT &amp;Node, ASTContext &amp;Context)</div><div class="ttdoc">Returns the results of matching Matcher on Node.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchFinder_8h_source.html#l00299">ASTMatchFinder.h:299</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a89709e44a7ac7799bcec565b520b84d2"><div class="ttname"><a href="#a89709e44a7ac7799bcec565b520b84d2">clang::ast_matchers::selectFirst</a></div><div class="ttdeci">const NodeT * selectFirst(StringRef BoundTo, const SmallVectorImpl&lt; BoundNodes &gt; &amp;Results)</div><div class="ttdoc">Returns the first result of type NodeT bound to BoundTo.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchFinder_8h_source.html#l00269">ASTMatchFinder.h:269</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchFinder_8h_source.html#l00269">269</a> of file <a class="el" href="ASTMatchFinder_8h_source.html">ASTMatchFinder.h</a>.</p>

<p class="reference">References <a class="el" href="BuildTree_8cpp_source.html#l01562">N</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>.</p>

</div>
</div>
<a id="a84b8656432877e43a7d14fc722c12383" name="a84b8656432877e43a7d14fc722c12383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b8656432877e43a7d14fc722c12383">&#9670;&#160;</a></span>sizeOfExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt; clang::ast_matchers::sizeOfExpr </td>
          <td>(</td>
          <td class="paramtype">const internal::Matcher&lt; <a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InnerMatcher</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as unaryExprOrTypeTraitExpr, but only matching sizeof. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02873">2873</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00967">allOf</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00794">stmt</a>, and <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00773">unaryExprOrTypeTraitExpr</a>.</p>

</div>
</div>
<a id="a62500923b2d8d2cfa607f4c2526aec1c" name="a62500923b2d8d2cfa607f4c2526aec1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62500923b2d8d2cfa607f4c2526aec1c">&#9670;&#160;</a></span>traverse() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename ToArg, typename FromArg &gt; class ArgumentAdapterT, typename T , typename ToTypes &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::TraversalWrapper&lt; internal::ArgumentAdaptingMatcherFuncAdaptor&lt; ArgumentAdapterT, T, ToTypes &gt; &gt; clang::ast_matchers::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a></td>          <td class="paramname"><span class="paramname"><em>TK</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const internal::ArgumentAdaptingMatcherFuncAdaptor&lt; ArgumentAdapterT, T, ToTypes &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InnerMatcher</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00821">821</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a9ebeafc3d90355e2bf42cdc4e882d16f" name="a9ebeafc3d90355e2bf42cdc4e882d16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ebeafc3d90355e2bf42cdc4e882d16f">&#9670;&#160;</a></span>traverse() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::BindableMatcher&lt; T &gt; clang::ast_matchers::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a></td>          <td class="paramname"><span class="paramname"><em>TK</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const internal::BindableMatcher&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InnerMatcher</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00801">801</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="abceee755f615e6fc0cd081dfe7186810" name="abceee755f615e6fc0cd081dfe7186810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abceee755f615e6fc0cd081dfe7186810">&#9670;&#160;</a></span>traverse() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::Matcher&lt; typename internal::GetClade&lt; T... &gt;::Type &gt; clang::ast_matchers::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a></td>          <td class="paramname"><span class="paramname"><em>TK</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const internal::MapAnyOfHelper&lt; T... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InnerMatcher</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00852">852</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchers_8h_source.html#l00791">traverse()</a>.</p>

</div>
</div>
<a id="ac24cf70324e1c82a857cd095e2d535fc" name="ac24cf70324e1c82a857cd095e2d535fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24cf70324e1c82a857cd095e2d535fc">&#9670;&#160;</a></span>traverse() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::Matcher&lt; T &gt; clang::ast_matchers::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a></td>          <td class="paramname"><span class="paramname"><em>TK</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const internal::Matcher&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InnerMatcher</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes all nested matchers to be matched with the specified traversal kind. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> i = 3.0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The matcher </p><div class="fragment"><div class="line"><a class="code hl_function" href="#ac24cf70324e1c82a857cd095e2d535fc">traverse</a>(<a class="code hl_enumvalue" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058afd4a878609d940f0f79ddb010c3ad92d">TK_IgnoreUnlessSpelledInSource</a>,</div>
<div class="line">  <a class="code hl_variable" href="#a056e81429237736b6458df18bb538c82">varDecl</a>(hasInitializer(<a class="code hl_variable" href="#a4a4e38c6224c16252040dc697a6af832">floatLiteral</a>().bind(<span class="stringliteral">&quot;init&quot;</span>)))</div>
<div class="line">)</div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a4a4e38c6224c16252040dc697a6af832"><div class="ttname"><a href="#a4a4e38c6224c16252040dc697a6af832">clang::ast_matchers::floatLiteral</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, FloatingLiteral &gt; floatLiteral</div><div class="ttdoc">Matches float literals of all sizes / encodings, e.g.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00906">ASTMatchersInternal.cpp:906</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ac24cf70324e1c82a857cd095e2d535fc"><div class="ttname"><a href="#ac24cf70324e1c82a857cd095e2d535fc">clang::ast_matchers::traverse</a></div><div class="ttdeci">internal::Matcher&lt; T &gt; traverse(TraversalKind TK, const internal::Matcher&lt; T &gt; &amp;InnerMatcher)</div><div class="ttdoc">Causes all nested matchers to be matched with the specified traversal kind.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchers_8h_source.html#l00791">ASTMatchers.h:791</a></div></div>
<div class="ttc" id="anamespaceclang_html_a6196a82dc53119822ac96e34a9726058afd4a878609d940f0f79ddb010c3ad92d"><div class="ttname"><a href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058afd4a878609d940f0f79ddb010c3ad92d">clang::TK_IgnoreUnlessSpelledInSource</a></div><div class="ttdeci">@ TK_IgnoreUnlessSpelledInSource</div><div class="ttdoc">Ignore AST nodes not written in the source.</div><div class="ttdef"><b>Definition</b> <a href="ASTTypeTraits_8h_source.html#l00045">ASTTypeTraits.h:44</a></div></div>
</div><!-- fragment --><p> matches the variable declaration with "init" bound to the "3.0". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00791">791</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tree_8cpp_source.html#l00306">clang::syntax::Node::assertInvariantsRecursive()</a>, <a class="el" href="ThreadSafety_8cpp_source.html#l01137">clang::threadSafety::BeforeSet::checkBeforeAfter()</a>, <a class="el" href="Tree_8cpp_source.html#l00257">clang::syntax::Node::dumpTokens()</a>, and <a class="el" href="ASTMatchers_8h_source.html#l00852">traverse()</a>.</p>

</div>
</div>
<a id="a301884494a34a99d91d8ed6b987d8ce6" name="a301884494a34a99d91d8ed6b987d8ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301884494a34a99d91d8ed6b987d8ce6">&#9670;&#160;</a></span>traverse() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename T, typename P1 &gt; class MatcherT, typename P1 , typename ReturnTypesF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::TraversalWrapper&lt; internal::PolymorphicMatcherWithParam1&lt; MatcherT, P1, ReturnTypesF &gt; &gt; clang::ast_matchers::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a></td>          <td class="paramname"><span class="paramname"><em>TK</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const internal::PolymorphicMatcherWithParam1&lt; MatcherT, P1, ReturnTypesF &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InnerMatcher</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00832">832</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a21a783f24f557b1ca228108ca71d10ad" name="a21a783f24f557b1ca228108ca71d10ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a783f24f557b1ca228108ca71d10ad">&#9670;&#160;</a></span>traverse() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename T, typename P1, typename P2 &gt; class MatcherT, typename P1 , typename P2 , typename ReturnTypesF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::TraversalWrapper&lt; internal::PolymorphicMatcherWithParam2&lt; MatcherT, P1, P2, ReturnTypesF &gt; &gt; clang::ast_matchers::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a></td>          <td class="paramname"><span class="paramname"><em>TK</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const internal::PolymorphicMatcherWithParam2&lt; MatcherT, P1, P2, ReturnTypesF &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InnerMatcher</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00843">843</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a873ebf9fb40f9c5b2f2f51d3e4cd2ca1" name="a873ebf9fb40f9c5b2f2f51d3e4cd2ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873ebf9fb40f9c5b2f2f51d3e4cd2ca1">&#9670;&#160;</a></span>traverse() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::TraversalWrapper&lt; internal::VariadicOperatorMatcher&lt; T... &gt; &gt; clang::ast_matchers::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a></td>          <td class="paramname"><span class="paramname"><em>TK</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const internal::VariadicOperatorMatcher&lt; T... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InnerMatcher</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00811">811</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7acfa3a6a57ccd2484a71e0f1bbe9c09" name="a7acfa3a6a57ccd2484a71e0f1bbe9c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acfa3a6a57ccd2484a71e0f1bbe9c09">&#9670;&#160;</a></span>accessSpecDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1AccessSpecDecl.html">AccessSpecDecl</a> &gt; clang::ast_matchers::accessSpecDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ access specifier declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">int</span> a;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <a class="el" href="#a7acfa3a6a57ccd2484a71e0f1bbe9c09" title="Matches C++ access specifier declarations.">accessSpecDecl()</a> matches 'public:' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00757">757</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a32844cb1d9bb3605e13b8bed8092cc14" name="a32844cb1d9bb3605e13b8bed8092cc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32844cb1d9bb3605e13b8bed8092cc14">&#9670;&#160;</a></span>addrLabelExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a> &gt; clang::ast_matchers::addrLabelExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches address of label statements (GNU extension). </p>
<p>Given </p><div class="fragment"><div class="line">FOO: bar();</div>
<div class="line"><span class="keywordtype">void</span> *ptr = &amp;&amp;FOO;</div>
<div class="line"><span class="keywordflow">goto</span> *bar;</div>
</div><!-- fragment --><p> <a class="el" href="#a32844cb1d9bb3605e13b8bed8092cc14" title="Matches address of label statements (GNU extension).">addrLabelExpr()</a> matches '&amp;&amp;FOO' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00888">888</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab7f7f0b785ca07327256931286ebc99f" name="ab7f7f0b785ca07327256931286ebc99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f7f0b785ca07327256931286ebc99f">&#9670;&#160;</a></span>allOf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicOperatorMatcherFunc&lt; 2, std::numeric_limits&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;<a class="el" href="____clang__cuda__math_8h.html#ae6bb573e13e3bd5738c8faa552b6a129">::max</a>()&gt; clang::ast_matchers::allOf = {internal::DynTypedMatcher::VO_AllOf}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if all given matchers match. </p>
<p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00967">967</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l02864">alignOfExpr()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00112">clang::ento::assignedToRef()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00139">clang::ento::forLoopMatcher()</a>, and <a class="el" href="ASTMatchers_8h_source.html#l02873">sizeOfExpr()</a>.</p>

</div>
</div>
<a id="ae56a1974283c9a2cb2410008e32fe3f1" name="ae56a1974283c9a2cb2410008e32fe3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56a1974283c9a2cb2410008e32fe3f1">&#9670;&#160;</a></span>anyOf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicOperatorMatcherFunc&lt; 2, std::numeric_limits&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;<a class="el" href="____clang__cuda__math_8h.html#ae6bb573e13e3bd5738c8faa552b6a129">::max</a>()&gt; clang::ast_matchers::anyOf = {internal::DynTypedMatcher::VO_AnyOf}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if any of the given matchers matches. </p>
<p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00964">964</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l02864">alignOfExpr()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00112">clang::ento::assignedToRef()</a>, <a class="el" href="ASTMatchers_8h_source.html#l03971">AST_MATCHER_P_OVERLOAD()</a>, <a class="el" href="ASTMatchers_8h_source.html#l03963">AST_MATCHER_P_OVERLOAD()</a>, <a class="el" href="ASTMatchers_8h_source.html#l04569">AST_POLYMORPHIC_MATCHER_P2()</a>, <a class="el" href="ASTMatchers_8h_source.html#l04630">AST_POLYMORPHIC_MATCHER_P2()</a>, <a class="el" href="ASTMatchers_8h_source.html#l03155">AST_POLYMORPHIC_MATCHER_P_OVERLOAD()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00094">clang::ento::changeIntBoundNode()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00139">clang::ento::forLoopMatcher()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00127">clang::ento::hasSuspiciousStmt()</a>, <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00162">clang::ento::isPossiblyEscaped()</a>, and <a class="el" href="LoopUnrolling_8cpp_source.html#l00082">clang::ento::simpleCondition()</a>.</p>

</div>
</div>
<a id="a770b1eeabaf13b5ab1547634f8fef742" name="a770b1eeabaf13b5ab1547634f8fef742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770b1eeabaf13b5ab1547634f8fef742">&#9670;&#160;</a></span>arraySubscriptExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ArraySubscriptExpr.html">ArraySubscriptExpr</a> &gt; clang::ast_matchers::arraySubscriptExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches array subscript expressions. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = a[1];</div>
</div><!-- fragment --><p> <a class="el" href="#a770b1eeabaf13b5ab1547634f8fef742" title="Matches array subscript expressions.">arraySubscriptExpr()</a> matches "a[1]" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00866">866</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a718f2e541f79e142d30c8f2911b5ef97" name="a718f2e541f79e142d30c8f2911b5ef97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718f2e541f79e142d30c8f2911b5ef97">&#9670;&#160;</a></span>arrayType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1ArrayType.html">ArrayType</a>&gt; clang::ast_matchers::arrayType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01008">1008</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SwiftCallingConv_8cpp_source.html#l00063">clang::CodeGen::swiftcall::SwiftAggLowering::addTypedData()</a>, <a class="el" href="CGExpr_8cpp_source.html#l03645">emitArraySubscriptGEP()</a>, <a class="el" href="CGDecl_8cpp_source.html#l02265">emitPartialArrayDestroy()</a>, <a class="el" href="Type_8h_source.html#l07095">clang::Type::getBaseElementTypeUnsafe()</a>, <a class="el" href="ASTContext_8cpp_source.html#l01686">clang::ASTContext::getDeclAlign()</a>, <a class="el" href="CFG_8cpp_source.html#l04999">clang::CFGImplicitDtor::getDestructorDecl()</a>, and <a class="el" href="SemaInit_8cpp_source.html#l00136">IsStringInit()</a>.</p>

</div>
</div>
<a id="a4329ae4c7c6f153f7529aab870ffec8b" name="a4329ae4c7c6f153f7529aab870ffec8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4329ae4c7c6f153f7529aab870ffec8b">&#9670;&#160;</a></span>asmStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1AsmStmt.html">AsmStmt</a> &gt; clang::ast_matchers::asmStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches asm statements. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> i = 100;</div>
<div class="line"> __asm(<span class="stringliteral">&quot;mov al, 2&quot;</span>);</div>
</div><!-- fragment --><p> <a class="el" href="#a4329ae4c7c6f153f7529aab870ffec8b" title="Matches asm statements.">asmStmt()</a> matches '__asm("mov al, 2")' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00898">898</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2fc5672f38513ca660c5c383e958cec0" name="a2fc5672f38513ca660c5c383e958cec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc5672f38513ca660c5c383e958cec0">&#9670;&#160;</a></span>atomicExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1AtomicExpr.html">AtomicExpr</a> &gt; clang::ast_matchers::atomicExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches atomic builtins. </p>
<p>Example matches __atomic_load_n(ptr, 1) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo() { <span class="keywordtype">int</span> *ptr; __atomic_load_n(ptr, 1); }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00920">920</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="acc4fec1590628a5b59ac12297cdf44de" name="acc4fec1590628a5b59ac12297cdf44de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4fec1590628a5b59ac12297cdf44de">&#9670;&#160;</a></span>atomicType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1AtomicType.html">AtomicType</a>&gt; clang::ast_matchers::atomicType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01016">1016</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SwiftCallingConv_8cpp_source.html#l00063">clang::CodeGen::swiftcall::SwiftAggLowering::addTypedData()</a>.</p>

</div>
</div>
<a id="a4b4d2e026596dc3bea52f83878ebc1a7" name="a4b4d2e026596dc3bea52f83878ebc1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4d2e026596dc3bea52f83878ebc1a7">&#9670;&#160;</a></span>autoreleasePoolStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAutoreleasePoolStmt.html">ObjCAutoreleasePoolStmt</a> &gt; clang::ast_matchers::autoreleasePoolStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches an Objective-C autorelease pool statement. </p>
<p>Given </p><div class="fragment"><div class="line">@autoreleasepool {</div>
<div class="line">  <span class="keywordtype">int</span> x = 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="el" href="#a4b4d2e026596dc3bea52f83878ebc1a7" title="Matches an Objective-C autorelease pool statement.">autoreleasePoolStmt(stmt())</a> matches the declaration of "x" inside the autorelease pool. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00725">725</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a900caa094a8fe83b37dd058e73246c67" name="a900caa094a8fe83b37dd058e73246c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900caa094a8fe83b37dd058e73246c67">&#9670;&#160;</a></span>autoType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1AutoType.html">AutoType</a>&gt; clang::ast_matchers::autoType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01017">1017</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aa466a1e59dbf5a8785b2561a308ae4fb" name="aa466a1e59dbf5a8785b2561a308ae4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa466a1e59dbf5a8785b2561a308ae4fb">&#9670;&#160;</a></span>binaryConditionalOperator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1BinaryConditionalOperator.html">BinaryConditionalOperator</a> &gt; clang::ast_matchers::binaryConditionalOperator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches binary conditional operator expressions (GNU extension). </p>
<p>Example matches a ?: b </p><div class="fragment"><div class="line">(a ?: <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) + 42;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00931">931</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a76efced611335bad85d3da6fe6ae790e" name="a76efced611335bad85d3da6fe6ae790e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76efced611335bad85d3da6fe6ae790e">&#9670;&#160;</a></span>binaryOperation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::MapAnyOfMatcher&lt; <a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a> &gt; clang::ast_matchers::binaryOperation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches nodes which can be used with binary operators. </p>
<p>The code </p><div class="fragment"><div class="line">var1 != var2;</div>
</div><!-- fragment --><p> might be represented in the clang AST as a binaryOperator, a cxxOperatorCallExpr or a cxxRewrittenBinaryOperator, depending on</p>
<ul>
<li>whether the types of var1 and var2 are fundamental (binaryOperator) or at least one is a class type (cxxOperatorCallExpr)</li>
<li>whether the code appears in a template declaration, if at least one of the vars is a dependent-type (binaryOperator)</li>
<li>whether the code relies on a rewritten binary operator, such as a spaceship operator or an inverted equality operator (cxxRewrittenBinaryOperator)</li>
</ul>
<p>This matcher elides details in places where the matchers for the nodes are compatible.</p>
<p>Given </p><div class="fragment"><div class="line"><a class="code hl_variable" href="#a76efced611335bad85d3da6fe6ae790e">binaryOperation</a>(</div>
<div class="line">  hasOperatorName(<span class="stringliteral">&quot;!=&quot;</span>),</div>
<div class="line">  hasLHS(<a class="code hl_variable" href="#adfc0ccd398780d345e2c541cc716cc66">expr</a>().bind(<span class="stringliteral">&quot;lhs&quot;</span>)),</div>
<div class="line">  hasRHS(<a class="code hl_variable" href="#adfc0ccd398780d345e2c541cc716cc66">expr</a>().bind(<span class="stringliteral">&quot;rhs&quot;</span>))</div>
<div class="line">)</div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a76efced611335bad85d3da6fe6ae790e"><div class="ttname"><a href="#a76efced611335bad85d3da6fe6ae790e">clang::ast_matchers::binaryOperation</a></div><div class="ttdeci">const internal::MapAnyOfMatcher&lt; BinaryOperator, CXXOperatorCallExpr, CXXRewrittenBinaryOperator &gt; binaryOperation</div><div class="ttdoc">Matches nodes which can be used with binary operators.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00926">ASTMatchersInternal.cpp:926</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_adfc0ccd398780d345e2c541cc716cc66"><div class="ttname"><a href="#adfc0ccd398780d345e2c541cc716cc66">clang::ast_matchers::expr</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, Expr &gt; expr</div><div class="ttdoc">Matches expressions.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00873">ASTMatchersInternal.cpp:873</a></div></div>
</div><!-- fragment --><p> matches each use of "!=" in: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>S{</div>
<div class="line">    <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> S&amp;) <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> foo()</div>
<div class="line">{</div>
<div class="line">   1 != 2;</div>
<div class="line">   S() != S();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> templ()</div>
<div class="line">{</div>
<div class="line">   1 != 2;</div>
<div class="line">   T() != S();</div>
<div class="line">}</div>
<div class="line"><span class="keyword">struct </span>HasOpEq</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code hl_function" href="namespaceclang.html#a4a57f21b55a81cefae4379e09a3be0c3">operator==</a>(<span class="keyword">const</span> HasOpEq &amp;) <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> inverse()</div>
<div class="line">{</div>
<div class="line">    HasOpEq s1;</div>
<div class="line">    HasOpEq s2;</div>
<div class="line">    <span class="keywordflow">if</span> (s1 != s2)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>HasSpaceship</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> operator&lt;=&gt;(<span class="keyword">const</span> HasOpEq &amp;) <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> use_spaceship()</div>
<div class="line">{</div>
<div class="line">    HasSpaceship s1;</div>
<div class="line">    HasSpaceship s2;</div>
<div class="line">    <span class="keywordflow">if</span> (s1 != s2)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceclang_html_a4a57f21b55a81cefae4379e09a3be0c3"><div class="ttname"><a href="namespaceclang.html#a4a57f21b55a81cefae4379e09a3be0c3">clang::operator==</a></div><div class="ttdeci">bool operator==(const CallGraphNode::CallRecord &amp;LHS, const CallGraphNode::CallRecord &amp;RHS)</div><div class="ttdef"><b>Definition</b> <a href="CallGraph_8h_source.html#l00207">CallGraph.h:207</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00926">926</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a92d236ec1064f604664b1e9123249e01" name="a92d236ec1064f604664b1e9123249e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d236ec1064f604664b1e9123249e01">&#9670;&#160;</a></span>binaryOperator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a> &gt; clang::ast_matchers::binaryOperator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches binary operator expressions. </p>
<p>Example matches a || b </p><div class="fragment"><div class="line">!(a || <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>)</div>
</div><!-- fragment --><p> See also the <a class="el" href="#a76efced611335bad85d3da6fe6ae790e" title="Matches nodes which can be used with binary operators.">binaryOperation()</a> matcher for more-general matching. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00923">923</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00094">clang::ento::changeIntBoundNode()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00139">clang::ento::forLoopMatcher()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l00435">potentiallyWritesIntoIvar()</a>, and <a class="el" href="LoopUnrolling_8cpp_source.html#l00082">clang::ento::simpleCondition()</a>.</p>

</div>
</div>
<a id="aeba4cdc11e5f93571b6b2107d4a9030e" name="aeba4cdc11e5f93571b6b2107d4a9030e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba4cdc11e5f93571b6b2107d4a9030e">&#9670;&#160;</a></span>blockDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1BlockDecl.html">BlockDecl</a> &gt; clang::ast_matchers::blockDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches block declarations. </p>
<p>Example matches the declaration of the nameless block printing an input integer.</p>
<div class="fragment"><div class="line">myFunc(^(<span class="keywordtype">int</span> p) {</div>
<div class="line">  <a class="code hl_function" href="opencl-c_8h.html#a1b66ea7b0c0b95a8154b5c0641848db6">printf</a>(<span class="stringliteral">&quot;%d&quot;</span>, p);</div>
<div class="line">})</div>
<div class="ttc" id="aopencl-c_8h_html_a1b66ea7b0c0b95a8154b5c0641848db6"><div class="ttname"><a href="opencl-c_8h.html#a1b66ea7b0c0b95a8154b5c0641848db6">printf</a></div><div class="ttdeci">int printf(__constant const char *st,...) __attribute__((format(printf</div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00820">820</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGDebugInfo_8cpp_source.html#l04479">clang::CodeGen::CGDebugInfo::EmitDeclareOfBlockLiteralArgVariable()</a>.</p>

</div>
</div>
<a id="a9731ff0864f46a3fb06e34554ae54cb8" name="a9731ff0864f46a3fb06e34554ae54cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9731ff0864f46a3fb06e34554ae54cb8">&#9670;&#160;</a></span>blockExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1BlockExpr.html">BlockExpr</a> &gt; clang::ast_matchers::blockExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a reference to a block. </p>
<p>Example: matches "^{}": </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() { ^{}(); }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00876">876</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a4c675c1451aa325c70a5608b974c96ae" name="a4c675c1451aa325c70a5608b974c96ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c675c1451aa325c70a5608b974c96ae">&#9670;&#160;</a></span>blockPointerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1BlockPointerType.html">BlockPointerType</a>&gt; clang::ast_matchers::blockPointerType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01022">1022</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a3570a0e97bc3258e6b063729994e791f" name="a3570a0e97bc3258e6b063729994e791f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3570a0e97bc3258e6b063729994e791f">&#9670;&#160;</a></span>breakStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1BreakStmt.html">BreakStmt</a> &gt; clang::ast_matchers::breakStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches break statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) { <span class="keywordflow">break</span>; }</div>
</div><!-- fragment --><p> <a class="el" href="#a3570a0e97bc3258e6b063729994e791f" title="Matches break statements.">breakStmt()</a> matches 'break' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00883">883</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2be6a43ee3ebdf93d13af0c726f1d739" name="a2be6a43ee3ebdf93d13af0c726f1d739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be6a43ee3ebdf93d13af0c726f1d739">&#9670;&#160;</a></span>builtinType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1BuiltinType.html">BuiltinType</a>&gt; clang::ast_matchers::builtinType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01007">1007</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a460801cda670b9a3ccc3d42f51f3bd5c" name="a460801cda670b9a3ccc3d42f51f3bd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460801cda670b9a3ccc3d42f51f3bd5c">&#9670;&#160;</a></span>callExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CallExpr.html">CallExpr</a> &gt; clang::ast_matchers::callExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches call expressions. </p>
<p>Example matches x.y() and y() </p><div class="fragment"><div class="line"><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> x;</div>
<div class="line">x.y();</div>
<div class="line">y();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00801">801</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaObjCProperty_8cpp_source.html#l01084">clang::Sema::ActOnPropertyImplDecl()</a>, <a class="el" href="ASTMatchers_8h_source.html#l03742">AST_MATCHER_P_OVERLOAD()</a>, <a class="el" href="ASTMatchers_8h_source.html#l04569">AST_POLYMORPHIC_MATCHER_P2()</a>, <a class="el" href="ASTMatchers_8h_source.html#l04630">AST_POLYMORPHIC_MATCHER_P2()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00105">clang::ento::callByRef()</a>, <a class="el" href="GtestMatchers_8cpp_source.html#l00089">gtestAssert()</a>, <a class="el" href="GtestMatchers_8cpp_source.html#l00096">gtestExpect()</a>, and <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>.</p>

</div>
</div>
<a id="a5725bf80823feea320c27f79c712e8f6" name="a5725bf80823feea320c27f79c712e8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5725bf80823feea320c27f79c712e8f6">&#9670;&#160;</a></span>caseStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CaseStmt.html">CaseStmt</a> &gt; clang::ast_matchers::caseStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches case statements inside switch statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">switch</span>(a) { <span class="keywordflow">case</span> 42: <span class="keywordflow">break</span>; <span class="keywordflow">default</span>: <span class="keywordflow">break</span>; }</div>
</div><!-- fragment --><p> <a class="el" href="#a5725bf80823feea320c27f79c712e8f6" title="Matches case statements inside switch statements.">caseStmt()</a> matches 'case 42:'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00891">891</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aee0910ccb567ed2465a935d7bd6831ed" name="aee0910ccb567ed2465a935d7bd6831ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0910ccb567ed2465a935d7bd6831ed">&#9670;&#160;</a></span>castExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CastExpr.html">CastExpr</a> &gt; clang::ast_matchers::castExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches any cast nodes of Clang's AST. </p>
<p>Example: <a class="el" href="#aee0910ccb567ed2465a935d7bd6831ed" title="Matches any cast nodes of Clang&#39;s AST.">castExpr()</a> matches each of the following: </p><div class="fragment"><div class="line">(<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>) 3;</div>
<div class="line"><span class="keyword">const_cast&lt;</span><a class="code hl_class" href="classclang_1_1Expr.html">Expr</a> *<span class="keyword">&gt;</span>(SubExpr);</div>
<div class="line"><span class="keywordtype">char</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> = 0;</div>
<div class="ttc" id="aclassclang_1_1Expr_html"><div class="ttname"><a href="classclang_1_1Expr.html">clang::Expr</a></div><div class="ttdoc">This represents one expression.</div><div class="ttdef"><b>Definition</b> <a href="Expr_8h_source.html#l00109">Expr.h:109</a></div></div>
</div><!-- fragment --><p> but does not match </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = (0);</div>
<div class="line"><span class="keywordtype">int</span> k = 0;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00950">950</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaExprObjC_8cpp_source.html#l03750">addFixitForObjCARCConversion()</a>, <a class="el" href="SemaExprObjC_8cpp_source.html#l04068">CheckObjCBridgeCFCast()</a>, <a class="el" href="SemaExprObjC_8cpp_source.html#l04002">CheckObjCBridgeNSCast()</a>, <a class="el" href="SemaExprObjC_8cpp_source.html#l04186">clang::Sema::CheckObjCBridgeRelatedCast()</a>, <a class="el" href="SemaExprObjC_8cpp_source.html#l04393">clang::Sema::CheckObjCConversion()</a>, <a class="el" href="SemaExprObjC_8cpp_source.html#l04136">clang::Sema::CheckTollFreeBridgeCast()</a>, <a class="el" href="SemaExprObjC_8cpp_source.html#l04207">clang::Sema::CheckTollFreeBridgeStaticCast()</a>, <a class="el" href="SemaExprObjC_8cpp_source.html#l04508">clang::Sema::diagnoseARCUnbridgedCast()</a>, <a class="el" href="SemaExprObjC_8cpp_source.html#l03870">diagnoseObjCARCConversion()</a>, and <a class="el" href="CGDecl_8cpp_source.html#l00678">tryEmitARCCopyWeakInit()</a>.</p>

</div>
</div>
<a id="ae2752fd9ce2d1e53440035178d4a0feb" name="ae2752fd9ce2d1e53440035178d4a0feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2752fd9ce2d1e53440035178d4a0feb">&#9670;&#160;</a></span>characterLiteral</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CharacterLiteral.html">CharacterLiteral</a> &gt; clang::ast_matchers::characterLiteral</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches character literals (also matches wchar_t). </p>
<p>Not matching Hex-encoded chars (e.g. 0x1234, which is a <a class="el" href="classclang_1_1IntegerLiteral.html">IntegerLiteral</a>), though.</p>
<p>Example matches 'a', L'a' </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> ch = <span class="charliteral">&#39;a&#39;</span>;</div>
<div class="line"><span class="keywordtype">wchar_t</span> chw = L<span class="charliteral">&#39;a&#39;</span>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00903">903</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab3d6075693f8e67b1a952da3fe26acaf" name="ab3d6075693f8e67b1a952da3fe26acaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d6075693f8e67b1a952da3fe26acaf">&#9670;&#160;</a></span>chooseExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ChooseExpr.html">ChooseExpr</a> &gt; clang::ast_matchers::chooseExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches GNU __builtin_choose_expr. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00916">916</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="afcdb6ae259330bdf0876aba6e07c8710" name="afcdb6ae259330bdf0876aba6e07c8710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdb6ae259330bdf0876aba6e07c8710">&#9670;&#160;</a></span>classTemplateDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ClassTemplateDecl.html">ClassTemplateDecl</a> &gt; clang::ast_matchers::classTemplateDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ class template declarations. </p>
<p>Example matches <code>Z</code> </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span>Z {};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00746">746</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a614a4778ab8392430ee9a0a28b7e9693" name="a614a4778ab8392430ee9a0a28b7e9693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614a4778ab8392430ee9a0a28b7e9693">&#9670;&#160;</a></span>classTemplatePartialSpecializationDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ClassTemplatePartialSpecializationDecl.html">ClassTemplatePartialSpecializationDecl</a> &gt; clang::ast_matchers::classTemplatePartialSpecializationDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ class template partial specializations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keywordtype">int</span> I&gt;</div>
<div class="line"><span class="keyword">class </span>A {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keywordtype">int</span> I&gt;</div>
<div class="line"><span class="keyword">class </span>A&lt;T, T*, I&gt; {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">class </span>A&lt;int, int, 1&gt; {};</div>
</div><!-- fragment --><p> <a class="el" href="#a614a4778ab8392430ee9a0a28b7e9693" title="Matches C++ class template partial specializations.">classTemplatePartialSpecializationDecl()</a> matches the specialization <code>A&lt;T,T*,I&gt;</code> but not <code>A&lt;int,int,1&gt;</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00752">752</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab81538ee441769591ce912334397e6b7" name="ab81538ee441769591ce912334397e6b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81538ee441769591ce912334397e6b7">&#9670;&#160;</a></span>classTemplateSpecializationDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a> &gt; clang::ast_matchers::classTemplateSpecializationDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ class template specializations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>A {};</div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class </span>A&lt;double&gt; {};</div>
<div class="line">A&lt;int&gt; a;</div>
</div><!-- fragment --><p> <a class="el" href="#ab81538ee441769591ce912334397e6b7" title="Matches C++ class template specializations.">classTemplateSpecializationDecl()</a> matches the specializations <code>A&lt;int&gt;</code> and <code>A&lt;double&gt;</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00749">749</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a7bf430f5b184451f864b0536db3494f0" name="a7bf430f5b184451f864b0536db3494f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf430f5b184451f864b0536db3494f0">&#9670;&#160;</a></span>complexType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1ComplexType.html">ComplexType</a>&gt; clang::ast_matchers::complexType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01009">1009</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SwiftCallingConv_8cpp_source.html#l00063">clang::CodeGen::swiftcall::SwiftAggLowering::addTypedData()</a>.</p>

</div>
</div>
<a id="adcac5ffe32ca0150ad183cbdc3d0f6c1" name="adcac5ffe32ca0150ad183cbdc3d0f6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcac5ffe32ca0150ad183cbdc3d0f6c1">&#9670;&#160;</a></span>compoundLiteralExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a> &gt; clang::ast_matchers::compoundLiteralExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches compound (i.e. </p>
<p>non-scalar) literals</p>
<p>Example match: {1}, (1, 2) </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> array[4] = {1};</div>
<div class="line">vector <span class="keywordtype">int</span> myvec = (vector <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(1, 2);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00913">913</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a496a3f466a3f754041e8a1cfd3aaf749" name="a496a3f466a3f754041e8a1cfd3aaf749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496a3f466a3f754041e8a1cfd3aaf749">&#9670;&#160;</a></span>compoundStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CompoundStmt.html">CompoundStmt</a> &gt; clang::ast_matchers::compoundStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches compound statements. </p>
<p>Example matches '{}' and '{{}}' in 'for (;;) {{}}' </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (;;) {{}}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00893">893</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ae471648f1de66bdde248ef4b1edae5e5" name="ae471648f1de66bdde248ef4b1edae5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae471648f1de66bdde248ef4b1edae5e5">&#9670;&#160;</a></span>conditionalOperator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ConditionalOperator.html">ConditionalOperator</a> &gt; clang::ast_matchers::conditionalOperator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches conditional operator expressions. </p>
<p>Example matches a ? b : c </p><div class="fragment"><div class="line">(a ? <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> : <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>) + 42</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00929">929</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>.</p>

</div>
</div>
<a id="aa71a954e32d97f8e6824bae9051b7853" name="aa71a954e32d97f8e6824bae9051b7853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71a954e32d97f8e6824bae9051b7853">&#9670;&#160;</a></span>constantArrayType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1ConstantArrayType.html">ConstantArrayType</a>&gt; clang::ast_matchers::constantArrayType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01010">1010</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a1636090af19685070c1f5183bce08909" name="a1636090af19685070c1f5183bce08909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1636090af19685070c1f5183bce08909">&#9670;&#160;</a></span>constantExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ConstantExpr.html">ConstantExpr</a> &gt; clang::ast_matchers::constantExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a constant expression wrapper. </p>
<p>Example matches the constant in the case statement: (matcher = <a class="el" href="#a1636090af19685070c1f5183bce08909" title="Matches a constant expression wrapper.">constantExpr()</a>) </p><div class="fragment"><div class="line"><span class="keywordflow">switch</span> (a) {</div>
<div class="line"><span class="keywordflow">case</span> 37: <span class="keywordflow">break</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00850">850</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="af901ad829d7e589a44f983a327351ebf" name="af901ad829d7e589a44f983a327351ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af901ad829d7e589a44f983a327351ebf">&#9670;&#160;</a></span>continueStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ContinueStmt.html">ContinueStmt</a> &gt; clang::ast_matchers::continueStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches continue statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) { <span class="keywordflow">continue</span>; }</div>
</div><!-- fragment --><p> <a class="el" href="#af901ad829d7e589a44f983a327351ebf" title="Matches continue statements.">continueStmt()</a> matches 'continue' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00884">884</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a0262eb3971f2f7649d0354cbddaaec73" name="a0262eb3971f2f7649d0354cbddaaec73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0262eb3971f2f7649d0354cbddaaec73">&#9670;&#160;</a></span>cStyleCastExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CStyleCastExpr.html">CStyleCastExpr</a> &gt; clang::ast_matchers::cStyleCastExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a C-style cast expression. </p>
<p>Example: Matches (int) 2.2f in </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>) 2.2f;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00945">945</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab3c320ec420f6590934c1a21e16d71ee" name="ab3c320ec420f6590934c1a21e16d71ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c320ec420f6590934c1a21e16d71ee">&#9670;&#160;</a></span>cudaKernelCallExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt;<a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CUDAKernelCallExpr.html">CUDAKernelCallExpr</a>&gt; clang::ast_matchers::cudaKernelCallExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01006">1006</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab78d0ccf6cfdd2460d9c4d5f7847605d" name="ab78d0ccf6cfdd2460d9c4d5f7847605d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78d0ccf6cfdd2460d9c4d5f7847605d">&#9670;&#160;</a></span>cxxBindTemporaryExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXBindTemporaryExpr.html">CXXBindTemporaryExpr</a> &gt; clang::ast_matchers::cxxBindTemporaryExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches nodes where temporaries are created. </p>
<p>Example matches FunctionTakesString(GetStringByValue()) (matcher = <a class="el" href="#ab78d0ccf6cfdd2460d9c4d5f7847605d" title="Matches nodes where temporaries are created.">cxxBindTemporaryExpr()</a>) </p><div class="fragment"><div class="line">FunctionTakesString(GetStringByValue());</div>
<div class="line">FunctionTakesStringByPointer(GetStringPointer());</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00858">858</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a409ccd26dc35075d52eef632d86bbf33" name="a409ccd26dc35075d52eef632d86bbf33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409ccd26dc35075d52eef632d86bbf33">&#9670;&#160;</a></span>cxxBoolLiteral</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a> &gt; clang::ast_matchers::cxxBoolLiteral</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches bool literals. </p>
<p>Example matches true </p><div class="fragment"><div class="line"><span class="keyword">true</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00900">900</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aed73db7e4f5258557e39edc7fc5168d0" name="aed73db7e4f5258557e39edc7fc5168d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed73db7e4f5258557e39edc7fc5168d0">&#9670;&#160;</a></span>cxxCatchStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXCatchStmt.html">CXXCatchStmt</a> &gt; clang::ast_matchers::cxxCatchStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches catch statements. </p>
<div class="fragment"><div class="line"><span class="keywordflow">try</span> {} <span class="keywordflow">catch</span>(<span class="keywordtype">int</span> i) {}</div>
</div><!-- fragment --><p> <a class="el" href="#aed73db7e4f5258557e39edc7fc5168d0" title="Matches catch statements.">cxxCatchStmt()</a> matches 'catch(int i)' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00894">894</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a704390715c62f500730acc8eb8133ee0" name="a704390715c62f500730acc8eb8133ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704390715c62f500730acc8eb8133ee0">&#9670;&#160;</a></span>cxxConstCastExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXConstCastExpr.html">CXXConstCastExpr</a> &gt; clang::ast_matchers::cxxConstCastExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a const_cast expression. </p>
<p>Example: Matches const_cast&lt;int*&gt;(&amp;r) in </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> n = 42;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> &amp;r(n);</div>
<div class="line"><span class="keywordtype">int</span>* p = <span class="keyword">const_cast&lt;</span><span class="keywordtype">int</span>*<span class="keyword">&gt;</span>(&amp;r);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00943">943</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab0da198b76c77bfd4737a339d5a78e33" name="ab0da198b76c77bfd4737a339d5a78e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0da198b76c77bfd4737a339d5a78e33">&#9670;&#160;</a></span>cxxConstructExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a> &gt; clang::ast_matchers::cxxConstructExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches constructor call expressions (including implicit ones). </p>
<p>Example matches string(ptr, n) and ptr within arguments of f (matcher = <a class="el" href="#ab0da198b76c77bfd4737a339d5a78e33" title="Matches constructor call expressions (including implicit ones).">cxxConstructExpr()</a>) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keyword">const</span> <span class="keywordtype">string</span> &amp;a, <span class="keyword">const</span> <span class="keywordtype">string</span> &amp;<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>);</div>
<div class="line"><span class="keywordtype">char</span> *ptr;</div>
<div class="line"><span class="keywordtype">int</span> n;</div>
<div class="line">f(<span class="keywordtype">string</span>(ptr, n), ptr);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00853">853</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l04569">AST_POLYMORPHIC_MATCHER_P2()</a>, and <a class="el" href="ASTMatchers_8h_source.html#l04630">AST_POLYMORPHIC_MATCHER_P2()</a>.</p>

</div>
</div>
<a id="a832104640e9b865d3d10cb779f59dbee" name="a832104640e9b865d3d10cb779f59dbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832104640e9b865d3d10cb779f59dbee">&#9670;&#160;</a></span>cxxConstructorDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a> &gt; clang::ast_matchers::cxxConstructorDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ constructor declarations. </p>
<p>Example matches Foo::Foo() and Foo::Foo(int) </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  Foo();</div>
<div class="line">  Foo(<span class="keywordtype">int</span>);</div>
<div class="line">  <span class="keywordtype">int</span> DoSomething();</div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00776">776</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l04569">AST_POLYMORPHIC_MATCHER_P2()</a>, and <a class="el" href="ASTMatchers_8h_source.html#l04630">AST_POLYMORPHIC_MATCHER_P2()</a>.</p>

</div>
</div>
<a id="a67d2f76b0d40efafcb16d997b1928f5b" name="a67d2f76b0d40efafcb16d997b1928f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d2f76b0d40efafcb16d997b1928f5b">&#9670;&#160;</a></span>cxxConversionDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXConversionDecl.html">CXXConversionDecl</a> &gt; clang::ast_matchers::cxxConversionDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches conversion operator declarations. </p>
<p>Example matches the operator. </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> { <span class="keyword">operator</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>() <span class="keyword">const</span>; };</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00785">785</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2d0414dac04ff22f5ebd022efd442d4e" name="a2d0414dac04ff22f5ebd022efd442d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0414dac04ff22f5ebd022efd442d4e">&#9670;&#160;</a></span>cxxCtorInitializer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a> &gt; clang::ast_matchers::cxxCtorInitializer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches constructor initializers. </p>
<p>Examples matches <code>i(42)</code>. </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {</div>
<div class="line">  C() : i(42) {}</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00758">758</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a400a7d8c9a439cb1c43dfa8ed4f6d5d7" name="a400a7d8c9a439cb1c43dfa8ed4f6d5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400a7d8c9a439cb1c43dfa8ed4f6d5d7">&#9670;&#160;</a></span>cxxDeductionGuideDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXDeductionGuideDecl.html">CXXDeductionGuideDecl</a> &gt; clang::ast_matchers::cxxDeductionGuideDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches user-defined and implicitly generated deduction guide. </p>
<p>Example matches the deduction guide. </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> { <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>(<span class="keywordtype">int</span>) };</div>
<div class="line"><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>(<span class="keywordtype">int</span>) -&gt; <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X&lt;int&gt;</a>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01055">1055</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a5505ee16ebcb2b7ee272e91d709849ee" name="a5505ee16ebcb2b7ee272e91d709849ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5505ee16ebcb2b7ee272e91d709849ee">&#9670;&#160;</a></span>cxxDefaultArgExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXDefaultArgExpr.html">CXXDefaultArgExpr</a> &gt; clang::ast_matchers::cxxDefaultArgExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the value of a default argument at the call site. </p>
<p>Example matches the <a class="el" href="classclang_1_1CXXDefaultArgExpr.html" title="A default argument (C++ [dcl.fct.default]).">CXXDefaultArgExpr</a> placeholder inserted for the default value of the second parameter in the call expression f(42) (matcher = <a class="el" href="#a5505ee16ebcb2b7ee272e91d709849ee" title="Matches the value of a default argument at the call site.">cxxDefaultArgExpr()</a>) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y = 0);</div>
<div class="line">f(42);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00868">868</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a21c9455ba631c516e4e7818a0f7f8eff" name="a21c9455ba631c516e4e7818a0f7f8eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c9455ba631c516e4e7818a0f7f8eff">&#9670;&#160;</a></span>cxxDeleteExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXDeleteExpr.html">CXXDeleteExpr</a> &gt; clang::ast_matchers::cxxDeleteExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches delete expressions. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">delete</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>;</div>
</div><!-- fragment --><p> <a class="el" href="#a21c9455ba631c516e4e7818a0f7f8eff" title="Matches delete expressions.">cxxDeleteExpr()</a> matches 'delete X'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00862">862</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a3285794ef7314a9b8ca5c18ed2744c13" name="a3285794ef7314a9b8ca5c18ed2744c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3285794ef7314a9b8ca5c18ed2744c13">&#9670;&#160;</a></span>cxxDependentScopeMemberExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a> &gt; clang::ast_matchers::cxxDependentScopeMemberExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches member expressions where the actual member referenced could not be resolved because the base expression or the member name was dependent. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> f() { T t; t.g(); }</div>
</div><!-- fragment --><p> <a class="el" href="#a3285794ef7314a9b8ca5c18ed2744c13" title="Matches member expressions where the actual member referenced could not be resolved because the base ...">cxxDependentScopeMemberExpr()</a> matches t.g </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00800">800</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ac797cd3d7e0d85d5bd07773f1c9e2f7e" name="ac797cd3d7e0d85d5bd07773f1c9e2f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac797cd3d7e0d85d5bd07773f1c9e2f7e">&#9670;&#160;</a></span>cxxDestructorDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXDestructorDecl.html">CXXDestructorDecl</a> &gt; clang::ast_matchers::cxxDestructorDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches explicit C++ destructor declarations. </p>
<p>Example matches Foo::~Foo() </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> ~Foo();</div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00778">778</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a446ee71422a19b825dd23d6dde2c0551" name="a446ee71422a19b825dd23d6dde2c0551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446ee71422a19b825dd23d6dde2c0551">&#9670;&#160;</a></span>cxxDynamicCastExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXDynamicCastExpr.html">CXXDynamicCastExpr</a> &gt; clang::ast_matchers::cxxDynamicCastExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a dynamic_cast expression. </p>
<p>Example: <a class="el" href="#a446ee71422a19b825dd23d6dde2c0551" title="Matches a dynamic_cast expression.">cxxDynamicCastExpr()</a> matches dynamic_cast&lt;D*&gt;(&amp;b); in </p><div class="fragment"><div class="line"><span class="keyword">struct </span>B { <span class="keyword">virtual</span> ~B() {} }; <span class="keyword">struct </span>D : B {};</div>
<div class="line">B <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">D* p = <span class="keyword">dynamic_cast&lt;</span>D*<span class="keyword">&gt;</span>(&amp;<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00941">941</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a8270a8d8f21ce50af2f56e4bcdd31eba" name="a8270a8d8f21ce50af2f56e4bcdd31eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8270a8d8f21ce50af2f56e4bcdd31eba">&#9670;&#160;</a></span>cxxForRangeStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a> &gt; clang::ast_matchers::cxxForRangeStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches range-based for statements. </p>
<p><a class="el" href="#a8270a8d8f21ce50af2f56e4bcdd31eba" title="Matches range-based for statements.">cxxForRangeStmt()</a> matches 'for (auto a : i)' </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i[] =  {1, 2, 3}; <span class="keywordflow">for</span> (<span class="keyword">auto</span> a : i);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 5; ++j);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00880">880</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a701d2c84173a8709dcb4a221ad478e1e" name="a701d2c84173a8709dcb4a221ad478e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701d2c84173a8709dcb4a221ad478e1e">&#9670;&#160;</a></span>cxxFunctionalCastExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a> &gt; clang::ast_matchers::cxxFunctionalCastExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches functional cast expressions. </p>
<p>Example: Matches Foo(bar); </p><div class="fragment"><div class="line">Foo f = bar;</div>
<div class="line">Foo g = (Foo) bar;</div>
<div class="line">Foo h = Foo(bar);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00952">952</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a831e164251478f3b38b3685d4d330cff" name="a831e164251478f3b38b3685d4d330cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831e164251478f3b38b3685d4d330cff">&#9670;&#160;</a></span>cxxMemberCallExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a> &gt; clang::ast_matchers::cxxMemberCallExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches member call expressions. </p>
<p>Example matches x.y() </p><div class="fragment"><div class="line"><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> x;</div>
<div class="line">x.y();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00804">804</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aebe825b22b86295d319b09c996fe78fd" name="aebe825b22b86295d319b09c996fe78fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe825b22b86295d319b09c996fe78fd">&#9670;&#160;</a></span>cxxMethodDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> &gt; clang::ast_matchers::cxxMethodDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches method declarations. </p>
<p>Example matches y </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> { <span class="keywordtype">void</span> y(); };</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00783">783</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l04569">AST_POLYMORPHIC_MATCHER_P2()</a>, <a class="el" href="ASTMatchers_8h_source.html#l04630">AST_POLYMORPHIC_MATCHER_P2()</a>, and <a class="el" href="GtestMatchers_8cpp_source.html#l00024">getComparisonDecl()</a>.</p>

</div>
</div>
<a id="a8c90fa40e809e57f174ef162b26bb7d9" name="a8c90fa40e809e57f174ef162b26bb7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c90fa40e809e57f174ef162b26bb7d9">&#9670;&#160;</a></span>cxxNewExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXNewExpr.html">CXXNewExpr</a> &gt; clang::ast_matchers::cxxNewExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches new expressions. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">new</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>;</div>
</div><!-- fragment --><p> <a class="el" href="#a8c90fa40e809e57f174ef162b26bb7d9" title="Matches new expressions.">cxxNewExpr()</a> matches 'new X'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00861">861</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a896f97c027b999f18752148a0921a19c" name="a896f97c027b999f18752148a0921a19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896f97c027b999f18752148a0921a19c">&#9670;&#160;</a></span>cxxNoexceptExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXNoexceptExpr.html">CXXNoexceptExpr</a> &gt; clang::ast_matchers::cxxNoexceptExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches noexcept expressions. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> a() noexcept;</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>() noexcept(<a class="code hl_define" href="stdbool_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>);</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>() noexcept(<a class="code hl_define" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>);</div>
<div class="line"><span class="keywordtype">bool</span> d() noexcept(noexcept(a()));</div>
<div class="line"><span class="keywordtype">bool</span> e = noexcept(<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>()) || noexcept(<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>());</div>
<div class="ttc" id="astdbool_8h_html_a41f9c5fb8b08eb5dc3edce4dcb37fee7"><div class="ttname"><a href="stdbool_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></div><div class="ttdeci">#define true</div><div class="ttdef"><b>Definition</b> <a href="stdbool_8h_source.html#l00016">stdbool.h:16</a></div></div>
<div class="ttc" id="astdbool_8h_html_a65e9886d74aaee76545e83dd09011727"><div class="ttname"><a href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></div><div class="ttdeci">#define false</div><div class="ttdef"><b>Definition</b> <a href="stdbool_8h_source.html#l00017">stdbool.h:17</a></div></div>
</div><!-- fragment --><p> <a class="el" href="#a896f97c027b999f18752148a0921a19c" title="Matches noexcept expressions.">cxxNoexceptExpr()</a> matches <code>noexcept(a())</code>, <code>noexcept(b())</code> and <code>noexcept(c())</code>. doesn't match the noexcept specifier in the declarations a, b, c or d. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00864">864</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ad74cde61d132689b56daab21db683425" name="ad74cde61d132689b56daab21db683425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74cde61d132689b56daab21db683425">&#9670;&#160;</a></span>cxxNullPtrLiteralExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXNullPtrLiteralExpr.html">CXXNullPtrLiteralExpr</a> &gt; clang::ast_matchers::cxxNullPtrLiteralExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches nullptr literal. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00915">915</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab422b5e5502151463a9d2d6ad04350e4" name="ab422b5e5502151463a9d2d6ad04350e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab422b5e5502151463a9d2d6ad04350e4">&#9670;&#160;</a></span>cxxOperatorCallExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a> &gt; clang::ast_matchers::cxxOperatorCallExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches overloaded operator calls. </p>
<p>Note that if an operator isn't overloaded, it won't match. Instead, use binaryOperator matcher. Currently it does not match operators such as new delete. FIXME: figure out why these do not match?</p>
<p>Example matches both operator&lt;&lt;((o &lt;&lt; b), c) and operator&lt;&lt;(o, b) (matcher = <a class="el" href="#ab422b5e5502151463a9d2d6ad04350e4" title="Matches overloaded operator calls.">cxxOperatorCallExpr()</a>) </p><div class="fragment"><div class="line">ostream &amp;<a class="code hl_function" href="namespaceclang.html#a60ee2b234598aa6e46b20012d281f701">operator&lt;&lt; </a>(ostream &amp;out, <span class="keywordtype">int</span> i) { };</div>
<div class="line">ostream &amp;o; <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = 1, <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> = 1;</div>
<div class="line">o &lt;&lt; <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> &lt;&lt; <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> See also the <a class="el" href="#a76efced611335bad85d3da6fe6ae790e" title="Matches nodes which can be used with binary operators.">binaryOperation()</a> matcher for more-general matching of binary uses of this AST node. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00870">870</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l04569">AST_POLYMORPHIC_MATCHER_P2()</a>, and <a class="el" href="ASTMatchers_8h_source.html#l04630">AST_POLYMORPHIC_MATCHER_P2()</a>.</p>

</div>
</div>
<a id="ac1ef73826e6b83dd0e8fc4a4b7284c74" name="ac1ef73826e6b83dd0e8fc4a4b7284c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ef73826e6b83dd0e8fc4a4b7284c74">&#9670;&#160;</a></span>cxxRecordDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a> &gt; clang::ast_matchers::cxxRecordDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ class declarations. </p>
<p>Example matches <code>X</code>, <code>Z</code> </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span>Z {};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00744">744</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="GtestMatchers_8cpp_source.html#l00024">getComparisonDecl()</a>, and <a class="el" href="RetainSummaryManager_8cpp_source.html#l00140">isSubclass()</a>.</p>

</div>
</div>
<a id="a04dc23e7233bd6aa6c8cd1240dfc71de" name="a04dc23e7233bd6aa6c8cd1240dfc71de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dc23e7233bd6aa6c8cd1240dfc71de">&#9670;&#160;</a></span>cxxReinterpretCastExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXReinterpretCastExpr.html">CXXReinterpretCastExpr</a> &gt; clang::ast_matchers::cxxReinterpretCastExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a reinterpret_cast expression. </p>
<p>Either the source expression or the destination type can be matched using <a class="el" href="#a9a14e1788aad32c318543405b5ec5962" title="Matches AST nodes that have child AST nodes that match the provided matcher.">has()</a>, but hasDestinationType() is more specific and can be more readable.</p>
<p>Example matches reinterpret_cast&lt;char*&gt;(&amp;p) in </p><div class="fragment"><div class="line"><span class="keywordtype">void</span>* p = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(&amp;p);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00937">937</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a3b9e9197127c18de63db7a43256f1aff" name="a3b9e9197127c18de63db7a43256f1aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9e9197127c18de63db7a43256f1aff">&#9670;&#160;</a></span>cxxRewrittenBinaryOperator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a> &gt; clang::ast_matchers::cxxRewrittenBinaryOperator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches rewritten binary operators. </p>
<p>Example matches use of "&lt;": </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;compare&gt;</span></div>
<div class="line"><span class="keyword">struct </span>HasSpaceshipMem {</div>
<div class="line">  <span class="keywordtype">int</span> a;</div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> operator&lt;=&gt;(<span class="keyword">const</span> HasSpaceshipMem&amp;) <span class="keyword">const</span> = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="PathDiagnostic_8cpp.html#a0a3098eaa1bf35a10ed829cd2ab49411">compare</a>() {</div>
<div class="line">  HasSpaceshipMem hs1, hs2;</div>
<div class="line">  <span class="keywordflow">if</span> (hs1 &lt; hs2)</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aPathDiagnostic_8cpp_html_a0a3098eaa1bf35a10ed829cd2ab49411"><div class="ttname"><a href="PathDiagnostic_8cpp.html#a0a3098eaa1bf35a10ed829cd2ab49411">compare</a></div><div class="ttdeci">static bool compare(const PathDiagnostic &amp;X, const PathDiagnostic &amp;Y)</div><div class="ttdef"><b>Definition</b> <a href="PathDiagnostic_8cpp_source.html#l00351">PathDiagnostic.cpp:351</a></div></div>
</div><!-- fragment --><p> See also the <a class="el" href="#a76efced611335bad85d3da6fe6ae790e" title="Matches nodes which can be used with binary operators.">binaryOperation()</a> matcher for more-general matching of this AST node. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00872">872</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aa83203112fbb0fc35646465509fce105" name="aa83203112fbb0fc35646465509fce105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83203112fbb0fc35646465509fce105">&#9670;&#160;</a></span>cxxStaticCastExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXStaticCastExpr.html">CXXStaticCastExpr</a> &gt; clang::ast_matchers::cxxStaticCastExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a C++ static_cast expression. </p>
<dl class="section see"><dt>See also</dt><dd>hasDestinationType </dd>
<dd>
reinterpretCast</dd></dl>
<p>Example: <a class="el" href="#aa83203112fbb0fc35646465509fce105" title="Matches a C++ static_cast expression.">cxxStaticCastExpr()</a> matches static_cast&lt;long&gt;(8) in </p><div class="fragment"><div class="line"><span class="keywordtype">long</span> eight(<span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>(8));</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00939">939</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ae4cf0cd73005c114b30400dc613baa59" name="ae4cf0cd73005c114b30400dc613baa59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4cf0cd73005c114b30400dc613baa59">&#9670;&#160;</a></span>cxxStdInitializerListExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXStdInitializerListExpr.html">CXXStdInitializerListExpr</a> &gt; clang::ast_matchers::cxxStdInitializerListExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ initializer list expressions. </p>
<p>Given </p><div class="fragment"><div class="line">std::vector&lt;int&gt; a({ 1, 2, 3 });</div>
<div class="line">std::vector&lt;int&gt; <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = { 4, 5 };</div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>[] = { 6, 7 };</div>
<div class="line">std::pair&lt;int, int&gt; d = { 8, 9 };</div>
</div><!-- fragment --><p> <a class="el" href="#ae4cf0cd73005c114b30400dc613baa59" title="Matches C++ initializer list expressions.">cxxStdInitializerListExpr()</a> matches "{ 1, 2, 3 }" and "{ 4, 5 }" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00835">835</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a704e8b0c7519edb6b05d1663a4266b6d" name="a704e8b0c7519edb6b05d1663a4266b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704e8b0c7519edb6b05d1663a4266b6d">&#9670;&#160;</a></span>cxxTemporaryObjectExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a> &gt; clang::ast_matchers::cxxTemporaryObjectExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches functional cast expressions having N != 1 arguments. </p>
<p>Example: Matches Foo(bar, bar) </p><div class="fragment"><div class="line">Foo h = Foo(bar, bar);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00954">954</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="af636f476cad8054e282b42e8ea613987" name="af636f476cad8054e282b42e8ea613987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af636f476cad8054e282b42e8ea613987">&#9670;&#160;</a></span>cxxThisExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXThisExpr.html">CXXThisExpr</a> &gt; clang::ast_matchers::cxxThisExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches implicit and explicit this expressions. </p>
<p>Example matches the implicit this expression in "return i". (matcher = <a class="el" href="#af636f476cad8054e282b42e8ea613987" title="Matches implicit and explicit this expressions.">cxxThisExpr()</a>) </p><div class="fragment"><div class="line"><span class="keyword">struct </span>foo {</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line">  <span class="keywordtype">int</span> f() { <span class="keywordflow">return</span> i; }</div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00856">856</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="abc856098ca748d9cff1734ff8fe3bd56" name="abc856098ca748d9cff1734ff8fe3bd56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc856098ca748d9cff1734ff8fe3bd56">&#9670;&#160;</a></span>cxxThrowExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXThrowExpr.html">CXXThrowExpr</a> &gt; clang::ast_matchers::cxxThrowExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches throw expressions. </p>
<div class="fragment"><div class="line"><span class="keywordflow">try</span> { <span class="keywordflow">throw</span> 5; } <span class="keywordflow">catch</span>(<span class="keywordtype">int</span> i) {}</div>
</div><!-- fragment --><p> <a class="el" href="#abc856098ca748d9cff1734ff8fe3bd56" title="Matches throw expressions.">cxxThrowExpr()</a> matches 'throw 5' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00896">896</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="af0002878ac1dc163307befba0daa2b17" name="af0002878ac1dc163307befba0daa2b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0002878ac1dc163307befba0daa2b17">&#9670;&#160;</a></span>cxxTryStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXTryStmt.html">CXXTryStmt</a> &gt; clang::ast_matchers::cxxTryStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches try statements. </p>
<div class="fragment"><div class="line"><span class="keywordflow">try</span> {} <span class="keywordflow">catch</span>(<span class="keywordtype">int</span> i) {}</div>
</div><!-- fragment --><p> <a class="el" href="#af0002878ac1dc163307befba0daa2b17" title="Matches try statements.">cxxTryStmt()</a> matches 'try {}' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00895">895</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="accfe2da9177520906d97d82833577922" name="accfe2da9177520906d97d82833577922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfe2da9177520906d97d82833577922">&#9670;&#160;</a></span>cxxUnresolvedConstructExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a> &gt; clang::ast_matchers::cxxUnresolvedConstructExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches unresolved constructor call expressions. </p>
<p>Example matches T(t) in return statement of f (matcher = <a class="el" href="#accfe2da9177520906d97d82833577922" title="Matches unresolved constructor call expressions.">cxxUnresolvedConstructExpr()</a>) </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keyword">const</span> T&amp; t) { <span class="keywordflow">return</span> T(t); }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00855">855</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a38bd085c51befd42c27944d815f2429b" name="a38bd085c51befd42c27944d815f2429b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38bd085c51befd42c27944d815f2429b">&#9670;&#160;</a></span>decayedType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1DecayedType.html">DecayedType</a>&gt; clang::ast_matchers::decayedType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01039">1039</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ac5ccadfbea5e9e43c2153175afca6cac" name="ac5ccadfbea5e9e43c2153175afca6cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ccadfbea5e9e43c2153175afca6cac">&#9670;&#160;</a></span>decl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt; clang::ast_matchers::decl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches declarations. </p>
<p>Examples matches <code>X</code>, <code>C</code>, and the friend declaration inside <code>C</code>; </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>();</div>
<div class="line"><span class="keyword">class </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {</div>
<div class="line">  <span class="keyword">friend</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>;</div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00734">734</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaStmt_8cpp_source.html#l00082">clang::Sema::ActOnForEachDeclStmt()</a>, <a class="el" href="SemaDeclObjC_8cpp_source.html#l04699">clang::Sema::ActOnMethodDeclaration()</a>, <a class="el" href="SemaDeclObjC_8cpp_source.html#l01410">clang::Sema::actOnObjCTypeArgsOrProtocolQualifiers()</a>, <a class="el" href="SemaDeclObjC_8cpp_source.html#l02487">checkMethodFamilyMismatch()</a>, <a class="el" href="SemaChecking_8cpp_source.html#l08179">CXXRecordMembersNamed()</a>, <a class="el" href="Type_8cpp_source.html#l03466">getInterestingTagDecl()</a>, <a class="el" href="Store_8cpp_source.html#l00480">clang::ento::StoreManager::getLValueIvar()</a>, <a class="el" href="CGExprConstant_8cpp_source.html#l02183">clang::CodeGen::CodeGenModule::getMemberPointerConstant()</a>, <a class="el" href="Decl_8cpp_source.html#l01823">getTemplateOrInnerLocStart()</a>, <a class="el" href="DeclObjC_8cpp_source.html#l00309">clang::ObjCInterfaceDecl::getTypeParamList()</a>, <a class="el" href="ExprCXX_8cpp_source.html#l01438">hasOnlyNonStaticMemberFunctions()</a>, <a class="el" href="SemaDecl_8cpp_source.html#l06290">clang::Sema::inferObjCARCLifetime()</a>, <a class="el" href="CGDecl_8cpp_source.html#l00671">isAccessedBy()</a>, <a class="el" href="ExprEngine_8cpp_source.html#l00817">clang::ento::ExprEngine::ProcessInitializer()</a>, and <a class="el" href="ASTReaderDecl_8cpp_source.html#l01537">clang::ASTDeclReader::VisitBlockDecl()</a>.</p>

</div>
</div>
<a id="a91cafc159defa3d1fdcbb28ec72ae418" name="a91cafc159defa3d1fdcbb28ec72ae418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cafc159defa3d1fdcbb28ec72ae418">&#9670;&#160;</a></span>declaratorDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a> &gt; clang::ast_matchers::declaratorDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches declarator declarations (field, variable, function and non-type template parameter declarations). </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> { <span class="keywordtype">int</span> y; };</div>
</div><!-- fragment --><p> <a class="el" href="#a91cafc159defa3d1fdcbb28ec72ae418" title="Matches declarator declarations (field, variable, function and non-type template parameter declaratio...">declaratorDecl()</a> matches <code>int</code> y. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00754">754</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a0781cbe6d50bd620cb6f8f0627378be6" name="a0781cbe6d50bd620cb6f8f0627378be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0781cbe6d50bd620cb6f8f0627378be6">&#9670;&#160;</a></span>declRefExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DeclRefExpr.html">DeclRefExpr</a> &gt; clang::ast_matchers::declRefExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions that refer to declarations. </p>
<p>Example matches x in if (x) </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> x;</div>
<div class="line"><span class="keywordflow">if</span> (x) {}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00874">874</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00112">clang::ento::assignedToRef()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00105">clang::ento::callByRef()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00094">clang::ento::changeIntBoundNode()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00139">clang::ento::forLoopMatcher()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00121">clang::ento::getAddrTo()</a>, and <a class="el" href="LoopUnrolling_8cpp_source.html#l00082">clang::ento::simpleCondition()</a>.</p>

</div>
</div>
<a id="adc3d4ad0df1926038d75178efe06dcd8" name="adc3d4ad0df1926038d75178efe06dcd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3d4ad0df1926038d75178efe06dcd8">&#9670;&#160;</a></span>declStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DeclStmt.html">DeclStmt</a> &gt; clang::ast_matchers::declStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches declaration statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a;</div>
</div><!-- fragment --><p> <a class="el" href="#adc3d4ad0df1926038d75178efe06dcd8" title="Matches declaration statements.">declStmt()</a> matches 'int a'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00795">795</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00112">clang::ento::assignedToRef()</a>, and <a class="el" href="LoopUnrolling_8cpp_source.html#l00139">clang::ento::forLoopMatcher()</a>.</p>

</div>
</div>
<a id="aca4b20199a79ce79c9d781bc6e207337" name="aca4b20199a79ce79c9d781bc6e207337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4b20199a79ce79c9d781bc6e207337">&#9670;&#160;</a></span>decltypeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1DecltypeType.html">DecltypeType</a>&gt; clang::ast_matchers::decltypeType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01018">1018</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab8c34f70634543e4f54c46ee7df6614f" name="ab8c34f70634543e4f54c46ee7df6614f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c34f70634543e4f54c46ee7df6614f">&#9670;&#160;</a></span>decompositionDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1DecompositionDecl.html">DecompositionDecl</a> &gt; clang::ast_matchers::decompositionDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches decomposition-declarations. </p>
<p>Examples matches the declaration node with <code>foo</code> and <code>bar</code>, but not <code>number</code>. (matcher = declStmt(<a class="el" href="#a9a14e1788aad32c318543405b5ec5962" title="Matches AST nodes that have child AST nodes that match the provided matcher.">has(decompositionDecl())</a>))</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> number = 42;</div>
<div class="line"><span class="keyword">auto</span> [foo, bar] = std::make_pair{42, 42};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00735">735</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aba73ea27d54608e9c8762cb68d2152e1" name="aba73ea27d54608e9c8762cb68d2152e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba73ea27d54608e9c8762cb68d2152e1">&#9670;&#160;</a></span>deducedTemplateSpecializationType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1DeducedTemplateSpecializationType.html">DeducedTemplateSpecializationType</a>&gt; clang::ast_matchers::deducedTemplateSpecializationType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01012">1012</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab7cc259a084492c93e3053e78ea9d088" name="ab7cc259a084492c93e3053e78ea9d088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7cc259a084492c93e3053e78ea9d088">&#9670;&#160;</a></span>defaultStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DefaultStmt.html">DefaultStmt</a> &gt; clang::ast_matchers::defaultStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches default statements inside switch statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">switch</span>(a) { <span class="keywordflow">case</span> 42: <span class="keywordflow">break</span>; <span class="keywordflow">default</span>: <span class="keywordflow">break</span>; }</div>
</div><!-- fragment --><p> <a class="el" href="#ab7cc259a084492c93e3053e78ea9d088" title="Matches default statements inside switch statements.">defaultStmt()</a> matches 'default:'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00892">892</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a20405c2c252045def43f9fb8a66e3e9e" name="a20405c2c252045def43f9fb8a66e3e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20405c2c252045def43f9fb8a66e3e9e">&#9670;&#160;</a></span>dependentSizedArrayType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1DependentSizedArrayType.html">DependentSizedArrayType</a>&gt; clang::ast_matchers::dependentSizedArrayType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01013">1013</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ac5af767c2d681ddb0122fec2e3ab43a5" name="ac5af767c2d681ddb0122fec2e3ab43a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5af767c2d681ddb0122fec2e3ab43a5">&#9670;&#160;</a></span>designatedInitExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DesignatedInitExpr.html">DesignatedInitExpr</a> &gt; clang::ast_matchers::designatedInitExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C99 designated initializer expressions [C99 6.7.8]. </p>
<p>Example: Matches { [2].y = 1.0, [0].x = 1.0 } </p><div class="fragment"><div class="line">point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00958">958</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ad35f9309e910ba3399781cc30baa2439" name="ad35f9309e910ba3399781cc30baa2439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35f9309e910ba3399781cc30baa2439">&#9670;&#160;</a></span>doStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DoStmt.html">DoStmt</a> &gt; clang::ast_matchers::doStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches do statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">do</span> {} <span class="keywordflow">while</span> (<span class="keyword">true</span>);</div>
</div><!-- fragment --><p> <a class="el" href="#ad35f9309e910ba3399781cc30baa2439" title="Matches do statements.">doStmt()</a> matches 'do {} while(true)' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00882">882</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab0c3c535f34a336b4e966342d44a631d" name="ab0c3c535f34a336b4e966342d44a631d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c3c535f34a336b4e966342d44a631d">&#9670;&#160;</a></span>eachOf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicOperatorMatcherFunc&lt; 2, std::numeric_limits&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;<a class="el" href="____clang__cuda__math_8h.html#ae6bb573e13e3bd5738c8faa552b6a129">::max</a>()&gt; clang::ast_matchers::eachOf = {internal::DynTypedMatcher::VO_EachOf}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if any of the given matchers matches. </p>
<p>Unlike <code>anyOf</code>, <code>eachOf</code> will generate a match result for each matching submatcher.</p>
<p>For example, in: </p><div class="fragment"><div class="line"><span class="keyword">class </span>A { <span class="keywordtype">int</span> a; <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>; };</div>
</div><!-- fragment --><p> The matcher: </p><div class="fragment"><div class="line"><a class="code hl_variable" href="#ac1ef73826e6b83dd0e8fc4a4b7284c74">cxxRecordDecl</a>(<a class="code hl_variable" href="#ab0c3c535f34a336b4e966342d44a631d">eachOf</a>(<a class="code hl_variable" href="#a9a14e1788aad32c318543405b5ec5962">has</a>(<a class="code hl_variable" href="#ab26f3ff62d6be975196efa86f3b15d82">fieldDecl</a>(<a class="code hl_function" href="#a4360554ed6340d60248b5d5930c44d49">hasName</a>(<span class="stringliteral">&quot;a&quot;</span>)).bind(<span class="stringliteral">&quot;v&quot;</span>)),</div>
<div class="line">                     <a class="code hl_variable" href="#a9a14e1788aad32c318543405b5ec5962">has</a>(<a class="code hl_variable" href="#ab26f3ff62d6be975196efa86f3b15d82">fieldDecl</a>(<a class="code hl_function" href="#a4360554ed6340d60248b5d5930c44d49">hasName</a>(<span class="stringliteral">&quot;b&quot;</span>)).bind(<span class="stringliteral">&quot;v&quot;</span>))))</div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ab0c3c535f34a336b4e966342d44a631d"><div class="ttname"><a href="#ab0c3c535f34a336b4e966342d44a631d">clang::ast_matchers::eachOf</a></div><div class="ttdeci">const internal::VariadicOperatorMatcherFunc&lt; 2, std::numeric_limits&lt; unsigned &gt;::max()&gt; eachOf</div><div class="ttdoc">Matches if any of the given matchers matches.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00961">ASTMatchersInternal.cpp:961</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ab26f3ff62d6be975196efa86f3b15d82"><div class="ttname"><a href="#ab26f3ff62d6be975196efa86f3b15d82">clang::ast_matchers::fieldDecl</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Decl, FieldDecl &gt; fieldDecl</div><div class="ttdoc">Matches field declarations.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00787">ASTMatchersInternal.cpp:787</a></div></div>
</div><!-- fragment --><p> will generate two results binding "v", the first of which binds the field declaration of <code>a</code>, the second the field declaration of <code>b</code>.</p>
<p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00961">961</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l03381">findAll()</a>.</p>

</div>
</div>
<a id="ae7ebd6b87d8af5808b5f789a530ba9ae" name="ae7ebd6b87d8af5808b5f789a530ba9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ebd6b87d8af5808b5f789a530ba9ae">&#9670;&#160;</a></span>elaboratedType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1ElaboratedType.html">ElaboratedType</a>&gt; clang::ast_matchers::elaboratedType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01035">1035</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a8dcb1ffb5fb859e719d305b311baaeba" name="a8dcb1ffb5fb859e719d305b311baaeba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcb1ffb5fb859e719d305b311baaeba">&#9670;&#160;</a></span>enumConstantDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1EnumConstantDecl.html">EnumConstantDecl</a> &gt; clang::ast_matchers::enumConstantDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches enum constants. </p>
<p>Example matches A, B, C </p><div class="fragment"><div class="line"><span class="keyword">enum</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {</div>
<div class="line">  A, B, <a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a></div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00781">781</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a31e48dc9e0067b916df8f57d3d3bb72a" name="a31e48dc9e0067b916df8f57d3d3bb72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e48dc9e0067b916df8f57d3d3bb72a">&#9670;&#160;</a></span>enumDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1EnumDecl.html">EnumDecl</a> &gt; clang::ast_matchers::enumDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches enum declarations. </p>
<p>Example matches X </p><div class="fragment"><div class="line"><span class="keyword">enum</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {</div>
<div class="line">  A, B, <a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a></div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00779">779</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="add0b65ac213d164ac0367dfa7aa95c80" name="add0b65ac213d164ac0367dfa7aa95c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0b65ac213d164ac0367dfa7aa95c80">&#9670;&#160;</a></span>enumType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1EnumType.html">EnumType</a>&gt; clang::ast_matchers::enumType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01030">1030</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aa64f0fe0351af4d0e37f7838e6385d3c" name="aa64f0fe0351af4d0e37f7838e6385d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64f0fe0351af4d0e37f7838e6385d3c">&#9670;&#160;</a></span>explicitCastExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a> &gt; clang::ast_matchers::explicitCastExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches explicit cast expressions. </p>
<p>Matches any cast expression written in user code, whether it be a C-style cast, a functional-style cast, or a keyword cast.</p>
<p>Does not match implicit conversions.</p>
<p>Note: the name "explicitCast" is chosen to match Clang's terminology, as Clang uses the term "cast" to apply to implicit conversions as well as to actual cast expressions.</p>
<dl class="section see"><dt>See also</dt><dd>hasDestinationType.</dd></dl>
<p>Example: matches all five of the casts in </p><div class="fragment"><div class="line"><a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>((<span class="keywordtype">int</span>)(<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(<span class="keyword">const_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(42)))))</div>
</div><!-- fragment --><p> but does not match the implicit conversion in </p><div class="fragment"><div class="line"><span class="keywordtype">long</span> ell = 42;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00947">947</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="adfc0ccd398780d345e2c541cc716cc66" name="adfc0ccd398780d345e2c541cc716cc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc0ccd398780d345e2c541cc716cc66">&#9670;&#160;</a></span>expr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt; clang::ast_matchers::expr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions. </p>
<p>Example matches x() </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() { x(); }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00873">873</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaDecl_8cpp_source.html#l18248">clang::Sema::ActOnFileScopeAsmDecl()</a>, <a class="el" href="ASTMatchers_8h_source.html#l04569">AST_POLYMORPHIC_MATCHER_P2()</a>, <a class="el" href="ASTMatchers_8h_source.html#l04630">AST_POLYMORPHIC_MATCHER_P2()</a>, <a class="el" href="SValBuilder_8h_source.html#l00187">clang::ento::SValBuilder::conjureSymbol()</a>, <a class="el" href="SValBuilder_8cpp_source.html#l00153">clang::ento::SValBuilder::conjureSymbolVal()</a>, <a class="el" href="CGExprScalar_8cpp_source.html#l03313">emitPointerArithmetic()</a>, <a class="el" href="Expr_8cpp_source.html#l02731">clang::Expr::findBoundMemberType()</a>, <a class="el" href="CGCXXABI_8cpp_source.html#l00164">clang::CodeGen::CGCXXABI::GetArrayCookieSize()</a>, <a class="el" href="DereferenceChecker_8cpp_source.html#l00094">getDereferenceExpr()</a>, <a class="el" href="CheckSecuritySyntaxOnly_8cpp_source.html#l00229">getIncrementedVar()</a>, <a class="el" href="SValBuilder_8cpp_source.html#l00204">clang::ento::SValBuilder::getMetadataSymbolVal()</a>, <a class="el" href="SValBuilder_8h_source.html#l00361">clang::ento::SValBuilder::makeLoc()</a>, <a class="el" href="CGCXXABI_8cpp_source.html#l00204">clang::CodeGen::CGCXXABI::ReadArrayCookie()</a>, <a class="el" href="CGCXXABI_8cpp_source.html#l00185">clang::CodeGen::CGCXXABI::requiresArrayCookie()</a>, <a class="el" href="CGCXXABI_8cpp_source.html#l00195">clang::CodeGen::CGCXXABI::requiresArrayCookie()</a>, <a class="el" href="Expr_8h_source.html#l04768">clang::InitListExpr::setInit()</a>, <a class="el" href="CodeGenFunction_8h_source.html#l01256">clang::CodeGen::CodeGenFunction::OpaqueValueMapping::shouldBindAsLValue()</a>, <a class="el" href="CodeGenFunction_8h_source.html#l01192">clang::CodeGen::CodeGenFunction::OpaqueValueMappingData::shouldBindAsLValue()</a>, and <a class="el" href="Expr_8cpp_source.html#l02126">clang::InitListExpr::updateInit()</a>.</p>

</div>
</div>
<a id="a071d31bd81eb28a0b2db583b181cfc01" name="a071d31bd81eb28a0b2db583b181cfc01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071d31bd81eb28a0b2db583b181cfc01">&#9670;&#160;</a></span>exprWithCleanups</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ExprWithCleanups.html">ExprWithCleanups</a> &gt; clang::ast_matchers::exprWithCleanups</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions that introduce cleanups to be run at the end of the sub-expression's evaluation. </p>
<p>Example matches std::string() </p><div class="fragment"><div class="line"><span class="keyword">const</span> std::string str = std::string();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00832">832</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab26f3ff62d6be975196efa86f3b15d82" name="ab26f3ff62d6be975196efa86f3b15d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26f3ff62d6be975196efa86f3b15d82">&#9670;&#160;</a></span>fieldDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a> &gt; clang::ast_matchers::fieldDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches field declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> { <span class="keywordtype">int</span> m; };</div>
</div><!-- fragment --><p> <a class="el" href="#ab26f3ff62d6be975196efa86f3b15d82" title="Matches field declarations.">fieldDecl()</a> matches 'm'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00787">787</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a0045003e9bc57bbe8c8f5e32a64c9533" name="a0045003e9bc57bbe8c8f5e32a64c9533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0045003e9bc57bbe8c8f5e32a64c9533">&#9670;&#160;</a></span>fixedPointLiteral</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1FixedPointLiteral.html">FixedPointLiteral</a> &gt; clang::ast_matchers::fixedPointLiteral</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches fixed point literals. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00909">909</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a4a4e38c6224c16252040dc697a6af832" name="a4a4e38c6224c16252040dc697a6af832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4e38c6224c16252040dc697a6af832">&#9670;&#160;</a></span>floatLiteral</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1FloatingLiteral.html">FloatingLiteral</a> &gt; clang::ast_matchers::floatLiteral</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches float literals of all sizes / encodings, e.g. </p>
<p>1.0, 1.0f, 1.0L and 1e10.</p>
<p>Does not match implicit conversions such as </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> a = 10;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00906">906</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a56e1d83c63172816c6678224f6d73fb8" name="a56e1d83c63172816c6678224f6d73fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e1d83c63172816c6678224f6d73fb8">&#9670;&#160;</a></span>forEach</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::ArgumentAdaptingMatcherFunc&lt; internal::ForEachMatcher &gt; clang::ast_matchers::forEach</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    {}</div>
</div><!-- fragment -->
<p>Matches AST nodes that have child AST nodes that match the provided matcher. </p>
<p>Example matches X, Y, Y::X, Z::Y, Z::Y::X (matcher = cxxRecordDecl(forEach(cxxRecordDecl(hasName("X"))) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {};</div>
<div class="line"><span class="keyword">class </span>Y { <span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {}; };  <span class="comment">// Matches Y, because Y::X is a class of name X</span></div>
<div class="line">                          <span class="comment">// inside Y.</span></div>
<div class="line"><span class="keyword">class </span>Z { <span class="keyword">class </span>Y { <span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {}; }; };  <span class="comment">// Does not match Z.</span></div>
</div><!-- fragment --><p>ChildT must be an AST base type.</p>
<p>As opposed to 'has', 'forEach' will cause a match for each result that matches instead of only on the first one.</p>
<p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00986">986</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a5114cdbe34bca53c82f6304894904740" name="a5114cdbe34bca53c82f6304894904740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5114cdbe34bca53c82f6304894904740">&#9670;&#160;</a></span>forEachDescendant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::ArgumentAdaptingMatcherFunc&lt; internal::ForEachDescendantMatcher &gt; clang::ast_matchers::forEachDescendant = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches AST nodes that have descendant AST nodes that match the provided matcher. </p>
<p>Example matches X, A, A::X, B, B::C, B::C::X (matcher = cxxRecordDecl(forEachDescendant(cxxRecordDecl(hasName("X"))))) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {};</div>
<div class="line"><span class="keyword">class </span>A { <span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {}; };  <span class="comment">// Matches A, because A::X is a class of name</span></div>
<div class="line">                          <span class="comment">// X inside A.</span></div>
<div class="line"><span class="keyword">class </span>B { <span class="keyword">class </span><a class="code hl_enumvalue" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> { <span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {}; }; };</div>
<div class="ttc" id="anamespaceAttributeLangSupport_html_a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e"><div class="ttname"><a href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">AttributeLangSupport::C</a></div><div class="ttdeci">@ C</div><div class="ttdef"><b>Definition</b> <a href="SemaDeclAttr_8cpp_source.html#l00051">SemaDeclAttr.cpp:51</a></div></div>
</div><!-- fragment --><p>DescendantT must be an AST base type.</p>
<p>As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for each result that matches instead of only on the first one.</p>
<p>Note: Recursively combined ForEachDescendant can cause many matches: cxxRecordDecl(forEachDescendant(cxxRecordDecl( <a class="el" href="#a5114cdbe34bca53c82f6304894904740" title="Matches AST nodes that have descendant AST nodes that match the provided matcher.">forEachDescendant(cxxRecordDecl())</a> ))) will match 10 times (plus injected class name matches) on: </p><div class="fragment"><div class="line"><span class="keyword">class </span>A { <span class="keyword">class </span>B { <span class="keyword">class </span>C { <span class="keyword">class </span>D { <span class="keyword">class </span>E {}; }; }; }; };</div>
</div><!-- fragment --><p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00989">989</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l03381">findAll()</a>.</p>

</div>
</div>
<a id="a8e6f109ac0734990e8ae974d36e76c7e" name="a8e6f109ac0734990e8ae974d36e76c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6f109ac0734990e8ae974d36e76c7e">&#9670;&#160;</a></span>forStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ForStmt.html">ForStmt</a> &gt; clang::ast_matchers::forStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches for statements. </p>
<p>Example matches 'for (;;) {}' </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (;;) {}</div>
<div class="line"><span class="keywordtype">int</span> i[] =  {1, 2, 3}; <span class="keywordflow">for</span> (<span class="keyword">auto</span> a : i);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00878">878</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00139">clang::ento::forLoopMatcher()</a>.</p>

</div>
</div>
<a id="aded924f4ec88be994f9c255803e6075c" name="aded924f4ec88be994f9c255803e6075c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded924f4ec88be994f9c255803e6075c">&#9670;&#160;</a></span>friendDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1FriendDecl.html">FriendDecl</a> &gt; clang::ast_matchers::friendDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches friend declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> { <span class="keyword">friend</span> <span class="keywordtype">void</span> foo(); };</div>
</div><!-- fragment --><p> <a class="el" href="#aded924f4ec88be994f9c255803e6075c" title="Matches friend declarations.">friendDecl()</a> matches 'friend void foo()'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00793">793</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab95624c30888b0c7688e3a6171ed49cc" name="ab95624c30888b0c7688e3a6171ed49cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95624c30888b0c7688e3a6171ed49cc">&#9670;&#160;</a></span>functionDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a> &gt; clang::ast_matchers::functionDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches function declarations. </p>
<p>Example matches f </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00790">790</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l04569">AST_POLYMORPHIC_MATCHER_P2()</a>, <a class="el" href="ASTMatchers_8h_source.html#l04630">AST_POLYMORPHIC_MATCHER_P2()</a>, <a class="el" href="ObjCAutoreleaseWriteChecker_8cpp_source.html#l00105">callsNames()</a>, <a class="el" href="GtestMatchers_8cpp_source.html#l00024">getComparisonDecl()</a>, and <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>.</p>

</div>
</div>
<a id="a92b417110dc9fa37bc246638349aea1b" name="a92b417110dc9fa37bc246638349aea1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b417110dc9fa37bc246638349aea1b">&#9670;&#160;</a></span>functionProtoType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1FunctionProtoType.html">FunctionProtoType</a>&gt; clang::ast_matchers::functionProtoType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01020">1020</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a973fc1ea542ea4bb3543d905e2ee1e11" name="a973fc1ea542ea4bb3543d905e2ee1e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973fc1ea542ea4bb3543d905e2ee1e11">&#9670;&#160;</a></span>functionTemplateDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1FunctionTemplateDecl.html">FunctionTemplateDecl</a> &gt; clang::ast_matchers::functionTemplateDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ function template declarations. </p>
<p>Example matches f </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> f(T t) {}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00792">792</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a76bdb41bba221f74825ffc014afcdc79" name="a76bdb41bba221f74825ffc014afcdc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bdb41bba221f74825ffc014afcdc79">&#9670;&#160;</a></span>functionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1FunctionType.html">FunctionType</a>&gt; clang::ast_matchers::functionType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01019">1019</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a3f42e20a3d2500bbee1741d7f8bc04f3" name="a3f42e20a3d2500bbee1741d7f8bc04f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f42e20a3d2500bbee1741d7f8bc04f3">&#9670;&#160;</a></span>genericSelectionExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1GenericSelectionExpr.html">GenericSelectionExpr</a> &gt; clang::ast_matchers::genericSelectionExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C11 _Generic expression. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00919">919</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a80570a2d56d8d2d1788318a946a68a05" name="a80570a2d56d8d2d1788318a946a68a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80570a2d56d8d2d1788318a946a68a05">&#9670;&#160;</a></span>gnuNullExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1GNUNullExpr.html">GNUNullExpr</a> &gt; clang::ast_matchers::gnuNullExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches GNU __null expression. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00917">917</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a8f07c79fb3acf3af34be21d41010648a" name="a8f07c79fb3acf3af34be21d41010648a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f07c79fb3acf3af34be21d41010648a">&#9670;&#160;</a></span>gotoStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1GotoStmt.html">GotoStmt</a> &gt; clang::ast_matchers::gotoStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches goto statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">goto</span> FOO;</div>
<div class="line">FOO: bar();</div>
</div><!-- fragment --><p> <a class="el" href="#a8f07c79fb3acf3af34be21d41010648a" title="Matches goto statements.">gotoStmt()</a> matches 'goto FOO' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00886">886</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00127">clang::ento::hasSuspiciousStmt()</a>.</p>

</div>
</div>
<a id="a9a14e1788aad32c318543405b5ec5962" name="a9a14e1788aad32c318543405b5ec5962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a14e1788aad32c318543405b5ec5962">&#9670;&#160;</a></span>has</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::ArgumentAdaptingMatcherFunc&lt; internal::HasMatcher &gt; clang::ast_matchers::has = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches AST nodes that have child AST nodes that match the provided matcher. </p>
<p>Example matches X, Y (matcher = cxxRecordDecl(has(cxxRecordDecl(hasName("X"))) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {};  <span class="comment">// Matches X, because X::X is a class of name X inside X.</span></div>
<div class="line"><span class="keyword">class </span>Y { <span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {}; };</div>
<div class="line"><span class="keyword">class </span>Z { <span class="keyword">class </span>Y { <span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {}; }; };  <span class="comment">// Does not match Z.</span></div>
</div><!-- fragment --><p>ChildT must be an AST base type.</p>
<p>Usable as: Any Matcher Note that has is direct matcher, so it also matches things like implicit casts and paren casts. If you are matching with expr then you should probably consider using ignoringParenImpCasts like: has(ignoringParenImpCasts(expr())). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00983">983</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00112">clang::ento::assignedToRef()</a>, and <a class="el" href="RewriteObjCFoundationAPI_8cpp_source.html#l00682">getLiteralInfo()</a>.</p>

</div>
</div>
<a id="a634196d2ad98165151a6e005f192bcdb" name="a634196d2ad98165151a6e005f192bcdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634196d2ad98165151a6e005f192bcdb">&#9670;&#160;</a></span>hasAncestor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::ArgumentAdaptingMatcherFunc&lt; internal::HasAncestorMatcher, internal::TypeList&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;, internal::TypeList&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt; &gt; clang::ast_matchers::hasAncestor = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches AST nodes that have an ancestor that matches the provided matcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() { <span class="keywordflow">if</span> (<span class="keyword">true</span>) { <span class="keywordtype">int</span> x = 42; } }</div>
<div class="line"><span class="keywordtype">void</span> g() { <span class="keywordflow">for</span> (;;) { <span class="keywordtype">int</span> x = 43; } }</div>
</div><!-- fragment --><p> <code>expr</code>(integerLiteral(<a class="el" href="#a634196d2ad98165151a6e005f192bcdb" title="Matches AST nodes that have an ancestor that matches the provided matcher.">hasAncestor(ifStmt())</a>)) matches <code>42</code>, but not 43.</p>
<p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00999">999</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a75176e564329aea08a65d667d019d9f8" name="a75176e564329aea08a65d667d019d9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75176e564329aea08a65d667d019d9f8">&#9670;&#160;</a></span>hasAnyName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicFunction&lt; internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;, StringRef, <a class="el" href="namespaceclang_1_1ast__matchers_1_1internal.html#a98699ed64da2a4f207680ab1d26934ac">internal::hasAnyNameFunc</a> &gt; clang::ast_matchers::hasAnyName = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <a class="el" href="classclang_1_1NamedDecl.html" title="This represents a decl that may have a name.">NamedDecl</a> nodes that have any of the specified names. </p>
<p>This matcher is only provided as a performance optimization of hasName. </p><div class="fragment"><div class="line"><a class="code hl_variable" href="#a75176e564329aea08a65d667d019d9f8">hasAnyName</a>(a, <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>, <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>)</div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a75176e564329aea08a65d667d019d9f8"><div class="ttname"><a href="#a75176e564329aea08a65d667d019d9f8">clang::ast_matchers::hasAnyName</a></div><div class="ttdeci">const internal::VariadicFunction&lt; internal::Matcher&lt; NamedDecl &gt;, StringRef, internal::hasAnyNameFunc &gt; hasAnyName</div><div class="ttdoc">Matches NamedDecl nodes that have any of the specified names.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00972">ASTMatchersInternal.cpp:972</a></div></div>
</div><!-- fragment --><p> is equivalent to, but faster than </p><div class="fragment"><div class="line"><a class="code hl_variable" href="#ae56a1974283c9a2cb2410008e32fe3f1">anyOf</a>(<a class="code hl_function" href="#a4360554ed6340d60248b5d5930c44d49">hasName</a>(a), <a class="code hl_function" href="#a4360554ed6340d60248b5d5930c44d49">hasName</a>(<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>), <a class="code hl_function" href="#a4360554ed6340d60248b5d5930c44d49">hasName</a>(<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>))</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00972">972</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ObjCAutoreleaseWriteChecker_8cpp_source.html#l00105">callsNames()</a>, and <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>.</p>

</div>
</div>
<a id="a5c7b689114837a79d0df0d9eeff59b1b" name="a5c7b689114837a79d0df0d9eeff59b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7b689114837a79d0df0d9eeff59b1b">&#9670;&#160;</a></span>hasAnyOperatorName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicFunction&lt;internal::HasOpNameMatcher, StringRef, <a class="el" href="namespaceclang_1_1ast__matchers_1_1internal.html#aa6c82af4b9087769a26b4e80ff53d5e0">internal::hasAnyOperatorNameFunc</a>&gt; clang::ast_matchers::hasAnyOperatorName = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00976">976</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a4baa5862611b82aa132a5ab534b63e9b" name="a4baa5862611b82aa132a5ab534b63e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4baa5862611b82aa132a5ab534b63e9b">&#9670;&#160;</a></span>hasAnyOverloadedOperatorName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicFunction&lt; internal::HasOverloadOpNameMatcher, StringRef, <a class="el" href="namespaceclang_1_1ast__matchers_1_1internal.html#a1e5b2642d58cd1ce19c81f4c4335fc80">internal::hasAnyOverloadedOperatorNameFunc</a> &gt; clang::ast_matchers::hasAnyOverloadedOperatorName = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches overloaded operator names. </p>
<p>Matches overloaded operator names specified in strings without the "operator" prefix: e.g. "&lt;&lt;".</p>
<p>hasAnyOverloadedOperatorName("+", "-") Is equivalent to anyOf(hasOverloadedOperatorName("+"), hasOverloadedOperatorName("-")) </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00979">979</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a6568b14e2ddad80f141bc0f81958f12b" name="a6568b14e2ddad80f141bc0f81958f12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6568b14e2ddad80f141bc0f81958f12b">&#9670;&#160;</a></span>hasAnySelector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicFunction&lt; internal::Matcher&lt; <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a> &gt;, StringRef, <a class="el" href="namespaceclang_1_1ast__matchers_1_1internal.html#a4fc6adb553977462ad8c1c98e6df506f">internal::hasAnySelectorFunc</a> &gt; clang::ast_matchers::hasAnySelector = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches when at least one of the supplied string equals to the <a class="el" href="classclang_1_1Selector.html#a4fc5593940af968fa1187c3cb6a8ef8b" title="Derive the full selector name (e.g.">Selector.getAsString()</a> </p>
<p>matcher = objCMessageExpr(hasSelector("methodA:", "methodB:")); matches both of the expressions below: </p><div class="fragment"><div class="line">[myObj methodA:argA];</div>
<div class="line">[myObj methodB:argB];</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00982">982</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2b133847db656cf51934b25cde311b8e" name="a2b133847db656cf51934b25cde311b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b133847db656cf51934b25cde311b8e">&#9670;&#160;</a></span>hasDescendant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::ArgumentAdaptingMatcherFunc&lt; internal::HasDescendantMatcher &gt; clang::ast_matchers::hasDescendant = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches AST nodes that have descendant AST nodes that match the provided matcher. </p>
<p>Example matches X, Y, Z (matcher = cxxRecordDecl(hasDescendant(cxxRecordDecl(hasName("X"))))) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {};  <span class="comment">// Matches X, because X::X is a class of name X inside X.</span></div>
<div class="line"><span class="keyword">class </span>Y { <span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {}; };</div>
<div class="line"><span class="keyword">class </span>Z { <span class="keyword">class </span>Y { <span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {}; }; };</div>
</div><!-- fragment --><p>DescendantT must be an AST base type.</p>
<p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00985">985</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00112">clang::ento::assignedToRef()</a>, <a class="el" href="LoopWidening_8cpp_source.html#l00044">clang::ento::getWidenedLoopState()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00127">clang::ento::hasSuspiciousStmt()</a>, <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>, and <a class="el" href="BugReporterVisitors_8cpp_source.html#l00435">potentiallyWritesIntoIvar()</a>.</p>

</div>
</div>
<a id="af6b510ddadcc0a313193fff2c1f18817" name="af6b510ddadcc0a313193fff2c1f18817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b510ddadcc0a313193fff2c1f18817">&#9670;&#160;</a></span>hasParent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::ArgumentAdaptingMatcherFunc&lt; internal::HasParentMatcher, internal::TypeList&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;, internal::TypeList&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt; &gt; clang::ast_matchers::hasParent = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches AST nodes that have a parent that matches the provided matcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() { <span class="keywordflow">for</span> (;;) { <span class="keywordtype">int</span> x = 42; <span class="keywordflow">if</span> (<span class="keyword">true</span>) { <span class="keywordtype">int</span> x = 43; } } }</div>
</div><!-- fragment --><p> <code>compoundStmt</code>(<a class="el" href="#af6b510ddadcc0a313193fff2c1f18817" title="Matches AST nodes that have a parent that matches the provided matcher.">hasParent(ifStmt())</a>) matches "{ int x = 43; }".</p>
<p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00994">994</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="af5cd72a6718872ac996d48de9a80bf81" name="af5cd72a6718872ac996d48de9a80bf81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5cd72a6718872ac996d48de9a80bf81">&#9670;&#160;</a></span>ifStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1IfStmt.html">IfStmt</a> &gt; clang::ast_matchers::ifStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if statements. </p>
<p>Example matches 'if (x) {}' </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (x) {}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00877">877</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>.</p>

</div>
</div>
<a id="af7b21c26d322030721227bd877344452" name="af7b21c26d322030721227bd877344452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b21c26d322030721227bd877344452">&#9670;&#160;</a></span>imaginaryLiteral</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ImaginaryLiteral.html">ImaginaryLiteral</a> &gt; clang::ast_matchers::imaginaryLiteral</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches imaginary literals, which are based on integer and floating point literals e.g.: 1i, 1.0i. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00907">907</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a28b1bdd70cca95686345d5a96d97071a" name="a28b1bdd70cca95686345d5a96d97071a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b1bdd70cca95686345d5a96d97071a">&#9670;&#160;</a></span>implicitCastExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ImplicitCastExpr.html">ImplicitCastExpr</a> &gt; clang::ast_matchers::implicitCastExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the implicit cast nodes of Clang's AST. </p>
<p>This matches many different places, including function call return value eliding, as well as any type conversions. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00949">949</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ad3014baa2a35a9fa076ae72bcedd48ad" name="ad3014baa2a35a9fa076ae72bcedd48ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3014baa2a35a9fa076ae72bcedd48ad">&#9670;&#160;</a></span>implicitValueInitExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ImplicitValueInitExpr.html">ImplicitValueInitExpr</a> &gt; clang::ast_matchers::implicitValueInitExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches implicit initializers of init list expressions. </p>
<p>Given </p><div class="fragment"><div class="line">point ptarray[10] = { [2].y = 1.0, [2].x = 2.0, [0].x = 1.0 };</div>
</div><!-- fragment --><p> <a class="el" href="#ad3014baa2a35a9fa076ae72bcedd48ad" title="Matches implicit initializers of init list expressions.">implicitValueInitExpr()</a> matches "[0].y" (implicitly) </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00837">837</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a49449307e3153888acf37c38d6d3fae8" name="a49449307e3153888acf37c38d6d3fae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49449307e3153888acf37c38d6d3fae8">&#9670;&#160;</a></span>incompleteArrayType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1IncompleteArrayType.html">IncompleteArrayType</a>&gt; clang::ast_matchers::incompleteArrayType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01014">1014</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aeb255b80ce8ca025df9e3d52ddbcfe9e" name="aeb255b80ce8ca025df9e3d52ddbcfe9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb255b80ce8ca025df9e3d52ddbcfe9e">&#9670;&#160;</a></span>indirectFieldDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1IndirectFieldDecl.html">IndirectFieldDecl</a> &gt; clang::ast_matchers::indirectFieldDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches indirect field declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> { <span class="keyword">struct </span>{ <span class="keywordtype">int</span> a; }; };</div>
</div><!-- fragment --><p> <a class="el" href="#aeb255b80ce8ca025df9e3d52ddbcfe9e" title="Matches indirect field declarations.">indirectFieldDecl()</a> matches 'a'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00789">789</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a8514475a0724042d82b5323d5a7710f6" name="a8514475a0724042d82b5323d5a7710f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8514475a0724042d82b5323d5a7710f6">&#9670;&#160;</a></span>initListExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1InitListExpr.html">InitListExpr</a> &gt; clang::ast_matchers::initListExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches init list expressions. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a[] = { 1, 2 };</div>
<div class="line"><span class="keyword">struct </span>B { <span class="keywordtype">int</span> x, y; };</div>
<div class="line">B <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = { 5, 6 };</div>
</div><!-- fragment --><p> <a class="el" href="#a8514475a0724042d82b5323d5a7710f6" title="Matches init list expressions.">initListExpr()</a> matches "{ 1, 2 }" and "{ 5, 6 }" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00833">833</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00112">clang::ento::assignedToRef()</a>.</p>

</div>
</div>
<a id="aecdc08b97af264df7f9a8cf2091ec679" name="aecdc08b97af264df7f9a8cf2091ec679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdc08b97af264df7f9a8cf2091ec679">&#9670;&#160;</a></span>injectedClassNameType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt; clang::ast_matchers::injectedClassNameType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01038">1038</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ad2109e16a4a151dc8f6416a66a750eac" name="ad2109e16a4a151dc8f6416a66a750eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2109e16a4a151dc8f6416a66a750eac">&#9670;&#160;</a></span>integerLiteral</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; clang::ast_matchers::integerLiteral</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches integer literals of all sizes / encodings, e.g. </p>
<p>1, 1L, 0x1 and 1<a class="el" href="classU.html">U</a>.</p>
<p>Does not match character-encoded integers such as L'a'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00905">905</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00139">clang::ento::forLoopMatcher()</a>, and <a class="el" href="LoopUnrolling_8cpp_source.html#l00082">clang::ento::simpleCondition()</a>.</p>

</div>
</div>
<a id="a6f0e34720bac0bffb62007c39c84ba58" name="a6f0e34720bac0bffb62007c39c84ba58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0e34720bac0bffb62007c39c84ba58">&#9670;&#160;</a></span>labelDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1LabelDecl.html">LabelDecl</a> &gt; clang::ast_matchers::labelDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a declaration of label. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">goto</span> FOO;</div>
<div class="line">FOO: bar();</div>
</div><!-- fragment --><p> <a class="el" href="#a6f0e34720bac0bffb62007c39c84ba58" title="Matches a declaration of label.">labelDecl()</a> matches 'FOO:' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00739">739</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="add73462f8d3fac6fc366163c4665447b" name="add73462f8d3fac6fc366163c4665447b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add73462f8d3fac6fc366163c4665447b">&#9670;&#160;</a></span>labelStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1LabelStmt.html">LabelStmt</a> &gt; clang::ast_matchers::labelStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches label statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">goto</span> FOO;</div>
<div class="line">FOO: bar();</div>
</div><!-- fragment --><p> <a class="el" href="#add73462f8d3fac6fc366163c4665447b" title="Matches label statements.">labelStmt()</a> matches 'FOO:' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00887">887</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a479809a0ad129df8390412a37ba54462" name="a479809a0ad129df8390412a37ba54462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479809a0ad129df8390412a37ba54462">&#9670;&#160;</a></span>lambdaExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1LambdaExpr.html">LambdaExpr</a> &gt; clang::ast_matchers::lambdaExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches lambda expressions. </p>
<p>Example matches [&amp;](){return 5;} </p><div class="fragment"><div class="line">[&amp;](){<span class="keywordflow">return</span> 5;}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00802">802</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a7cf8474301563772fb4c854671e4f33f" name="a7cf8474301563772fb4c854671e4f33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf8474301563772fb4c854671e4f33f">&#9670;&#160;</a></span>linkageSpecDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1LinkageSpecDecl.html">LinkageSpecDecl</a> &gt; clang::ast_matchers::linkageSpecDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a declaration of a linkage specification. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {}</div>
</div><!-- fragment --><p> <a class="el" href="#a7cf8474301563772fb4c854671e4f33f" title="Matches a declaration of a linkage specification.">linkageSpecDecl()</a> matches "extern "C" {}" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00737">737</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a7c5bc758921dbbbe367f4940d4ee43c8" name="a7c5bc758921dbbbe367f4940d4ee43c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5bc758921dbbbe367f4940d4ee43c8">&#9670;&#160;</a></span>lValueReferenceType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1LValueReferenceType.html">LValueReferenceType</a>&gt; clang::ast_matchers::lValueReferenceType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01027">1027</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aa051954c84b4df94040c842186dc7af7" name="aa051954c84b4df94040c842186dc7af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa051954c84b4df94040c842186dc7af7">&#9670;&#160;</a></span>materializeTemporaryExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1MaterializeTemporaryExpr.html">MaterializeTemporaryExpr</a> &gt; clang::ast_matchers::materializeTemporaryExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches nodes where temporaries are materialized. </p>
<p>Example: Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>T {<span class="keywordtype">void</span> func();};</div>
<div class="line">T f();</div>
<div class="line"><span class="keywordtype">void</span> g(T);</div>
</div><!-- fragment --><p> <a class="el" href="#aa051954c84b4df94040c842186dc7af7" title="Matches nodes where temporaries are materialized.">materializeTemporaryExpr()</a> matches 'f()' in these statements </p><div class="fragment"><div class="line">T u(f());</div>
<div class="line">g(f());</div>
<div class="line">f().func();</div>
</div><!-- fragment --><p> but does not match </p><div class="fragment"><div class="line">f();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00860">860</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ac11400493de87945dbc3c568ac8e4b08" name="ac11400493de87945dbc3c568ac8e4b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11400493de87945dbc3c568ac8e4b08">&#9670;&#160;</a></span>memberExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1MemberExpr.html">MemberExpr</a> &gt; clang::ast_matchers::memberExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches member expressions. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y {</div>
<div class="line">  <span class="keywordtype">void</span> x() { this-&gt;x(); x(); Y y; y.x(); a; this-&gt;<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>; Y::b; }</div>
<div class="line">  <span class="keywordtype">int</span> a; <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <a class="el" href="#ac11400493de87945dbc3c568ac8e4b08" title="Matches member expressions.">memberExpr()</a> matches this-&gt;x, x, y.x, a, this-&gt;b </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00796">796</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>.</p>

</div>
</div>
<a id="a90ba9a33f85183fb53caeab41d583eb4" name="a90ba9a33f85183fb53caeab41d583eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ba9a33f85183fb53caeab41d583eb4">&#9670;&#160;</a></span>memberPointerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1MemberPointerType.html">MemberPointerType</a>&gt; clang::ast_matchers::memberPointerType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01023">1023</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a58f643ef24ff21b9fcedf8bca5c56a66" name="a58f643ef24ff21b9fcedf8bca5c56a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f643ef24ff21b9fcedf8bca5c56a66">&#9670;&#160;</a></span>namedDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt; clang::ast_matchers::namedDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a declaration of anything that could have a name. </p>
<p>Example matches <code>X</code>, <code>S</code>, the anonymous union type, <code>i</code>, and <code><a class="el" href="classU.html">U</a></code>; </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>;</div>
<div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">  <span class="keyword">union </span>{</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">  } <a class="code hl_class" href="classU.html">U</a>;</div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00738">738</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab75d519da08b712a2dbc687eb84bfafd" name="ab75d519da08b712a2dbc687eb84bfafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75d519da08b712a2dbc687eb84bfafd">&#9670;&#160;</a></span>namespaceAliasDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NamespaceAliasDecl.html">NamespaceAliasDecl</a> &gt; clang::ast_matchers::namespaceAliasDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a declaration of a namespace alias. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>test {}</div>
<div class="line"><span class="keyword">namespace </span>alias = ::test;</div>
</div><!-- fragment --><p> <a class="el" href="#ab75d519da08b712a2dbc687eb84bfafd" title="Matches a declaration of a namespace alias.">namespaceAliasDecl()</a> matches "namespace alias" but not "namespace test" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00742">742</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ad499907435f5547a1f44215dd65c00a2" name="ad499907435f5547a1f44215dd65c00a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad499907435f5547a1f44215dd65c00a2">&#9670;&#160;</a></span>namespaceDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NamespaceDecl.html">NamespaceDecl</a> &gt; clang::ast_matchers::namespaceDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a declaration of a namespace. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>{}</div>
<div class="line"><span class="keyword">namespace </span>test {}</div>
</div><!-- fragment --><p> <a class="el" href="#ad499907435f5547a1f44215dd65c00a2" title="Matches a declaration of a namespace.">namespaceDecl()</a> matches "namespace {}" and "namespace test {}" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00740">740</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a426e811c0ed2c4e2fa0ad0491f3ac54f" name="a426e811c0ed2c4e2fa0ad0491f3ac54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426e811c0ed2c4e2fa0ad0491f3ac54f">&#9670;&#160;</a></span>nestedNameSpecifier</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt;<a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a>&gt; clang::ast_matchers::nestedNameSpecifier</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01002">1002</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="afc5b4f5e6d4a60a21d2d08d000dc4fde" name="afc5b4f5e6d4a60a21d2d08d000dc4fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5b4f5e6d4a60a21d2d08d000dc4fde">&#9670;&#160;</a></span>nestedNameSpecifierLoc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt;<a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>&gt; clang::ast_matchers::nestedNameSpecifierLoc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01004">1004</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a4c54a7bb3aa3ae9d1fdca749e1da10c6" name="a4c54a7bb3aa3ae9d1fdca749e1da10c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c54a7bb3aa3ae9d1fdca749e1da10c6">&#9670;&#160;</a></span>nonTypeTemplateParmDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NonTypeTemplateParmDecl.html">NonTypeTemplateParmDecl</a> &gt; clang::ast_matchers::nonTypeTemplateParmDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches non-type template parameter declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keywordtype">int</span> N&gt; <span class="keyword">struct </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {};</div>
</div><!-- fragment --><p> <a class="el" href="#a4c54a7bb3aa3ae9d1fdca749e1da10c6" title="Matches non-type template parameter declarations.">nonTypeTemplateParmDecl()</a> matches 'N', but not 'T'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00763">763</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a4e85f3028bc3d2d590878c3587d43f5c" name="a4e85f3028bc3d2d590878c3587d43f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e85f3028bc3d2d590878c3587d43f5c">&#9670;&#160;</a></span>nullStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1NullStmt.html">NullStmt</a> &gt; clang::ast_matchers::nullStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches null statements. </p>
<div class="fragment"><div class="line">foo();;</div>
</div><!-- fragment --><p> <a class="el" href="#a4e85f3028bc3d2d590878c3587d43f5c" title="Matches null statements.">nullStmt()</a> matches the second ';' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00897">897</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a928d07f25f82fdf52ca6b480e0aca4d5" name="a928d07f25f82fdf52ca6b480e0aca4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928d07f25f82fdf52ca6b480e0aca4d5">&#9670;&#160;</a></span>objcCatchStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAtCatchStmt.html">ObjCAtCatchStmt</a> &gt; clang::ast_matchers::objcCatchStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C @catch statements. </p>
<p>Example matches @catch </p><div class="fragment"><div class="line"><span class="keywordflow">@try</span> {}</div>
<div class="line"><span class="keywordflow">@catch</span> (...) {}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00828">828</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a64d992911b288aaba2ba96ecc5e1e33c" name="a64d992911b288aaba2ba96ecc5e1e33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d992911b288aaba2ba96ecc5e1e33c">&#9670;&#160;</a></span>objcCategoryDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCCategoryDecl.html">ObjCCategoryDecl</a> &gt; clang::ast_matchers::objcCategoryDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C category declarations. </p>
<p>Example matches Foo (Additions) </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>Foo (Additions)</div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00814">814</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a9a8d9b5d54b3ed41d0b2d03e776af90e" name="a9a8d9b5d54b3ed41d0b2d03e776af90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8d9b5d54b3ed41d0b2d03e776af90e">&#9670;&#160;</a></span>objcCategoryImplDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCCategoryImplDecl.html">ObjCCategoryImplDecl</a> &gt; clang::ast_matchers::objcCategoryImplDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C category definitions. </p>
<p>Example matches Foo (Additions) </p><div class="fragment"><div class="line"><span class="keyword">@implementation </span>Foo (Additions)</div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00816">816</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2d463a0af3ae121edc9b41d14c0706a7" name="a2d463a0af3ae121edc9b41d14c0706a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d463a0af3ae121edc9b41d14c0706a7">&#9670;&#160;</a></span>objcFinallyStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAtFinallyStmt.html">ObjCAtFinallyStmt</a> &gt; clang::ast_matchers::objcFinallyStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C @finally statements. </p>
<p>Example matches @finally </p><div class="fragment"><div class="line"><span class="keywordflow">@try</span> {}</div>
<div class="line"><span class="keywordflow">@finally</span> {}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00830">830</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="acd07286ab423090b73a60717e8ccf5a7" name="acd07286ab423090b73a60717e8ccf5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd07286ab423090b73a60717e8ccf5a7">&#9670;&#160;</a></span>objcImplementationDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCImplementationDecl.html">ObjCImplementationDecl</a> &gt; clang::ast_matchers::objcImplementationDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C implementation declarations. </p>
<p>Example matches Foo </p><div class="fragment"><div class="line"><span class="keyword">@implementation </span>Foo</div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00810">810</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab10a69694c50b6e017fbe02072e7115e" name="ab10a69694c50b6e017fbe02072e7115e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10a69694c50b6e017fbe02072e7115e">&#9670;&#160;</a></span>objcInterfaceDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a> &gt; clang::ast_matchers::objcInterfaceDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C interface declarations. </p>
<p>Example matches Foo </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>Foo</div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00808">808</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a10b9991e6e90b4ca132af940b11b4339" name="a10b9991e6e90b4ca132af940b11b4339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b9991e6e90b4ca132af940b11b4339">&#9670;&#160;</a></span>objcIvarDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCIvarDecl.html">ObjCIvarDecl</a> &gt; clang::ast_matchers::objcIvarDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C instance variable declarations. </p>
<p>Example matches _enabled </p><div class="fragment"><div class="line"><span class="keyword">@implementation </span>Foo {</div>
<div class="line">  BOOL _enabled;</div>
<div class="line">}</div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00821">821</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a1691aa67fc4125c0978aa73995001aa8" name="a1691aa67fc4125c0978aa73995001aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1691aa67fc4125c0978aa73995001aa8">&#9670;&#160;</a></span>objcIvarRefExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCIvarRefExpr.html">ObjCIvarRefExpr</a> &gt; clang::ast_matchers::objcIvarRefExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a reference to an ObjCIvar. </p>
<p>Example: matches "a" in "init" method: </p><div class="fragment"><div class="line"><span class="keyword">@implementation </span>A {</div>
<div class="line">  NSString *a;</div>
<div class="line">}</div>
<div class="line">- (void) init {</div>
<div class="line">  a = <span class="stringliteral">@&quot;hello&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00875">875</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BugReporterVisitors_8cpp_source.html#l00435">potentiallyWritesIntoIvar()</a>.</p>

</div>
</div>
<a id="a76e430a6b71305865cc46c57a9465c84" name="a76e430a6b71305865cc46c57a9465c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e430a6b71305865cc46c57a9465c84">&#9670;&#160;</a></span>objcMessageExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a> &gt; clang::ast_matchers::objcMessageExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches ObjectiveC Message invocation expressions. </p>
<p>The innermost message send invokes the "alloc" class method on the NSString class, while the outermost message send invokes the "initWithString" instance method on the object returned from NSString's "alloc". This matcher should match both message sends. </p><div class="fragment"><div class="line">[[NSString alloc] initWithString:<span class="stringliteral">@&quot;Hello&quot;</span>]</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00806">806</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a3a90eb6eeec44cfb79ef98129ad90ec1" name="a3a90eb6eeec44cfb79ef98129ad90ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a90eb6eeec44cfb79ef98129ad90ec1">&#9670;&#160;</a></span>objcMethodDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a> &gt; clang::ast_matchers::objcMethodDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C method declarations. </p>
<p>Example matches both declaration and definition of -[Foo method] </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>Foo</div>
<div class="line">- (void)method;</div>
<div class="line"><span class="keyword">@end</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">@implementation </span>Foo</div>
<div class="line">- (void)method {}</div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00818">818</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a1c474e1c9e9c11c0699a97cc0c617d90" name="a1c474e1c9e9c11c0699a97cc0c617d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c474e1c9e9c11c0699a97cc0c617d90">&#9670;&#160;</a></span>objcObjectPointerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1ObjCObjectPointerType.html">ObjCObjectPointerType</a>&gt; clang::ast_matchers::objcObjectPointerType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01025">1025</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2bfb6ad7b935550af24feaa79d757eca" name="a2bfb6ad7b935550af24feaa79d757eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfb6ad7b935550af24feaa79d757eca">&#9670;&#160;</a></span>objcPropertyDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a> &gt; clang::ast_matchers::objcPropertyDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C property declarations. </p>
<p>Example matches enabled </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>Foo</div>
<div class="line"><span class="keyword">@property</span> BOOL enabled;</div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00823">823</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a27b140b9aeec980b173418f5b4490c8e" name="a27b140b9aeec980b173418f5b4490c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b140b9aeec980b173418f5b4490c8e">&#9670;&#160;</a></span>objcProtocolDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCProtocolDecl.html">ObjCProtocolDecl</a> &gt; clang::ast_matchers::objcProtocolDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C protocol declarations. </p>
<p>Example matches FooDelegate </p><div class="fragment"><div class="line"><span class="keyword">@protocol </span>FooDelegate</div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00812">812</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="abb294df9fab76f0f4677ccc500d94f26" name="abb294df9fab76f0f4677ccc500d94f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb294df9fab76f0f4677ccc500d94f26">&#9670;&#160;</a></span>objcThrowStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAtThrowStmt.html">ObjCAtThrowStmt</a> &gt; clang::ast_matchers::objcThrowStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C @throw statements. </p>
<p>Example matches @throw </p><div class="fragment"><div class="line"><span class="keyword">@throw</span> obj;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00825">825</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aa54c79304345729b9a3b5f1abf9dc5a8" name="aa54c79304345729b9a3b5f1abf9dc5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54c79304345729b9a3b5f1abf9dc5a8">&#9670;&#160;</a></span>objcTryStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAtTryStmt.html">ObjCAtTryStmt</a> &gt; clang::ast_matchers::objcTryStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C @try statements. </p>
<p>Example matches @try </p><div class="fragment"><div class="line"><span class="keywordflow">@try</span> {}</div>
<div class="line"><span class="keywordflow">@catch</span> (...) {}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00826">826</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a381bce396b06bba5e9bd658b76caa2cd" name="a381bce396b06bba5e9bd658b76caa2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381bce396b06bba5e9bd658b76caa2cd">&#9670;&#160;</a></span>ompDefaultClause</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt;<a class="el" href="classclang_1_1OMPClause.html">OMPClause</a>, <a class="el" href="classclang_1_1OMPDefaultClause.html">OMPDefaultClause</a>&gt; clang::ast_matchers::ompDefaultClause</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01053">1053</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aa46c78f9e0d25b95959055d0265dedd8" name="aa46c78f9e0d25b95959055d0265dedd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46c78f9e0d25b95959055d0265dedd8">&#9670;&#160;</a></span>ompExecutableDirective</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt;<a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a>&gt; clang::ast_matchers::ompExecutableDirective</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01051">1051</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ae7160bb2f02400b2152dc7e0b10d763a" name="ae7160bb2f02400b2152dc7e0b10d763a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7160bb2f02400b2152dc7e0b10d763a">&#9670;&#160;</a></span>opaqueValueExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1OpaqueValueExpr.html">OpaqueValueExpr</a> &gt; clang::ast_matchers::opaqueValueExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches opaque value expressions. </p>
<p>They are used as helpers to reference another expressions and can be met in BinaryConditionalOperators, for example.</p>
<p>Example matches 'a' </p><div class="fragment"><div class="line">(a ?: <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>) + 42;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00933">933</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2a07934509f8d264c16974bbe0c15ac7" name="a2a07934509f8d264c16974bbe0c15ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a07934509f8d264c16974bbe0c15ac7">&#9670;&#160;</a></span>optionally</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicOperatorMatcherFunc&lt; 1, 1 &gt; clang::ast_matchers::optionally</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    internal::DynTypedMatcher::VO_Optionally}</div>
</div><!-- fragment -->
<p>Matches any node regardless of the submatcher. </p>
<p>However, <code>optionally</code> will retain any bindings generated by the submatcher. Useful when additional information which may or may not present about a main matching node is desired.</p>
<p>For example, in: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo {</div>
<div class="line">  <span class="keywordtype">int</span> bar;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The matcher: </p><div class="fragment"><div class="line"><a class="code hl_variable" href="#ac1ef73826e6b83dd0e8fc4a4b7284c74">cxxRecordDecl</a>(</div>
<div class="line">  <a class="code hl_variable" href="#a2a07934509f8d264c16974bbe0c15ac7">optionally</a>(<a class="code hl_variable" href="#a9a14e1788aad32c318543405b5ec5962">has</a>(</div>
<div class="line">    <a class="code hl_variable" href="#ab26f3ff62d6be975196efa86f3b15d82">fieldDecl</a>(<a class="code hl_function" href="#a4360554ed6340d60248b5d5930c44d49">hasName</a>(<span class="stringliteral">&quot;bar&quot;</span>)).bind(<span class="stringliteral">&quot;var&quot;</span>)</div>
<div class="line">))).bind(<span class="stringliteral">&quot;record&quot;</span>)</div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a2a07934509f8d264c16974bbe0c15ac7"><div class="ttname"><a href="#a2a07934509f8d264c16974bbe0c15ac7">clang::ast_matchers::optionally</a></div><div class="ttdeci">const internal::VariadicOperatorMatcherFunc&lt; 1, 1 &gt; optionally</div><div class="ttdoc">Matches any node regardless of the submatcher.</div><div class="ttdef"><b>Definition</b> <a href="ASTMatchersInternal_8cpp_source.html#l00968">ASTMatchersInternal.cpp:968</a></div></div>
</div><!-- fragment --><p> will produce a result binding for both "record" and "var". The matcher will produce a "record" binding for even if there is no data member named "bar" in that class.</p>
<p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00968">968</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a97ef12437e36922d96bea2cb8f762b9a" name="a97ef12437e36922d96bea2cb8f762b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ef12437e36922d96bea2cb8f762b9a">&#9670;&#160;</a></span>parenExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ParenExpr.html">ParenExpr</a> &gt; clang::ast_matchers::parenExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches parentheses used in expressions. </p>
<p>Example matches (foo() + 1) </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> foo() { <span class="keywordflow">return</span> 1; }</div>
<div class="line"><span class="keywordtype">int</span> a = (foo() + 1);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00851">851</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a6137ba1734e9c2499cefdac0ad7474de" name="a6137ba1734e9c2499cefdac0ad7474de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6137ba1734e9c2499cefdac0ad7474de">&#9670;&#160;</a></span>parenListExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ParenListExpr.html">ParenListExpr</a> &gt; clang::ast_matchers::parenListExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches paren list expressions. </p>
<p>ParenListExprs don't have a predefined type and are used for late parsing. In the final AST, they can be met in template declarations.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {</div>
<div class="line">  <span class="keywordtype">void</span> f() {</div>
<div class="line">    <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> x(*<span class="keyword">this</span>);</div>
<div class="line">    <span class="keywordtype">int</span> a = 0, <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = 1; <span class="keywordtype">int</span> i = (a, <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>);</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p> <a class="el" href="#a6137ba1734e9c2499cefdac0ad7474de" title="Matches paren list expressions.">parenListExpr()</a> matches "*this" but NOT matches (a, b) because (a, b) has a predefined type and is a <a class="el" href="classclang_1_1ParenExpr.html" title="ParenExpr - This represents a parethesized expression, e.g.">ParenExpr</a>, not a <a class="el" href="classclang_1_1ParenListExpr.html">ParenListExpr</a>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00838">838</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a6f014abb752de135c866b75515997918" name="a6f014abb752de135c866b75515997918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f014abb752de135c866b75515997918">&#9670;&#160;</a></span>parenType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1ParenType.html">ParenType</a>&gt; clang::ast_matchers::parenType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01021">1021</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a3b7539a5a5ad3112f453ffb3ab9a67c5" name="a3b7539a5a5ad3112f453ffb3ab9a67c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7539a5a5ad3112f453ffb3ab9a67c5">&#9670;&#160;</a></span>parmVarDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ParmVarDecl.html">ParmVarDecl</a> &gt; clang::ast_matchers::parmVarDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches parameter variable declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> x);</div>
</div><!-- fragment --><p> <a class="el" href="#a3b7539a5a5ad3112f453ffb3ab9a67c5" title="Matches parameter variable declarations.">parmVarDecl()</a> matches <code>int</code> x. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00755">755</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00105">clang::ento::callByRef()</a>.</p>

</div>
</div>
<a id="ab54c06461d2b15cc9701a1f8a5507daf" name="ab54c06461d2b15cc9701a1f8a5507daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54c06461d2b15cc9701a1f8a5507daf">&#9670;&#160;</a></span>pointerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1PointerType.html">PointerType</a>&gt; clang::ast_matchers::pointerType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01024">1024</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaStmt_8cpp_source.html#l03994">clang::Sema::ActOnObjCAtSynchronizedOperand()</a>, <a class="el" href="SemaChecking_8cpp_source.html#l04704">clang::Sema::BuildAtomicExpr()</a>, <a class="el" href="SemaChecking_8cpp_source.html#l04357">CheckNonNullArguments()</a>, <a class="el" href="SemaStmt_8cpp_source.html#l01888">clang::Sema::CheckObjCForCollectionOperand()</a>, <a class="el" href="CGExprScalar_8cpp_source.html#l03313">emitPointerArithmetic()</a>, and <a class="el" href="OSObjectCStyleCast_8cpp_source.html#l00062">hasTypePointingTo()</a>.</p>

</div>
</div>
<a id="a33b52666b405fc2bf1a28120d488488c" name="a33b52666b405fc2bf1a28120d488488c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b52666b405fc2bf1a28120d488488c">&#9670;&#160;</a></span>predefinedExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1PredefinedExpr.html">PredefinedExpr</a> &gt; clang::ast_matchers::predefinedExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches predefined identifier expressions [C99 6.4.2.2]. </p>
<p>Example: Matches <b>func</b> </p><div class="fragment"><div class="line"><a class="code hl_function" href="opencl-c_8h.html#a1b66ea7b0c0b95a8154b5c0641848db6">printf</a>(<span class="stringliteral">&quot;%s&quot;</span>, __func__);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00956">956</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aefc28b8bf75f10413691d11b9c371116" name="aefc28b8bf75f10413691d11b9c371116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc28b8bf75f10413691d11b9c371116">&#9670;&#160;</a></span>qualType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt; clang::ast_matchers::qualType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code>QualTypes</code> in the clang AST. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00769">769</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l03856">AST_MATCHER_P_OVERLOAD()</a>, <a class="el" href="ASTMatchers_8h_source.html#l03917">AST_MATCHER_P_OVERLOAD()</a>, <a class="el" href="ASTMatchers_8h_source.html#l03798">AST_POLYMORPHIC_MATCHER_P_OVERLOAD()</a>, and <a class="el" href="LoopUnrolling_8cpp_source.html#l00105">clang::ento::callByRef()</a>.</p>

</div>
</div>
<a id="ace97e34c0eac8c61ce7fe928633657c9" name="ace97e34c0eac8c61ce7fe928633657c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace97e34c0eac8c61ce7fe928633657c9">&#9670;&#160;</a></span>recordDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1RecordDecl.html">RecordDecl</a> &gt; clang::ast_matchers::recordDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches class, struct, and union declarations. </p>
<p>Example matches <code>X</code>, <code>Z</code>, <code><a class="el" href="classU.html">U</a></code>, and <code>S</code> </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span>Z {};</div>
<div class="line"><span class="keyword">struct </span>S {};</div>
<div class="line"><span class="keyword">union </span><a class="code hl_class" href="classU.html">U</a> {};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00743">743</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaType_8cpp_source.html#l03968">classifyPointerDeclarator()</a>, and <a class="el" href="AbstractBasicWriter_8h_source.html#l00183">clang::serialization::WriteDispatcher&lt; FunctionDecl * &gt;::write()</a>.</p>

</div>
</div>
<a id="aba33a83216073984c1a929a28f3091d3" name="aba33a83216073984c1a929a28f3091d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba33a83216073984c1a929a28f3091d3">&#9670;&#160;</a></span>recordType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1RecordType.html">RecordType</a>&gt; clang::ast_matchers::recordType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01033">1033</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaDeclCXX_8cpp_source.html#l15838">clang::Sema::BuildExceptionDeclaration()</a>, <a class="el" href="SemaDecl_8cpp_source.html#l12848">clang::Sema::CheckCompleteVariableDeclaration()</a>, <a class="el" href="SemaType_8cpp_source.html#l03968">classifyPointerDeclarator()</a>, <a class="el" href="SwiftCallingConv_8cpp_source.html#l00815">classifyType()</a>, and <a class="el" href="CGBlocks_8cpp_source.html#l00388">isSafeForCXXConstantCapture()</a>.</p>

</div>
</div>
<a id="af815f75b8b46c51b83b9a63fd65ac7e9" name="af815f75b8b46c51b83b9a63fd65ac7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af815f75b8b46c51b83b9a63fd65ac7e9">&#9670;&#160;</a></span>referenceType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1ReferenceType.html">ReferenceType</a>&gt; clang::ast_matchers::referenceType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01026">1026</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00112">clang::ento::assignedToRef()</a>, and <a class="el" href="LoopWidening_8cpp_source.html#l00044">clang::ento::getWidenedLoopState()</a>.</p>

</div>
</div>
<a id="a42e8f0ff0127b0536c53a76dbf5f28a7" name="a42e8f0ff0127b0536c53a76dbf5f28a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e8f0ff0127b0536c53a76dbf5f28a7">&#9670;&#160;</a></span>returnStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ReturnStmt.html">ReturnStmt</a> &gt; clang::ast_matchers::returnStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches return statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> 1;</div>
</div><!-- fragment --><p> <a class="el" href="#a42e8f0ff0127b0536c53a76dbf5f28a7" title="Matches return statements.">returnStmt()</a> matches 'return 1' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00885">885</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00127">clang::ento::hasSuspiciousStmt()</a>.</p>

</div>
</div>
<a id="a0914bea7f6abd63ad8a6e823a608bf92" name="a0914bea7f6abd63ad8a6e823a608bf92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0914bea7f6abd63ad8a6e823a608bf92">&#9670;&#160;</a></span>rValueReferenceType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1RValueReferenceType.html">RValueReferenceType</a>&gt; clang::ast_matchers::rValueReferenceType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01028">1028</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a99ab1f66ff6c5a790900ae8f625e9a09" name="a99ab1f66ff6c5a790900ae8f625e9a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ab1f66ff6c5a790900ae8f625e9a09">&#9670;&#160;</a></span>staticAssertDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1StaticAssertDecl.html">StaticAssertDecl</a> &gt; clang::ast_matchers::staticAssertDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a C++ static_assert declaration. </p>
<p>Example: staticAssertExpr() matches static_assert(sizeof(S) == sizeof(int)) in </p><div class="fragment"><div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">  <span class="keywordtype">int</span> x;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(S) == <span class="keyword">sizeof</span>(<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>));</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00935">935</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ade2304887c9dd0e9fad2e0ff35320739" name="ade2304887c9dd0e9fad2e0ff35320739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2304887c9dd0e9fad2e0ff35320739">&#9670;&#160;</a></span>stmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt; clang::ast_matchers::stmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches statements. </p>
<p>Given </p><div class="fragment"><div class="line">{ ++a; }</div>
</div><!-- fragment --><p> <a class="el" href="#ade2304887c9dd0e9fad2e0ff35320739" title="Matches statements.">stmt()</a> matches both the compound statement '{ ++a; }' and '++a'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00794">794</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l02864">alignOfExpr()</a>, <a class="el" href="CFG_8h_source.html#l01258">clang::CFG::BuildOptions::alwaysAdd()</a>, <a class="el" href="LiveVariables_8cpp_source.html#l00496">clang::LiveVariables::computeLiveness()</a>, <a class="el" href="SValBuilder_8h_source.html#l00179">clang::ento::SValBuilder::conjureSymbol()</a>, <a class="el" href="SValBuilder_8cpp_source.html#l00172">clang::ento::SValBuilder::conjureSymbolVal()</a>, <a class="el" href="AnalysisDeclContext_8cpp_source.html#l00190">clang::AnalysisDeclContext::getBlockForRegisteredExpression()</a>, <a class="el" href="LoopWidening_8cpp_source.html#l00044">clang::ento::getWidenedLoopState()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00127">clang::ento::hasSuspiciousStmt()</a>, <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00162">clang::ento::isPossiblyEscaped()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l00435">potentiallyWritesIntoIvar()</a>, <a class="el" href="AnalysisDeclContext_8cpp_source.html#l00180">clang::AnalysisDeclContext::registerForcedBlockExpression()</a>, <a class="el" href="ASTMatchers_8h_source.html#l02873">sizeOfExpr()</a>, and <a class="el" href="CFG_8h_source.html#l01380">clang::CFG::VisitBlockStmts()</a>.</p>

</div>
</div>
<a id="a07128394c216b2d373a8ee39956e7689" name="a07128394c216b2d373a8ee39956e7689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07128394c216b2d373a8ee39956e7689">&#9670;&#160;</a></span>stmtExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1StmtExpr.html">StmtExpr</a> &gt; clang::ast_matchers::stmtExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches statement expression (GNU extension). </p>
<p>Example match: ({ int X = 4; X; }) </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> = ({ <span class="keywordtype">int</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> = 4; <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>; });</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00921">921</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2c9fffe33e90bbb4b8f099caf377d7b1" name="a2c9fffe33e90bbb4b8f099caf377d7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9fffe33e90bbb4b8f099caf377d7b1">&#9670;&#160;</a></span>stringLiteral</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1StringLiteral.html">StringLiteral</a> &gt; clang::ast_matchers::stringLiteral</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches string literals (also matches wide string literals). </p>
<p>Example matches "abcd", L"abcd" </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> *<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a> = <span class="stringliteral">&quot;abcd&quot;</span>;</div>
<div class="line"><span class="keywordtype">wchar_t</span> *ws = L<span class="stringliteral">&quot;abcd&quot;</span>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00901">901</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="af06b6e50f8eb6094020ec5bf89a746a4" name="af06b6e50f8eb6094020ec5bf89a746a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06b6e50f8eb6094020ec5bf89a746a4">&#9670;&#160;</a></span>substNonTypeTemplateParmExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1SubstNonTypeTemplateParmExpr.html">SubstNonTypeTemplateParmExpr</a> &gt; clang::ast_matchers::substNonTypeTemplateParmExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches substitutions of non-type template parameters. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N&gt;</div>
<div class="line"><span class="keyword">struct </span>A { <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = <a class="code hl_variable" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a>; };</div>
<div class="line"><span class="keyword">struct </span>B : <span class="keyword">public</span> A&lt;42&gt; {};</div>
</div><!-- fragment --><p> <a class="el" href="#af06b6e50f8eb6094020ec5bf89a746a4" title="Matches substitutions of non-type template parameters.">substNonTypeTemplateParmExpr()</a> matches "N" in the right-hand side of "static const int n = N;" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00840">840</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a220e5a0250d5fdc7cad9d0da256132fe" name="a220e5a0250d5fdc7cad9d0da256132fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220e5a0250d5fdc7cad9d0da256132fe">&#9670;&#160;</a></span>substTemplateTypeParmType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1SubstTemplateTypeParmType.html">SubstTemplateTypeParmType</a>&gt; clang::ast_matchers::substTemplateTypeParmType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01036">1036</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab7abc89804682f83816d2323cdc718cf" name="ab7abc89804682f83816d2323cdc718cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7abc89804682f83816d2323cdc718cf">&#9670;&#160;</a></span>switchCase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1SwitchCase.html">SwitchCase</a> &gt; clang::ast_matchers::switchCase</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches case and default statements inside switch statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">switch</span>(a) { <span class="keywordflow">case</span> 42: <span class="keywordflow">break</span>; <span class="keywordflow">default</span>: <span class="keywordflow">break</span>; }</div>
</div><!-- fragment --><p> <a class="el" href="#ab7abc89804682f83816d2323cdc718cf" title="Matches case and default statements inside switch statements.">switchCase()</a> matches 'case 42:' and 'default:'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00890">890</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="abf04346715336de0dfc10dac8ed114d9" name="abf04346715336de0dfc10dac8ed114d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf04346715336de0dfc10dac8ed114d9">&#9670;&#160;</a></span>switchStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1SwitchStmt.html">SwitchStmt</a> &gt; clang::ast_matchers::switchStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches switch statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">switch</span>(a) { <span class="keywordflow">case</span> 42: <span class="keywordflow">break</span>; <span class="keywordflow">default</span>: <span class="keywordflow">break</span>; }</div>
</div><!-- fragment --><p> <a class="el" href="#abf04346715336de0dfc10dac8ed114d9" title="Matches switch statements.">switchStmt()</a> matches 'switch(a)'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00889">889</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00127">clang::ento::hasSuspiciousStmt()</a>, and <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>.</p>

</div>
</div>
<a id="a036eda5d1a6e83d02a2479799aa1e0ad" name="a036eda5d1a6e83d02a2479799aa1e0ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036eda5d1a6e83d02a2479799aa1e0ad">&#9670;&#160;</a></span>tagDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TagDecl.html">TagDecl</a> &gt; clang::ast_matchers::tagDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches tag declarations. </p>
<p>Example matches X, Z, <a class="el" href="classU.html">U</a>, S, E </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span>Z {};</div>
<div class="line"><span class="keyword">struct </span>S {};</div>
<div class="line"><span class="keyword">union </span><a class="code hl_class" href="classU.html">U</a> {};</div>
<div class="line"><span class="keyword">enum</span> E {</div>
<div class="line">  A, B, <a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a></div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00782">782</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a46559546a6a5dbdb21f04e377ddb0baf" name="a46559546a6a5dbdb21f04e377ddb0baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46559546a6a5dbdb21f04e377ddb0baf">&#9670;&#160;</a></span>tagType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1TagType.html">TagType</a>&gt; clang::ast_matchers::tagType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01034">1034</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTContext_8cpp_source.html#l06450">clang::ASTContext::getCFConstantStringDecl()</a>.</p>

</div>
</div>
<a id="a56c848824461ac59d9a1c7e7aeea9ec3" name="a56c848824461ac59d9a1c7e7aeea9ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c848824461ac59d9a1c7e7aeea9ec3">&#9670;&#160;</a></span>templateArgument</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a> &gt; clang::ast_matchers::templateArgument</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template arguments. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {};</div>
<div class="line"><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C&lt;int&gt;</a> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> <a class="el" href="#a56c848824461ac59d9a1c7e7aeea9ec3" title="Matches template arguments.">templateArgument()</a> matches 'int' in C&lt;int&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00759">759</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ac2354be35a4ff17fd80deade9753ea97" name="ac2354be35a4ff17fd80deade9753ea97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2354be35a4ff17fd80deade9753ea97">&#9670;&#160;</a></span>templateArgumentLoc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a> &gt; clang::ast_matchers::templateArgumentLoc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template arguments (with location info). </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {};</div>
<div class="line"><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C&lt;int&gt;</a> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> <a class="el" href="#ac2354be35a4ff17fd80deade9753ea97" title="Matches template arguments (with location info).">templateArgumentLoc()</a> matches 'int' in C&lt;int&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00760">760</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2244dfcab0601fe79666d8a4a9dde4b9" name="a2244dfcab0601fe79666d8a4a9dde4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2244dfcab0601fe79666d8a4a9dde4b9">&#9670;&#160;</a></span>templateName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1TemplateName.html">TemplateName</a> &gt; clang::ast_matchers::templateName</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template name. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> { };</div>
<div class="line"><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X&lt;int&gt;</a> xi;</div>
</div><!-- fragment --><p> <a class="el" href="#a2244dfcab0601fe79666d8a4a9dde4b9" title="Matches template name.">templateName()</a> matches 'X' in X&lt;int&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00761">761</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="af35e48d050bc59b7a1cf9f428753e937" name="af35e48d050bc59b7a1cf9f428753e937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35e48d050bc59b7a1cf9f428753e937">&#9670;&#160;</a></span>templateSpecializationType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt; clang::ast_matchers::templateSpecializationType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01031">1031</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab193711230649b28f6fd61cde737bed5" name="ab193711230649b28f6fd61cde737bed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab193711230649b28f6fd61cde737bed5">&#9670;&#160;</a></span>templateTemplateParmDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TemplateTemplateParmDecl.html">TemplateTemplateParmDecl</a> &gt; clang::ast_matchers::templateTemplateParmDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template template parameter declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>Z, <span class="keywordtype">int</span> <a class="code hl_variable" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a>&gt; <span class="keyword">struct </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {};</div>
</div><!-- fragment --><p> <a class="el" href="#a95a6a300dc0c5bbfdcdc2af001c316f6" title="Matches template type parameter declarations.">templateTypeParmDecl()</a> matches 'Z', but not 'N'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00767">767</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a95a6a300dc0c5bbfdcdc2af001c316f6" name="a95a6a300dc0c5bbfdcdc2af001c316f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a6a300dc0c5bbfdcdc2af001c316f6">&#9670;&#160;</a></span>templateTypeParmDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TemplateTypeParmDecl.html">TemplateTypeParmDecl</a> &gt; clang::ast_matchers::templateTypeParmDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template type parameter declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keywordtype">int</span> N&gt; <span class="keyword">struct </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> {};</div>
</div><!-- fragment --><p> <a class="el" href="#a95a6a300dc0c5bbfdcdc2af001c316f6" title="Matches template type parameter declarations.">templateTypeParmDecl()</a> matches 'T', but not 'N'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00765">765</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a93f7f721802fd12747c14f2b45dc06c0" name="a93f7f721802fd12747c14f2b45dc06c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f7f721802fd12747c14f2b45dc06c0">&#9670;&#160;</a></span>templateTypeParmType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt; clang::ast_matchers::templateTypeParmType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01037">1037</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aaa73ed83faa263bfb5cface81d30ef91" name="aaa73ed83faa263bfb5cface81d30ef91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa73ed83faa263bfb5cface81d30ef91">&#9670;&#160;</a></span>translationUnitDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TranslationUnitDecl.html">TranslationUnitDecl</a> &gt; clang::ast_matchers::translationUnitDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the top declaration context. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>;</div>
<div class="line"><span class="keyword">namespace </span>NS {</div>
<div class="line"><span class="keywordtype">int</span> Y;</div>
<div class="line">}  <span class="comment">// namespace NS</span></div>
</div><!-- fragment --><p> decl(hasDeclContext(translationUnitDecl())) matches "int X", but not "int Y". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00727">727</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a600679c157b5bd05c4bfb940fb2511dd" name="a600679c157b5bd05c4bfb940fb2511dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600679c157b5bd05c4bfb940fb2511dd">&#9670;&#160;</a></span>type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1Type.html">Type</a> &gt; clang::ast_matchers::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code>Types</code> in the clang AST. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00770">770</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaDeclObjC_8cpp_source.html#l01410">clang::Sema::actOnObjCTypeArgsOrProtocolQualifiers()</a>, <a class="el" href="SemaInit_8cpp_source.html#l03723">clang::InitializationSequence::AddPassByIndirectCopyRestoreStep()</a>, <a class="el" href="ASTContext_8cpp_source.html#l05101">clang::ASTContext::applyObjCProtocolQualifiers()</a>, <a class="el" href="SemaType_8cpp_source.html#l00837">applyObjCTypeArgs()</a>, <a class="el" href="SemaExpr_8cpp_source.html#l07251">breakDownVectorType()</a>, <a class="el" href="SemaExprMember_8cpp_source.html#l00948">clang::Sema::BuildMemberReferenceExpr()</a>, <a class="el" href="Transforms_8cpp_source.html#l00038">clang::arcmt::trans::canApplyWeak()</a>, <a class="el" href="SemaType_8cpp_source.html#l07040">checkNullabilityTypeSpecifier()</a>, <a class="el" href="SemaType_8cpp_source.html#l07144">checkObjCKindOfType()</a>, <a class="el" href="Expr_8cpp_source.html#l04460">clang::PseudoObjectExpr::Create()</a>, <a class="el" href="SemaType_8cpp_source.html#l00069">diagnoseBadTypeAttribute()</a>, <a class="el" href="CGDebugInfo_8cpp_source.html#l04479">clang::CodeGen::CGDebugInfo::EmitDeclareOfBlockLiteralArgVariable()</a>, <a class="el" href="Expr_8cpp_source.html#l02731">clang::Expr::findBoundMemberType()</a>, <a class="el" href="SemaOverload_8cpp_source.html#l14993">clang::Sema::FixOverloadedFunctionReference()</a>, <a class="el" href="Type_8h_source.html#l07095">clang::Type::getBaseElementTypeUnsafe()</a>, <a class="el" href="SemaExprObjC_8cpp_source.html#l01454">getBaseMessageSendResultType()</a>, <a class="el" href="SwiftCallingConv_8cpp_source.html#l00567">clang::CodeGen::swiftcall::SwiftAggLowering::getCoerceAndExpandTypes()</a>, <a class="el" href="CGExprConstant_8cpp_source.html#l01604">getNonMemoryType()</a>, <a class="el" href="Type_8h_source.html#l07102">clang::Type::getPointeeOrArrayElementType()</a>, <a class="el" href="ASTContext_8h_source.html#l02008">clang::ASTContext::getUnqualifiedObjCPointerType()</a>, <a class="el" href="ASTContext_8cpp_source.html#l03432">clang::ASTContext::getVariableArrayDecayedType()</a>, <a class="el" href="SemaType_8cpp_source.html#l07336">handleFunctionTypeAttr()</a>, <a class="el" href="SemaType_8cpp_source.html#l06692">handleObjCGCTypeAttr()</a>, <a class="el" href="SemaType_8cpp_source.html#l06505">handleObjCOwnershipTypeAttr()</a>, <a class="el" href="SemaType_8cpp_source.html#l01942">inferARCLifetimeForPointee()</a>, <a class="el" href="SemaDeclObjC_8cpp_source.html#l04519">mergeTypeNullabilityForRedecl()</a>, and <a class="el" href="APINotes_2Types_8h_source.html#l00326">clang::api_notes::VariableInfo::setType()</a>.</p>

</div>
</div>
<a id="a13f1d727044894974cd023ecdd58c879" name="a13f1d727044894974cd023ecdd58c879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f1d727044894974cd023ecdd58c879">&#9670;&#160;</a></span>typeAliasDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TypeAliasDecl.html">TypeAliasDecl</a> &gt; clang::ast_matchers::typeAliasDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches type alias declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>;</div>
<div class="line"><span class="keyword">using </span>Y = <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>;</div>
</div><!-- fragment --><p> <a class="el" href="#a13f1d727044894974cd023ecdd58c879" title="Matches type alias declarations.">typeAliasDecl()</a> matches "using Y = int", but not "typedef int X" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00731">731</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a89576459aa43e2e320832d2221f6d405" name="a89576459aa43e2e320832d2221f6d405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89576459aa43e2e320832d2221f6d405">&#9670;&#160;</a></span>typeAliasTemplateDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TypeAliasTemplateDecl.html">TypeAliasTemplateDecl</a> &gt; clang::ast_matchers::typeAliasTemplateDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches type alias template declarations. </p>
<p><a class="el" href="#a89576459aa43e2e320832d2221f6d405" title="Matches type alias template declarations.">typeAliasTemplateDecl()</a> matches </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">using </span>Y = <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X&lt;T&gt;</a>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00733">733</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a3c8a234965f6e7ef273e30c9b19fd778" name="a3c8a234965f6e7ef273e30c9b19fd778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8a234965f6e7ef273e30c9b19fd778">&#9670;&#160;</a></span>typedefDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TypedefDecl.html">TypedefDecl</a> &gt; clang::ast_matchers::typedefDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches typedef declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>;</div>
<div class="line"><span class="keyword">using </span>Y = <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>;</div>
</div><!-- fragment --><p> <a class="el" href="#a3c8a234965f6e7ef273e30c9b19fd778" title="Matches typedef declarations.">typedefDecl()</a> matches "typedef int X", but not "using Y = int" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00728">728</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaType_8cpp_source.html#l07040">checkNullabilityTypeSpecifier()</a>.</p>

</div>
</div>
<a id="a0e36abe1065caf311d087b0a24ce3b00" name="a0e36abe1065caf311d087b0a24ce3b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e36abe1065caf311d087b0a24ce3b00">&#9670;&#160;</a></span>typedefNameDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a> &gt; clang::ast_matchers::typedefNameDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches typedef name declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>;</div>
<div class="line"><span class="keyword">using </span>Y = <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>;</div>
</div><!-- fragment --><p> <a class="el" href="#a0e36abe1065caf311d087b0a24ce3b00" title="Matches typedef name declarations.">typedefNameDecl()</a> matches "typedef int X" and "using Y = int" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00730">730</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="adab6fe99e4ce4c0c2d6d7d6a7f38194e" name="adab6fe99e4ce4c0c2d6d7d6a7f38194e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab6fe99e4ce4c0c2d6d7d6a7f38194e">&#9670;&#160;</a></span>typedefType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1TypedefType.html">TypedefType</a>&gt; clang::ast_matchers::typedefType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01029">1029</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaType_8cpp_source.html#l07040">checkNullabilityTypeSpecifier()</a>, <a class="el" href="Type_8cpp_source.html#l04255">clang::Type::isObjCIndependentClassType()</a>, and <a class="el" href="Type_8cpp_source.html#l04242">clang::Type::isObjCNSObjectType()</a>.</p>

</div>
</div>
<a id="a605961d8a647c2ec766b2417552393a2" name="a605961d8a647c2ec766b2417552393a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605961d8a647c2ec766b2417552393a2">&#9670;&#160;</a></span>typeLoc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt; clang::ast_matchers::typeLoc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code>TypeLocs</code> in the clang AST. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00771">771</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a4e6f1fbd69a5f3bd0b1f7c81f30ba547" name="a4e6f1fbd69a5f3bd0b1f7c81f30ba547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6f1fbd69a5f3bd0b1f7c81f30ba547">&#9670;&#160;</a></span>unaryExprOrTypeTraitExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a> &gt; clang::ast_matchers::unaryExprOrTypeTraitExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches sizeof (C99), alignof (C++11) and vec_step (OpenCL) </p>
<p>Given </p><div class="fragment"><div class="line">Foo x = bar;</div>
<div class="line"><span class="keywordtype">int</span> y = <span class="keyword">sizeof</span>(x) + <span class="keyword">alignof</span>(x);</div>
</div><!-- fragment --><p> <a class="el" href="#a4e6f1fbd69a5f3bd0b1f7c81f30ba547" title="Matches sizeof (C99), alignof (C++11) and vec_step (OpenCL)">unaryExprOrTypeTraitExpr()</a> matches <code>sizeof(x)</code> and <code><a class="el" href="stdalign_8h.html#abb241e4f00c28465643e1010172aef04">alignof(x)</a></code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00773">773</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l02864">alignOfExpr()</a>, and <a class="el" href="ASTMatchers_8h_source.html#l02873">sizeOfExpr()</a>.</p>

</div>
</div>
<a id="a71ac1ea4304cca5a3d773782c45e3a9d" name="a71ac1ea4304cca5a3d773782c45e3a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ac1ea4304cca5a3d773782c45e3a9d">&#9670;&#160;</a></span>unaryOperator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UnaryOperator.html">UnaryOperator</a> &gt; clang::ast_matchers::unaryOperator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches unary operator expressions. </p>
<p>Example matches !a </p><div class="fragment"><div class="line">!a || <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00927">927</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00094">clang::ento::changeIntBoundNode()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00139">clang::ento::forLoopMatcher()</a>, and <a class="el" href="LoopUnrolling_8cpp_source.html#l00121">clang::ento::getAddrTo()</a>.</p>

</div>
</div>
<a id="ac495193c61151ba0fa6d6a3d8963e32c" name="ac495193c61151ba0fa6d6a3d8963e32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac495193c61151ba0fa6d6a3d8963e32c">&#9670;&#160;</a></span>unaryTransformType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1UnaryTransformType.html">UnaryTransformType</a>&gt; clang::ast_matchers::unaryTransformType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01032">1032</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a183ba07d4205e38e5d960a99062722dc" name="a183ba07d4205e38e5d960a99062722dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183ba07d4205e38e5d960a99062722dc">&#9670;&#160;</a></span>unless</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicOperatorMatcherFunc&lt; 1, 1 &gt; clang::ast_matchers::unless</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    internal::DynTypedMatcher::VO_UnaryNot}</div>
</div><!-- fragment -->
<p>Matches if the provided matcher does not match. </p>
<p>Example matches Y (matcher = cxxRecordDecl(unless(hasName("X")))) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {};</div>
<div class="line"><span class="keyword">class </span>Y {};</div>
</div><!-- fragment --><p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01000">1000</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00105">clang::ento::callByRef()</a>, and <a class="el" href="LoopUnrolling_8cpp_source.html#l00139">clang::ento::forLoopMatcher()</a>.</p>

</div>
</div>
<a id="a3721288207aea6b68f442b2d752e78d0" name="a3721288207aea6b68f442b2d752e78d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3721288207aea6b68f442b2d752e78d0">&#9670;&#160;</a></span>unresolvedLookupExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UnresolvedLookupExpr.html">UnresolvedLookupExpr</a> &gt; clang::ast_matchers::unresolvedLookupExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches reference to a name that can be looked up during parsing but could not be resolved to a specific declaration. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">T foo() { T a; <span class="keywordflow">return</span> a; }</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> bar() {</div>
<div class="line">  foo&lt;T&gt;();</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="el" href="#a3721288207aea6b68f442b2d752e78d0" title="Matches reference to a name that can be looked up during parsing but could not be resolved to a speci...">unresolvedLookupExpr()</a> matches </p><div class="fragment"><div class="line">foo&lt;T&gt;() </div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00845">845</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab9f2cfd327a640154b61dc04b4dbe173" name="ab9f2cfd327a640154b61dc04b4dbe173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f2cfd327a640154b61dc04b4dbe173">&#9670;&#160;</a></span>unresolvedMemberExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UnresolvedMemberExpr.html">UnresolvedMemberExpr</a> &gt; clang::ast_matchers::unresolvedMemberExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches unresolved member expressions. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> f();</div>
<div class="line">  <span class="keywordtype">void</span> g();</div>
<div class="line">};</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> h() { <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> x; x.f&lt;T&gt;(); x.g(); }</div>
</div><!-- fragment --><p> <a class="el" href="#ab9f2cfd327a640154b61dc04b4dbe173" title="Matches unresolved member expressions.">unresolvedMemberExpr()</a> matches x.f&lt;T&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00798">798</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a5ebfdb4a7578a482a07cefc8e5907c85" name="a5ebfdb4a7578a482a07cefc8e5907c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebfdb4a7578a482a07cefc8e5907c85">&#9670;&#160;</a></span>unresolvedUsingTypenameDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1UnresolvedUsingTypenameDecl.html">UnresolvedUsingTypenameDecl</a> &gt; clang::ast_matchers::unresolvedUsingTypenameDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches unresolved using value declarations that involve the typename. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_class" href="classBase.html">Base</a> { <span class="keyword">typedef</span> T Foo; };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>S : <span class="keyword">private</span> <a class="code hl_class" href="classBase.html">Base</a>&lt;T&gt; {</div>
<div class="line">  <span class="keyword">using </span>typename <a class="code hl_class" href="classBase.html">Base&lt;T&gt;::Foo</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <a class="el" href="#a5ebfdb4a7578a482a07cefc8e5907c85" title="Matches unresolved using value declarations that involve the typename.">unresolvedUsingTypenameDecl()</a> matches </p><div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_class" href="classBase.html">Base</a>&lt;T&gt;::Foo </div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00849">849</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="af2fcb7fd463685d9e37e8f31637ed45f" name="af2fcb7fd463685d9e37e8f31637ed45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fcb7fd463685d9e37e8f31637ed45f">&#9670;&#160;</a></span>unresolvedUsingValueDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1UnresolvedUsingValueDecl.html">UnresolvedUsingValueDecl</a> &gt; clang::ast_matchers::unresolvedUsingValueDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches unresolved using value declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> : <span class="keyword">private</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> {</div>
<div class="line">  <span class="keyword">using </span>X::x;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <a class="el" href="#af2fcb7fd463685d9e37e8f31637ed45f" title="Matches unresolved using value declarations.">unresolvedUsingValueDecl()</a> matches </p><div class="fragment"><div class="line"><span class="keyword">using </span>X::x </div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00847">847</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab2f2a941709daf18c1eb096bdde38868" name="ab2f2a941709daf18c1eb096bdde38868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f2a941709daf18c1eb096bdde38868">&#9670;&#160;</a></span>userDefinedLiteral</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UserDefinedLiteral.html">UserDefinedLiteral</a> &gt; clang::ast_matchers::userDefinedLiteral</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches user defined literal operator call. </p>
<p>Example match: "foo"_suffix </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00911">911</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2a9d64e967b6707c36254647d2bc4155" name="a2a9d64e967b6707c36254647d2bc4155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9d64e967b6707c36254647d2bc4155">&#9670;&#160;</a></span>usingDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1UsingDecl.html">UsingDecl</a> &gt; clang::ast_matchers::usingDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches using declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> { <span class="keywordtype">int</span> x; }</div>
<div class="line"><span class="keyword">using </span>X::x;</div>
</div><!-- fragment --><p> <a class="el" href="#a2a9d64e967b6707c36254647d2bc4155" title="Matches using declarations.">usingDecl()</a> matches </p><div class="fragment"><div class="line"><span class="keyword">using </span>X::x </div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00841">841</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="af0b5096b155587486eb932cc3a86c481" name="af0b5096b155587486eb932cc3a86c481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b5096b155587486eb932cc3a86c481">&#9670;&#160;</a></span>usingDirectiveDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1UsingDirectiveDecl.html">UsingDirectiveDecl</a> &gt; clang::ast_matchers::usingDirectiveDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches using namespace declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> { <span class="keywordtype">int</span> x; }</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a>;</div>
</div><!-- fragment --><p> <a class="el" href="#af0b5096b155587486eb932cc3a86c481" title="Matches using namespace declarations.">usingDirectiveDecl()</a> matches </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> </div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00843">843</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aaa27f54246f26b3989e97274e01a4c30" name="aaa27f54246f26b3989e97274e01a4c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa27f54246f26b3989e97274e01a4c30">&#9670;&#160;</a></span>valueDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ValueDecl.html">ValueDecl</a> &gt; clang::ast_matchers::valueDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches any value declaration. </p>
<p>Example matches A, B, C and F </p><div class="fragment"><div class="line"><span class="keyword">enum</span> <a class="code hl_function" href="CompilationDatabase_8cpp.html#a9a49441f73fccd3c5a00b729ac1dc56c">X</a> { A, B, <a class="code hl_enumvalue" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a> };</div>
<div class="line"><span class="keywordtype">void</span> F();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00774">774</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a056e81429237736b6458df18bb538c82" name="a056e81429237736b6458df18bb538c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056e81429237736b6458df18bb538c82">&#9670;&#160;</a></span>varDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a> &gt; clang::ast_matchers::varDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches variable declarations. </p>
<p>Note: this does not match declarations of member variables, which are "field" declarations in Clang parlance.</p>
<p>Example matches a </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00786">786</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00112">clang::ento::assignedToRef()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00105">clang::ento::callByRef()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00094">clang::ento::changeIntBoundNode()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00139">clang::ento::forLoopMatcher()</a>, <a class="el" href="LoopWidening_8cpp_source.html#l00044">clang::ento::getWidenedLoopState()</a>, <a class="el" href="ExprEngine_8cpp_source.html#l00951">clang::ento::ExprEngine::ProcessAutomaticObjDtor()</a>, and <a class="el" href="LoopUnrolling_8cpp_source.html#l00082">clang::ento::simpleCondition()</a>.</p>

</div>
</div>
<a id="a3c4b5ef3a0104b7fcf7b3e2e4eeee0df" name="a3c4b5ef3a0104b7fcf7b3e2e4eeee0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4b5ef3a0104b7fcf7b3e2e4eeee0df">&#9670;&#160;</a></span>variableArrayType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AstTypeMatcher&lt;<a class="el" href="classclang_1_1VariableArrayType.html">VariableArrayType</a>&gt; clang::ast_matchers::variableArrayType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01015">1015</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a63fb772f53dc8076440090557a4bb388" name="a63fb772f53dc8076440090557a4bb388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fb772f53dc8076440090557a4bb388">&#9670;&#160;</a></span>whileStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1WhileStmt.html">WhileStmt</a> &gt; clang::ast_matchers::whileStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches while statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {}</div>
</div><!-- fragment --><p> <a class="el" href="#a63fb772f53dc8076440090557a4bb388" title="Matches while statements.">whileStmt()</a> matches 'while (true) {}'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00881">881</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 8 2024 10:08:23 for clang by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
