<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: clang::ObjCInterfaceType Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">clang<span id="projectnumber">&#160;17.0.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceclang.html">clang</a></li><li class="navelem"><a class="el" href="classclang_1_1ObjCInterfaceType.html">ObjCInterfaceType</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classclang_1_1ObjCInterfaceType-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">clang::ObjCInterfaceType Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Represents <code>typeof(type)</code>, a C2x feature and GCC extension, or `typeof_unqual(type), a C2x feature.  
 <a href="#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="Type_8h_source.html">clang/AST/Type.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for clang::ObjCInterfaceType:</div>
<div class="dyncontent">
<div class="center"><img src="classclang_1_1ObjCInterfaceType__inherit__graph.png" border="0" usemap="#aclang_1_1ObjCInterfaceType_inherit__map" alt="Inheritance graph"/></div>
<map name="aclang_1_1ObjCInterfaceType_inherit__map" id="aclang_1_1ObjCInterfaceType_inherit__map">
<area shape="rect" title="Represents typeof(type), a C2x feature and GCC extension, or `typeof_unqual(type),..." alt="" coords="5,79,189,104"/>
<area shape="rect" href="classObjCObjectType.html" title=" " alt="" coords="35,5,160,31"/>
<area shape="poly" title=" " alt="" coords="100,44,100,79,95,79,95,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a236c55ef6d6a877a830de05f41366a27" id="r_a236c55ef6d6a877a830de05f41366a27"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="#a236c55ef6d6a877a830de05f41366a27a02f2cca4460e37fca444925b04fda33f">qual_iterator</a>
, <a class="el" href="#a236c55ef6d6a877a830de05f41366a27aaac975957d702cab1041242dadd4efb5">qual_begin</a>
, <a class="el" href="#a236c55ef6d6a877a830de05f41366a27a800c81021225056bc2f0c747a924bc24">qual_end</a>
, <a class="el" href="#a236c55ef6d6a877a830de05f41366a27a710a99f3bce93c5576d562ffba30931f">getNumProtocols</a>
, <br />
&#160;&#160;<a class="el" href="#a236c55ef6d6a877a830de05f41366a27a520cd7dea01a6e671e9f063caac3f073">getProtocol</a>
<br />
 }</td></tr>
<tr class="separator:a236c55ef6d6a877a830de05f41366a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1933b5e5a9dfd317f8bb48e2492befca" id="r_a1933b5e5a9dfd317f8bb48e2492befca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1933b5e5a9dfd317f8bb48e2492befca">getDecl</a> () const</td></tr>
<tr class="memdesc:a1933b5e5a9dfd317f8bb48e2492befca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the declaration of this interface.  <br /></td></tr>
<tr class="separator:a1933b5e5a9dfd317f8bb48e2492befca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818b0b6f024405f259cebe5e4158d43e" id="r_a818b0b6f024405f259cebe5e4158d43e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared</a> () const</td></tr>
<tr class="separator:a818b0b6f024405f259cebe5e4158d43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34de3b2f21f3e7139333ad451b076e5f" id="r_a34de3b2f21f3e7139333ad451b076e5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar</a> () const</td></tr>
<tr class="separator:a34de3b2f21f3e7139333ad451b076e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acd6e13ff6004d2be696e101745e8d482" id="r_acd6e13ff6004d2be696e101745e8d482"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof</a> (const <a class="el" href="classclang_1_1Type.html">Type</a> *T)</td></tr>
<tr class="separator:acd6e13ff6004d2be696e101745e8d482"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a81992f52dc601812ba88cecd0da65c8c" id="r_a81992f52dc601812ba88cecd0da65c8c"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81992f52dc601812ba88cecd0da65c8c">ASTContext</a></td></tr>
<tr class="separator:a81992f52dc601812ba88cecd0da65c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8560551ea81515968dd468e2e4082e" id="r_a5d8560551ea81515968dd468e2e4082e"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d8560551ea81515968dd468e2e4082e">ASTReader</a></td></tr>
<tr class="separator:a5d8560551ea81515968dd468e2e4082e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea3ec5e1aaa161fa14afe27378bdb7c" id="r_a9ea3ec5e1aaa161fa14afe27378bdb7c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9ea3ec5e1aaa161fa14afe27378bdb7c"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ea3ec5e1aaa161fa14afe27378bdb7c">serialization::AbstractTypeReader</a></td></tr>
<tr class="separator:a9ea3ec5e1aaa161fa14afe27378bdb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents <code>typeof(type)</code>, a C2x feature and GCC extension, or `typeof_unqual(type), a C2x feature. </p>
<p>class TypeOfType : public <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a> { friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>; // <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> creates these.</p>
<p><a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> TOType;</p>
<p>TypeOfType(QualType T, QualType Can, TypeOfKind Kind) : <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a>(TypeOf, Kind == <a class="el" href="namespaceclang.html#a4956f71cf945894371063f7db8206c90a797dbea6d5d367c38e8397c9d34c4d2e">TypeOfKind::Unqualified</a> ? Can.getAtomicUnqualifiedType() : Can, T-&gt;getDependence()), TOType(T) { TypeOfBits.IsUnqual = Kind == <a class="el" href="namespaceclang.html#a4956f71cf945894371063f7db8206c90a797dbea6d5d367c38e8397c9d34c4d2e">TypeOfKind::Unqualified</a>; }</p>
<p>public: <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> getUnmodifiedType() const { return TOType; }</p>
<p>/ Remove a single level of sugar. <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const </a>{ <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> QT = getUnmodifiedType(); return TypeOfBits.IsUnqual ? QT.getAtomicUnqualifiedType() : QT; }</p>
<p>/ Returns whether this type directly provides sugar. bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const </a>{ return true; }</p>
<p>/ Returns the kind of 'typeof' type this is. TypeOfKind getKind() const { return TypeOfBits.IsUnqual ? <a class="el" href="namespaceclang.html#a4956f71cf945894371063f7db8206c90a797dbea6d5d367c38e8397c9d34c4d2e">TypeOfKind::Unqualified</a> : <a class="el" href="namespaceclang.html#a4956f71cf945894371063f7db8206c90a71c9a8e40cea3d43a08f0436437ee819">TypeOfKind::Qualified</a>; }</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == TypeOf; } };</p>
<p>/ Represents the type <code>decltype(expr)</code> (C++11). class DecltypeType : public <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a> { <a class="el" href="classclang_1_1Expr.html" title="This represents one expression.">Expr</a> *E; <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> UnderlyingType;</p>
<p>protected: friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>; // <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> creates these.</p>
<p>DecltypeType(<a class="el" href="classclang_1_1Expr.html" title="This represents one expression.">Expr</a> *E, <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> underlyingType, <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> can = QualType());</p>
<p>public: <a class="el" href="classclang_1_1Expr.html" title="This represents one expression.">Expr</a> *getUnderlyingExpr() const { return E; } <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> getUnderlyingType() const { return UnderlyingType; }</p>
<p>/ Remove a single level of sugar. <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const</a>;</p>
<p>/ Returns whether this type directly provides sugar. bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const</a>;</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == Decltype; } };</p>
<p>/ Internal representation of canonical, dependent / decltype(expr) types. / / This class is used internally by the <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> to manage / canonical, dependent types, only. Clients will only see instances / of this class via DecltypeType nodes. class DependentDecltypeType : public DecltypeType, public llvm::FoldingSetNode { const <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> &amp;Context;</p>
<p>public: DependentDecltypeType(const ASTContext &amp;Context, Expr *E);</p>
<p>void Profile(llvm::FoldingSetNodeID &amp;ID) { Profile(ID, Context, getUnderlyingExpr()); }</p>
<p>static void Profile(llvm::FoldingSetNodeID &amp;ID, const ASTContext &amp;Context,
                      Expr *E); };</p>
<p>/ A unary type transform, which is a type constructed from another. class UnaryTransformType : public <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a> { public: enum UTTKind { #define <a class="el" href="Type_8h.html#a607b6dab634ee8156b7f434e3773bf45">TRANSFORM_TYPE_TRAIT_DEF(Enum, _)</a> <br  />
</p>
<p>};</p>
<p>private: / The untransformed type. <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> BaseType;</p>
<p>/ The transformed type if not dependent, otherwise the same as BaseType. <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> UnderlyingType;</p>
<p>UTTKind UKind;</p>
<p>protected: friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>;</p>
<p>UnaryTransformType(QualType BaseTy, QualType UnderlyingTy, UTTKind UKind,
                     QualType CanonicalTy);</p>
<p>public: bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const </a>{ return !isDependentType(); } <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const </a>{ return UnderlyingType; }</p>
<p><a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> getUnderlyingType() const { return UnderlyingType; } <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> getBaseType() const { return BaseType; }</p>
<p>UTTKind getUTTKind() const { return UKind; }</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == UnaryTransform; } };</p>
<p>/ Internal representation of canonical, dependent / __underlying_type(type) types. / / This class is used internally by the <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> to manage / canonical, dependent types, only. Clients will only see instances / of this class via UnaryTransformType nodes. class DependentUnaryTransformType : public UnaryTransformType, public llvm::FoldingSetNode { public: DependentUnaryTransformType(const ASTContext &amp;C, QualType BaseType,
                              UTTKind UKind);</p>
<p>void Profile(llvm::FoldingSetNodeID &amp;ID) { Profile(ID, getBaseType(), getUTTKind()); }</p>
<p>static void Profile(llvm::FoldingSetNodeID &amp;ID, QualType BaseType,
                      UTTKind UKind) { ID.AddPointer(BaseType.getAsOpaquePtr()); ID.AddInteger((unsigned)UKind); } };</p>
<p>class TagType : public <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a> { friend class <a class="el" href="classclang_1_1ASTReader.html" title="Reads an AST files chain containing the contents of a translation unit.">ASTReader</a>; template &lt;class T&gt; friend class <a class="el" href="classclang_1_1serialization_1_1AbstractTypeReader.html">serialization::AbstractTypeReader</a>;</p>
<p>/ Stores the <a class="el" href="classclang_1_1TagDecl.html" title="Represents the declaration of a struct/union/class/enum.">TagDecl</a> associated with this type. The decl may point to any / <a class="el" href="classclang_1_1TagDecl.html" title="Represents the declaration of a struct/union/class/enum.">TagDecl</a> that declares the entity. <a class="el" href="classclang_1_1TagDecl.html" title="Represents the declaration of a struct/union/class/enum.">TagDecl</a> *decl;</p>
<p>protected: TagType(TypeClass TC, const TagDecl *D, QualType can);</p>
<p>public: <a class="el" href="classclang_1_1TagDecl.html" title="Represents the declaration of a struct/union/class/enum.">TagDecl</a> *getDecl() const;</p>
<p>/ Determines whether this type is in the process of being defined. bool isBeingDefined() const;</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == Enum || T-&gt;getTypeClass() == Record; } };</p>
<p>/ A helper class that allows the use of isa/cast/dyncast / to detect TagType objects of structs/unions/classes. class RecordType : public TagType { protected: friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>; // <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> creates these.</p>
<p>explicit RecordType(const RecordDecl &lt;em&gt;D) : TagType(Record, reinterpret_cast&lt;const <a class="el" href="classclang_1_1TagDecl.html" title="Represents the declaration of a struct/union/class/enum.">TagDecl</a>&gt;(D), QualType()) {} explicit RecordType(TypeClass TC, RecordDecl &lt;em&gt;D) : TagType(TC, reinterpret_cast&lt;const <a class="el" href="classclang_1_1TagDecl.html" title="Represents the declaration of a struct/union/class/enum.">TagDecl</a>&gt;(D), QualType()) {}</p>
<p>public: <a class="el" href="classclang_1_1RecordDecl.html" title="Represents a struct/union/class.">RecordDecl</a> <em><a class="el" href="#a1933b5e5a9dfd317f8bb48e2492befca" title="Get the declaration of this interface.">getDecl() const </a>{ return reinterpret_cast&lt;<a class="el" href="classclang_1_1RecordDecl.html" title="Represents a struct/union/class.">RecordDecl</a></em>&gt;(TagType::getDecl()); }</p>
<p>/ Recursively check all fields in the record for const-ness. If any field / is declared const, return true. Otherwise, return false. bool hasConstFields() const;</p>
<p>bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const </a>{ return false; } <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const </a>{ return QualType(this, 0); }</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == Record; } };</p>
<p>/ A helper class that allows the use of isa/cast/dyncast / to detect TagType objects of enums. class EnumType : public TagType { friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>; // <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> creates these.</p>
<p>explicit EnumType(const EnumDecl &lt;em&gt;D) : TagType(Enum, reinterpret_cast&lt;const <a class="el" href="classclang_1_1TagDecl.html" title="Represents the declaration of a struct/union/class/enum.">TagDecl</a>&gt;(D), QualType()) {}</p>
<p>public: <a class="el" href="classclang_1_1EnumDecl.html" title="Represents an enum.">EnumDecl</a> <em><a class="el" href="#a1933b5e5a9dfd317f8bb48e2492befca" title="Get the declaration of this interface.">getDecl() const </a>{ return reinterpret_cast&lt;<a class="el" href="classclang_1_1EnumDecl.html" title="Represents an enum.">EnumDecl</a></em>&gt;(TagType::getDecl()); }</p>
<p>bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const </a>{ return false; } <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const </a>{ return QualType(this, 0); }</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == Enum; } };</p>
<p>/ An attributed type is a type to which a type attribute has been applied. / / The "modified type" is the fully-sugared type to which the attributed / type was applied; generally it is not canonically equivalent to the / attributed type. The "equivalent type" is the minimally-desugared type / which the type is canonically equivalent to. / / For example, in the following attributed type: / int32_t <b>attribute</b>((vector_size(16))) / - the modified type is the <a class="el" href="classclang_1_1TypedefType.html">TypedefType</a> for int32_t / - the equivalent type is VectorType(16, int32_t) / - the canonical type is VectorType(16, int) class AttributedType : public <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a>, public llvm::FoldingSetNode { public: using Kind = <a class="el" href="namespaceclang_1_1attr.html#ac160b7b7240633e6932ebb177d0f03ef">attr::Kind</a>;</p>
<p>private: friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>; // <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> creates these</p>
<p><a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> ModifiedType; <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> EquivalentType;</p>
<p>AttributedType(QualType canon, attr::Kind attrKind, QualType modified,
                 QualType equivalent) : <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a>(Attributed, canon, equivalent-&gt;getDependence()), ModifiedType(modified), EquivalentType(equivalent) { AttributedTypeBits.AttrKind = attrKind; }</p>
<p>public: Kind getAttrKind() const { return static_cast&lt;Kind&gt;(AttributedTypeBits.AttrKind); }</p>
<p><a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> getModifiedType() const { return ModifiedType; } <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> getEquivalentType() const { return EquivalentType; }</p>
<p>bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const </a>{ return true; } <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const </a>{ return getEquivalentType(); }</p>
<p>/ Does this attribute behave like a type qualifier? / / A type qualifier adjusts a type to provide specialized rules for / a specific object, like the standard const and volatile qualifiers. / This includes attributes controlling things like nullability, / address spaces, and ARC ownership. The value of the object is still / largely described by the modified type. / / In contrast, many type attributes "rewrite" their modified type to / produce a fundamentally different type, not necessarily related in any / formalizable way to the original type. For example, calling convention / and vector attributes are not simple type qualifiers. / / <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a> qualifiers are often, but not always, reflected in the canonical / type. bool isQualifier() const;</p>
<p>bool isMSTypeSpec() const;</p>
<p>bool isWebAssemblyFuncrefSpec() const;</p>
<p>bool isCallingConv() const;</p>
<p>std::optional&lt;NullabilityKind&gt; getImmediateNullability() const;</p>
<p>/ Retrieve the attribute kind corresponding to the given / nullability kind. static Kind getNullabilityAttrKind(NullabilityKind kind) { switch (kind) { case <a class="el" href="namespaceclang.html#a37d70548a277a723aba96e9a6853b944af61ee17dd32eb7a956dfa45182277ed7" title="Values of this type can never be null.">NullabilityKind::NonNull</a>: return attr::TypeNonNull;</p>
<p>case <a class="el" href="namespaceclang.html#a37d70548a277a723aba96e9a6853b944a46ad517b8b7aa4e368a7cc226533bfb6" title="Values of this type can be null.">NullabilityKind::Nullable</a>: return attr::TypeNullable;</p>
<p>case <a class="el" href="namespaceclang.html#a37d70548a277a723aba96e9a6853b944aeb8445ba39721c846150b52fa3495f31">NullabilityKind::NullableResult</a>: return attr::TypeNullableResult;</p>
<p>case <a class="el" href="namespaceclang.html#a37d70548a277a723aba96e9a6853b944a6fcdc090caeade09d0efd6253932b6f5" title="Whether values of this type can be null is (explicitly) unspecified.">NullabilityKind::Unspecified</a>: return attr::TypeNullUnspecified; } llvm_unreachable("Unknown nullability kind."); }</p>
<p>/ Strip off the top-level nullability annotation on the given / type, if it's there. / /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type to strip. If the type is exactly an / AttributedType specifying nullability (without looking through / type sugar), the nullability is returned and this type changed / to the underlying modified type. / / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the top-level nullability, if present. static std::optional&lt;NullabilityKind&gt; stripOuterNullability(QualType &amp;T);</dd></dl>
<p>void Profile(llvm::FoldingSetNodeID &amp;ID) { Profile(ID, getAttrKind(), ModifiedType, EquivalentType); }</p>
<p>static void Profile(llvm::FoldingSetNodeID &amp;ID, Kind attrKind,
                      QualType modified, QualType equivalent) { ID.AddInteger(attrKind); ID.AddPointer(modified.getAsOpaquePtr()); ID.AddPointer(equivalent.getAsOpaquePtr()); }</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == Attributed; } };</p>
<p>class BTFTagAttributedType : public <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a>, public llvm::FoldingSetNode { private: friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>; // <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> creates these</p>
<p><a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> WrappedType; const BTFTypeTagAttr *BTFAttr;</p>
<p>BTFTagAttributedType(QualType Canon, QualType Wrapped,
                       const BTFTypeTagAttr *BTFAttr) : <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a>(BTFTagAttributed, Canon, Wrapped-&gt;getDependence()), WrappedType(Wrapped), BTFAttr(BTFAttr) {}</p>
<p>public: <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> getWrappedType() const { return WrappedType; } const BTFTypeTagAttr *getAttr() const { return BTFAttr; }</p>
<p>bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const </a>{ return true; } <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const </a>{ return getWrappedType(); }</p>
<p>void Profile(llvm::FoldingSetNodeID &amp;ID) { Profile(ID, WrappedType, BTFAttr); }</p>
<p>static void Profile(llvm::FoldingSetNodeID &amp;ID, QualType Wrapped,
                      const BTFTypeTagAttr *BTFAttr) { ID.AddPointer(Wrapped.getAsOpaquePtr()); ID.AddPointer(BTFAttr); }</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == BTFTagAttributed; } };</p>
<p>class TemplateTypeParmType : public <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a>, public llvm::FoldingSetNode { friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>; // <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> creates these</p>
<p>Helper data collector for canonical types. struct CanonicalTTPTInfo { unsigned Depth : 15; unsigned ParameterPack : 1; unsigned Index : 16; };</p>
<p>union { Info for the canonical type. CanonicalTTPTInfo CanTTPTInfo;</p>
<p>Info for the non-canonical type. <a class="el" href="classclang_1_1TemplateTypeParmDecl.html" title="Declaration of a template type parameter.">TemplateTypeParmDecl</a> *TTPDecl; };</p>
<p>/ Build a non-canonical type. TemplateTypeParmType(TemplateTypeParmDecl *TTPDecl, QualType Canon) : <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a>(TemplateTypeParm, Canon, TypeDependence::DependentInstantiation | (Canon-&gt;getDependence() &amp; TypeDependence::UnexpandedPack)), TTPDecl(TTPDecl) {}</p>
<p>/ Build the canonical type. TemplateTypeParmType(unsigned D, unsigned I, bool PP) : <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a>(TemplateTypeParm, QualType(this, 0), TypeDependence::DependentInstantiation | (PP ? TypeDependence::UnexpandedPack : TypeDependence::None)) { CanTTPTInfo.Depth = D; CanTTPTInfo.Index = I; CanTTPTInfo.ParameterPack = PP; }</p>
<p>const CanonicalTTPTInfo&amp; getCanTTPTInfo() const { <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> Can = getCanonicalTypeInternal(); return Can-&gt;castAs&lt;TemplateTypeParmType&gt;()-&gt;CanTTPTInfo; }</p>
<p>public: unsigned getDepth() const { return getCanTTPTInfo().Depth; } unsigned getIndex() const { return getCanTTPTInfo().Index; } bool isParameterPack() const { return getCanTTPTInfo().ParameterPack; }</p>
<p><a class="el" href="classclang_1_1TemplateTypeParmDecl.html" title="Declaration of a template type parameter.">TemplateTypeParmDecl</a> *getDecl() const { return isCanonicalUnqualified() ? nullptr : TTPDecl; }</p>
<p><a class="el" href="classclang_1_1IdentifierInfo.html" title="One of these records is kept for each identifier that is lexed.">IdentifierInfo</a> *getIdentifier() const;</p>
<p>bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const </a>{ return false; } <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const </a>{ return QualType(this, 0); }</p>
<p>void Profile(llvm::FoldingSetNodeID &amp;ID) { Profile(ID, getDepth(), getIndex(), isParameterPack(), <a class="el" href="#a1933b5e5a9dfd317f8bb48e2492befca" title="Get the declaration of this interface.">getDecl()</a>); }</p>
<p>static void Profile(llvm::FoldingSetNodeID &amp;ID, unsigned Depth,
                      unsigned Index, bool ParameterPack,
                      TemplateTypeParmDecl *TTPDecl) { ID.AddInteger(Depth); ID.AddInteger(Index); ID.AddBoolean(ParameterPack); ID.AddPointer(TTPDecl); }</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == TemplateTypeParm; } };</p>
<p>/ Represents the result of substituting a type for a template / type parameter. / / Within an instantiated template, all template type parameters have / been replaced with these. They are used solely to record that a / type was originally written as a template type parameter; / therefore they are never canonical. class SubstTemplateTypeParmType final : public <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a>, public llvm::FoldingSetNode, private llvm::TrailingObjects&lt;SubstTemplateTypeParmType, QualType&gt; { friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>; friend class llvm::TrailingObjects&lt;SubstTemplateTypeParmType, QualType&gt;;</p>
<p><a class="el" href="classclang_1_1Decl.html" title="Decl - This represents one declaration (or definition), e.g.">Decl</a> *AssociatedDecl;</p>
<p>SubstTemplateTypeParmType(QualType Replacement, Decl *AssociatedDecl,
                            unsigned Index, std::optional&lt;unsigned&gt; PackIndex);</p>
<p>public: / Gets the type that was substituted for the template / parameter. <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> getReplacementType() const { return SubstTemplateTypeParmTypeBits.HasNonCanonicalUnderlyingType ? *getTrailingObjects&lt;QualType&gt;() : getCanonicalTypeInternal(); }</p>
<p>/ A template-like entity which owns the whole pattern being substituted. / This will usually own a set of template parameters, or in some / cases might even be a template parameter itself. <a class="el" href="classclang_1_1Decl.html" title="Decl - This represents one declaration (or definition), e.g.">Decl</a> *getAssociatedDecl() const { return AssociatedDecl; }</p>
<p>/ Gets the template parameter declaration that was substituted for. const <a class="el" href="classclang_1_1TemplateTypeParmDecl.html" title="Declaration of a template type parameter.">TemplateTypeParmDecl</a> *getReplacedParameter() const;</p>
<p>/ Returns the index of the replaced parameter in the associated declaration. / This should match the result of <code><a class="el" href="Type_8cpp.html#a255ed07a34d39f6f9e9fa765fef961e7">getReplacedParameter()</a>-&gt;getIndex()</code>. unsigned getIndex() const { return SubstTemplateTypeParmTypeBits.Index; }</p>
<p>std::optional&lt;unsigned&gt; getPackIndex() const { if (SubstTemplateTypeParmTypeBits.PackIndex == 0) return std::nullopt; return SubstTemplateTypeParmTypeBits.PackIndex - 1; }</p>
<p>bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const </a>{ return true; } <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const </a>{ return getReplacementType(); }</p>
<p>void Profile(llvm::FoldingSetNodeID &amp;ID) { Profile(ID, getReplacementType(), getAssociatedDecl(), getIndex(), getPackIndex()); }</p>
<p>static void Profile(llvm::FoldingSetNodeID &amp;ID, QualType Replacement,
                      const Decl *AssociatedDecl, unsigned Index,
                      std::optional&lt;unsigned&gt; PackIndex) { Replacement.Profile(ID); ID.AddPointer(AssociatedDecl); ID.AddInteger(Index); ID.AddInteger(PackIndex ? *PackIndex - 1 : 0); }</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == SubstTemplateTypeParm; } };</p>
<p>/ Represents the result of substituting a set of types for a template / type parameter pack. / / When a pack expansion in the source code contains multiple parameter packs / and those parameter packs correspond to different levels of template / parameter lists, this type node is used to represent a template type / parameter pack from an outer level, which has already had its argument pack / substituted but that still lives within a pack expansion that itself / could not be instantiated. When actually performing a substitution into / that pack expansion (e.g., when all template parameters have corresponding / arguments), this type will be replaced with the <code>SubstTemplateTypeParmType</code> / at the current pack substitution index. class SubstTemplateTypeParmPackType : public <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a>, public llvm::FoldingSetNode { friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>;</p>
<p>/ A pointer to the set of template arguments that this / parameter pack is instantiated with. const <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> *Arguments;</p>
<p>llvm::PointerIntPair&lt;Decl *, 1, bool&gt; AssociatedDeclAndFinal;</p>
<p>SubstTemplateTypeParmPackType(QualType Canon, Decl *AssociatedDecl,
                                unsigned Index, bool Final,
                                const TemplateArgument &amp;ArgPack);</p>
<p>public: <a class="el" href="classclang_1_1IdentifierInfo.html" title="One of these records is kept for each identifier that is lexed.">IdentifierInfo</a> *getIdentifier() const;</p>
<p>/ A template-like entity which owns the whole pattern being substituted. / This will usually own a set of template parameters, or in some / cases might even be a template parameter itself. <a class="el" href="classclang_1_1Decl.html" title="Decl - This represents one declaration (or definition), e.g.">Decl</a> *getAssociatedDecl() const;</p>
<p>/ Gets the template parameter declaration that was substituted for. const <a class="el" href="classclang_1_1TemplateTypeParmDecl.html" title="Declaration of a template type parameter.">TemplateTypeParmDecl</a> *getReplacedParameter() const;</p>
<p>/ Returns the index of the replaced parameter in the associated declaration. / This should match the result of <code><a class="el" href="Type_8cpp.html#a255ed07a34d39f6f9e9fa765fef961e7">getReplacedParameter()</a>-&gt;getIndex()</code>. unsigned getIndex() const { return SubstTemplateTypeParmPackTypeBits.Index; }</p>
<p>When true the substitution will be 'Final' (subst node won't be placed). bool getFinal() const;</p>
<p>unsigned getNumArgs() const { return SubstTemplateTypeParmPackTypeBits.NumArgs; }</p>
<p>bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const </a>{ return false; } <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const </a>{ return QualType(this, 0); }</p>
<p><a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> getArgumentPack() const;</p>
<p>void Profile(llvm::FoldingSetNodeID &amp;ID); static void Profile(llvm::FoldingSetNodeID &amp;ID, const Decl *AssociatedDecl,
                      unsigned Index, bool Final,
                      const TemplateArgument &amp;ArgPack);</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == SubstTemplateTypeParmPack; } };</p>
<p>/ Common base class for placeholders for types that get replaced by / placeholder type deduction: C++11 auto, C++14 decltype(auto), C++17 deduced / class template types, and constrained type names. / / These types are usually a placeholder for a deduced type. However, before / the initializer is attached, or (usually) if the initializer is / type-dependent, there is no deduced type and the type is canonical. In / the latter case, it is also a dependent type. class DeducedType : public <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a> { <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> DeducedAsType;</p>
<p>protected: DeducedType(TypeClass TC, QualType DeducedAsType,
              TypeDependence ExtraDependence, QualType Canon) : <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a>(TC, Canon, ExtraDependence | (DeducedAsType.isNull() ? TypeDependence::None : DeducedAsType-&gt;getDependence() &amp; ~TypeDependence::VariablyModified)), DeducedAsType(DeducedAsType) {}</p>
<p>public: bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const </a>{ return !DeducedAsType.isNull(); } <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const </a>{ return <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared()</a> ? DeducedAsType : QualType(this, 0); }</p>
<p>/ Get the type deduced for this placeholder type, or null if it / has not been deduced. <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> getDeducedType() const { return DeducedAsType; } bool isDeduced() const { return !DeducedAsType.isNull() || isDependentType(); }</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == Auto || T-&gt;getTypeClass() == DeducedTemplateSpecialization; } };</p>
<p>/ Represents a C++11 auto or C++14 decltype(auto) type, possibly constrained / by a type-constraint. class alignas(8) AutoType : public DeducedType, public llvm::FoldingSetNode { friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>; // <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> creates these</p>
<p><a class="el" href="classclang_1_1ConceptDecl.html" title="Declaration of a C++20 concept.">ConceptDecl</a> *TypeConstraintConcept;</p>
<p>AutoType(QualType DeducedAsType, AutoTypeKeyword Keyword,
           TypeDependence ExtraDependence, QualType Canon, ConceptDecl *CD,
           ArrayRef&lt;TemplateArgument&gt; TypeConstraintArgs);</p>
<p>public: ArrayRef&lt;TemplateArgument&gt; getTypeConstraintArguments() const { return {reinterpret_cast&lt;const TemplateArgument *&gt;(this + 1), AutoTypeBits.NumArgs}; }</p>
<p><a class="el" href="classclang_1_1ConceptDecl.html" title="Declaration of a C++20 concept.">ConceptDecl</a> *getTypeConstraintConcept() const { return TypeConstraintConcept; }</p>
<p>bool isConstrained() const { return TypeConstraintConcept != nullptr; }</p>
<p>bool isDecltypeAuto() const { return getKeyword() == <a class="el" href="namespaceclang.html#a1a6ce9e9f0ae0ea079a7de8e31532788abc8996323c1df06aae8a1696d4fa486b" title="decltype(auto)">AutoTypeKeyword::DecltypeAuto</a>; }</p>
<p>bool isGNUAutoType() const { return getKeyword() == <a class="el" href="namespaceclang.html#a1a6ce9e9f0ae0ea079a7de8e31532788a7fc111cdffb1d28b0612fa8a48ff2154" title="__auto_type (GNU extension)">AutoTypeKeyword::GNUAutoType</a>; }</p>
<p>AutoTypeKeyword getKeyword() const { return (AutoTypeKeyword)AutoTypeBits.Keyword; }</p>
<p>void Profile(llvm::FoldingSetNodeID &amp;ID, const ASTContext &amp;Context); static void Profile(llvm::FoldingSetNodeID &amp;ID, const ASTContext &amp;Context,
                      QualType Deduced, AutoTypeKeyword Keyword,
                      bool IsDependent, ConceptDecl *CD,
                      ArrayRef&lt;TemplateArgument&gt; Arguments);</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == Auto; } };</p>
<p>/ Represents a C++17 deduced template specialization type. class DeducedTemplateSpecializationType : public DeducedType, public llvm::FoldingSetNode { friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>; // <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> creates these</p>
<p>/ The name of the template whose arguments will be deduced. <a class="el" href="classclang_1_1TemplateName.html" title="Represents a C++ template name within the type system.">TemplateName</a> Template;</p>
<p>DeducedTemplateSpecializationType(TemplateName Template,
                                    QualType DeducedAsType,
                                    bool IsDeducedAsDependent) : DeducedType(DeducedTemplateSpecialization, DeducedAsType, toTypeDependence(Template.getDependence()) | (IsDeducedAsDependent ? TypeDependence::DependentInstantiation : TypeDependence::None), DeducedAsType.isNull() ? QualType(this, 0) : DeducedAsType.getCanonicalType()), Template(Template) {}</p>
<p>public: / Retrieve the name of the template that we are deducing. <a class="el" href="classclang_1_1TemplateName.html" title="Represents a C++ template name within the type system.">TemplateName</a> getTemplateName() const { return Template;}</p>
<p>void Profile(llvm::FoldingSetNodeID &amp;ID) { Profile(ID, getTemplateName(), getDeducedType(), isDependentType()); }</p>
<p>static void Profile(llvm::FoldingSetNodeID &amp;ID, TemplateName Template,
                      QualType Deduced, bool IsDependent) { Template.Profile(ID); <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> CanonicalType = Deduced.isNull() ? Deduced : Deduced.getCanonicalType(); ID.AddPointer(CanonicalType.getAsOpaquePtr()); ID.AddBoolean(IsDependent || Template.isDependent()); }</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == DeducedTemplateSpecialization; } };</p>
<p>/ Represents a type template specialization; the template / must be a class template, a type alias template, or a template / template parameter. A template which cannot be resolved to one of / these, e.g. because it is written with a dependent scope / specifier, is instead represented as a / <code>DependentTemplateSpecializationType</code>. / / A non-dependent template specialization type is always "sugar", / typically for a <code>RecordType</code>. For example, a class template / specialization type of <code>vector&lt;int&gt;</code> will refer to a tag type for / the instantiation <code>std::vector&lt;int, std::allocator&lt;int&gt;&gt;</code> / / Template specializations are dependent if either the template or / any of the template arguments are dependent, in which case the / type may also be canonical. / / Instances of this type are allocated with a trailing array of / TemplateArguments, followed by a <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> representing the / non-canonical aliased type when the template is a type alias / template. class alignas(8) TemplateSpecializationType : public <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a>, public llvm::FoldingSetNode { friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>; // <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> creates these</p>
<p>/ The name of the template being specialized. This is / either a <a class="el" href="classclang_1_1TemplateName.html#ac4a936d273dfda546e902fd11e313679a7f442025acbd85fa712e9c002be8dc5b" title="A single template declaration.">TemplateName::Template</a> (in which case it is a / ClassTemplateDecl*, a TemplateTemplateParmDecl*, or a / TypeAliasTemplateDecl*), a / <a class="el" href="classclang_1_1TemplateName.html#ac4a936d273dfda546e902fd11e313679aa2bb9b8d33fcaf9bff64e1c8fa7de8c7" title="A template template parameter pack that has been substituted for a template template argument pack,...">TemplateName::SubstTemplateTemplateParmPack</a>, or a / <a class="el" href="classclang_1_1TemplateName.html#ac4a936d273dfda546e902fd11e313679a87b16754756549462473b00d0797b4ad" title="A template template parameter that has been substituted for some other template name.">TemplateName::SubstTemplateTemplateParm</a> (in which case the / replacement must, recursively, be one of these). <a class="el" href="classclang_1_1TemplateName.html" title="Represents a C++ template name within the type system.">TemplateName</a> Template;</p>
<p>TemplateSpecializationType(TemplateName T,
                             ArrayRef&lt;TemplateArgument&gt; Args,
                             QualType Canon,
                             QualType Aliased);</p>
<p>public: / Determine whether any of the given template arguments are dependent. / / The converted arguments should be supplied when known; whether an / argument is dependent can depend on the conversions performed on it / (for example, a 'const int' passed as a template argument might be / dependent if the parameter is a reference but non-dependent if the / parameter is an int). / / Note that the <code>Args</code> parameter is unused: this is intentional, to remind / the caller that they need to pass in the converted arguments, not the / specified arguments. static bool anyDependentTemplateArguments(ArrayRef&lt;TemplateArgumentLoc&gt; Args,
                                ArrayRef&lt;TemplateArgument&gt; Converted); static bool anyDependentTemplateArguments(const TemplateArgumentListInfo &amp;,
                                ArrayRef&lt;TemplateArgument&gt; Converted); static bool anyInstantiationDependentTemplateArguments(
      ArrayRef&lt;TemplateArgumentLoc&gt; Args);</p>
<p>/ True if this template specialization type matches a current / instantiation in the context in which it is found. bool isCurrentInstantiation() const { return isa&lt;InjectedClassNameType&gt;(getCanonicalTypeInternal()); }</p>
<p>/ Determine if this template specialization type is for a type alias / template that has been substituted. / / Nearly every template specialization type whose template is an alias / template will be substituted. However, this is not the case when / the specialization contains a pack expansion but the template alias / does not have a corresponding parameter pack, e.g., / / </p><div class="fragment"><div class="line"><span class="comment">/// template&lt;typename T, typename U, typename V&gt; struct S;</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// template&lt;typename T, typename U&gt; using A = S&lt;T, int, U&gt;;</span></div>
<div class="line"><span class="comment">/// template&lt;typename... Ts&gt; struct X {</span></div>
<div class="line"><span class="comment">///   typedef A&lt;Ts...&gt; type; // not a type alias</span></div>
<div class="line"><span class="comment">/// };</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool isTypeAlias() const { return TemplateSpecializationTypeBits.TypeAlias; }</p>
<p>/ Get the aliased type, if this is a specialization of a type alias / template. <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> getAliasedType() const;</p>
<p>/ Retrieve the name of the template that we are specializing. <a class="el" href="classclang_1_1TemplateName.html" title="Represents a C++ template name within the type system.">TemplateName</a> getTemplateName() const { return Template; }</p>
<p>ArrayRef&lt;TemplateArgument&gt; template_arguments() const { return {reinterpret_cast&lt;const TemplateArgument *&gt;(this + 1), TemplateSpecializationTypeBits.NumArgs}; }</p>
<p>bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const </a>{ return !isDependentType() || isCurrentInstantiation() || isTypeAlias(); }</p>
<p><a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const </a>{ return isTypeAlias() ? getAliasedType() : getCanonicalTypeInternal(); }</p>
<p>void Profile(llvm::FoldingSetNodeID &amp;ID, const ASTContext &amp;Ctx); static void Profile(llvm::FoldingSetNodeID &amp;ID, TemplateName T,
                      ArrayRef&lt;TemplateArgument&gt; Args,
                      const ASTContext &amp;Context);</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == TemplateSpecialization; } };</p>
<p>/ Print a template argument list, including the '&lt;' and '&gt;' / enclosing the template arguments. void printTemplateArgumentList(raw_ostream &amp;OS, ArrayRef&lt;TemplateArgument&gt; Args, const <a class="el" href="structclang_1_1PrintingPolicy.html" title="Describes how types, statements, expressions, and declarations should be printed.">PrintingPolicy</a> &amp;Policy, const <a class="el" href="classclang_1_1TemplateParameterList.html" title="Stores a list of template parameters for a TemplateDecl and its derived classes.">TemplateParameterList</a> *TPL = nullptr);</p>
<p>void printTemplateArgumentList(raw_ostream &amp;OS, ArrayRef&lt;TemplateArgumentLoc&gt; Args, const <a class="el" href="structclang_1_1PrintingPolicy.html" title="Describes how types, statements, expressions, and declarations should be printed.">PrintingPolicy</a> &amp;Policy, const <a class="el" href="classclang_1_1TemplateParameterList.html" title="Stores a list of template parameters for a TemplateDecl and its derived classes.">TemplateParameterList</a> *TPL = nullptr);</p>
<p>void printTemplateArgumentList(raw_ostream &amp;OS, const <a class="el" href="classclang_1_1TemplateArgumentListInfo.html" title="A convenient class for passing around template argument information.">TemplateArgumentListInfo</a> &amp;Args, const <a class="el" href="structclang_1_1PrintingPolicy.html" title="Describes how types, statements, expressions, and declarations should be printed.">PrintingPolicy</a> &amp;Policy, const <a class="el" href="classclang_1_1TemplateParameterList.html" title="Stores a list of template parameters for a TemplateDecl and its derived classes.">TemplateParameterList</a> *TPL = nullptr);</p>
<p>/ Make a best-effort determination of whether the type T can be produced by / substituting Args into the default argument of Param. bool isSubstitutedDefaultArgument(ASTContext &amp;Ctx, TemplateArgument Arg,
                                  const NamedDecl *Param,
                                  ArrayRef&lt;TemplateArgument&gt; Args,
                                  unsigned Depth);</p>
<p>/ The injected class name of a C++ class template or class / template partial specialization. Used to record that a type was / spelled with a bare identifier rather than as a template-id; the / equivalent for non-templated classes is just RecordType. / / Injected class name types are always dependent. Template / instantiation turns these into RecordTypes. / / Injected class name types are always canonical. This works / because it is impossible to compare an injected class name type / with the corresponding non-injected template type, for the same / reason that it is impossible to directly compare template / parameters from different dependent contexts: injected class name / types can only occur within the scope of a particular templated / declaration, and within that scope every template specialization / will canonicalize to the injected class name (when appropriate / according to the rules of the language). class InjectedClassNameType : public <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a> { friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>; // <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> creates these. friend class <a class="el" href="classclang_1_1ASTNodeImporter.html">ASTNodeImporter</a>; friend class <a class="el" href="classclang_1_1ASTReader.html" title="Reads an AST files chain containing the contents of a translation unit.">ASTReader</a>; // FIXME: <a class="el" href="classclang_1_1ASTContext.html#a2ced0f10bc335d828364d2e5918744d0" title="getInjectedClassNameType - Return the unique reference to the injected class name type for the specif...">ASTContext::getInjectedClassNameType</a> is not currently suitable for AST reading, too much interdependencies. template &lt;class T&gt; friend class <a class="el" href="classclang_1_1serialization_1_1AbstractTypeReader.html">serialization::AbstractTypeReader</a>;</p>
<p><a class="el" href="classclang_1_1CXXRecordDecl.html" title="Represents a C++ struct/union/class.">CXXRecordDecl</a> *Decl;</p>
<p>/ The template specialization which this type represents. / For example, in / template &lt;class T&gt; class A { ... }; / this is A&lt;T&gt;, whereas in / template &lt;class X, class Y&gt; class A&lt;B&lt;X,Y&gt; &gt; { ... }; / this is A&lt;B&lt;X,Y&gt; &gt;. / / It is always unqualified, always a template specialization type, / and always dependent. <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> InjectedType;</p>
<p>InjectedClassNameType(CXXRecordDecl *D, QualType TST) : <a class="el" href="ASTMatchFinder_8cpp.html#a00b5b979fc4b4e5bfe20af5f70977941">Type(InjectedClassName, QualType(),
             TypeDependence::DependentInstantiation)</a>, Decl(D), InjectedType(TST) { assert(isa&lt;TemplateSpecializationType&gt;(TST)); assert(!TST.hasQualifiers()); assert(TST-&gt;isDependentType()); }</p>
<p>public: <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> getInjectedSpecializationType() const { return InjectedType; }</p>
<p>const TemplateSpecializationType *getInjectedTST() const { return cast&lt;TemplateSpecializationType&gt;(InjectedType.getTypePtr()); }</p>
<p><a class="el" href="classclang_1_1TemplateName.html" title="Represents a C++ template name within the type system.">TemplateName</a> getTemplateName() const { return getInjectedTST()-&gt;getTemplateName(); }</p>
<p><a class="el" href="classclang_1_1CXXRecordDecl.html" title="Represents a C++ struct/union/class.">CXXRecordDecl</a> *getDecl() const;</p>
<p>bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const </a>{ return false; } <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const </a>{ return QualType(this, 0); }</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == InjectedClassName; } };</p>
<p>/ The kind of a tag type. enum TagTypeKind { / The "struct" keyword. TTK_Struct,</p>
<p>/ The "__interface" keyword. TTK_Interface,</p>
<p>/ The "union" keyword. TTK_Union,</p>
<p>/ The "class" keyword. TTK_Class,</p>
<p>/ The "enum" keyword. TTK_Enum };</p>
<p>/ The elaboration keyword that precedes a qualified type name or / introduces an elaborated-type-specifier. enum ElaboratedTypeKeyword { / The "struct" keyword introduces the elaborated-type-specifier. ETK_Struct,</p>
<p>/ The "__interface" keyword introduces the elaborated-type-specifier. ETK_Interface,</p>
<p>/ The "union" keyword introduces the elaborated-type-specifier. ETK_Union,</p>
<p>/ The "class" keyword introduces the elaborated-type-specifier. ETK_Class,</p>
<p>/ The "enum" keyword introduces the elaborated-type-specifier. ETK_Enum,</p>
<p>/ The "typename" keyword precedes the qualified type name, e.g., / <code>typename</code> T::type. ETK_Typename,</p>
<p>/ No keyword precedes the qualified type name. ETK_None };</p>
<p>/ A helper class for <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a> nodes having an ElaboratedTypeKeyword. / The keyword in stored in the free bits of the base class. / Also provides a few static helpers for converting and printing / elaborated type keyword and tag type kind enumerations. class TypeWithKeyword : public <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a> { protected: TypeWithKeyword(ElaboratedTypeKeyword Keyword, TypeClass tc,
                  QualType Canonical, TypeDependence Dependence) : <a class="el" href="ASTMatchFinder_8cpp.html#a00b5b979fc4b4e5bfe20af5f70977941">Type(tc, Canonical, Dependence)</a> { TypeWithKeywordBits.Keyword = Keyword; }</p>
<p>public: ElaboratedTypeKeyword getKeyword() const { return static_cast&lt;ElaboratedTypeKeyword&gt;(TypeWithKeywordBits.Keyword); }</p>
<p>/ Converts a type specifier (<a class="el" href="classclang_1_1DeclSpec.html#a774704a118c512f397a98447c9b4653f">DeclSpec::TST</a>) into an elaborated type keyword. static ElaboratedTypeKeyword getKeywordForTypeSpec(unsigned TypeSpec);</p>
<p>/ Converts a type specifier (<a class="el" href="classclang_1_1DeclSpec.html#a774704a118c512f397a98447c9b4653f">DeclSpec::TST</a>) into a tag type kind. / It is an error to provide a type specifier which <em>isn't</em> a tag kind here. static TagTypeKind getTagTypeKindForTypeSpec(unsigned TypeSpec);</p>
<p>/ Converts a TagTypeKind into an elaborated type keyword. static ElaboratedTypeKeyword getKeywordForTagTypeKind(TagTypeKind Tag);</p>
<p>/ Converts an elaborated type keyword into a TagTypeKind. / It is an error to provide an elaborated type keyword / which <em>isn't</em> a tag kind here. static TagTypeKind getTagTypeKindForKeyword(ElaboratedTypeKeyword Keyword);</p>
<p>static bool KeywordIsTagTypeKind(ElaboratedTypeKeyword Keyword);</p>
<p>static StringRef getKeywordName(ElaboratedTypeKeyword Keyword);</p>
<p>static StringRef getTagTypeKindName(TagTypeKind Kind) { return getKeywordName(getKeywordForTagTypeKind(Kind)); }</p>
<p>class CannotCastToThisType {}; static CannotCastToThisType <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *)</a>; };</p>
<p>/ Represents a type that was referred to using an elaborated type / keyword, e.g., struct S, or via a qualified name, e.g., N::M::type, / or both. / / This type is used to keep track of a type name as written in the / source code, including tag keywords and any nested-name-specifiers. / The type itself is always "sugar", used to express what was written / in the source code but containing no additional semantic information. class ElaboratedType final : public TypeWithKeyword, public llvm::FoldingSetNode, private llvm::TrailingObjects&lt;ElaboratedType, TagDecl *&gt; { friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>; // <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> creates these friend TrailingObjects;</p>
<p>/ The nested name specifier containing the qualifier. <a class="el" href="classclang_1_1NestedNameSpecifier.html" title="Represents a C++ nested name specifier, such as &quot;\::std::vector&lt;int&gt;::&quot;.">NestedNameSpecifier</a> *NNS;</p>
<p>/ The type that this qualified name refers to. <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> NamedType;</p>
<p>/ The (re)declaration of this tag type owned by this occurrence is stored / as a trailing object if there is one. Use getOwnedTagDecl to obtain / it, or obtain a null pointer if there is none.</p>
<p>ElaboratedType(ElaboratedTypeKeyword Keyword, NestedNameSpecifier *NNS,
                 QualType NamedType, QualType CanonType, TagDecl *OwnedTagDecl) : TypeWithKeyword(Keyword, Elaborated, CanonType, Any semantic dependence on the qualifier will have been incorporated into NamedType. We still need to track syntactic (instantiation / error / pack) dependence on the qualifier. NamedType-&gt;getDependence() | (NNS ? toSyntacticDependence( toTypeDependence(NNS-&gt;getDependence())) : TypeDependence::None)), NNS(NNS), NamedType(NamedType) { ElaboratedTypeBits.HasOwnedTagDecl = false; if (OwnedTagDecl) { ElaboratedTypeBits.HasOwnedTagDecl = true; getTrailingObjects&lt;TagDecl *&gt;() = OwnedTagDecl; } }</p>
<p>public: / Retrieve the qualification on this type. <a class="el" href="classclang_1_1NestedNameSpecifier.html" title="Represents a C++ nested name specifier, such as &quot;\::std::vector&lt;int&gt;::&quot;.">NestedNameSpecifier</a> *getQualifier() const { return NNS; }</p>
<p>/ Retrieve the type named by the qualified-id. <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> getNamedType() const { return NamedType; }</p>
<p>/ Remove a single level of sugar. <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const </a>{ return getNamedType(); }</p>
<p>/ Returns whether this type directly provides sugar. bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const </a>{ return true; }</p>
<p>/ Return the (re)declaration of this type owned by this occurrence of this / type, or nullptr if there is none. <a class="el" href="classclang_1_1TagDecl.html" title="Represents the declaration of a struct/union/class/enum.">TagDecl</a> *getOwnedTagDecl() const { return ElaboratedTypeBits.HasOwnedTagDecl ? *getTrailingObjects&lt;<a class="el" href="classclang_1_1TagDecl.html" title="Represents the declaration of a struct/union/class/enum.">TagDecl</a> *&gt;() : nullptr; }</p>
<p>void Profile(llvm::FoldingSetNodeID &amp;ID) { Profile(ID, getKeyword(), NNS, NamedType, getOwnedTagDecl()); }</p>
<p>static void Profile(llvm::FoldingSetNodeID &amp;ID, ElaboratedTypeKeyword Keyword,
                      NestedNameSpecifier *NNS, QualType NamedType,
                      TagDecl *OwnedTagDecl) { ID.AddInteger(Keyword); ID.AddPointer(NNS); NamedType.Profile(ID); ID.AddPointer(OwnedTagDecl); }</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == Elaborated; } };</p>
<p>/ Represents a qualified type name for which the type name is / dependent. / / DependentNameType represents a class of dependent types that involve a / possibly dependent nested-name-specifier (e.g., "T::") followed by a / name of a type. The DependentNameType may start with a "typename" (for a / typename-specifier), "class", "struct", "union", or "enum" (for a / dependent elaborated-type-specifier), or nothing (in contexts where we / know that we must be referring to a type, e.g., in a base class specifier). / Typically the nested-name-specifier is dependent, but in MSVC compatibility / mode, this type is used with non-dependent names to delay name lookup until / instantiation. class DependentNameType : public TypeWithKeyword, public llvm::FoldingSetNode { friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>; // <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> creates these</p>
<p>/ The nested name specifier containing the qualifier. <a class="el" href="classclang_1_1NestedNameSpecifier.html" title="Represents a C++ nested name specifier, such as &quot;\::std::vector&lt;int&gt;::&quot;.">NestedNameSpecifier</a> *NNS;</p>
<p>/ The type that this typename specifier refers to. const <a class="el" href="classclang_1_1IdentifierInfo.html" title="One of these records is kept for each identifier that is lexed.">IdentifierInfo</a> *Name;</p>
<p>DependentNameType(ElaboratedTypeKeyword Keyword, NestedNameSpecifier *NNS,
                    const IdentifierInfo *Name, QualType CanonType) : TypeWithKeyword(Keyword, DependentName, CanonType, TypeDependence::DependentInstantiation | toTypeDependence(NNS-&gt;getDependence())), NNS(NNS), Name(Name) {}</p>
<p>public: / Retrieve the qualification on this type. <a class="el" href="classclang_1_1NestedNameSpecifier.html" title="Represents a C++ nested name specifier, such as &quot;\::std::vector&lt;int&gt;::&quot;.">NestedNameSpecifier</a> *getQualifier() const { return NNS; }</p>
<p>/ Retrieve the type named by the typename specifier as an identifier. / / This routine will return a non-NULL identifier pointer when the / form of the original typename was terminated by an identifier, / e.g., "typename T::type". const <a class="el" href="classclang_1_1IdentifierInfo.html" title="One of these records is kept for each identifier that is lexed.">IdentifierInfo</a> *getIdentifier() const { return Name; }</p>
<p>bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const </a>{ return false; } <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const </a>{ return QualType(this, 0); }</p>
<p>void Profile(llvm::FoldingSetNodeID &amp;ID) { Profile(ID, getKeyword(), NNS, Name); }</p>
<p>static void Profile(llvm::FoldingSetNodeID &amp;ID, ElaboratedTypeKeyword Keyword,
                      NestedNameSpecifier *NNS, const IdentifierInfo *Name) { ID.AddInteger(Keyword); ID.AddPointer(NNS); ID.AddPointer(Name); }</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == DependentName; } };</p>
<p>/ Represents a template specialization type whose template cannot be / resolved, e.g. / A&lt;T&gt;::template B&lt;T&gt; class alignas(8) DependentTemplateSpecializationType : public TypeWithKeyword, public llvm::FoldingSetNode { friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>; // <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> creates these</p>
<p>/ The nested name specifier containing the qualifier. <a class="el" href="classclang_1_1NestedNameSpecifier.html" title="Represents a C++ nested name specifier, such as &quot;\::std::vector&lt;int&gt;::&quot;.">NestedNameSpecifier</a> *NNS;</p>
<p>/ The identifier of the template. const <a class="el" href="classclang_1_1IdentifierInfo.html" title="One of these records is kept for each identifier that is lexed.">IdentifierInfo</a> *Name;</p>
<p>DependentTemplateSpecializationType(ElaboratedTypeKeyword Keyword,
                                      NestedNameSpecifier *NNS,
                                      const IdentifierInfo *Name,
                                      ArrayRef&lt;TemplateArgument&gt; Args,
                                      QualType Canon);</p>
<p>public: <a class="el" href="classclang_1_1NestedNameSpecifier.html" title="Represents a C++ nested name specifier, such as &quot;\::std::vector&lt;int&gt;::&quot;.">NestedNameSpecifier</a> *getQualifier() const { return NNS; } const <a class="el" href="classclang_1_1IdentifierInfo.html" title="One of these records is kept for each identifier that is lexed.">IdentifierInfo</a> *getIdentifier() const { return Name; }</p>
<p>ArrayRef&lt;TemplateArgument&gt; template_arguments() const { return {reinterpret_cast&lt;const TemplateArgument *&gt;(this + 1), DependentTemplateSpecializationTypeBits.NumArgs}; }</p>
<p>bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const </a>{ return false; } <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const </a>{ return QualType(this, 0); }</p>
<p>void Profile(llvm::FoldingSetNodeID &amp;ID, const ASTContext &amp;Context) { Profile(ID, Context, getKeyword(), NNS, Name, template_arguments()); }</p>
<p>static void Profile(llvm::FoldingSetNodeID &amp;ID,
                      const ASTContext &amp;Context,
                      ElaboratedTypeKeyword Keyword,
                      NestedNameSpecifier *Qualifier,
                      const IdentifierInfo *Name,
                      ArrayRef&lt;TemplateArgument&gt; Args);</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == DependentTemplateSpecialization; } };</p>
<p>/ Represents a pack expansion of types. / / Pack expansions are part of C++11 variadic templates. A pack / expansion contains a pattern, which itself contains one or more / "unexpanded" parameter packs. When instantiated, a pack expansion / produces a series of types, each instantiated from the pattern of / the expansion, where the Ith instantiation of the pattern uses the / Ith arguments bound to each of the unexpanded parameter packs. The / pack expansion is considered to "expand" these unexpanded / parameter packs. / / </p><div class="fragment"><div class="line"><span class="comment">/// template&lt;typename ...Types&gt; struct tuple;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">/// template&lt;typename ...Types&gt;</span></div>
<div class="line"><span class="comment">/// struct tuple_of_references {</span></div>
<div class="line"><span class="comment">///   typedef tuple&lt;Types&amp;...&gt; type;</span></div>
<div class="line"><span class="comment">/// };</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / Here, the pack expansion <code>Types&amp;</code>... is represented via a / PackExpansionType whose pattern is Types&amp;. class PackExpansionType : public <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a>, public llvm::FoldingSetNode { friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>; // <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> creates these</p>
<p>/ The pattern of the pack expansion. <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> Pattern;</p>
<p>PackExpansionType(QualType Pattern, QualType Canon,
                    std::optional&lt;unsigned&gt; NumExpansions) : <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a>(PackExpansion, Canon, (Pattern-&gt;getDependence() | TypeDependence::Dependent | TypeDependence::Instantiation) &amp; ~TypeDependence::UnexpandedPack), Pattern(Pattern) { PackExpansionTypeBits.NumExpansions = NumExpansions ? *NumExpansions + 1 : 0; }</p>
<p>public: / Retrieve the pattern of this pack expansion, which is the / type that will be repeatedly instantiated when instantiating the / pack expansion itself. <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> getPattern() const { return Pattern; }</p>
<p>/ Retrieve the number of expansions that this pack expansion will / generate, if known. std::optional&lt;unsigned&gt; getNumExpansions() const { if (PackExpansionTypeBits.NumExpansions) return PackExpansionTypeBits.NumExpansions - 1; return std::nullopt; }</p>
<p>bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const </a>{ return false; } <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const </a>{ return QualType(this, 0); }</p>
<p>void Profile(llvm::FoldingSetNodeID &amp;ID) { Profile(ID, getPattern(), getNumExpansions()); }</p>
<p>static void Profile(llvm::FoldingSetNodeID &amp;ID, QualType Pattern,
                      std::optional&lt;unsigned&gt; NumExpansions) { ID.AddPointer(Pattern.getAsOpaquePtr()); ID.AddBoolean(NumExpansions.has_value()); if (NumExpansions) ID.AddInteger(*NumExpansions); }</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == PackExpansion; } };</p>
<p>/ This class wraps the list of protocol qualifiers. For types that can / take ObjC protocol qualifers, they can subclass this class. template &lt;class T&gt; class ObjCProtocolQualifiers { protected: ObjCProtocolQualifiers() = default;</p>
<p><a class="el" href="classclang_1_1ObjCProtocolDecl.html" title="Represents an Objective-C protocol declaration.">ObjCProtocolDecl</a> * const <em>getProtocolStorage() const { return const_cast&lt;ObjCProtocolQualifiers</em>&gt;(this)-&gt;getProtocolStorage(); }</p>
<p><a class="el" href="classclang_1_1ObjCProtocolDecl.html" title="Represents an Objective-C protocol declaration.">ObjCProtocolDecl</a> **getProtocolStorage() { return static_cast&lt;T*&gt;(this)-&gt;getProtocolStorageImpl(); }</p>
<p>void setNumProtocols(unsigned N) { static_cast&lt;T*&gt;(this)-&gt;setNumProtocolsImpl(N); }</p>
<p>void initialize(ArrayRef&lt;ObjCProtocolDecl *&gt; protocols) { setNumProtocols(protocols.size()); assert(<a class="el" href="#a236c55ef6d6a877a830de05f41366a27a710a99f3bce93c5576d562ffba30931f">getNumProtocols()</a> == protocols.size() &amp;&amp; "bitfield overflow in protocol count"); if (!protocols.empty()) memcpy(getProtocolStorage(), protocols.data(), protocols.size() * sizeof(ObjCProtocolDecl*)); }</p>
<p>public: using qual_iterator = <a class="el" href="classclang_1_1ObjCProtocolDecl.html" title="Represents an Objective-C protocol declaration.">ObjCProtocolDecl</a> * const *; using qual_range = llvm::iterator_range&lt;qual_iterator&gt;;</p>
<p>qual_range quals() const { return qual_range(<a class="el" href="#a236c55ef6d6a877a830de05f41366a27aaac975957d702cab1041242dadd4efb5">qual_begin()</a>, <a class="el" href="#a236c55ef6d6a877a830de05f41366a27a800c81021225056bc2f0c747a924bc24">qual_end()</a>); } qual_iterator <a class="el" href="#a236c55ef6d6a877a830de05f41366a27aaac975957d702cab1041242dadd4efb5">qual_begin() const </a>{ return getProtocolStorage(); } qual_iterator <a class="el" href="#a236c55ef6d6a877a830de05f41366a27a800c81021225056bc2f0c747a924bc24">qual_end() const </a>{ return <a class="el" href="#a236c55ef6d6a877a830de05f41366a27aaac975957d702cab1041242dadd4efb5">qual_begin()</a> + <a class="el" href="#a236c55ef6d6a877a830de05f41366a27a710a99f3bce93c5576d562ffba30931f">getNumProtocols()</a>; }</p>
<p>bool qual_empty() const { return <a class="el" href="#a236c55ef6d6a877a830de05f41366a27a710a99f3bce93c5576d562ffba30931f">getNumProtocols()</a> == 0; }</p>
<p>/ Return the number of qualifying protocols in this type, or 0 if / there are none. unsigned <a class="el" href="#a236c55ef6d6a877a830de05f41366a27a710a99f3bce93c5576d562ffba30931f">getNumProtocols() const </a>{ return static_cast&lt;const T*&gt;(this)-&gt;getNumProtocolsImpl(); }</p>
<p>/ Fetch a protocol by index. <a class="el" href="classclang_1_1ObjCProtocolDecl.html" title="Represents an Objective-C protocol declaration.">ObjCProtocolDecl</a> *getProtocol(unsigned I) const { assert(I &lt; <a class="el" href="#a236c55ef6d6a877a830de05f41366a27a710a99f3bce93c5576d562ffba30931f">getNumProtocols()</a> &amp;&amp; "Out-of-range protocol access"); return <a class="el" href="#a236c55ef6d6a877a830de05f41366a27aaac975957d702cab1041242dadd4efb5">qual_begin()</a>[I]; }</p>
<p>/ Retrieve all of the protocol qualifiers. ArrayRef&lt;ObjCProtocolDecl *&gt; getProtocols() const { return ArrayRef&lt;ObjCProtocolDecl *&gt;(<a class="el" href="#a236c55ef6d6a877a830de05f41366a27aaac975957d702cab1041242dadd4efb5">qual_begin()</a>, <a class="el" href="#a236c55ef6d6a877a830de05f41366a27a710a99f3bce93c5576d562ffba30931f">getNumProtocols()</a>); } };</p>
<p>/ Represents a type parameter type in Objective C. It can take / a list of protocols. class ObjCTypeParamType : public <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a>, public ObjCProtocolQualifiers&lt;ObjCTypeParamType&gt;, public llvm::FoldingSetNode { friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>; friend class ObjCProtocolQualifiers&lt;ObjCTypeParamType&gt;;</p>
<p>/ The number of protocols stored on this type. unsigned NumProtocols : 6;</p>
<p><a class="el" href="classclang_1_1ObjCTypeParamDecl.html" title="Represents the declaration of an Objective-C type parameter.">ObjCTypeParamDecl</a> *OTPDecl;</p>
<p>/ The protocols are stored after the ObjCTypeParamType node. In the / canonical type, the list of protocols are sorted alphabetically / and uniqued. <a class="el" href="classclang_1_1ObjCProtocolDecl.html" title="Represents an Objective-C protocol declaration.">ObjCProtocolDecl</a> **getProtocolStorageImpl();</p>
<p>/ Return the number of qualifying protocols in this interface type, / or 0 if there are none. unsigned getNumProtocolsImpl() const { return NumProtocols; }</p>
<p>void setNumProtocolsImpl(unsigned N) { NumProtocols = N; }</p>
<p>ObjCTypeParamType(const ObjCTypeParamDecl *D,
                    QualType can,
                    ArrayRef&lt;ObjCProtocolDecl *&gt; protocols);</p>
<p>public: bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const </a>{ return true; } <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const </a>{ return getCanonicalTypeInternal(); }</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == ObjCTypeParam; }</p>
<p>void Profile(llvm::FoldingSetNodeID &amp;ID); static void Profile(llvm::FoldingSetNodeID &amp;ID,
                      const ObjCTypeParamDecl *OTPDecl,
                      QualType CanonicalType,
                      ArrayRef&lt;ObjCProtocolDecl *&gt; protocols);</p>
<p><a class="el" href="classclang_1_1ObjCTypeParamDecl.html" title="Represents the declaration of an Objective-C type parameter.">ObjCTypeParamDecl</a> *getDecl() const { return OTPDecl; } };</p>
<p>/ Represents a class type in Objective C. / / Every Objective C type is a combination of a base type, a set of / type arguments (optional, for parameterized classes) and a list of / protocols. / / Given the following declarations: / </p><div class="fragment"><div class="line"><span class="comment">///   \@class C&lt;T&gt;;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   \@protocol P;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / 'C' is an <a class="el" href="classclang_1_1ObjCInterfaceType.html" title="Represents typeof(type), a C2x feature and GCC extension, or `typeof_unqual(type),...">ObjCInterfaceType</a> C. It is sugar for an <a class="el" href="classObjCObjectType.html">ObjCObjectType</a> / with base C and no protocols. / / 'C</p>
<p>' is an unspecialized <a class="el" href="classObjCObjectType.html">ObjCObjectType</a> with base C and protocol list [P]. / 'C&lt;C*&gt;' is a specialized <a class="el" href="classObjCObjectType.html">ObjCObjectType</a> with type arguments 'C*' and no / protocol list. / 'C&lt;C*&gt;</p>
<p>' is a specialized <a class="el" href="classObjCObjectType.html">ObjCObjectType</a> with base C, type arguments 'C*', / and protocol list [P]. / / 'id' is a <a class="el" href="classclang_1_1TypedefType.html">TypedefType</a> which is sugar for an <a class="el" href="classclang_1_1ObjCObjectPointerType.html" title="Represents a pointer to an Objective C object.">ObjCObjectPointerType</a> whose / pointee is an <a class="el" href="classObjCObjectType.html">ObjCObjectType</a> with base BuiltinType::ObjCIdType / and no protocols. / / 'id</p>
<p>' is an <a class="el" href="classclang_1_1ObjCObjectPointerType.html" title="Represents a pointer to an Objective C object.">ObjCObjectPointerType</a> whose pointee is an <a class="el" href="classObjCObjectType.html">ObjCObjectType</a> / with base BuiltinType::ObjCIdType and protocol list [P]. Eventually / this should get its own sugar class to better represent the source. class <a class="el" href="classObjCObjectType.html">ObjCObjectType</a> : public <a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a>, public ObjCProtocolQualifiers&lt;ObjCObjectType&gt; { friend class ObjCProtocolQualifiers&lt;ObjCObjectType&gt;;</p>
<p>ObjCObjectType.NumTypeArgs - the number of type arguments stored after the <a class="el" href="classclang_1_1ObjCObjectPointerType.html" title="Represents a pointer to an Objective C object.">ObjCObjectPointerType</a> node. ObjCObjectType.NumProtocols - the number of protocols stored after the type arguments of <a class="el" href="classclang_1_1ObjCObjectPointerType.html" title="Represents a pointer to an Objective C object.">ObjCObjectPointerType</a> node.</p>
<p>These protocols are those written directly on the type. If protocol qualifiers ever become additive, the iterators will need to get kindof complicated.</p>
<p>In the canonical object type, these are sorted alphabetically and uniqued.</p>
<p>/ Either a <a class="el" href="classclang_1_1BuiltinType.html" title="This class is used for builtin types like &#39;int&#39;.">BuiltinType</a> or an InterfaceType or sugar for either. <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> BaseType;</p>
<p>/ Cached superclass type. mutable llvm::PointerIntPair&lt;const ObjCObjectType *, 1, bool&gt; CachedSuperClassType;</p>
<p><a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> *getTypeArgStorage(); const <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> *getTypeArgStorage() const { return const_cast&lt;ObjCObjectType *&gt;(this)-&gt;getTypeArgStorage(); }</p>
<p><a class="el" href="classclang_1_1ObjCProtocolDecl.html" title="Represents an Objective-C protocol declaration.">ObjCProtocolDecl</a> **getProtocolStorageImpl(); / Return the number of qualifying protocols in this interface type, / or 0 if there are none. unsigned getNumProtocolsImpl() const { return ObjCObjectTypeBits.NumProtocols; } void setNumProtocolsImpl(unsigned N) { ObjCObjectTypeBits.NumProtocols = N; }</p>
<p>protected: enum Nonce_ObjCInterface { Nonce_ObjCInterface };</p>
<p><a class="el" href="classObjCObjectType.html">ObjCObjectType(QualType Canonical, QualType Base,
                 ArrayRef&lt;QualType&gt; typeArgs,
                 ArrayRef&lt;ObjCProtocolDecl *&gt; protocols,
                 bool isKindOf)</a>;</p>
<p><a class="el" href="classObjCObjectType.html">ObjCObjectType(enum Nonce_ObjCInterface)</a> : <a class="el" href="ASTMatchFinder_8cpp.html#a00b5b979fc4b4e5bfe20af5f70977941">Type(ObjCInterface, QualType(), TypeDependence::None)</a>, BaseType(QualType(this_(), 0)) { ObjCObjectTypeBits.NumProtocols = 0; ObjCObjectTypeBits.NumTypeArgs = 0; ObjCObjectTypeBits.IsKindOf = 0; }</p>
<p>void computeSuperClassTypeSlow() const;</p>
<p>public: / Gets the base type of this object type. This is always (possibly / sugar for) one of: / - the 'id' builtin type (as opposed to the 'id' type visible to the / user, which is a typedef for an <a class="el" href="classclang_1_1ObjCObjectPointerType.html" title="Represents a pointer to an Objective C object.">ObjCObjectPointerType</a>) / - the 'Class' builtin type (same caveat) / - an <a class="el" href="classObjCObjectType.html">ObjCObjectType</a> (currently always an <a class="el" href="classclang_1_1ObjCInterfaceType.html" title="Represents typeof(type), a C2x feature and GCC extension, or `typeof_unqual(type),...">ObjCInterfaceType</a>) <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> getBaseType() const { return BaseType; }</p>
<p>bool isObjCId() const { return getBaseType()-&gt;isSpecificBuiltinType(BuiltinType::ObjCId); }</p>
<p>bool isObjCClass() const { return getBaseType()-&gt;isSpecificBuiltinType(BuiltinType::ObjCClass); }</p>
<p>bool isObjCUnqualifiedId() const { return qual_empty() &amp;&amp; isObjCId(); } bool isObjCUnqualifiedClass() const { return qual_empty() &amp;&amp; isObjCClass(); } bool isObjCUnqualifiedIdOrClass() const { if (!qual_empty()) return false; if (const <a class="el" href="classclang_1_1BuiltinType.html" title="This class is used for builtin types like &#39;int&#39;.">BuiltinType</a> *T = getBaseType()-&gt;getAs&lt;BuiltinType&gt;()) return T-&gt;<a class="el" href="DeclBase_8cpp.html#a37d13911f1772d0ed90b6b2e89cf3c60">getKind()</a> == BuiltinType::ObjCId || T-&gt;<a class="el" href="DeclBase_8cpp.html#a37d13911f1772d0ed90b6b2e89cf3c60">getKind()</a> == BuiltinType::ObjCClass; return false; } bool isObjCQualifiedId() const { return !qual_empty() &amp;&amp; isObjCId(); } bool isObjCQualifiedClass() const { return !qual_empty() &amp;&amp; isObjCClass(); }</p>
<p>/ Gets the interface declaration for this object type, if the base type / really is an interface. <a class="el" href="classclang_1_1ObjCInterfaceDecl.html" title="Represents an ObjC class declaration.">ObjCInterfaceDecl</a> *getInterface() const;</p>
<p>/ Determine whether this object type is "specialized", meaning / that it has type arguments. bool isSpecialized() const;</p>
<p>/ Determine whether this object type was written with type arguments. bool isSpecializedAsWritten() const { return ObjCObjectTypeBits.NumTypeArgs &gt; 0; }</p>
<p>/ Determine whether this object type is "unspecialized", meaning / that it has no type arguments. bool isUnspecialized() const { return !isSpecialized(); }</p>
<p>/ Determine whether this object type is "unspecialized" as / written, meaning that it has no type arguments. bool isUnspecializedAsWritten() const { return !isSpecializedAsWritten(); }</p>
<p>/ Retrieve the type arguments of this object type (semantically). ArrayRef&lt;QualType&gt; getTypeArgs() const;</p>
<p>/ Retrieve the type arguments of this object type as they were / written. ArrayRef&lt;QualType&gt; getTypeArgsAsWritten() const { return <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>(getTypeArgStorage(), ObjCObjectTypeBits.NumTypeArgs); }</p>
<p>/ Whether this is a "__kindof" type as written. bool isKindOfTypeAsWritten() const { return ObjCObjectTypeBits.IsKindOf; }</p>
<p>/ Whether this ia a "__kindof" type (semantically). bool isKindOfType() const;</p>
<p>/ Retrieve the type of the superclass of this object type. / / This operation substitutes any type arguments into the / superclass of the current class type, potentially producing a / specialization of the superclass type. Produces a null type if / there is no superclass. <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> getSuperClassType() const { if (!CachedSuperClassType.getInt()) computeSuperClassTypeSlow();</p>
<p>assert(CachedSuperClassType.getInt() &amp;&amp; "Superclass not set?"); return <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a>(CachedSuperClassType.getPointer(), 0); }</p>
<p>/ Strip off the Objective-C "kindof" type and (with it) any / protocol qualifiers. <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> stripObjCKindOfTypeAndQuals(const ASTContext &amp;ctx) const;</p>
<p>bool <a class="el" href="#a818b0b6f024405f259cebe5e4158d43e">isSugared() const </a>{ return false; } <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <a class="el" href="#a34de3b2f21f3e7139333ad451b076e5f">desugar() const </a>{ return QualType(this, 0); }</p>
<p>static bool <a class="el" href="#acd6e13ff6004d2be696e101745e8d482">classof(const Type *T)</a> { return T-&gt;getTypeClass() == ObjCObject || T-&gt;getTypeClass() == ObjCInterface; } };</p>
<p>/ A class providing a concrete implementation / of <a class="el" href="classObjCObjectType.html">ObjCObjectType</a>, so as to not increase the footprint of / <a class="el" href="classclang_1_1ObjCInterfaceType.html" title="Represents typeof(type), a C2x feature and GCC extension, or `typeof_unqual(type),...">ObjCInterfaceType</a>. Code outside of <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a> and the core type / system should not reference this type. class ObjCObjectTypeImpl : public <a class="el" href="classObjCObjectType.html">ObjCObjectType</a>, public llvm::FoldingSetNode { friend class <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>;</p>
<p>If anyone adds fields here, ObjCObjectType::getProtocolStorage() will need to be modified.</p>
<p>ObjCObjectTypeImpl(QualType Canonical, QualType Base,
                     ArrayRef&lt;QualType&gt; typeArgs,
                     ArrayRef&lt;ObjCProtocolDecl *&gt; protocols,
                     bool isKindOf) : <a class="el" href="classObjCObjectType.html">ObjCObjectType(Canonical, Base, typeArgs, protocols, isKindOf)</a> {}</p>
<p>public: void Profile(llvm::FoldingSetNodeID &amp;ID); static void Profile(llvm::FoldingSetNodeID &amp;ID,
                      QualType Base,
                      ArrayRef&lt;QualType&gt; typeArgs,
                      ArrayRef&lt;ObjCProtocolDecl *&gt; protocols,
                      bool isKindOf); };</p>
<p>inline <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> <em>ObjCObjectType::getTypeArgStorage() { return reinterpret_cast&lt;QualType *&gt;(static_cast&lt;ObjCObjectTypeImpl</em>&gt;(this)+1); }</p>
<p>inline <a class="el" href="classclang_1_1ObjCProtocolDecl.html" title="Represents an Objective-C protocol declaration.">ObjCProtocolDecl</a> <b>ObjCObjectType::getProtocolStorageImpl() { return reinterpret_cast&lt;<a class="el" href="classclang_1_1ObjCProtocolDecl.html" title="Represents an Objective-C protocol declaration.">ObjCProtocolDecl</a></b>&gt;( getTypeArgStorage() + ObjCObjectTypeBits.NumTypeArgs); }</p>
<p>inline <a class="el" href="classclang_1_1ObjCProtocolDecl.html" title="Represents an Objective-C protocol declaration.">ObjCProtocolDecl</a> <b>ObjCTypeParamType::getProtocolStorageImpl() { return reinterpret_cast&lt;<a class="el" href="classclang_1_1ObjCProtocolDecl.html" title="Represents an Objective-C protocol declaration.">ObjCProtocolDecl</a></b>&gt;( static_cast&lt;ObjCTypeParamType*&gt;(this)+1); }</p>
<p>/ Interfaces are the core concept in Objective-C for object oriented design. / They basically correspond to C++ classes. There are two kinds of interface / types: normal interfaces like <code>NSString</code>, and qualified interfaces, which / are qualified with a protocol list like <code>NSString&lt;NSCopyable, NSAmazing&gt;</code>. </p><pre class="fragment">ObjCInterfaceType guarantees the following properties when considered
as a subtype of its superclass, ObjCObjectType:
  - There are no protocol qualifiers.  To reinforce this, code which
    tries to invoke the protocol methods via an ObjCInterfaceType will
    fail to compile.
  - It is its own base type.  That is, if T is an ObjCInterfaceType*,
    T-&gt;getBaseType() == QualType(T, 0). 
</pre> 
<p class="definition">Definition at line <a class="el" href="Type_8h_source.html#l06276">6276</a> of file <a class="el" href="Type_8h_source.html">Type.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a236c55ef6d6a877a830de05f41366a27" name="a236c55ef6d6a877a830de05f41366a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236c55ef6d6a877a830de05f41366a27">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a236c55ef6d6a877a830de05f41366a27a02f2cca4460e37fca444925b04fda33f" name="a236c55ef6d6a877a830de05f41366a27a02f2cca4460e37fca444925b04fda33f"></a>qual_iterator&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a236c55ef6d6a877a830de05f41366a27aaac975957d702cab1041242dadd4efb5" name="a236c55ef6d6a877a830de05f41366a27aaac975957d702cab1041242dadd4efb5"></a>qual_begin&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a236c55ef6d6a877a830de05f41366a27a800c81021225056bc2f0c747a924bc24" name="a236c55ef6d6a877a830de05f41366a27a800c81021225056bc2f0c747a924bc24"></a>qual_end&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a236c55ef6d6a877a830de05f41366a27a710a99f3bce93c5576d562ffba30931f" name="a236c55ef6d6a877a830de05f41366a27a710a99f3bce93c5576d562ffba30931f"></a>getNumProtocols&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a236c55ef6d6a877a830de05f41366a27a520cd7dea01a6e671e9f063caac3f073" name="a236c55ef6d6a877a830de05f41366a27a520cd7dea01a6e671e9f063caac3f073"></a>getProtocol&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Type_8h_source.html#l06302">6302</a> of file <a class="el" href="Type_8h_source.html">Type.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acd6e13ff6004d2be696e101745e8d482" name="acd6e13ff6004d2be696e101745e8d482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6e13ff6004d2be696e101745e8d482">&#9670;&#160;</a></span>classof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::ObjCInterfaceType::classof </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>T</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Type_8h_source.html#l06294">6294</a> of file <a class="el" href="Type_8h_source.html">Type.h</a>.</p>

</div>
</div>
<a id="a34de3b2f21f3e7139333ad451b076e5f" name="a34de3b2f21f3e7139333ad451b076e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34de3b2f21f3e7139333ad451b076e5f">&#9670;&#160;</a></span>desugar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1QualType.html">QualType</a> clang::ObjCInterfaceType::desugar </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Type_8h_source.html#l06292">6292</a> of file <a class="el" href="Type_8h_source.html">Type.h</a>.</p>

</div>
</div>
<a id="a1933b5e5a9dfd317f8bb48e2492befca" name="a1933b5e5a9dfd317f8bb48e2492befca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1933b5e5a9dfd317f8bb48e2492befca">&#9670;&#160;</a></span>getDecl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a> * ObjCInterfaceType::getDecl </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the declaration of this interface. </p>

<p class="definition">Definition at line <a class="el" href="Type_8cpp_source.html#l00829">829</a> of file <a class="el" href="Type_8cpp_source.html">Type.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeclBase_8h_source.html#l00946">clang::Decl::getCanonicalDecl()</a>, and <a class="el" href="DeclObjC_8h_source.html#l01530">clang::ObjCInterfaceDecl::getDefinition()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTContext_8cpp_source.html#l09866">clang::ASTContext::canAssignObjCInterfacesInBlockPointer()</a>, <a class="el" href="CGDebugInfo_8cpp_source.html#l05772">clang::CodeGen::CGDebugInfo::finalize()</a>, <a class="el" href="TypeLoc_8h_source.html#l01082">clang::ObjCInterfaceTypeLoc::getIFaceDecl()</a>, <a class="el" href="SemaExprObjC_8cpp_source.html#l01974">clang::Sema::HandleExprPropertyRefExpr()</a>, and <a class="el" href="JSONNodeDumper_8cpp_source.html#l00740">clang::JSONNodeDumper::VisitObjCInterfaceType()</a>.</p>

</div>
</div>
<a id="a818b0b6f024405f259cebe5e4158d43e" name="a818b0b6f024405f259cebe5e4158d43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818b0b6f024405f259cebe5e4158d43e">&#9670;&#160;</a></span>isSugared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::ObjCInterfaceType::isSugared </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Type_8h_source.html#l06291">6291</a> of file <a class="el" href="Type_8h_source.html">Type.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a81992f52dc601812ba88cecd0da65c8c" name="a81992f52dc601812ba88cecd0da65c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81992f52dc601812ba88cecd0da65c8c">&#9670;&#160;</a></span>ASTContext</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Type_8h_source.html#l06277">6277</a> of file <a class="el" href="Type_8h_source.html">Type.h</a>.</p>

</div>
</div>
<a id="a5d8560551ea81515968dd468e2e4082e" name="a5d8560551ea81515968dd468e2e4082e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8560551ea81515968dd468e2e4082e">&#9670;&#160;</a></span>ASTReader</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classclang_1_1ASTReader.html">ASTReader</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Type_8h_source.html#l06278">6278</a> of file <a class="el" href="Type_8h_source.html">Type.h</a>.</p>

</div>
</div>
<a id="a9ea3ec5e1aaa161fa14afe27378bdb7c" name="a9ea3ec5e1aaa161fa14afe27378bdb7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea3ec5e1aaa161fa14afe27378bdb7c">&#9670;&#160;</a></span>serialization::AbstractTypeReader</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classclang_1_1serialization_1_1AbstractTypeReader.html">serialization::AbstractTypeReader</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Type_8h_source.html#l06279">6279</a> of file <a class="el" href="Type_8h_source.html">Type.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/clang/AST/<a class="el" href="Type_8h_source.html">Type.h</a></li>
<li>lib/AST/<a class="el" href="Type_8cpp_source.html">Type.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 8 2024 17:02:17 for clang by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
