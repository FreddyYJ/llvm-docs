<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: clang::ModuleMap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">clang<span id="projectnumber">&#160;17.0.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceclang.html">clang</a></li><li class="navelem"><a class="el" href="classclang_1_1ModuleMap.html">ModuleMap</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classclang_1_1ModuleMap-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">clang::ModuleMap Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="ModuleMap_8h_source.html">clang/Lex/ModuleMap.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A header that is known to reside within a given module, whether it was included or excluded.  <a href="classclang_1_1ModuleMap_1_1KnownHeader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac7a2413d4d0a8f29d2dad359bcfd8dec" id="r_ac7a2413d4d0a8f29d2dad359bcfd8dec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a> { <a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8deca50b6dee47a2d5b1f50f46dc46e4c96aa">NormalHeader</a> = 0x0
, <a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8deca0500e1f1c1ee8f9e6c76c993aa48b0d4">PrivateHeader</a> = 0x1
, <a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8decad7e8857e09c5d0fbe70ad90e0e584200">TextualHeader</a> = 0x2
, <a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8deca29ca8d089c3fd646d54e611219d0d877">ExcludedHeader</a> = 0x4
 }</td></tr>
<tr class="memdesc:ac7a2413d4d0a8f29d2dad359bcfd8dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags describing the role of a module header.  <a href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">More...</a><br /></td></tr>
<tr class="separator:ac7a2413d4d0a8f29d2dad359bcfd8dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22c56a8f11f61caa8ab58809a21cca3" id="r_ac22c56a8f11f61caa8ab58809a21cca3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac22c56a8f11f61caa8ab58809a21cca3">AdditionalModMapsSet</a> = <a class="el" href="classllvm_1_1SmallPtrSet.html">llvm::SmallPtrSet</a>&lt;const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *, 1&gt;</td></tr>
<tr class="separator:ac22c56a8f11f61caa8ab58809a21cca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b352087754574155a198a4cb0d6e197" id="r_a1b352087754574155a198a4cb0d6e197"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b352087754574155a198a4cb0d6e197">module_iterator</a> = llvm::StringMap&lt;<a class="el" href="classclang_1_1Module.html">Module</a> *&gt;::const_iterator</td></tr>
<tr class="separator:a1b352087754574155a198a4cb0d6e197"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac588ee8d4c631303982ed1c68002f49d" id="r_ac588ee8d4c631303982ed1c68002f49d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac588ee8d4c631303982ed1c68002f49d">resolveLinkAsDependencies</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod)</td></tr>
<tr class="memdesc:ac588ee8d4c631303982ed1c68002f49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use PendingLinkAsModule information to mark top level link names that are going to be replaced by export_as aliases.  <br /></td></tr>
<tr class="separator:ac588ee8d4c631303982ed1c68002f49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06068cd4735154ef4218ab96f9462412" id="r_a06068cd4735154ef4218ab96f9462412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06068cd4735154ef4218ab96f9462412">addLinkAsDependency</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod)</td></tr>
<tr class="memdesc:a06068cd4735154ef4218ab96f9462412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make module to use export_as as the link dependency name if enough information is available or add it to a pending list otherwise.  <br /></td></tr>
<tr class="separator:a06068cd4735154ef4218ab96f9462412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767bb9d1787801348282cf9b588df471" id="r_a767bb9d1787801348282cf9b588df471"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a767bb9d1787801348282cf9b588df471">ModuleMap</a> (<a class="el" href="classclang_1_1SourceManager.html">SourceManager</a> &amp;SourceMgr, <a class="el" href="classclang_1_1DiagnosticsEngine.html">DiagnosticsEngine</a> &amp;Diags, const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;LangOpts, const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> *Target, <a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a> &amp;HeaderInfo)</td></tr>
<tr class="memdesc:a767bb9d1787801348282cf9b588df471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new module map.  <br /></td></tr>
<tr class="separator:a767bb9d1787801348282cf9b588df471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8769cd7eba3cb7f8f1cd2dde890603d" id="r_ab8769cd7eba3cb7f8f1cd2dde890603d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8769cd7eba3cb7f8f1cd2dde890603d">~ModuleMap</a> ()</td></tr>
<tr class="memdesc:ab8769cd7eba3cb7f8f1cd2dde890603d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the module map.  <br /></td></tr>
<tr class="separator:ab8769cd7eba3cb7f8f1cd2dde890603d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc441df169e00dbd5ab3a5db003d454f" id="r_abc441df169e00dbd5ab3a5db003d454f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc441df169e00dbd5ab3a5db003d454f">setTarget</a> (const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> &amp;Target)</td></tr>
<tr class="memdesc:abc441df169e00dbd5ab3a5db003d454f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target information.  <br /></td></tr>
<tr class="separator:abc441df169e00dbd5ab3a5db003d454f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af87b750c2e1f3b11a77b99a40a755f" id="r_a5af87b750c2e1f3b11a77b99a40a755f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5af87b750c2e1f3b11a77b99a40a755f">setBuiltinIncludeDir</a> (<a class="el" href="classclang_1_1DirectoryEntryRef.html">DirectoryEntryRef</a> Dir)</td></tr>
<tr class="memdesc:a5af87b750c2e1f3b11a77b99a40a755f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the directory that contains Clang-supplied include files, such as our <a class="el" href="stdarg_8h.html">stdarg.h</a> or <a class="el" href="tgmath_8h.html">tgmath.h</a>.  <br /></td></tr>
<tr class="separator:a5af87b750c2e1f3b11a77b99a40a755f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68be9dccb44faab58c2109371768c01e" id="r_a68be9dccb44faab58c2109371768c01e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68be9dccb44faab58c2109371768c01e">getBuiltinDir</a> () const</td></tr>
<tr class="memdesc:a68be9dccb44faab58c2109371768c01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the directory that contains Clang-supplied include files.  <br /></td></tr>
<tr class="separator:a68be9dccb44faab58c2109371768c01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8ca3bc91f0e93e6c706b80f263e521" id="r_a1e8ca3bc91f0e93e6c706b80f263e521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e8ca3bc91f0e93e6c706b80f263e521">isBuiltinHeader</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *<a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">File</a>)</td></tr>
<tr class="separator:a1e8ca3bc91f0e93e6c706b80f263e521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516ba163200648ee309a8b16ccc0d62a" id="r_a516ba163200648ee309a8b16ccc0d62a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a516ba163200648ee309a8b16ccc0d62a">addModuleMapCallbacks</a> (std::unique_ptr&lt; <a class="el" href="classclang_1_1ModuleMapCallbacks.html">ModuleMapCallbacks</a> &gt; Callback)</td></tr>
<tr class="memdesc:a516ba163200648ee309a8b16ccc0d62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a module map callback.  <br /></td></tr>
<tr class="separator:a516ba163200648ee309a8b16ccc0d62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c2312745196384b06b31469fa258bd" id="r_a45c2312745196384b06b31469fa258bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45c2312745196384b06b31469fa258bd">findModuleForHeader</a> (<a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">File</a>, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> AllowTextual=<a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> AllowExcluded=<a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:a45c2312745196384b06b31469fa258bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the module that owns the given header file, if any.  <br /></td></tr>
<tr class="separator:a45c2312745196384b06b31469fa258bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33e5e7b75c6545c48d6b4765d826e80" id="r_ae33e5e7b75c6545c48d6b4765d826e80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae33e5e7b75c6545c48d6b4765d826e80">findAllModulesForHeader</a> (<a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">File</a>)</td></tr>
<tr class="memdesc:ae33e5e7b75c6545c48d6b4765d826e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the modules that contain the given header file.  <br /></td></tr>
<tr class="separator:ae33e5e7b75c6545c48d6b4765d826e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7569af5b4b731de5a135caf8636681b3" id="r_a7569af5b4b731de5a135caf8636681b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7569af5b4b731de5a135caf8636681b3">findResolvedModulesForHeader</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *<a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">File</a>) const</td></tr>
<tr class="memdesc:a7569af5b4b731de5a135caf8636681b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="#ae33e5e7b75c6545c48d6b4765d826e80">findAllModulesForHeader</a>, but do not attempt to infer module ownership from umbrella headers if we've not already done so.  <br /></td></tr>
<tr class="separator:a7569af5b4b731de5a135caf8636681b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ce2c7a23bcff10e7ae4bfcda637182" id="r_a64ce2c7a23bcff10e7ae4bfcda637182"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64ce2c7a23bcff10e7ae4bfcda637182">resolveHeaderDirectives</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *<a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">File</a>) const</td></tr>
<tr class="memdesc:a64ce2c7a23bcff10e7ae4bfcda637182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all lazy header directives for the specified file.  <br /></td></tr>
<tr class="separator:a64ce2c7a23bcff10e7ae4bfcda637182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dcd87105f5059bc55a3f3db230e9bb" id="r_a41dcd87105f5059bc55a3f3db230e9bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41dcd87105f5059bc55a3f3db230e9bb">resolveHeaderDirectives</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, std::optional&lt; const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> * &gt; <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">File</a>) const</td></tr>
<tr class="memdesc:a41dcd87105f5059bc55a3f3db230e9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve lazy header directives for the specified module.  <br /></td></tr>
<tr class="separator:a41dcd87105f5059bc55a3f3db230e9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cfc8d05dbf3c2cceb132f4c789b8d1" id="r_a22cfc8d05dbf3c2cceb132f4c789b8d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22cfc8d05dbf3c2cceb132f4c789b8d1">diagnoseHeaderInclusion</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *RequestingModule, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> RequestingModuleIsModuleInterface, <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> FilenameLoc, StringRef <a class="el" href="Format_8cpp.html#ad1d2004964f78dae576fc66650252f7c">Filename</a>, <a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">File</a>)</td></tr>
<tr class="memdesc:a22cfc8d05dbf3c2cceb132f4c789b8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports errors if a module must not include a specific file.  <br /></td></tr>
<tr class="separator:a22cfc8d05dbf3c2cceb132f4c789b8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4894e6adb8982448b6724c996d0f5e4" id="r_aa4894e6adb8982448b6724c996d0f5e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4894e6adb8982448b6724c996d0f5e4">isHeaderInUnavailableModule</a> (<a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> Header) const</td></tr>
<tr class="memdesc:aa4894e6adb8982448b6724c996d0f5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the given header is part of a module marked 'unavailable'.  <br /></td></tr>
<tr class="separator:aa4894e6adb8982448b6724c996d0f5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648ba5f0cd274dd3acd6ee14aeae1cdc" id="r_a648ba5f0cd274dd3acd6ee14aeae1cdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a648ba5f0cd274dd3acd6ee14aeae1cdc">isHeaderUnavailableInModule</a> (<a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> Header, const <a class="el" href="classclang_1_1Module.html">Module</a> *RequestingModule) const</td></tr>
<tr class="memdesc:a648ba5f0cd274dd3acd6ee14aeae1cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the given header is unavailable as part of the specified module.  <br /></td></tr>
<tr class="separator:a648ba5f0cd274dd3acd6ee14aeae1cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bee9d02a3e7ced6bc9f7dd42ede743" id="r_a35bee9d02a3e7ced6bc9f7dd42ede743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35bee9d02a3e7ced6bc9f7dd42ede743">findModule</a> (StringRef Name) const</td></tr>
<tr class="memdesc:a35bee9d02a3e7ced6bc9f7dd42ede743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a module with the given name.  <br /></td></tr>
<tr class="separator:a35bee9d02a3e7ced6bc9f7dd42ede743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9682383d1483005eb8de8ab46275f5e5" id="r_a9682383d1483005eb8de8ab46275f5e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9682383d1483005eb8de8ab46275f5e5">lookupModuleUnqualified</a> (StringRef Name, <a class="el" href="classclang_1_1Module.html">Module</a> *Context) const</td></tr>
<tr class="memdesc:a9682383d1483005eb8de8ab46275f5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a module with the given name using lexical name lookup, starting at the given context.  <br /></td></tr>
<tr class="separator:a9682383d1483005eb8de8ab46275f5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bd056e3b16607ace724463606dd3d5" id="r_ac4bd056e3b16607ace724463606dd3d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4bd056e3b16607ace724463606dd3d5">lookupModuleQualified</a> (StringRef Name, <a class="el" href="classclang_1_1Module.html">Module</a> *Context) const</td></tr>
<tr class="memdesc:ac4bd056e3b16607ace724463606dd3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a module with the given name within the given context, using direct (qualified) name lookup.  <br /></td></tr>
<tr class="separator:ac4bd056e3b16607ace724463606dd3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115a5b7b114346aaa534995084fc3ac0" id="r_a115a5b7b114346aaa534995084fc3ac0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classclang_1_1Module.html">Module</a> *, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a115a5b7b114346aaa534995084fc3ac0">findOrCreateModule</a> (StringRef Name, <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsFramework, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsExplicit)</td></tr>
<tr class="memdesc:a115a5b7b114346aaa534995084fc3ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a new module or submodule, or create it if it does not already exist.  <br /></td></tr>
<tr class="separator:a115a5b7b114346aaa534995084fc3ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab984430b63c290eb25d0b696d486303c" id="r_ab984430b63c290eb25d0b696d486303c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab984430b63c290eb25d0b696d486303c">createGlobalModuleFragmentForModuleUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>=nullptr)</td></tr>
<tr class="memdesc:ab984430b63c290eb25d0b696d486303c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a global module fragment for a C++ module unit.  <br /></td></tr>
<tr class="separator:ab984430b63c290eb25d0b696d486303c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf18580f5e9d15f4563065ab035a6483" id="r_aaf18580f5e9d15f4563065ab035a6483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf18580f5e9d15f4563065ab035a6483">createImplicitGlobalModuleFragmentForModuleUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsExported, <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>=nullptr)</td></tr>
<tr class="separator:aaf18580f5e9d15f4563065ab035a6483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea4a5b3bc65f0ff822859970c2ecac0" id="r_acea4a5b3bc65f0ff822859970c2ecac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acea4a5b3bc65f0ff822859970c2ecac0">createPrivateModuleFragmentForInterfaceUnit</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>, <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc)</td></tr>
<tr class="memdesc:acea4a5b3bc65f0ff822859970c2ecac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a global module fragment for a C++ module interface unit.  <br /></td></tr>
<tr class="separator:acea4a5b3bc65f0ff822859970c2ecac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f1f85e8474bddc3b2c4d0938540457" id="r_af6f1f85e8474bddc3b2c4d0938540457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6f1f85e8474bddc3b2c4d0938540457">createModuleUnitWithKind</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, StringRef Name, <a class="el" href="classclang_1_1Module.html#acdab95b809e6c2a027d4ca2763c90b70">Module::ModuleKind</a> Kind)</td></tr>
<tr class="memdesc:af6f1f85e8474bddc3b2c4d0938540457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new C++ module with the specified kind, and reparent any pending global module fragment(s) to it.  <br /></td></tr>
<tr class="separator:af6f1f85e8474bddc3b2c4d0938540457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8dfb44af54446f37a943a9dd4b9c4f" id="r_aca8dfb44af54446f37a943a9dd4b9c4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca8dfb44af54446f37a943a9dd4b9c4f">createModuleForInterfaceUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, StringRef Name)</td></tr>
<tr class="memdesc:aca8dfb44af54446f37a943a9dd4b9c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new module for a C++ module interface unit.  <br /></td></tr>
<tr class="separator:aca8dfb44af54446f37a943a9dd4b9c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759d721452cbf7773605b71193c7a762" id="r_a759d721452cbf7773605b71193c7a762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a759d721452cbf7773605b71193c7a762">createModuleForImplementationUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, StringRef Name)</td></tr>
<tr class="memdesc:a759d721452cbf7773605b71193c7a762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new module for a C++ module implementation unit.  <br /></td></tr>
<tr class="separator:a759d721452cbf7773605b71193c7a762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488004c9aee8ccd0836e58ab114813ed" id="r_a488004c9aee8ccd0836e58ab114813ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a488004c9aee8ccd0836e58ab114813ed">createHeaderUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, StringRef Name, <a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a> H)</td></tr>
<tr class="memdesc:a488004c9aee8ccd0836e58ab114813ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a C++20 header unit.  <br /></td></tr>
<tr class="separator:a488004c9aee8ccd0836e58ab114813ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68b0b03f415bfbaedc292c33b881c41" id="r_af68b0b03f415bfbaedc292c33b881c41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af68b0b03f415bfbaedc292c33b881c41">inferFrameworkModule</a> (<a class="el" href="classclang_1_1DirectoryEntryRef.html">DirectoryEntryRef</a> FrameworkDir, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsSystem, <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>)</td></tr>
<tr class="memdesc:af68b0b03f415bfbaedc292c33b881c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the contents of a framework module map from the given framework directory.  <br /></td></tr>
<tr class="separator:af68b0b03f415bfbaedc292c33b881c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031a847ae6f15d895ef5808fd4af56aa" id="r_a031a847ae6f15d895ef5808fd4af56aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a031a847ae6f15d895ef5808fd4af56aa">createShadowedModule</a> (StringRef Name, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsFramework, <a class="el" href="classclang_1_1Module.html">Module</a> *ShadowingModule)</td></tr>
<tr class="memdesc:a031a847ae6f15d895ef5808fd4af56aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new top-level module that is shadowed by <code>ShadowingModule</code>.  <br /></td></tr>
<tr class="separator:a031a847ae6f15d895ef5808fd4af56aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390f6e47e08d60984fca9c6c492d42f7" id="r_a390f6e47e08d60984fca9c6c492d42f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a390f6e47e08d60984fca9c6c492d42f7">finishModuleDeclarationScope</a> ()</td></tr>
<tr class="memdesc:a390f6e47e08d60984fca9c6c492d42f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new declaration scope for module names, allowing previously defined modules to shadow definitions from the new scope.  <br /></td></tr>
<tr class="separator:a390f6e47e08d60984fca9c6c492d42f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df11cf9b74e240aa373f25c1a63b49f" id="r_a3df11cf9b74e240aa373f25c1a63b49f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3df11cf9b74e240aa373f25c1a63b49f">mayShadowNewModule</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *ExistingModule)</td></tr>
<tr class="separator:a3df11cf9b74e240aa373f25c1a63b49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b14289476fe5638600e7e1d78f41a0e" id="r_a3b14289476fe5638600e7e1d78f41a0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b14289476fe5638600e7e1d78f41a0e">canInferFrameworkModule</a> (const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *Dir) const</td></tr>
<tr class="memdesc:a3b14289476fe5638600e7e1d78f41a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a framework module can be inferred in the given directory.  <br /></td></tr>
<tr class="separator:a3b14289476fe5638600e7e1d78f41a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303d98d21ca4002f64a8efe0d0861897" id="r_a303d98d21ca4002f64a8efe0d0861897"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceclang.html#a0efb349752d772b8c3fb7ce4b27a229e">OptionalFileEntryRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a303d98d21ca4002f64a8efe0d0861897">getContainingModuleMapFile</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="classclang_1_1Module.html">Module</a>) const</td></tr>
<tr class="memdesc:a303d98d21ca4002f64a8efe0d0861897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the module map file containing the definition of the given module.  <br /></td></tr>
<tr class="separator:a303d98d21ca4002f64a8efe0d0861897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7079336099f427b383128cfa445dd4ea" id="r_a7079336099f427b383128cfa445dd4ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceclang.html#a0efb349752d772b8c3fb7ce4b27a229e">OptionalFileEntryRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7079336099f427b383128cfa445dd4ea">getModuleMapFileForUniquing</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *M) const</td></tr>
<tr class="memdesc:a7079336099f427b383128cfa445dd4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the module map file that (along with the module name) uniquely identifies this module.  <br /></td></tr>
<tr class="separator:a7079336099f427b383128cfa445dd4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cf116b47bb6201a8154feab288cc65" id="r_a64cf116b47bb6201a8154feab288cc65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64cf116b47bb6201a8154feab288cc65">setInferredModuleAllowedBy</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *M, const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *ModMap)</td></tr>
<tr class="separator:a64cf116b47bb6201a8154feab288cc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1261e559ef2565d078189e60f96b85" id="r_a7a1261e559ef2565d078189e60f96b85"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a1261e559ef2565d078189e60f96b85">canonicalizeModuleMapPath</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; char &gt; &amp;Path)</td></tr>
<tr class="memdesc:a7a1261e559ef2565d078189e60f96b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize <code>Path</code> in a manner suitable for a module map file.  <br /></td></tr>
<tr class="separator:a7a1261e559ef2565d078189e60f96b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f089144fb15ba586196345ad98b8d0c" id="r_a9f089144fb15ba586196345ad98b8d0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac22c56a8f11f61caa8ab58809a21cca3">AdditionalModMapsSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f089144fb15ba586196345ad98b8d0c">getAdditionalModuleMapFiles</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *M)</td></tr>
<tr class="memdesc:a9f089144fb15ba586196345ad98b8d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get any module map files other than getModuleMapFileForUniquing(M) that define submodules of a top-level module <code>M</code>.  <br /></td></tr>
<tr class="separator:a9f089144fb15ba586196345ad98b8d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748c66535339dbf5b860b72eff5cbadb" id="r_a748c66535339dbf5b860b72eff5cbadb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a748c66535339dbf5b860b72eff5cbadb">addAdditionalModuleMapFile</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *M, const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *<a class="el" href="classclang_1_1ModuleMap.html">ModuleMap</a>)</td></tr>
<tr class="separator:a748c66535339dbf5b860b72eff5cbadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d91ee91e3d302d32885c4d790b3915" id="r_a03d91ee91e3d302d32885c4d790b3915"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03d91ee91e3d302d32885c4d790b3915">resolveExports</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Complain)</td></tr>
<tr class="memdesc:a03d91ee91e3d302d32885c4d790b3915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all of the unresolved exports in the given module.  <br /></td></tr>
<tr class="separator:a03d91ee91e3d302d32885c4d790b3915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff262a15ac7933edd463953d969e4f6b" id="r_aff262a15ac7933edd463953d969e4f6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff262a15ac7933edd463953d969e4f6b">resolveUses</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Complain)</td></tr>
<tr class="memdesc:aff262a15ac7933edd463953d969e4f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all of the unresolved uses in the given module.  <br /></td></tr>
<tr class="separator:aff262a15ac7933edd463953d969e4f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635593eb7f27a7297eb22afacd08d104" id="r_a635593eb7f27a7297eb22afacd08d104"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a635593eb7f27a7297eb22afacd08d104">resolveConflicts</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Complain)</td></tr>
<tr class="memdesc:a635593eb7f27a7297eb22afacd08d104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all of the unresolved conflicts in the given module.  <br /></td></tr>
<tr class="separator:a635593eb7f27a7297eb22afacd08d104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4201bac04ec898145e7fd1b94cd9e9" id="r_a8d4201bac04ec898145e7fd1b94cd9e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d4201bac04ec898145e7fd1b94cd9e9">setUmbrellaHeaderAsWritten</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> UmbrellaHeader, const Twine &amp;NameAsWritten, const Twine &amp;PathRelativeToRootModuleDirectory)</td></tr>
<tr class="memdesc:a8d4201bac04ec898145e7fd1b94cd9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the umbrella header of the given module to the given header.  <br /></td></tr>
<tr class="separator:a8d4201bac04ec898145e7fd1b94cd9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202d290fccdf570de977224a277e24b9" id="r_a202d290fccdf570de977224a277e24b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a202d290fccdf570de977224a277e24b9">setUmbrellaDirAsWritten</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="classclang_1_1DirectoryEntryRef.html">DirectoryEntryRef</a> UmbrellaDir, const Twine &amp;NameAsWritten, const Twine &amp;PathRelativeToRootModuleDirectory)</td></tr>
<tr class="memdesc:a202d290fccdf570de977224a277e24b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the umbrella directory of the given module to the given directory.  <br /></td></tr>
<tr class="separator:a202d290fccdf570de977224a277e24b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb605a0f3e5ac2213bab92d201fc1ec1" id="r_acb605a0f3e5ac2213bab92d201fc1ec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb605a0f3e5ac2213bab92d201fc1ec1">addHeader</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a> Header, <a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a> <a class="el" href="FormatToken_8h.html#a0b435a0263eeabdc103dad5124bf391a">Role</a>, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Imported=<a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:acb605a0f3e5ac2213bab92d201fc1ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds this header to the given module.  <br /></td></tr>
<tr class="separator:acb605a0f3e5ac2213bab92d201fc1ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fef6a4583dbb427a8c66c8c45987d6" id="r_a42fef6a4583dbb427a8c66c8c45987d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42fef6a4583dbb427a8c66c8c45987d6">parseModuleMapFile</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *<a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">File</a>, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsSystem, <a class="el" href="classclang_1_1DirectoryEntryRef.html">DirectoryEntryRef</a> HomeDir, <a class="el" href="classclang_1_1FileID.html">FileID</a> ID=<a class="el" href="classclang_1_1FileID.html">FileID</a>(), <a class="el" href="classunsigned.html">unsigned</a> *<a class="el" href="Format_8cpp.html#a9fcf84dffafb0ea03c0f9b686ddbf2b3">Offset</a>=nullptr, <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> ExternModuleLoc=<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>())</td></tr>
<tr class="memdesc:a42fef6a4583dbb427a8c66c8c45987d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the given module map file, and record any modules we encounter.  <br /></td></tr>
<tr class="separator:a42fef6a4583dbb427a8c66c8c45987d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed1579ac35c5dcb1ab68449949a6912" id="r_a0ed1579ac35c5dcb1ab68449949a6912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ed1579ac35c5dcb1ab68449949a6912">dump</a> ()</td></tr>
<tr class="memdesc:a0ed1579ac35c5dcb1ab68449949a6912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the contents of the module map, for debugging purposes.  <br /></td></tr>
<tr class="separator:a0ed1579ac35c5dcb1ab68449949a6912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab65f1f0882fcff9a15da9cfbf0fd02" id="r_a6ab65f1f0882fcff9a15da9cfbf0fd02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a1b352087754574155a198a4cb0d6e197">module_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ab65f1f0882fcff9a15da9cfbf0fd02">module_begin</a> () const</td></tr>
<tr class="separator:a6ab65f1f0882fcff9a15da9cfbf0fd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9e3147d81ec86cf00eea874d9ea95b" id="r_a9d9e3147d81ec86cf00eea874d9ea95b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a1b352087754574155a198a4cb0d6e197">module_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d9e3147d81ec86cf00eea874d9ea95b">module_end</a> () const</td></tr>
<tr class="separator:a9d9e3147d81ec86cf00eea874d9ea95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc466d3e7e6077fea6c69d48759ec723" id="r_afc466d3e7e6077fea6c69d48759ec723"><td class="memItemLeft" align="right" valign="top">llvm::iterator_range&lt; <a class="el" href="#a1b352087754574155a198a4cb0d6e197">module_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc466d3e7e6077fea6c69d48759ec723">modules</a> () const</td></tr>
<tr class="separator:afc466d3e7e6077fea6c69d48759ec723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61bce84c6ecb21f1f05539c84b855ad" id="r_ac61bce84c6ecb21f1f05539c84b855ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac61bce84c6ecb21f1f05539c84b855ad">cacheModuleLoad</a> (const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;II, <a class="el" href="classclang_1_1Module.html">Module</a> *M)</td></tr>
<tr class="memdesc:ac61bce84c6ecb21f1f05539c84b855ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache a module load. M might be nullptr.  <br /></td></tr>
<tr class="separator:ac61bce84c6ecb21f1f05539c84b855ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7838b0a7136fe054ff162989f4e5a473" id="r_a7838b0a7136fe054ff162989f4e5a473"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classclang_1_1Module.html">Module</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7838b0a7136fe054ff162989f4e5a473">getCachedModuleLoad</a> (const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;II)</td></tr>
<tr class="memdesc:a7838b0a7136fe054ff162989f4e5a473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a cached module load.  <br /></td></tr>
<tr class="separator:a7838b0a7136fe054ff162989f4e5a473"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af95957116dd995616c90e64c864811cd" id="r_af95957116dd995616c90e64c864811cd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af95957116dd995616c90e64c864811cd">headerKindToRole</a> (<a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a> Kind)</td></tr>
<tr class="memdesc:af95957116dd995616c90e64c864811cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a header kind to a role. Requires Kind to not be HK_Excluded.  <br /></td></tr>
<tr class="separator:af95957116dd995616c90e64c864811cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c51efd0ee64aaadd73218544eeeb01" id="r_a32c51efd0ee64aaadd73218544eeeb01"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32c51efd0ee64aaadd73218544eeeb01">headerRoleToKind</a> (<a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a> <a class="el" href="FormatToken_8h.html#a0b435a0263eeabdc103dad5124bf391a">Role</a>)</td></tr>
<tr class="memdesc:a32c51efd0ee64aaadd73218544eeeb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a header role to a kind.  <br /></td></tr>
<tr class="separator:a32c51efd0ee64aaadd73218544eeeb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddbcfb5014e3bd0bcf33a30b41cc511" id="r_a5ddbcfb5014e3bd0bcf33a30b41cc511"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ddbcfb5014e3bd0bcf33a30b41cc511">isModular</a> (<a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a> <a class="el" href="FormatToken_8h.html#a0b435a0263eeabdc103dad5124bf391a">Role</a>)</td></tr>
<tr class="memdesc:a5ddbcfb5014e3bd0bcf33a30b41cc511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the header with the given role is a modular one.  <br /></td></tr>
<tr class="separator:a5ddbcfb5014e3bd0bcf33a30b41cc511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c825f7506d1abd0d9bc54eba6330e6" id="r_a40c825f7506d1abd0d9bc54eba6330e6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40c825f7506d1abd0d9bc54eba6330e6">isBuiltinHeader</a> (StringRef FileName)</td></tr>
<tr class="memdesc:a40c825f7506d1abd0d9bc54eba6330e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this a compiler builtin header?  <br /></td></tr>
<tr class="separator:a40c825f7506d1abd0d9bc54eba6330e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a69fccb440615f32e24516ed4e718457d" id="r_a69fccb440615f32e24516ed4e718457d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69fccb440615f32e24516ed4e718457d">ModuleMapParser</a></td></tr>
<tr class="separator:a69fccb440615f32e24516ed4e718457d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00074">74</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac22c56a8f11f61caa8ab58809a21cca3" name="ac22c56a8f11f61caa8ab58809a21cca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22c56a8f11f61caa8ab58809a21cca3">&#9670;&#160;</a></span>AdditionalModMapsSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac22c56a8f11f61caa8ab58809a21cca3">clang::ModuleMap::AdditionalModMapsSet</a> = <a class="el" href="classllvm_1_1SmallPtrSet.html">llvm::SmallPtrSet</a>&lt;const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00197">197</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<a id="a1b352087754574155a198a4cb0d6e197" name="a1b352087754574155a198a4cb0d6e197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b352087754574155a198a4cb0d6e197">&#9670;&#160;</a></span>module_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1b352087754574155a198a4cb0d6e197">clang::ModuleMap::module_iterator</a> = llvm::StringMap&lt;<a class="el" href="classclang_1_1Module.html">Module</a> *&gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00732">732</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac7a2413d4d0a8f29d2dad359bcfd8dec" name="ac7a2413d4d0a8f29d2dad359bcfd8dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">&#9670;&#160;</a></span>ModuleHeaderRole</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">clang::ModuleMap::ModuleHeaderRole</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags describing the role of a module header. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac7a2413d4d0a8f29d2dad359bcfd8deca50b6dee47a2d5b1f50f46dc46e4c96aa" name="ac7a2413d4d0a8f29d2dad359bcfd8deca50b6dee47a2d5b1f50f46dc46e4c96aa"></a>NormalHeader&#160;</td><td class="fielddoc"><p>This header is normally included in the module. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a2413d4d0a8f29d2dad359bcfd8deca0500e1f1c1ee8f9e6c76c993aa48b0d4" name="ac7a2413d4d0a8f29d2dad359bcfd8deca0500e1f1c1ee8f9e6c76c993aa48b0d4"></a>PrivateHeader&#160;</td><td class="fielddoc"><p>This header is included but private. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a2413d4d0a8f29d2dad359bcfd8decad7e8857e09c5d0fbe70ad90e0e584200" name="ac7a2413d4d0a8f29d2dad359bcfd8decad7e8857e09c5d0fbe70ad90e0e584200"></a>TextualHeader&#160;</td><td class="fielddoc"><p>This header is part of the module (for layering purposes) but should be textually included. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a2413d4d0a8f29d2dad359bcfd8deca29ca8d089c3fd646d54e611219d0d877" name="ac7a2413d4d0a8f29d2dad359bcfd8deca29ca8d089c3fd646d54e611219d0d877"></a>ExcludedHeader&#160;</td><td class="fielddoc"><p>This header is explicitly excluded from the module. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00127">127</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a767bb9d1787801348282cf9b588df471" name="a767bb9d1787801348282cf9b588df471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767bb9d1787801348282cf9b588df471">&#9670;&#160;</a></span>ModuleMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ModuleMap::ModuleMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceManager.html">SourceManager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SourceMgr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1DiagnosticsEngine.html">DiagnosticsEngine</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Diags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>LangOpts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>Target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>HeaderInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new module map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SourceMgr</td><td>The source manager used to find module files and headers. This source manager should be shared with the header-search mechanism, since they will refer to the same headers.</td></tr>
    <tr><td class="paramname">Diags</td><td>A diagnostic engine used for diagnostics.</td></tr>
    <tr><td class="paramname">LangOpts</td><td>Language options for this translation unit.</td></tr>
    <tr><td class="paramname">Target</td><td>The target for this translation unit. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00318">318</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="ab8769cd7eba3cb7f8f1cd2dde890603d" name="ab8769cd7eba3cb7f8f1cd2dde890603d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8769cd7eba3cb7f8f1cd2dde890603d">&#9670;&#160;</a></span>~ModuleMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ModuleMap::~ModuleMap </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the module map. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00326">326</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a748c66535339dbf5b860b72eff5cbadb" name="a748c66535339dbf5b860b72eff5cbadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748c66535339dbf5b860b72eff5cbadb">&#9670;&#160;</a></span>addAdditionalModuleMapFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::addAdditionalModuleMapFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>ModuleMap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01342">1342</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="acb605a0f3e5ac2213bab92d201fc1ec1" name="acb605a0f3e5ac2213bab92d201fc1ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb605a0f3e5ac2213bab92d201fc1ec1">&#9670;&#160;</a></span>addHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::addHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a></td>          <td class="paramname"><span class="paramname"><em>Header</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a></td>          <td class="paramname"><span class="paramname"><em>Role</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>Imported</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds this header to the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Role</td><td>The role of the header wrt the module. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01257">1257</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00244">clang::Module::Header::Entry</a>, <a class="el" href="FileEntry_8h_source.html#l00061">clang::FileEntryRef::getName()</a>, <a class="el" href="Module_8h_source.html#l00624">clang::Module::getTopLevelModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00076">headerRoleToKind()</a>, <a class="el" href="Module_8h_source.html#l00256">clang::Module::Headers</a>, <a class="el" href="LangOptions_8h_source.html#l00518">clang::LangOptions::isCompilingModule()</a>, <a class="el" href="HeaderSearch_8cpp_source.html#l01389">clang::HeaderSearch::MarkFileModuleHeader()</a>, and <a class="el" href="FormatToken_8h_source.html#l00785">Role</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00941">createHeaderUnit()</a>, and <a class="el" href="ASTReader_8cpp_source.html#l01936">clang::serialization::reader::HeaderFileInfoTrait::ReadData()</a>.</p>

</div>
</div>
<a id="a06068cd4735154ef4218ab96f9462412" name="a06068cd4735154ef4218ab96f9462412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06068cd4735154ef4218ab96f9462412">&#9670;&#160;</a></span>addLinkAsDependency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::addLinkAsDependency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make module to use export_as as the link dependency name if enough information is available or add it to a pending list otherwise. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00069">69</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00172">clang::Module::ExportAsModule</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00801">findModule()</a>, <a class="el" href="Module_8h_source.html#l00101">clang::Module::Name</a>, and <a class="el" href="Module_8h_source.html#l00438">clang::Module::UseExportAsModuleLinkName</a>.</p>

</div>
</div>
<a id="a516ba163200648ee309a8b16ccc0d62a" name="a516ba163200648ee309a8b16ccc0d62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516ba163200648ee309a8b16ccc0d62a">&#9670;&#160;</a></span>addModuleMapCallbacks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::addModuleMapCallbacks </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classclang_1_1ModuleMapCallbacks.html">ModuleMapCallbacks</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Callback</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a module map callback. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00422">422</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="DependencyFile_8cpp_source.html#l00183">clang::DependencyCollector::attachToPreprocessor()</a>, and <a class="el" href="ModuleDependencyCollector_8cpp_source.html#l00087">clang::ModuleDependencyCollector::attachToPreprocessor()</a>.</p>

</div>
</div>
<a id="ac61bce84c6ecb21f1f05539c84b855ad" name="ac61bce84c6ecb21f1f05539c84b855ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61bce84c6ecb21f1f05539c84b855ad">&#9670;&#160;</a></span>cacheModuleLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::cacheModuleLoad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>II</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>M</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache a module load. M might be nullptr. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00741">741</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l01966">clang::CompilerInstance::loadModule()</a>.</p>

</div>
</div>
<a id="a3b14289476fe5638600e7e1d78f41a0e" name="a3b14289476fe5638600e7e1d78f41a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b14289476fe5638600e7e1d78f41a0e">&#9670;&#160;</a></span>canInferFrameworkModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::ModuleMap::canInferFrameworkModule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>Dir</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a framework module can be inferred in the given directory. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00609">609</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrontendAction_8cpp_source.html#l00441">loadModuleMapForModuleBuild()</a>.</p>

</div>
</div>
<a id="a7a1261e559ef2565d078189e60f96b85" name="a7a1261e559ef2565d078189e60f96b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1261e559ef2565d078189e60f96b85">&#9670;&#160;</a></span>canonicalizeModuleMapPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code ModuleMap::canonicalizeModuleMapPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalize <code>Path</code> in a manner suitable for a module map file. </p>
<p>In particular, this canonicalizes the parent directory separately from the filename so that it does not affect header resolution relative to the modulemap.</p>
<dl class="section return"><dt>Returns</dt><dd>an error code if any filesystem operations failed. In this case <code>Path</code> is not modified. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01310">1310</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="FileManager_8cpp_source.html#l00634">clang::FileManager::getCanonicalName()</a>, <a class="el" href="FileManager_8cpp_source.html#l00119">clang::FileManager::getDirectoryRef()</a>, and <a class="el" href="ASTDiff_8cpp_source.html#l00191">Parent</a>.</p>

</div>
</div>
<a id="ab984430b63c290eb25d0b696d486303c" name="ab984430b63c290eb25d0b696d486303c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab984430b63c290eb25d0b696d486303c">&#9670;&#160;</a></span>createGlobalModuleFragmentForModuleUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createGlobalModuleFragmentForModuleUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>Loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Parent</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a global module fragment for a C++ module unit. </p>
<p>We model the global module fragment as a submodule of the module interface unit. Unfortunately, we can't create the module interface unit's <a class="el" href="classclang_1_1Module.html" title="Describes a module or submodule.">Module</a> until later, because we don't know what it will be called usually. See C++20 [module.unit]/7.2 for the case we could know its parent. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00846">846</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00131">clang::Module::ExplicitGlobalModuleFragment</a>, <a class="el" href="namespaceclang.html#ad145f7432ac192abba688627ec3d64dcae55f75a29310d7b60f7ac1d390c8ae42">clang::Module</a>, <a class="el" href="ASTDiff_8cpp_source.html#l00191">Parent</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="a488004c9aee8ccd0836e58ab114813ed" name="a488004c9aee8ccd0836e58ab114813ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488004c9aee8ccd0836e58ab114813ed">&#9670;&#160;</a></span>createHeaderUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createHeaderUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>Loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a></td>          <td class="paramname"><span class="paramname"><em>H</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a C++20 header unit. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00941">941</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l01257">addHeader()</a>, <a class="el" href="LangOptions_8h_source.html#l00437">clang::LangOptions::CurrentModule</a>, <a class="el" href="namespaceclang.html#ad145f7432ac192abba688627ec3d64dcae55f75a29310d7b60f7ac1d390c8ae42">clang::Module</a>, <a class="el" href="Module_8h_source.html#l00115">clang::Module::ModuleHeaderUnit</a>, <a class="el" href="ModuleMap_8h_source.html#l00129">NormalHeader</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="aaf18580f5e9d15f4563065ab035a6483" name="aaf18580f5e9d15f4563065ab035a6483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf18580f5e9d15f4563065ab035a6483">&#9670;&#160;</a></span>createImplicitGlobalModuleFragmentForModuleUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createImplicitGlobalModuleFragmentForModuleUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>Loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsExported</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Parent</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00858">858</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00139">clang::Module::ImplicitGlobalModuleFragment</a>, <a class="el" href="namespaceclang.html#ad145f7432ac192abba688627ec3d64dcae55f75a29310d7b60f7ac1d390c8ae42">clang::Module</a>, <a class="el" href="ASTDiff_8cpp_source.html#l00191">Parent</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="a759d721452cbf7773605b71193c7a762" name="a759d721452cbf7773605b71193c7a762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759d721452cbf7773605b71193c7a762">&#9670;&#160;</a></span>createModuleForImplementationUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createModuleForImplementationUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>Loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new module for a C++ module implementation unit. </p>
<p>The interface module for this implementation (implicitly imported) must exist and be loaded and present in the modules map.</p>
<dl class="section return"><dt>Returns</dt><dd>The newly-created module. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00917">917</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l00883">createModuleUnitWithKind()</a>, <a class="el" href="LangOptions_8h_source.html#l00437">clang::LangOptions::CurrentModule</a>, <a class="el" href="Module_8h_source.html#l00121">clang::Module::ModuleImplementationUnit</a>, <a class="el" href="Module_8h_source.html#l00118">clang::Module::ModuleInterfaceUnit</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="aca8dfb44af54446f37a943a9dd4b9c4f" name="aca8dfb44af54446f37a943a9dd4b9c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8dfb44af54446f37a943a9dd4b9c4f">&#9670;&#160;</a></span>createModuleForInterfaceUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createModuleForInterfaceUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>Loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new module for a C++ module interface unit. </p>
<p>The module must not already exist, and will be configured for the current compilation.</p>
<p>Note that this also sets the current module to the newly-created module.</p>
<dl class="section return"><dt>Returns</dt><dd>The newly-created module. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00899">899</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l00883">createModuleUnitWithKind()</a>, <a class="el" href="LangOptions_8h_source.html#l00437">clang::LangOptions::CurrentModule</a>, <a class="el" href="Module_8h_source.html#l00118">clang::Module::ModuleInterfaceUnit</a>, <a class="el" href="ModuleMap_8h_source.html#l00132">PrivateHeader</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="af6f1f85e8474bddc3b2c4d0938540457" name="af6f1f85e8474bddc3b2c4d0938540457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f1f85e8474bddc3b2c4d0938540457">&#9670;&#160;</a></span>createModuleUnitWithKind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createModuleUnitWithKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>Loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html#acdab95b809e6c2a027d4ca2763c90b70">Module::ModuleKind</a></td>          <td class="paramname"><span class="paramname"><em>Kind</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new C++ module with the specified kind, and reparent any pending global module fragment(s) to it. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00883">883</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#ad145f7432ac192abba688627ec3d64dcae55f75a29310d7b60f7ac1d390c8ae42">clang::Module</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00917">createModuleForImplementationUnit()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00899">createModuleForInterfaceUnit()</a>.</p>

</div>
</div>
<a id="acea4a5b3bc65f0ff822859970c2ecac0" name="acea4a5b3bc65f0ff822859970c2ecac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea4a5b3bc65f0ff822859970c2ecac0">&#9670;&#160;</a></span>createPrivateModuleFragmentForInterfaceUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createPrivateModuleFragmentForInterfaceUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>Loc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a global module fragment for a C++ module interface unit. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00874">874</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#ad145f7432ac192abba688627ec3d64dcae55f75a29310d7b60f7ac1d390c8ae42">clang::Module</a>, <a class="el" href="ASTDiff_8cpp_source.html#l00191">Parent</a>, <a class="el" href="Module_8h_source.html#l00134">clang::Module::PrivateModuleFragment</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="a031a847ae6f15d895ef5808fd4af56aa" name="a031a847ae6f15d895ef5808fd4af56aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031a847ae6f15d895ef5808fd4af56aa">&#9670;&#160;</a></span>createShadowedModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createShadowedModule </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsFramework</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>ShadowingModule</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new top-level module that is shadowed by <code>ShadowingModule</code>. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01146">1146</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8cpp_source.html#l00323">clang::Module::markUnavailable()</a>, <a class="el" href="namespaceclang.html#ad145f7432ac192abba688627ec3d64dcae55f75a29310d7b60f7ac1d390c8ae42">clang::Module</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="a22cfc8d05dbf3c2cceb132f4c789b8d1" name="a22cfc8d05dbf3c2cceb132f4c789b8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cfc8d05dbf3c2cceb132f4c789b8d1">&#9670;&#160;</a></span>diagnoseHeaderInclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::diagnoseHeaderInclusion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>RequestingModule</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>RequestingModuleIsModuleInterface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>FilenameLoc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a></td>          <td class="paramname"><span class="paramname"><em>File</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports errors if a module must not include a specific file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RequestingModule</td><td>The module including a file.</td></tr>
    <tr><td class="paramname">RequestingModuleIsModuleInterface</td><td><code>true</code> if the inclusion is in the interface of RequestingModule, <code>false</code> if it's in the implementation of RequestingModule. <a class="el" href="classclang_1_1Value.html">Value</a> is ignored and meaningless if RequestingModule is nullptr.</td></tr>
    <tr><td class="paramname">FilenameLoc</td><td>The location of the inclusion's filename.</td></tr>
    <tr><td class="paramname">Filename</td><td>The included filename as written.</td></tr>
    <tr><td class="paramname">File</td><td>The included file. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00470">470</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8cpp_source.html#l00290">clang::Module::directlyUses()</a>, <a class="el" href="ModuleMap_8h_source.html#l00139">ExcludedHeader</a>, <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="Format_8cpp_source.html#l02922">Filename</a>, <a class="el" href="Module_8cpp_source.html#l00241">clang::Module::getFullModuleName()</a>, <a class="el" href="ModuleMap_8h_source.html#l00174">clang::ModuleMap::KnownHeader::getModule()</a>, <a class="el" href="ModuleMap_8h_source.html#l00177">clang::ModuleMap::KnownHeader::getRole()</a>, <a class="el" href="Module_8h_source.html#l00624">clang::Module::getTopLevelModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00466">getTopLevelOrNull()</a>, <a class="el" href="LangOptions_8h_source.html#l00518">clang::LangOptions::isCompilingModule()</a>, <a class="el" href="Module_8h_source.html#l00309">clang::Module::IsFramework</a>, <a class="el" href="Module_8h_source.html#l00101">clang::Module::Name</a>, <a class="el" href="Basic_2Diagnostic_8h_source.html#l01542">clang::DiagnosticsEngine::Report()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l01222">resolveHeaderDirectives()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l01382">resolveUses()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00445">violatesPrivateInclude()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PPDirectives_8cpp_source.html#l00946">clang::Preprocessor::LookupFile()</a>.</p>

</div>
</div>
<a id="a0ed1579ac35c5dcb1ab68449949a6912" name="a0ed1579ac35c5dcb1ab68449949a6912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed1579ac35c5dcb1ab68449949a6912">&#9670;&#160;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_DUMP_METHOD void ModuleMap::dump </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the contents of the module map, for debugging purposes. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01347">1347</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8cpp_source.html#l00452">clang::Module::print()</a>.</p>

</div>
</div>
<a id="ae33e5e7b75c6545c48d6b4765d826e80" name="ae33e5e7b75c6545c48d6b4765d826e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33e5e7b75c6545c48d6b4765d826e80">&#9670;&#160;</a></span>findAllModulesForHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">ModuleMap::KnownHeader</a> &gt; ModuleMap::findAllModulesForHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a></td>          <td class="paramname"><span class="paramname"><em>File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve all the modules that contain the given header file. </p>
<p>Note that this does not implicitly load module maps, except for builtin headers, and does not consult the external source. (Those checks are the responsibility of <a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a>.)</p>
<p>Typically, <a class="el" href="#a45c2312745196384b06b31469fa258bd">findModuleForHeader</a> should be used instead, as it picks the preferred module for the header. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00682">682</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l01574">clang::HeaderSearch::findAllModulesForHeader()</a>.</p>

</div>
</div>
<a id="a35bee9d02a3e7ced6bc9f7dd42ede743" name="a35bee9d02a3e7ced6bc9f7dd42ede743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bee9d02a3e7ced6bc9f7dd42ede743">&#9670;&#160;</a></span>findModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::findModule </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a module with the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The named module, if known; otherwise, returns null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00801">801</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00069">addLinkAsDependency()</a>, <a class="el" href="ModuleManager_8cpp_source.html#l00053">clang::serialization::ModuleManager::lookupByModuleName()</a>, <a class="el" href="HeaderSearch_8cpp_source.html#l00272">clang::HeaderSearch::lookupModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00819">lookupModuleQualified()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00809">lookupModuleUnqualified()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00058">resolveLinkAsDependencies()</a>.</p>

</div>
</div>
<a id="a45c2312745196384b06b31469fa258bd" name="a45c2312745196384b06b31469fa258bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c2312745196384b06b31469fa258bd">&#9670;&#160;</a></span>findModuleForHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">ModuleMap::KnownHeader</a> ModuleMap::findModuleForHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a></td>          <td class="paramname"><span class="paramname"><em>File</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>AllowTextual</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>AllowExcluded</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the module that owns the given header file, if any. </p>
<p>Note that this does not implicitly load module maps, except for builtin headers, and does not consult the external source. (Those checks are the responsibility of <a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a>.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">File</td><td>The header file that is likely to be included.</td></tr>
    <tr><td class="paramname">AllowTextual</td><td>If <code>true</code> and <code>File</code> is a textual header, return its owning module. Otherwise, no <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html" title="A header that is known to reside within a given module, whether it was included or excluded.">KnownHeader</a> will be returned if the file is only known as a textual header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The module <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html" title="A header that is known to reside within a given module, whether it was included or excluded.">KnownHeader</a>, which provides the module that owns the given header file. The <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html" title="A header that is known to reside within a given module, whether it was included or excluded.">KnownHeader</a> is default constructed to indicate that no module owns this header file. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00580">580</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00139">ExcludedHeader</a>, <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="ModuleMap_8h_source.html#l00174">clang::ModuleMap::KnownHeader::getModule()</a>, <a class="el" href="ModuleMap_8h_source.html#l00177">clang::ModuleMap::KnownHeader::getRole()</a>, <a class="el" href="Module_8h_source.html#l00624">clang::Module::getTopLevelModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00552">isBetterKnownHeader()</a>, <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>, and <a class="el" href="ModuleMap_8h_source.html#l00136">TextualHeader</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l01563">clang::HeaderSearch::findModuleForHeader()</a>, and <a class="el" href="PPDirectives_8cpp_source.html#l00854">clang::Preprocessor::getModuleForLocation()</a>.</p>

</div>
</div>
<a id="a115a5b7b114346aaa534995084fc3ac0" name="a115a5b7b114346aaa534995084fc3ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115a5b7b114346aaa534995084fc3ac0">&#9670;&#160;</a></span>findOrCreateModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classclang_1_1Module.html">Module</a> *, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt; ModuleMap::findOrCreateModule </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsFramework</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsExplicit</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a new module or submodule, or create it if it does not already exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to find or create.</td></tr>
    <tr><td class="paramname">Parent</td><td>The module that will act as the parent of this submodule, or nullptr to indicate that this is a top-level module.</td></tr>
    <tr><td class="paramname">IsFramework</td><td>Whether this is a framework module.</td></tr>
    <tr><td class="paramname">IsExplicit</td><td>Whether this is an explicit submodule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The found or newly-created module, along with a boolean value that will be true if the module is newly-created. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00826">826</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="LangOptions_8h_source.html#l00437">clang::LangOptions::CurrentModule</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00819">lookupModuleQualified()</a>, <a class="el" href="namespaceclang.html#ad145f7432ac192abba688627ec3d64dcae55f75a29310d7b60f7ac1d390c8ae42">clang::Module</a>, <a class="el" href="ASTDiff_8cpp_source.html#l00191">Parent</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="a7569af5b4b731de5a135caf8636681b3" name="a7569af5b4b731de5a135caf8636681b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7569af5b4b731de5a135caf8636681b3">&#9670;&#160;</a></span>findResolvedModulesForHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">ModuleMap::KnownHeader</a> &gt; ModuleMap::findResolvedModulesForHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>File</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="#ae33e5e7b75c6545c48d6b4765d826e80">findAllModulesForHeader</a>, but do not attempt to infer module ownership from umbrella headers if we've not already done so. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00694">694</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l01222">resolveHeaderDirectives()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l01584">clang::HeaderSearch::findResolvedModulesForHeader()</a>.</p>

</div>
</div>
<a id="a390f6e47e08d60984fca9c6c492d42f7" name="a390f6e47e08d60984fca9c6c492d42f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390f6e47e08d60984fca9c6c492d42f7">&#9670;&#160;</a></span>finishModuleDeclarationScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::finishModuleDeclarationScope </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new declaration scope for module names, allowing previously defined modules to shadow definitions from the new scope. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classclang_1_1Module.html" title="Describes a module or submodule.">Module</a> names from earlier scopes will shadow names from the new scope, which is the opposite of how shadowing works for variables. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00600">600</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrontendAction_8cpp_source.html#l00575">clang::FrontendAction::BeginSourceFile()</a>.</p>

</div>
</div>
<a id="a9f089144fb15ba586196345ad98b8d0c" name="a9f089144fb15ba586196345ad98b8d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f089144fb15ba586196345ad98b8d0c">&#9670;&#160;</a></span>getAdditionalModuleMapFiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac22c56a8f11f61caa8ab58809a21cca3">AdditionalModMapsSet</a> * clang::ModuleMap::getAdditionalModuleMapFiles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>M</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get any module map files other than getModuleMapFileForUniquing(M) that define submodules of a top-level module <code>M</code>. </p>
<p>This is cheaper than getting the module map file for each submodule individually, since the expected number of results is very small. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00649">649</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<a id="a68be9dccb44faab58c2109371768c01e" name="a68be9dccb44faab58c2109371768c01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68be9dccb44faab58c2109371768c01e">&#9670;&#160;</a></span>getBuiltinDir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> * clang::ModuleMap::getBuiltinDir </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the directory that contains Clang-supplied include files. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00413">413</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<a id="a7838b0a7136fe054ff162989f4e5a473" name="a7838b0a7136fe054ff162989f4e5a473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7838b0a7136fe054ff162989f4e5a473">&#9670;&#160;</a></span>getCachedModuleLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classclang_1_1Module.html">Module</a> * &gt; clang::ModuleMap::getCachedModuleLoad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>II</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a cached module load. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00746">746</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l01966">clang::CompilerInstance::loadModule()</a>.</p>

</div>
</div>
<a id="a303d98d21ca4002f64a8efe0d0861897" name="a303d98d21ca4002f64a8efe0d0861897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303d98d21ca4002f64a8efe0d0861897">&#9670;&#160;</a></span>getContainingModuleMapFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceclang.html#a0efb349752d772b8c3fb7ce4b27a229e">OptionalFileEntryRef</a> ModuleMap::getContainingModuleMapFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Module</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the module map file containing the definition of the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classclang_1_1Module.html" title="Describes a module or submodule.">Module</a></td><td>The module whose module map file will be returned, if known.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The file entry for the module map file containing the given module, or nullptr if the module definition was inferred. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01286">1286</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00104">clang::Module::DefinitionLoc</a>, and <a class="el" href="SourceLocation_8h_source.html#l00111">clang::SourceLocation::isInvalid()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l01310">compileModule()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l01295">getModuleMapFileForUniquing()</a>.</p>

</div>
</div>
<a id="a7079336099f427b383128cfa445dd4ea" name="a7079336099f427b383128cfa445dd4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7079336099f427b383128cfa445dd4ea">&#9670;&#160;</a></span>getModuleMapFileForUniquing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceclang.html#a0efb349752d772b8c3fb7ce4b27a229e">OptionalFileEntryRef</a> ModuleMap::getModuleMapFileForUniquing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>M</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the module map file that (along with the module name) uniquely identifies this module. </p>
<p>The particular module that <code>Name</code> refers to may depend on how the module was found in header search. However, the combination of <code>Name</code> and this module map will be globally unique for top-level modules. In the case of inferred modules, returns the module map that allowed the inference (e.g. contained 'module *'). Otherwise, returns <a class="el" href="#a303d98d21ca4002f64a8efe0d0861897" title="Retrieve the module map file containing the definition of the given module.">getContainingModuleMapFile()</a>. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01295">1295</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l01286">getContainingModuleMapFile()</a>, and <a class="el" href="Module_8h_source.html#l00324">clang::Module::IsInferred</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleDepCollector_8cpp_source.html#l00230">clang::tooling::dependencies::ModuleDepCollector::applyDiscoveredDependencies()</a>, <a class="el" href="CompilerInstance_8cpp_source.html#l01310">compileModule()</a>, <a class="el" href="HeaderSearch_8cpp_source.html#l00173">clang::HeaderSearch::getCachedModuleFileName()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l00214">clang::HeaderSearch::getPrebuiltImplicitModuleFileName()</a>.</p>

</div>
</div>
<a id="af95957116dd995616c90e64c864811cd" name="af95957116dd995616c90e64c864811cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95957116dd995616c90e64c864811cd">&#9670;&#160;</a></span>headerKindToRole()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleMap::ModuleHeaderRole</a> ModuleMap::headerKindToRole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a></td>          <td class="paramname"><span class="paramname"><em>Kind</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a header kind to a role. Requires Kind to not be HK_Excluded. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00093">93</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00139">ExcludedHeader</a>, <a class="el" href="Module_8h_source.html#l00235">clang::Module::HK_Excluded</a>, <a class="el" href="Module_8h_source.html#l00231">clang::Module::HK_Normal</a>, <a class="el" href="Module_8h_source.html#l00233">clang::Module::HK_Private</a>, <a class="el" href="Module_8h_source.html#l00234">clang::Module::HK_PrivateTextual</a>, <a class="el" href="Module_8h_source.html#l00232">clang::Module::HK_Textual</a>, <a class="el" href="ModuleMap_8h_source.html#l00129">NormalHeader</a>, <a class="el" href="ModuleMap_8h_source.html#l00132">PrivateHeader</a>, and <a class="el" href="ModuleMap_8h_source.html#l00136">TextualHeader</a>.</p>

</div>
</div>
<a id="a32c51efd0ee64aaadd73218544eeeb01" name="a32c51efd0ee64aaadd73218544eeeb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c51efd0ee64aaadd73218544eeeb01">&#9670;&#160;</a></span>headerRoleToKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a> ModuleMap::headerRoleToKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a></td>          <td class="paramname"><span class="paramname"><em>Role</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a header role to a kind. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00076">76</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00139">ExcludedHeader</a>, <a class="el" href="Module_8h_source.html#l00235">clang::Module::HK_Excluded</a>, <a class="el" href="Module_8h_source.html#l00231">clang::Module::HK_Normal</a>, <a class="el" href="Module_8h_source.html#l00233">clang::Module::HK_Private</a>, <a class="el" href="Module_8h_source.html#l00234">clang::Module::HK_PrivateTextual</a>, <a class="el" href="Module_8h_source.html#l00232">clang::Module::HK_Textual</a>, <a class="el" href="ModuleMap_8h_source.html#l00129">NormalHeader</a>, <a class="el" href="ModuleMap_8h_source.html#l00132">PrivateHeader</a>, <a class="el" href="FormatToken_8h_source.html#l00785">Role</a>, and <a class="el" href="ModuleMap_8h_source.html#l00136">TextualHeader</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l01257">addHeader()</a>.</p>

</div>
</div>
<a id="af68b0b03f415bfbaedc292c33b881c41" name="af68b0b03f415bfbaedc292c33b881c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68b0b03f415bfbaedc292c33b881c41">&#9670;&#160;</a></span>inferFrameworkModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::inferFrameworkModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DirectoryEntryRef.html">DirectoryEntryRef</a></td>          <td class="paramname"><span class="paramname"><em>FrameworkDir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsSystem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Parent</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the contents of a framework module map from the given framework directory. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00965">965</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ASTDiff_8cpp_source.html#l00191">Parent</a>.</p>

</div>
</div>
<a id="a1e8ca3bc91f0e93e6c706b80f263e521" name="a1e8ca3bc91f0e93e6c706b80f263e521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8ca3bc91f0e93e6c706b80f263e521">&#9670;&#160;</a></span>isBuiltinHeader() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isBuiltinHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00395">395</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00379">isBuiltinHeader()</a>.</p>

</div>
</div>
<a id="a40c825f7506d1abd0d9bc54eba6330e6" name="a40c825f7506d1abd0d9bc54eba6330e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c825f7506d1abd0d9bc54eba6330e6">&#9670;&#160;</a></span>isBuiltinHeader() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isBuiltinHeader </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>FileName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this a compiler builtin header? </p>
<p>Determine whether the given file name is the name of a builtin header, supplied by Clang to replace, override, or augment existing system headers. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00379">379</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00395">isBuiltinHeader()</a>, <a class="el" href="HeaderSearch_8cpp_source.html#l01408">clang::HeaderSearch::ShouldEnterIncludeFile()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l01593">suggestModule()</a>.</p>

</div>
</div>
<a id="aa4894e6adb8982448b6724c996d0f5e4" name="aa4894e6adb8982448b6724c996d0f5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4894e6adb8982448b6724c996d0f5e4">&#9670;&#160;</a></span>isHeaderInUnavailableModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isHeaderInUnavailableModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a></td>          <td class="paramname"><span class="paramname"><em>Header</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the given header is part of a module marked 'unavailable'. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00703">703</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l00707">isHeaderUnavailableInModule()</a>.</p>

</div>
</div>
<a id="a648ba5f0cd274dd3acd6ee14aeae1cdc" name="a648ba5f0cd274dd3acd6ee14aeae1cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648ba5f0cd274dd3acd6ee14aeae1cdc">&#9670;&#160;</a></span>isHeaderUnavailableInModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isHeaderUnavailableInModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a></td>          <td class="paramname"><span class="paramname"><em>Header</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>RequestingModule</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the given header is unavailable as part of the specified module. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00707">707</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00139">ExcludedHeader</a>, <a class="el" href="FileEntry_8h_source.html#l00073">clang::FileEntryRef::getDir()</a>, <a class="el" href="Module_8cpp_source.html#l00266">clang::Module::getEffectiveUmbrellaDir()</a>, <a class="el" href="DirectoryEntry_8h_source.html#l00059">clang::DirectoryEntryRef::getName()</a>, <a class="el" href="FileEntry_8h_source.html#l00061">clang::FileEntryRef::getName()</a>, <a class="el" href="Module_8h_source.html#l00330">clang::Module::InferSubmodules</a>, <a class="el" href="Module_8h_source.html#l00499">clang::Module::isAvailable()</a>, <a class="el" href="Module_8cpp_source.html#l00195">clang::Module::isSubModuleOf()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00819">lookupModuleQualified()</a>, <a class="el" href="Module_8h_source.html#l00147">clang::Module::Parent</a>, <a class="el" href="ModuleMap_8cpp_source.html#l01222">resolveHeaderDirectives()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00340">sanitizeFilenameAsIdentifier()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00136">TextualHeader</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrontendAction_8cpp_source.html#l00332">collectModuleHeaderIncludes()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00703">isHeaderInUnavailableModule()</a>.</p>

</div>
</div>
<a id="a5ddbcfb5014e3bd0bcf33a30b41cc511" name="a5ddbcfb5014e3bd0bcf33a30b41cc511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ddbcfb5014e3bd0bcf33a30b41cc511">&#9670;&#160;</a></span>isModular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isModular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a></td>          <td class="paramname"><span class="paramname"><em>Role</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the header with the given role is a modular one. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00109">109</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00139">ExcludedHeader</a>, <a class="el" href="FormatToken_8h_source.html#l00785">Role</a>, and <a class="el" href="ModuleMap_8h_source.html#l00136">TextualHeader</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l01389">clang::HeaderSearch::MarkFileModuleHeader()</a>, and <a class="el" href="ASTReader_8cpp_source.html#l01936">clang::serialization::reader::HeaderFileInfoTrait::ReadData()</a>.</p>

</div>
</div>
<a id="ac4bd056e3b16607ace724463606dd3d5" name="ac4bd056e3b16607ace724463606dd3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bd056e3b16607ace724463606dd3d5">&#9670;&#160;</a></span>lookupModuleQualified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::lookupModuleQualified </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Context</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a module with the given name within the given context, using direct (qualified) name lookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to look up.</td></tr>
    <tr><td class="paramname">Context</td><td>The module for which we will look for a submodule. If null, we will look for a top-level module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The named submodule, if known; otherwose, returns null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00819">819</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l00801">findModule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00826">findOrCreateModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00707">isHeaderUnavailableInModule()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00809">lookupModuleUnqualified()</a>.</p>

</div>
</div>
<a id="a9682383d1483005eb8de8ab46275f5e5" name="a9682383d1483005eb8de8ab46275f5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9682383d1483005eb8de8ab46275f5e5">&#9670;&#160;</a></span>lookupModuleUnqualified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::lookupModuleUnqualified </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Context</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a module with the given name using lexical name lookup, starting at the given context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to look up.</td></tr>
    <tr><td class="paramname">Context</td><td>The module context, from which we will perform lexical name lookup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The named module, if known; otherwise, returns null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00809">809</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l00801">findModule()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00819">lookupModuleQualified()</a>.</p>

</div>
</div>
<a id="a3df11cf9b74e240aa373f25c1a63b49f" name="a3df11cf9b74e240aa373f25c1a63b49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df11cf9b74e240aa373f25c1a63b49f">&#9670;&#160;</a></span>mayShadowNewModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::ModuleMap::mayShadowNewModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>ExistingModule</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00602">602</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00147">clang::Module::Parent</a>.</p>

</div>
</div>
<a id="a6ab65f1f0882fcff9a15da9cfbf0fd02" name="a6ab65f1f0882fcff9a15da9cfbf0fd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab65f1f0882fcff9a15da9cfbf0fd02">&#9670;&#160;</a></span>module_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1b352087754574155a198a4cb0d6e197">module_iterator</a> clang::ModuleMap::module_begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00734">734</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l02212">clang::CompilerInstance::loadGlobalModuleIndex()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00736">modules()</a>.</p>

</div>
</div>
<a id="a9d9e3147d81ec86cf00eea874d9ea95b" name="a9d9e3147d81ec86cf00eea874d9ea95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9e3147d81ec86cf00eea874d9ea95b">&#9670;&#160;</a></span>module_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1b352087754574155a198a4cb0d6e197">module_iterator</a> clang::ModuleMap::module_end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00735">735</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l02212">clang::CompilerInstance::loadGlobalModuleIndex()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00736">modules()</a>.</p>

</div>
</div>
<a id="afc466d3e7e6077fea6c69d48759ec723" name="afc466d3e7e6077fea6c69d48759ec723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc466d3e7e6077fea6c69d48759ec723">&#9670;&#160;</a></span>modules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::iterator_range&lt; <a class="el" href="#a1b352087754574155a198a4cb0d6e197">module_iterator</a> &gt; clang::ModuleMap::modules </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00736">736</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00734">module_begin()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00735">module_end()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l01839">clang::HeaderSearch::collectAllModules()</a>.</p>

</div>
</div>
<a id="a42fef6a4583dbb427a8c66c8c45987d6" name="a42fef6a4583dbb427a8c66c8c45987d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42fef6a4583dbb427a8c66c8c45987d6">&#9670;&#160;</a></span>parseModuleMapFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::parseModuleMapFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>File</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsSystem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1DirectoryEntryRef.html">DirectoryEntryRef</a></td>          <td class="paramname"><span class="paramname"><em>HomeDir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileID.html">FileID</a></td>          <td class="paramname"><span class="paramname"><em>ID</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classclang_1_1FileID.html">FileID</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>ExternModuleLoc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the given module map file, and record any modules we encounter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">File</td><td>The file to be parsed.</td></tr>
    <tr><td class="paramname">IsSystem</td><td>Whether this module map file is in a system header directory, and therefore should be considered a system module.</td></tr>
    <tr><td class="paramname">HomeDir</td><td>The directory in which relative paths within this module map file will be resolved.</td></tr>
    <tr><td class="paramname">ID</td><td>The <a class="el" href="classclang_1_1FileID.html" title="An opaque identifier used by SourceManager which refers to a source file (MemoryBuffer) along with it...">FileID</a> of the file to process, if we've already entered it.</td></tr>
    <tr><td class="paramname">Offset</td><td>[inout] On input the offset at which to start parsing. On output, the offset at which the module map terminated.</td></tr>
    <tr><td class="paramname">ExternModuleLoc</td><td>The location of the "extern module" declaration that caused us to load this module map file, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an error occurred, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l03081">3081</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="SourceManager_8h_source.html#l00085">clang::SrcMgr::C_System_ModuleMap</a>, <a class="el" href="SourceManager_8h_source.html#l00084">clang::SrcMgr::C_User_ModuleMap</a>, <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="Lexer_8cpp_source.html#l01149">clang::Lexer::getSourceLocation()</a>, <a class="el" href="Format_8cpp_source.html#l02924">Offset</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="a635593eb7f27a7297eb22afacd08d104" name="a635593eb7f27a7297eb22afacd08d104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635593eb7f27a7297eb22afacd08d104">&#9670;&#160;</a></span>resolveConflicts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::resolveConflicts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>Complain</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all of the unresolved conflicts in the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mod</td><td>The module whose conflicts should be resolved.</td></tr>
    <tr><td class="paramname">Complain</td><td>Whether to emit diagnostics for failures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any errors were encountered while resolving conflicts, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01395">1395</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00467">clang::Module::Conflicts</a>, <a class="el" href="Module_8h_source.html#l00463">clang::Module::Conflict::Message</a>, <a class="el" href="Module_8h_source.html#l00460">clang::Module::Conflict::Other</a>, <a class="el" href="namespaceclang.html#addf89b16eec81ec256e98fa0cc9cdd65a4a3b76ab214699973b85cc072788ff7d">clang::Unresolved</a>, and <a class="el" href="Module_8h_source.html#l00455">clang::Module::UnresolvedConflicts</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sema_8cpp_source.html#l01104">clang::Sema::ActOnEndOfTranslationUnit()</a>, and <a class="el" href="PPLexerChange_8cpp_source.html#l00700">clang::Preprocessor::EnterSubmodule()</a>.</p>

</div>
</div>
<a id="a03d91ee91e3d302d32885c4d790b3915" name="a03d91ee91e3d302d32885c4d790b3915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d91ee91e3d302d32885c4d790b3915">&#9670;&#160;</a></span>resolveExports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::resolveExports </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>Complain</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all of the unresolved exports in the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mod</td><td>The module whose exports should be resolved.</td></tr>
    <tr><td class="paramname">Complain</td><td>Whether to emit diagnostics for failures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any errors were encountered while resolving exports, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01369">1369</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00385">clang::Module::Exports</a>, <a class="el" href="namespaceclang.html#addf89b16eec81ec256e98fa0cc9cdd65a4a3b76ab214699973b85cc072788ff7d">clang::Unresolved</a>, and <a class="el" href="Module_8h_source.html#l00403">clang::Module::UnresolvedExports</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sema_8cpp_source.html#l01104">clang::Sema::ActOnEndOfTranslationUnit()</a>, and <a class="el" href="PPLexerChange_8cpp_source.html#l00700">clang::Preprocessor::EnterSubmodule()</a>.</p>

</div>
</div>
<a id="a64ce2c7a23bcff10e7ae4bfcda637182" name="a64ce2c7a23bcff10e7ae4bfcda637182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ce2c7a23bcff10e7ae4bfcda637182">&#9670;&#160;</a></span>resolveHeaderDirectives() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::resolveHeaderDirectives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>File</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all lazy header directives for the specified file. </p>
<p>This ensures that the <a class="el" href="structclang_1_1HeaderFileInfo.html" title="The preprocessor keeps track of this information for each file that is #included.">HeaderFileInfo</a> on <a class="el" href="classclang_1_1HeaderSearch.html" title="Encapsulates the information needed to find the file referenced by a #include or #include_next,...">HeaderSearch</a> is up to date. This is effectively internal, but is exposed so <a class="el" href="classclang_1_1HeaderSearch.html" title="Encapsulates the information needed to find the file referenced by a #include or #include_next,...">HeaderSearch</a> can call it. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01222">1222</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l01222">resolveHeaderDirectives()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrontendAction_8cpp_source.html#l00332">collectModuleHeaderIncludes()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00470">diagnoseHeaderInclusion()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00694">findResolvedModulesForHeader()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00707">isHeaderUnavailableInModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l01222">resolveHeaderDirectives()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l01408">clang::HeaderSearch::ShouldEnterIncludeFile()</a>.</p>

</div>
</div>
<a id="a41dcd87105f5059bc55a3f3db230e9bb" name="a41dcd87105f5059bc55a3f3db230e9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41dcd87105f5059bc55a3f3db230e9bb">&#9670;&#160;</a></span>resolveHeaderDirectives() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::resolveHeaderDirectives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>File</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve lazy header directives for the specified module. </p>
<p>If File is provided, only headers with same size and modtime are resolved. If File is not set, all headers are resolved. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01238">1238</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="Module_8h_source.html#l00267">clang::Module::UnresolvedHeaderDirective::ModTime</a>, <a class="el" href="Module_8h_source.html#l00266">clang::Module::UnresolvedHeaderDirective::Size</a>, and <a class="el" href="Module_8h_source.html#l00272">clang::Module::UnresolvedHeaders</a>.</p>

</div>
</div>
<a id="ac588ee8d4c631303982ed1c68002f49d" name="ac588ee8d4c631303982ed1c68002f49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac588ee8d4c631303982ed1c68002f49d">&#9670;&#160;</a></span>resolveLinkAsDependencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::resolveLinkAsDependencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use PendingLinkAsModule information to mark top level link names that are going to be replaced by export_as aliases. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00058">58</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l00801">findModule()</a>, and <a class="el" href="Module_8h_source.html#l00101">clang::Module::Name</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l01966">clang::CompilerInstance::loadModule()</a>.</p>

</div>
</div>
<a id="aff262a15ac7933edd463953d969e4f6b" name="aff262a15ac7933edd463953d969e4f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff262a15ac7933edd463953d969e4f6b">&#9670;&#160;</a></span>resolveUses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::resolveUses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>Complain</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all of the unresolved uses in the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mod</td><td>The module whose uses should be resolved.</td></tr>
    <tr><td class="paramname">Complain</td><td>Whether to emit diagnostics for failures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any errors were encountered while resolving uses, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01382">1382</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00406">clang::Module::DirectUses</a>, <a class="el" href="namespaceclang.html#addf89b16eec81ec256e98fa0cc9cdd65a4a3b76ab214699973b85cc072788ff7d">clang::Unresolved</a>, and <a class="el" href="Module_8h_source.html#l00409">clang::Module::UnresolvedDirectUses</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sema_8cpp_source.html#l01104">clang::Sema::ActOnEndOfTranslationUnit()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00470">diagnoseHeaderInclusion()</a>, <a class="el" href="PPLexerChange_8cpp_source.html#l00700">clang::Preprocessor::EnterSubmodule()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l01593">suggestModule()</a>.</p>

</div>
</div>
<a id="a5af87b750c2e1f3b11a77b99a40a755f" name="a5af87b750c2e1f3b11a77b99a40a755f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af87b750c2e1f3b11a77b99a40a755f">&#9670;&#160;</a></span>setBuiltinIncludeDir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::setBuiltinIncludeDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DirectoryEntryRef.html">DirectoryEntryRef</a></td>          <td class="paramname"><span class="paramname"><em>Dir</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the directory that contains Clang-supplied include files, such as our <a class="el" href="stdarg_8h.html">stdarg.h</a> or <a class="el" href="tgmath_8h.html">tgmath.h</a>. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00408">408</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitHeaderSearch_8cpp_source.html#l00629">clang::ApplyHeaderSearchOptions()</a>.</p>

</div>
</div>
<a id="a64cf116b47bb6201a8154feab288cc65" name="a64cf116b47bb6201a8154feab288cc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cf116b47bb6201a8154feab288cc65">&#9670;&#160;</a></span>setInferredModuleAllowedBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setInferredModuleAllowedBy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>ModMap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01304">1304</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00324">clang::Module::IsInferred</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrontendAction_8cpp_source.html#l00484">prepareToBuildModule()</a>.</p>

</div>
</div>
<a id="abc441df169e00dbd5ab3a5db003d454f" name="abc441df169e00dbd5ab3a5db003d454f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc441df169e00dbd5ab3a5db003d454f">&#9670;&#160;</a></span>setTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the target information. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00333">333</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l00747">clang::HeaderSearch::setTarget()</a>.</p>

</div>
</div>
<a id="a202d290fccdf570de977224a277e24b9" name="a202d290fccdf570de977224a277e24b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202d290fccdf570de977224a277e24b9">&#9670;&#160;</a></span>setUmbrellaDirAsWritten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setUmbrellaDirAsWritten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1DirectoryEntryRef.html">DirectoryEntryRef</a></td>          <td class="paramname"><span class="paramname"><em>UmbrellaDir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>NameAsWritten</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>PathRelativeToRootModuleDirectory</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the umbrella directory of the given module to the given directory. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01176">1176</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00159">clang::Module::Umbrella</a>, <a class="el" href="Module_8h_source.html#l00165">clang::Module::UmbrellaAsWritten</a>, and <a class="el" href="Module_8h_source.html#l00168">clang::Module::UmbrellaRelativeToRootModuleDirectory</a>.</p>

</div>
</div>
<a id="a8d4201bac04ec898145e7fd1b94cd9e9" name="a8d4201bac04ec898145e7fd1b94cd9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4201bac04ec898145e7fd1b94cd9e9">&#9670;&#160;</a></span>setUmbrellaHeaderAsWritten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setUmbrellaHeaderAsWritten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a></td>          <td class="paramname"><span class="paramname"><em>UmbrellaHeader</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>NameAsWritten</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>PathRelativeToRootModuleDirectory</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the umbrella header of the given module to the given header. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01161">1161</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="FileEntry_8h_source.html#l00073">clang::FileEntryRef::getDir()</a>, <a class="el" href="ModuleMap_8h_source.html#l00129">NormalHeader</a>, <a class="el" href="Module_8h_source.html#l00159">clang::Module::Umbrella</a>, <a class="el" href="Module_8h_source.html#l00165">clang::Module::UmbrellaAsWritten</a>, and <a class="el" href="Module_8h_source.html#l00168">clang::Module::UmbrellaRelativeToRootModuleDirectory</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a69fccb440615f32e24516ed4e718457d" name="a69fccb440615f32e24516ed4e718457d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fccb440615f32e24516ed4e718457d">&#9670;&#160;</a></span>ModuleMapParser</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classclang_1_1ModuleMapParser.html">ModuleMapParser</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00200">200</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/clang/Lex/<a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a></li>
<li>lib/Lex/<a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 8 2024 17:02:16 for clang by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
