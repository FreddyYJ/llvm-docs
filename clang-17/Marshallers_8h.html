<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: lib/ASTMatchers/Dynamic/Marshallers.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">clang<span id="projectnumber">&#160;17.0.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_db8107f59e31a4b90f4f59a836476962.html">ASTMatchers</a></li><li class="navelem"><a class="el" href="dir_5def9e738340f8db2b57571724273d51.html">Dynamic</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Marshallers.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Functions templates and classes to wrap matcher construct functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="ASTTypeTraits_8h_source.html">clang/AST/ASTTypeTraits.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="OperationKinds_8h_source.html">clang/AST/OperationKinds.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ASTMatchersInternal_8h_source.html">clang/ASTMatchers/ASTMatchersInternal.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Diagnostics_8h_source.html">clang/ASTMatchers/Dynamic/Diagnostics.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="VariantValue_8h_source.html">clang/ASTMatchers/Dynamic/VariantValue.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AttrKinds_8h_source.html">clang/Basic/AttrKinds.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LLVM_8h_source.html">clang/Basic/LLVM.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="OpenMPKinds_8h_source.html">clang/Basic/OpenMPKinds.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TypeTraits_8h_source.html">clang/Basic/TypeTraits.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/ArrayRef.h&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/StringRef.h&quot;</code><br />
<code>#include &quot;llvm/ADT/StringSwitch.h&quot;</code><br />
<code>#include &quot;llvm/ADT/Twine.h&quot;</code><br />
<code>#include &quot;llvm/Support/Regex.h&quot;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;clang/Basic/AttrList.inc&quot;</code><br />
<code>#include &quot;clang/AST/OperationKinds.def&quot;</code><br />
<code>#include &quot;llvm/Frontend/OpenMP/OMP.inc&quot;</code><br />
<code>#include &quot;clang/Basic/TokenKinds.def&quot;</code><br />
</div>
<p><a href="Marshallers_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01const_01T_01_6_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; const T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01std_1_1string_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01StringRef_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; StringRef &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01ast__matchers_1_1internal_1_1Matcher_3_01T_01_4_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; ast_matchers::internal::Matcher&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01bool_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01double_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01unsigned_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; unsigned &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01attr_1_1Kind_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; attr::Kind &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01CastKind_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; CastKind &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01llvm_1_1Regex_1_1RegexFlags_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; llvm::Regex::RegexFlags &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01OpenMPClauseKind_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; OpenMPClauseKind &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01UnaryExprOrTypeTrait_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; UnaryExprOrTypeTrait &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">clang::ast_matchers::dynamic::internal::MatcherDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matcher descriptor interface.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1FixedArgCountMatcherDescriptor.html">clang::ast_matchers::dynamic::internal::FixedArgCountMatcherDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple callback implementation.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1FixedArgCountMatcherDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1BuildReturnTypeVector.html">clang::ast_matchers::dynamic::internal::BuildReturnTypeVector&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1BuildReturnTypeVector_3_01ast__matchers_1fdec462b476326a6db07c018c815c3f3.html">clang::ast_matchers::dynamic::internal::BuildReturnTypeVector&lt; ast_matchers::internal::Matcher&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1BuildReturnTypeVector_3_01ast__matchers_1cc40eb1dccb7d8196b0826e998b27b9e.html">clang::ast_matchers::dynamic::internal::BuildReturnTypeVector&lt; ast_matchers::internal::BindableMatcher&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1VariadicFuncMatcherDescriptor.html">clang::ast_matchers::dynamic::internal::VariadicFuncMatcherDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matcher descriptor for variadic functions.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1VariadicFuncMatcherDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1DynCastAllOfMatcherDescriptor.html">clang::ast_matchers::dynamic::internal::DynCastAllOfMatcherDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return CK_Trivial when appropriate for VariadicDynCastAllOfMatchers.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1DynCastAllOfMatcherDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1AdaptativeOverloadCollector.html">clang::ast_matchers::dynamic::internal::AdaptativeOverloadCollector&lt; ArgumentAdapterT, FromTypes, ToTypes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class used to collect all the possible overloads of an argument adaptative matcher function.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1AdaptativeOverloadCollector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1OverloadedMatcherDescriptor.html">clang::ast_matchers::dynamic::internal::OverloadedMatcherDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html" title="Matcher descriptor interface.">MatcherDescriptor</a> that wraps multiple "overloads" of the same matcher.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1OverloadedMatcherDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1RegexMatcherDescriptor.html">clang::ast_matchers::dynamic::internal::RegexMatcherDescriptor&lt; ReturnType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1VariadicOperatorMatcherDescriptor.html">clang::ast_matchers::dynamic::internal::VariadicOperatorMatcherDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic operator marshaller function.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1VariadicOperatorMatcherDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MapAnyOfMatcherDescriptor.html">clang::ast_matchers::dynamic::internal::MapAnyOfMatcherDescriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MapAnyOfBuilderDescriptor.html">clang::ast_matchers::dynamic::internal::MapAnyOfBuilderDescriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang.html">clang</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html">clang::ast_matchers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic.html">clang::ast_matchers::dynamic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html">clang::ast_matchers::dynamic::internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ada2b318e6a7f4de87f18987b5f3b4859" id="r_ada2b318e6a7f4de87f18987b5f3b4859"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada2b318e6a7f4de87f18987b5f3b4859">ATTR</a>(<a class="el" href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a>)</td></tr>
<tr class="separator:ada2b318e6a7f4de87f18987b5f3b4859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6796f43d0f5e6dfa0eb95157e2a436f" id="r_aa6796f43d0f5e6dfa0eb95157e2a436f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6796f43d0f5e6dfa0eb95157e2a436f">CAST_OPERATION</a>(Name)</td></tr>
<tr class="separator:aa6796f43d0f5e6dfa0eb95157e2a436f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c01d19d8da079646c91a83b77a07a8" id="r_a74c01d19d8da079646c91a83b77a07a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74c01d19d8da079646c91a83b77a07a8">GEN_CLANG_CLAUSE_CLASS</a></td></tr>
<tr class="separator:a74c01d19d8da079646c91a83b77a07a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bad911a6488fa2115dc9be0a0d4f60" id="r_ad6bad911a6488fa2115dc9be0a0d4f60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6bad911a6488fa2115dc9be0a0d4f60">CLAUSE_CLASS</a>(<a class="el" href="ExprConstant_8cpp.html#ae4a213489715e2de4562b3ae0538648dacf20423ed48998082c20099488a0917c">Enum</a>,  Str,  Class)</td></tr>
<tr class="separator:ad6bad911a6488fa2115dc9be0a0d4f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04236156b580f429d41637c375bcb6ba" id="r_a04236156b580f429d41637c375bcb6ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04236156b580f429d41637c375bcb6ba">UNARY_EXPR_OR_TYPE_TRAIT</a>(Spelling,  Name,  Key)</td></tr>
<tr class="separator:a04236156b580f429d41637c375bcb6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76f465c0c7870b710f3f13e880f6a20" id="r_ae76f465c0c7870b710f3f13e880f6a20"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae76f465c0c7870b710f3f13e880f6a20">CXX11_UNARY_EXPR_OR_TYPE_TRAIT</a>(Spelling,  Name,  Key)</td></tr>
<tr class="separator:ae76f465c0c7870b710f3f13e880f6a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82801a20b786614a3ca52da901055ec" id="r_ac82801a20b786614a3ca52da901055ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac82801a20b786614a3ca52da901055ec">CHECK_ARG_COUNT</a>(count)</td></tr>
<tr class="memdesc:ac82801a20b786614a3ca52da901055ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macros to check the arguments on all marshaller functions.  <br /></td></tr>
<tr class="separator:ac82801a20b786614a3ca52da901055ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8bdc295f29b7aff6cf6c808731748cc" id="r_ae8bdc295f29b7aff6cf6c808731748cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8bdc295f29b7aff6cf6c808731748cc">CHECK_ARG_TYPE</a>(index,  type)</td></tr>
<tr class="separator:ae8bdc295f29b7aff6cf6c808731748cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab2e2f1bb0c7c50fff0d24ea386e09770" id="r_ab2e2f1bb0c7c50fff0d24ea386e09770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ab2e2f1bb0c7c50fff0d24ea386e09770">clang::ast_matchers::dynamic::internal::isRetKindConvertibleTo</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ASTNodeKind.html">ASTNodeKind</a> &gt; RetKinds, <a class="el" href="classclang_1_1ASTNodeKind.html">ASTNodeKind</a> Kind, <a class="el" href="classunsigned.html">unsigned</a> *Specificity, <a class="el" href="classclang_1_1ASTNodeKind.html">ASTNodeKind</a> *LeastDerivedKind)</td></tr>
<tr class="separator:ab2e2f1bb0c7c50fff0d24ea386e09770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611d85ec910e5e626f593c5190fa8587" id="r_a611d85ec910e5e626f593c5190fa8587"><td class="memTemplParams" colspan="2">template&lt;class PolyMatcher &gt; </td></tr>
<tr class="memitem:a611d85ec910e5e626f593c5190fa8587"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a611d85ec910e5e626f593c5190fa8587">clang::ast_matchers::dynamic::internal::mergePolyMatchers</a> (const PolyMatcher &amp;Poly, std::vector&lt; DynTypedMatcher &gt; &amp;Out, ast_matchers::internal::EmptyTypeList)</td></tr>
<tr class="memdesc:a611d85ec910e5e626f593c5190fa8587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper methods to extract and merge all possible typed matchers out of the polymorphic object.  <br /></td></tr>
<tr class="separator:a611d85ec910e5e626f593c5190fa8587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a69f6ac494daf92d4faa12d47b3515" id="r_ac7a69f6ac494daf92d4faa12d47b3515"><td class="memTemplParams" colspan="2">template&lt;class PolyMatcher , class TypeList &gt; </td></tr>
<tr class="memitem:ac7a69f6ac494daf92d4faa12d47b3515"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ac7a69f6ac494daf92d4faa12d47b3515">clang::ast_matchers::dynamic::internal::mergePolyMatchers</a> (const PolyMatcher &amp;Poly, std::vector&lt; DynTypedMatcher &gt; &amp;Out, TypeList)</td></tr>
<tr class="separator:ac7a69f6ac494daf92d4faa12d47b3515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572949cd07e77a61658f87dddb278eb2" id="r_a572949cd07e77a61658f87dddb278eb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html">VariantMatcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a572949cd07e77a61658f87dddb278eb2">clang::ast_matchers::dynamic::internal::outvalueToVariantMatcher</a> (const DynTypedMatcher &amp;Matcher)</td></tr>
<tr class="memdesc:a572949cd07e77a61658f87dddb278eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the return values of the functions into a <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html" title="A variant matcher object.">VariantMatcher</a>.  <br /></td></tr>
<tr class="separator:a572949cd07e77a61658f87dddb278eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35023ff5e5cf5dc47918e816175c10b" id="r_af35023ff5e5cf5dc47918e816175c10b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af35023ff5e5cf5dc47918e816175c10b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html">VariantMatcher</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#af35023ff5e5cf5dc47918e816175c10b">clang::ast_matchers::dynamic::internal::outvalueToVariantMatcher</a> (const T &amp;PolyMatcher, typename T::ReturnTypes *=nullptr)</td></tr>
<tr class="separator:af35023ff5e5cf5dc47918e816175c10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8312641563547ae80af4c2e0cafd0e2" id="r_ac8312641563547ae80af4c2e0cafd0e2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac8312641563547ae80af4c2e0cafd0e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ac8312641563547ae80af4c2e0cafd0e2">clang::ast_matchers::dynamic::internal::buildReturnTypeVectorFromTypeList</a> (std::vector&lt; <a class="el" href="classclang_1_1ASTNodeKind.html">ASTNodeKind</a> &gt; &amp;RetTypes)</td></tr>
<tr class="separator:ac8312641563547ae80af4c2e0cafd0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7897d5c8cdea71d71d9996e00c7f9aa" id="r_ac7897d5c8cdea71d71d9996e00c7f9aa"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac7897d5c8cdea71d71d9996e00c7f9aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ac7897d5c8cdea71d71d9996e00c7f9aa">clang::ast_matchers::dynamic::internal::buildReturnTypeVectorFromTypeList&lt; ast_matchers::internal::EmptyTypeList &gt;</a> (std::vector&lt; <a class="el" href="classclang_1_1ASTNodeKind.html">ASTNodeKind</a> &gt; &amp;RetTypes)</td></tr>
<tr class="separator:ac7897d5c8cdea71d71d9996e00c7f9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d99dffd67a0a3b394f6cb2937a86d93" id="r_a5d99dffd67a0a3b394f6cb2937a86d93"><td class="memTemplParams" colspan="2">template&lt;typename ResultT , typename ArgT , ResultT(*)(<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const ArgT * &gt;) Func&gt; </td></tr>
<tr class="memitem:a5d99dffd67a0a3b394f6cb2937a86d93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html">VariantMatcher</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a5d99dffd67a0a3b394f6cb2937a86d93">clang::ast_matchers::dynamic::internal::variadicMatcherDescriptor</a> (StringRef MatcherName, <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1SourceRange.html">SourceRange</a> NameRange, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1ParserValue.html">ParserValue</a> &gt; Args, <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1Diagnostics.html">Diagnostics</a> *Error)</td></tr>
<tr class="memdesc:a5d99dffd67a0a3b394f6cb2937a86d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic marshaller function.  <br /></td></tr>
<tr class="separator:a5d99dffd67a0a3b394f6cb2937a86d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932fbeb8822576c997993bf764ceb996" id="r_a932fbeb8822576c997993bf764ceb996"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType &gt; </td></tr>
<tr class="memitem:a932fbeb8822576c997993bf764ceb996"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html">VariantMatcher</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a932fbeb8822576c997993bf764ceb996">clang::ast_matchers::dynamic::internal::matcherMarshall0</a> (void(*Func)(), StringRef MatcherName, <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1SourceRange.html">SourceRange</a> NameRange, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1ParserValue.html">ParserValue</a> &gt; Args, <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1Diagnostics.html">Diagnostics</a> *Error)</td></tr>
<tr class="memdesc:a932fbeb8822576c997993bf764ceb996"><td class="mdescLeft">&#160;</td><td class="mdescRight">0-arg marshaller function.  <br /></td></tr>
<tr class="separator:a932fbeb8822576c997993bf764ceb996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dd575adf88d03c6513970fe28ad34c" id="r_ab4dd575adf88d03c6513970fe28ad34c"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename ArgType1 &gt; </td></tr>
<tr class="memitem:ab4dd575adf88d03c6513970fe28ad34c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html">VariantMatcher</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ab4dd575adf88d03c6513970fe28ad34c">clang::ast_matchers::dynamic::internal::matcherMarshall1</a> (void(*Func)(), StringRef MatcherName, <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1SourceRange.html">SourceRange</a> NameRange, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1ParserValue.html">ParserValue</a> &gt; Args, <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1Diagnostics.html">Diagnostics</a> *Error)</td></tr>
<tr class="memdesc:ab4dd575adf88d03c6513970fe28ad34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-arg marshaller function.  <br /></td></tr>
<tr class="separator:ab4dd575adf88d03c6513970fe28ad34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f86276188da48e75eecc3fd5a6d510" id="r_a24f86276188da48e75eecc3fd5a6d510"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename ArgType1 , typename ArgType2 &gt; </td></tr>
<tr class="memitem:a24f86276188da48e75eecc3fd5a6d510"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html">VariantMatcher</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a24f86276188da48e75eecc3fd5a6d510">clang::ast_matchers::dynamic::internal::matcherMarshall2</a> (void(*Func)(), StringRef MatcherName, <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1SourceRange.html">SourceRange</a> NameRange, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1ParserValue.html">ParserValue</a> &gt; Args, <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1Diagnostics.html">Diagnostics</a> *Error)</td></tr>
<tr class="memdesc:a24f86276188da48e75eecc3fd5a6d510"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-arg marshaller function.  <br /></td></tr>
<tr class="separator:a24f86276188da48e75eecc3fd5a6d510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45cc29b00eee4164b706a78cccb57d6" id="r_ab45cc29b00eee4164b706a78cccb57d6"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType &gt; </td></tr>
<tr class="memitem:ab45cc29b00eee4164b706a78cccb57d6"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ab45cc29b00eee4164b706a78cccb57d6">clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall</a> (ReturnType(*Func)(), StringRef MatcherName)</td></tr>
<tr class="memdesc:ab45cc29b00eee4164b706a78cccb57d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions to select the appropriate marshaller functions.  <br /></td></tr>
<tr class="separator:ab45cc29b00eee4164b706a78cccb57d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64332ec7f1fc93bb65058b9cda9bc494" id="r_a64332ec7f1fc93bb65058b9cda9bc494"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename ArgType1 &gt; </td></tr>
<tr class="memitem:a64332ec7f1fc93bb65058b9cda9bc494"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a64332ec7f1fc93bb65058b9cda9bc494">clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall</a> (ReturnType(*Func)(ArgType1), StringRef MatcherName)</td></tr>
<tr class="memdesc:a64332ec7f1fc93bb65058b9cda9bc494"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-arg overload  <br /></td></tr>
<tr class="separator:a64332ec7f1fc93bb65058b9cda9bc494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fd4809910502bcca1cd4af627416c6" id="r_a18fd4809910502bcca1cd4af627416c6"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename ArgType1 , typename ArgType2 &gt; </td></tr>
<tr class="memitem:a18fd4809910502bcca1cd4af627416c6"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a18fd4809910502bcca1cd4af627416c6">clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall</a> (ReturnType(*Func)(ArgType1, ArgType2), StringRef MatcherName)</td></tr>
<tr class="memdesc:a18fd4809910502bcca1cd4af627416c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-arg overload  <br /></td></tr>
<tr class="separator:a18fd4809910502bcca1cd4af627416c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d69ce34c5b137ac4b81c7b5998c30c2" id="r_a6d69ce34c5b137ac4b81c7b5998c30c2"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType &gt; </td></tr>
<tr class="memitem:a6d69ce34c5b137ac4b81c7b5998c30c2"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a6d69ce34c5b137ac4b81c7b5998c30c2">clang::ast_matchers::dynamic::internal::makeMatcherRegexMarshall</a> (ReturnType(*FuncFlags)(llvm::StringRef, llvm::Regex::RegexFlags), ReturnType(*Func)(llvm::StringRef))</td></tr>
<tr class="separator:a6d69ce34c5b137ac4b81c7b5998c30c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59472b7a0bf042d2a8de4692932100a0" id="r_a59472b7a0bf042d2a8de4692932100a0"><td class="memTemplParams" colspan="2">template&lt;typename ResultT , typename ArgT , ResultT(*)(<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const ArgT * &gt;) Func&gt; </td></tr>
<tr class="memitem:a59472b7a0bf042d2a8de4692932100a0"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a59472b7a0bf042d2a8de4692932100a0">clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall</a> (ast_matchers::internal::VariadicFunction&lt; ResultT, ArgT, Func &gt; VarFunc, StringRef MatcherName)</td></tr>
<tr class="memdesc:a59472b7a0bf042d2a8de4692932100a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic overload.  <br /></td></tr>
<tr class="separator:a59472b7a0bf042d2a8de4692932100a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af915ed19baf1aaee68e279d8eb5e2555" id="r_af915ed19baf1aaee68e279d8eb5e2555"><td class="memTemplParams" colspan="2">template&lt;typename BaseT , typename DerivedT &gt; </td></tr>
<tr class="memitem:af915ed19baf1aaee68e279d8eb5e2555"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#af915ed19baf1aaee68e279d8eb5e2555">clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall</a> (ast_matchers::internal::VariadicDynCastAllOfMatcher&lt; BaseT, DerivedT &gt; VarFunc, StringRef MatcherName)</td></tr>
<tr class="memdesc:af915ed19baf1aaee68e279d8eb5e2555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for VariadicDynCastAllOfMatchers.  <br /></td></tr>
<tr class="separator:af915ed19baf1aaee68e279d8eb5e2555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b1f8c76ca8a4efb2d529d5e6a7ee3e" id="r_a07b1f8c76ca8a4efb2d529d5e6a7ee3e"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename ToArg, typename FromArg &gt; class ArgumentAdapterT, typename FromTypes , typename ToTypes &gt; </td></tr>
<tr class="memitem:a07b1f8c76ca8a4efb2d529d5e6a7ee3e"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a07b1f8c76ca8a4efb2d529d5e6a7ee3e">clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall</a> (ast_matchers::internal::ArgumentAdaptingMatcherFunc&lt; ArgumentAdapterT, FromTypes, ToTypes &gt;, StringRef MatcherName)</td></tr>
<tr class="memdesc:a07b1f8c76ca8a4efb2d529d5e6a7ee3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument adaptative overload.  <br /></td></tr>
<tr class="separator:a07b1f8c76ca8a4efb2d529d5e6a7ee3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3e6db33e1195951ed976093e266a04" id="r_a7d3e6db33e1195951ed976093e266a04"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classunsigned.html">unsigned</a> MinCount, <a class="el" href="classunsigned.html">unsigned</a> MaxCount&gt; </td></tr>
<tr class="memitem:a7d3e6db33e1195951ed976093e266a04"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a7d3e6db33e1195951ed976093e266a04">clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall</a> (ast_matchers::internal::VariadicOperatorMatcherFunc&lt; MinCount, MaxCount &gt; Func, StringRef MatcherName)</td></tr>
<tr class="memdesc:a7d3e6db33e1195951ed976093e266a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic operator overload.  <br /></td></tr>
<tr class="separator:a7d3e6db33e1195951ed976093e266a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1ba5d99570fb65194d8b1ef63ac9be" id="r_a2c1ba5d99570fb65194d8b1ef63ac9be"><td class="memTemplParams" colspan="2">template&lt;typename CladeType , typename... MatcherT&gt; </td></tr>
<tr class="memitem:a2c1ba5d99570fb65194d8b1ef63ac9be"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a2c1ba5d99570fb65194d8b1ef63ac9be">clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall</a> (ast_matchers::internal::MapAnyOfMatcherImpl&lt; CladeType, MatcherT... &gt;, StringRef MatcherName)</td></tr>
<tr class="separator:a2c1ba5d99570fb65194d8b1ef63ac9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions templates and classes to wrap matcher construct functions. </p>
<p>A collection of template function and classes that provide a generic marshalling layer on top of matcher construct functions. These are used by the registry to export all marshaller constructors with the same generic interface. </p>

<p class="definition">Definition in file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ada2b318e6a7f4de87f18987b5f3b4859" name="ada2b318e6a7f4de87f18987b5f3b4859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2b318e6a7f4de87f18987b5f3b4859">&#9670;&#160;</a></span>ATTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ATTR</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">.Case(#<a class="code hl_define" href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a>, attr::X)</div>
<div class="ttc" id="aInterpreter_2Value_8h_html_a094c3d875c5b3d55fb5307c29cfc2c18"><div class="ttname"><a href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a></div><div class="ttdeci">#define X(type, name)</div><div class="ttdef"><b>Definition</b> <a href="Interpreter_2Value_8h_source.html#l00094">Value.h:94</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa6796f43d0f5e6dfa0eb95157e2a436f" name="aa6796f43d0f5e6dfa0eb95157e2a436f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6796f43d0f5e6dfa0eb95157e2a436f">&#9670;&#160;</a></span>CAST_OPERATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAST_OPERATION</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">.Case(#Name, CK_##Name)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac82801a20b786614a3ca52da901055ec" name="ac82801a20b786614a3ca52da901055ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82801a20b786614a3ca52da901055ec">&#9670;&#160;</a></span>CHECK_ARG_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_ARG_COUNT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>count</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">if</span> (Args.size() != count) {                                                  \</div>
<div class="line">    <a class="code hl_typedef" href="ByteCodeEmitter_8cpp.html#a4bd5334353e73943f5521049c0a1522a">Error</a>-&gt;addError(NameRange, <a class="code hl_typedef" href="ByteCodeEmitter_8cpp.html#a4bd5334353e73943f5521049c0a1522a">Error</a>-&gt;ET_RegistryWrongArgCount)                \</div>
<div class="line">        &lt;&lt; count &lt;&lt; Args.size();                                               \</div>
<div class="line">    <span class="keywordflow">return</span> VariantMatcher();                                                   \</div>
<div class="line">  }</div>
<div class="ttc" id="aByteCodeEmitter_8cpp_html_a4bd5334353e73943f5521049c0a1522a"><div class="ttname"><a href="ByteCodeEmitter_8cpp.html#a4bd5334353e73943f5521049c0a1522a">Error</a></div><div class="ttdeci">llvm::Error Error</div><div class="ttdef"><b>Definition</b> <a href="ByteCodeEmitter_8cpp_source.html#l00022">ByteCodeEmitter.cpp:22</a></div></div>
</div><!-- fragment -->
<p>Helper macros to check the arguments on all marshaller functions. </p>

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l00623">623</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Marshallers_8h_source.html#l00652">clang::ast_matchers::dynamic::internal::matcherMarshall0()</a>, <a class="el" href="Marshallers_8h_source.html#l00663">clang::ast_matchers::dynamic::internal::matcherMarshall1()</a>, and <a class="el" href="Marshallers_8h_source.html#l00676">clang::ast_matchers::dynamic::internal::matcherMarshall2()</a>.</p>

</div>
</div>
<a id="ae8bdc295f29b7aff6cf6c808731748cc" name="ae8bdc295f29b7aff6cf6c808731748cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8bdc295f29b7aff6cf6c808731748cc">&#9670;&#160;</a></span>CHECK_ARG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_ARG_TYPE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">if</span> (!ArgTypeTraits&lt;type&gt;::hasCorrectType(Args[index].<a class="code hl_enumeration" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>)) {               \</div>
<div class="line">    <a class="code hl_typedef" href="ByteCodeEmitter_8cpp.html#a4bd5334353e73943f5521049c0a1522a">Error</a>-&gt;addError(Args[index].Range, <a class="code hl_typedef" href="ByteCodeEmitter_8cpp.html#a4bd5334353e73943f5521049c0a1522a">Error</a>-&gt;ET_RegistryWrongArgType)         \</div>
<div class="line">        &lt;&lt; (index + 1) &lt;&lt; ArgTypeTraits&lt;type&gt;::getKind().asString()            \</div>
<div class="line">        &lt;&lt; Args[index].Value.getTypeAsString();                                \</div>
<div class="line">    <span class="keywordflow">return</span> VariantMatcher();                                                   \</div>
<div class="line">  }                                                                            \</div>
<div class="line">  if (!ArgTypeTraits&lt;type&gt;::hasCorrectValue(Args[index].<a class="code hl_enumeration" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>)) {              \</div>
<div class="line">    if (std::optional&lt;std::string&gt; BestGuess =                                 \</div>
<div class="line">            ArgTypeTraits&lt;type&gt;::getBestGuess(Args[index].<a class="code hl_enumeration" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>)) {            \</div>
<div class="line">      <a class="code hl_typedef" href="ByteCodeEmitter_8cpp.html#a4bd5334353e73943f5521049c0a1522a">Error</a>-&gt;addError(Args[index].Range,                                       \</div>
<div class="line">                      <a class="code hl_typedef" href="ByteCodeEmitter_8cpp.html#a4bd5334353e73943f5521049c0a1522a">Error</a>-&gt;ET_RegistryUnknownEnumWithReplace)                \</div>
<div class="line">          &lt;&lt; index + 1 &lt;&lt; Args[index].Value.getString() &lt;&lt; *BestGuess;         \</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Args[index].<a class="code hl_enumeration" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>.isString()) {                                 \</div>
<div class="line">      <a class="code hl_typedef" href="ByteCodeEmitter_8cpp.html#a4bd5334353e73943f5521049c0a1522a">Error</a>-&gt;addError(Args[index].Range, <a class="code hl_typedef" href="ByteCodeEmitter_8cpp.html#a4bd5334353e73943f5521049c0a1522a">Error</a>-&gt;ET_RegistryValueNotFound)      \</div>
<div class="line">          &lt;&lt; Args[index].Value.getString();                                    \</div>
<div class="line">    }                                                                          \</div>
<div class="line">    <span class="keywordflow">return</span> VariantMatcher();                                                   \</div>
<div class="line">  }</div>
<div class="ttc" id="aUninitializedValues_8cpp_html_a896c037a32087c5c20d97e64a1786880"><div class="ttname"><a href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a></div><div class="ttdeci">Value</div><div class="ttdef"><b>Definition</b> <a href="UninitializedValues_8cpp_source.html#l00120">UninitializedValues.cpp:120</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l00630">630</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Marshallers_8h_source.html#l00663">clang::ast_matchers::dynamic::internal::matcherMarshall1()</a>, and <a class="el" href="Marshallers_8h_source.html#l00676">clang::ast_matchers::dynamic::internal::matcherMarshall2()</a>.</p>

</div>
</div>
<a id="ad6bad911a6488fa2115dc9be0a0d4f60" name="ad6bad911a6488fa2115dc9be0a0d4f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6bad911a6488fa2115dc9be0a0d4f60">&#9670;&#160;</a></span>CLAUSE_CLASS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CLAUSE_CLASS</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="ExprConstant_8cpp.html#ae4a213489715e2de4562b3ae0538648dacf20423ed48998082c20099488a0917c">Enum</a></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Class</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">.Case(#<a class="code hl_enumvalue" href="ExprConstant_8cpp.html#ae4a213489715e2de4562b3ae0538648dacf20423ed48998082c20099488a0917c">Enum</a>, llvm::omp::Clause::Enum)</div>
<div class="ttc" id="aExprConstant_8cpp_html_ae4a213489715e2de4562b3ae0538648dacf20423ed48998082c20099488a0917c"><div class="ttname"><a href="ExprConstant_8cpp.html#ae4a213489715e2de4562b3ae0538648dacf20423ed48998082c20099488a0917c">GCCTypeClass::Enum</a></div><div class="ttdeci">@ Enum</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae76f465c0c7870b710f3f13e880f6a20" name="ae76f465c0c7870b710f3f13e880f6a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76f465c0c7870b710f3f13e880f6a20">&#9670;&#160;</a></span>CXX11_UNARY_EXPR_OR_TYPE_TRAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CXX11_UNARY_EXPR_OR_TYPE_TRAIT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Spelling</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  .Case(#Name, UETT_##Name)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a74c01d19d8da079646c91a83b77a07a8" name="a74c01d19d8da079646c91a83b77a07a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c01d19d8da079646c91a83b77a07a8">&#9670;&#160;</a></span>GEN_CLANG_CLAUSE_CLASS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEN_CLANG_CLAUSE_CLASS</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04236156b580f429d41637c375bcb6ba" name="a04236156b580f429d41637c375bcb6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04236156b580f429d41637c375bcb6ba">&#9670;&#160;</a></span>UNARY_EXPR_OR_TYPE_TRAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNARY_EXPR_OR_TYPE_TRAIT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Spelling</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">.Case(#Name, UETT_##Name)</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 8 2024 17:02:10 for clang by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
