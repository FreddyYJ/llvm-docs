<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: lib/Headers/avx2intrin.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">clang<span id="projectnumber">&#160;17.0.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_32af269ab941e393bd1c05d50cd12728.html">Headers</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">avx2intrin.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a href="avx2intrin_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9c3364b71a7fe0439ba73567fc303fcc" id="r_a9c3364b71a7fe0439ba73567fc303fcc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;&#160;&#160;<a class="el" href="____clang__hip__libdevice__declares_8h.html#a3da0931a820e46f95754b07f9b413d58">__attribute__</a>((__always_inline__, __nodebug__, __target__(&quot;avx2&quot;), __min_vector_width__(256)))</td></tr>
<tr class="separator:a9c3364b71a7fe0439ba73567fc303fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5269551cf777adb9ce7ae4726145df2" id="r_aa5269551cf777adb9ce7ae4726145df2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;&#160;&#160;<a class="el" href="____clang__hip__libdevice__declares_8h.html#a3da0931a820e46f95754b07f9b413d58">__attribute__</a>((__always_inline__, __nodebug__, __target__(&quot;avx2&quot;), __min_vector_width__(128)))</td></tr>
<tr class="separator:aa5269551cf777adb9ce7ae4726145df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac139092f30e8322e5d76257b5bac2886" id="r_ac139092f30e8322e5d76257b5bac2886"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac139092f30e8322e5d76257b5bac2886">_mm256_mpsadbw_epu8</a>(<a class="el" href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a>,  Y,  M)</td></tr>
<tr class="memdesc:ac139092f30e8322e5d76257b5bac2886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes sixteen sum of absolute difference (SAD) operations on sets of four unsigned 8-bit integers from the 256-bit integer vectors <em>X</em> and <em>Y</em>.  <br /></td></tr>
<tr class="separator:ac139092f30e8322e5d76257b5bac2886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe3521900e672c4655149ced8682d05" id="r_a8fe3521900e672c4655149ced8682d05"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fe3521900e672c4655149ced8682d05">_mm256_alignr_epi8</a>(a,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>,  n)</td></tr>
<tr class="memdesc:a8fe3521900e672c4655149ced8682d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the lower half of the 256-bit vector <em>a</em> as the upper half of a temporary 256-bit value, and the lower half of the 256-bit vector <em>b</em> as the lower half of the temporary value.  <br /></td></tr>
<tr class="separator:a8fe3521900e672c4655149ced8682d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad018a82854ddb7a5c81d00ea72140972" id="r_ad018a82854ddb7a5c81d00ea72140972"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad018a82854ddb7a5c81d00ea72140972">_mm256_blend_epi16</a>(V1,  V2,  M)</td></tr>
<tr class="memdesc:ad018a82854ddb7a5c81d00ea72140972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges 16-bit integer values from either of the two 256-bit vectors <em>V1</em> or <em>V2</em>, as specified by the immediate integer operand <em>M</em>, and returns the resulting 256-bit vector of [16 x i16].  <br /></td></tr>
<tr class="separator:ad018a82854ddb7a5c81d00ea72140972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e537a750e453f44a0ed29eeeba6c88" id="r_ac0e537a750e453f44a0ed29eeeba6c88"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0e537a750e453f44a0ed29eeeba6c88">_mm256_shuffle_epi32</a>(a,  imm)</td></tr>
<tr class="memdesc:ac0e537a750e453f44a0ed29eeeba6c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles 32-bit integers from the 256-bit vector of [8 x i32] in <em>a</em> according to control information in the integer literal <em>imm</em>, and returns the 256-bit result.  <br /></td></tr>
<tr class="separator:ac0e537a750e453f44a0ed29eeeba6c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067971162dbcfead4d820ccda94fc850" id="r_a067971162dbcfead4d820ccda94fc850"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a067971162dbcfead4d820ccda94fc850">_mm256_shufflehi_epi16</a>(a,  imm)</td></tr>
<tr class="memdesc:a067971162dbcfead4d820ccda94fc850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles 16-bit integers from the 256-bit vector of [16 x i16] in <em>a</em> according to control information in the integer literal <em>imm</em>, and returns the 256-bit result.  <br /></td></tr>
<tr class="separator:a067971162dbcfead4d820ccda94fc850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ebb6cfdddfb1692373d6cf70ac8ccf" id="r_ad3ebb6cfdddfb1692373d6cf70ac8ccf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3ebb6cfdddfb1692373d6cf70ac8ccf">_mm256_shufflelo_epi16</a>(a,  imm)</td></tr>
<tr class="memdesc:ad3ebb6cfdddfb1692373d6cf70ac8ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles 16-bit integers from the 256-bit vector of [16 x i16] <em>a</em> according to control information in the integer literal <em>imm</em>, and returns the 256-bit [16 x i16] result.  <br /></td></tr>
<tr class="separator:ad3ebb6cfdddfb1692373d6cf70ac8ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f1212570d0e3dee4a64ef6e8a19693" id="r_ac2f1212570d0e3dee4a64ef6e8a19693"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2f1212570d0e3dee4a64ef6e8a19693">_mm256_slli_si256</a>(a,  imm)</td></tr>
<tr class="memdesc:ac2f1212570d0e3dee4a64ef6e8a19693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 128-bit half of the 256-bit integer vector <em>a</em> left by <em>imm</em> bytes, shifting in zero bytes, and returns the result.  <br /></td></tr>
<tr class="separator:ac2f1212570d0e3dee4a64ef6e8a19693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adabedfb750d899e60f3685b434c6ad" id="r_a0adabedfb750d899e60f3685b434c6ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0adabedfb750d899e60f3685b434c6ad">_mm256_bslli_epi128</a>(a,  imm)</td></tr>
<tr class="memdesc:a0adabedfb750d899e60f3685b434c6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 128-bit half of the 256-bit integer vector <em>a</em> left by <em>imm</em> bytes, shifting in zero bytes, and returns the result.  <br /></td></tr>
<tr class="separator:a0adabedfb750d899e60f3685b434c6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a707f6f1a0cc3039cacb54fb420d4b" id="r_a59a707f6f1a0cc3039cacb54fb420d4b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59a707f6f1a0cc3039cacb54fb420d4b">_mm256_srli_si256</a>(a,  imm)</td></tr>
<tr class="memdesc:a59a707f6f1a0cc3039cacb54fb420d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 128-bit half of the 256-bit integer vector in <em>a</em> right by <em>imm</em> bytes, shifting in zero bytes, and returns the result.  <br /></td></tr>
<tr class="separator:a59a707f6f1a0cc3039cacb54fb420d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf654837b8bfee81dbdcae53b79e7961" id="r_acf654837b8bfee81dbdcae53b79e7961"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf654837b8bfee81dbdcae53b79e7961">_mm256_bsrli_epi128</a>(a,  imm)</td></tr>
<tr class="memdesc:acf654837b8bfee81dbdcae53b79e7961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 128-bit half of the 256-bit integer vector in <em>a</em> right by <em>imm</em> bytes, shifting in zero bytes, and returns the result.  <br /></td></tr>
<tr class="separator:acf654837b8bfee81dbdcae53b79e7961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7c90e2a3c140bd5828be66dd00450c" id="r_a2c7c90e2a3c140bd5828be66dd00450c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c7c90e2a3c140bd5828be66dd00450c">_mm_broadcastsi128_si256</a>(<a class="el" href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a>)</td></tr>
<tr class="separator:a2c7c90e2a3c140bd5828be66dd00450c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a2ff86a16a4fc5a9e3c94a817064ea" id="r_a51a2ff86a16a4fc5a9e3c94a817064ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51a2ff86a16a4fc5a9e3c94a817064ea">_mm_blend_epi32</a>(V1,  V2,  M)</td></tr>
<tr class="memdesc:a51a2ff86a16a4fc5a9e3c94a817064ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges 32-bit integer elements from either of the two 128-bit vectors of [4 x i32] in <em>V1</em> or <em>V2</em> to the result's 128-bit vector of [4 x i32], as specified by the immediate integer operand <em>M</em>.  <br /></td></tr>
<tr class="separator:a51a2ff86a16a4fc5a9e3c94a817064ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8fd952a7c88dfb5b9437f0cd94b9db" id="r_a5f8fd952a7c88dfb5b9437f0cd94b9db"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f8fd952a7c88dfb5b9437f0cd94b9db">_mm256_blend_epi32</a>(V1,  V2,  M)</td></tr>
<tr class="memdesc:a5f8fd952a7c88dfb5b9437f0cd94b9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges 32-bit integer elements from either of the two 256-bit vectors of [8 x i32] in <em>V1</em> or <em>V2</em> to return a 256-bit vector of [8 x i32], as specified by the immediate integer operand <em>M</em>.  <br /></td></tr>
<tr class="separator:a5f8fd952a7c88dfb5b9437f0cd94b9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e712383837346afed6b8bb7980d1ed1" id="r_a6e712383837346afed6b8bb7980d1ed1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e712383837346afed6b8bb7980d1ed1">_mm256_permute4x64_pd</a>(<a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>,  M)</td></tr>
<tr class="memdesc:a6e712383837346afed6b8bb7980d1ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the result's 256-bit vector of [4 x double] to copies of elements of the 256-bit vector of [4 x double] in <em>V</em> as specified by the immediate value <em>M</em>.  <br /></td></tr>
<tr class="separator:a6e712383837346afed6b8bb7980d1ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68537aee7b7c35974ea46b32d6be8539" id="r_a68537aee7b7c35974ea46b32d6be8539"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68537aee7b7c35974ea46b32d6be8539">_mm256_permute4x64_epi64</a>(<a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>,  M)</td></tr>
<tr class="memdesc:a68537aee7b7c35974ea46b32d6be8539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the result's 256-bit vector of [4 x i64] result to copies of elements of the 256-bit vector of [4 x i64] in <em>V</em> as specified by the immediate value <em>M</em>.  <br /></td></tr>
<tr class="separator:a68537aee7b7c35974ea46b32d6be8539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42c8a9ffd50a4d2e392dc16043f3be2" id="r_aa42c8a9ffd50a4d2e392dc16043f3be2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa42c8a9ffd50a4d2e392dc16043f3be2">_mm256_permute2x128_si256</a>(V1,  V2,  M)</td></tr>
<tr class="memdesc:aa42c8a9ffd50a4d2e392dc16043f3be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each half of the 256-bit result either to zero or to one of the four possible 128-bit halves of the 256-bit vectors <em>V1</em> and <em>V2</em>, as specified by the immediate value <em>M</em>.  <br /></td></tr>
<tr class="separator:aa42c8a9ffd50a4d2e392dc16043f3be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad58b51492bbbb175bcafd021585d930" id="r_aad58b51492bbbb175bcafd021585d930"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad58b51492bbbb175bcafd021585d930">_mm256_extracti128_si256</a>(<a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>,  M)</td></tr>
<tr class="memdesc:aad58b51492bbbb175bcafd021585d930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts half of the 256-bit vector <em>V</em> to the 128-bit result.  <br /></td></tr>
<tr class="separator:aad58b51492bbbb175bcafd021585d930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8406778aad3e2dac47927d38a6689714" id="r_a8406778aad3e2dac47927d38a6689714"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8406778aad3e2dac47927d38a6689714">_mm256_inserti128_si256</a>(V1,  V2,  M)</td></tr>
<tr class="memdesc:a8406778aad3e2dac47927d38a6689714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the 256-bit vector <em>V1</em> to the result, then overwrites half of the result with the 128-bit vector <em>V2</em>.  <br /></td></tr>
<tr class="separator:a8406778aad3e2dac47927d38a6689714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2af56dc678cba90344c8efc51e42fef" id="r_af2af56dc678cba90344c8efc51e42fef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2af56dc678cba90344c8efc51e42fef">_mm_mask_i32gather_pd</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:af2af56dc678cba90344c8efc51e42fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers two 64-bit floating-point values, either from the 128-bit vector of [2 x double] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <br /></td></tr>
<tr class="separator:af2af56dc678cba90344c8efc51e42fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9ef334e167c132b6a9f13770b77f01" id="r_a8a9ef334e167c132b6a9f13770b77f01"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a9ef334e167c132b6a9f13770b77f01">_mm256_mask_i32gather_pd</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a8a9ef334e167c132b6a9f13770b77f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers four 64-bit floating-point values, either from the 256-bit vector of [4 x double] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a8a9ef334e167c132b6a9f13770b77f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2e967b6fb85089168a6887111c1320" id="r_abb2e967b6fb85089168a6887111c1320"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb2e967b6fb85089168a6887111c1320">_mm_mask_i64gather_pd</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:abb2e967b6fb85089168a6887111c1320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers two 64-bit floating-point values, either from the 128-bit vector of [2 x double] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>.  <br /></td></tr>
<tr class="separator:abb2e967b6fb85089168a6887111c1320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5b86b0ba922eb270ec2b545c8a537d" id="r_acf5b86b0ba922eb270ec2b545c8a537d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf5b86b0ba922eb270ec2b545c8a537d">_mm256_mask_i64gather_pd</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:acf5b86b0ba922eb270ec2b545c8a537d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers four 64-bit floating-point values, either from the 256-bit vector of [4 x double] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>.  <br /></td></tr>
<tr class="separator:acf5b86b0ba922eb270ec2b545c8a537d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d9ce668f45c18f008ccb4ba4920880" id="r_a66d9ce668f45c18f008ccb4ba4920880"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66d9ce668f45c18f008ccb4ba4920880">_mm_mask_i32gather_ps</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a66d9ce668f45c18f008ccb4ba4920880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers four 32-bit floating-point values, either from the 128-bit vector of [4 x float] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a66d9ce668f45c18f008ccb4ba4920880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7767cbba8a5c61bf05fe06ee416a4542" id="r_a7767cbba8a5c61bf05fe06ee416a4542"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7767cbba8a5c61bf05fe06ee416a4542">_mm256_mask_i32gather_ps</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a7767cbba8a5c61bf05fe06ee416a4542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers eight 32-bit floating-point values, either from the 256-bit vector of [8 x float] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [8 x i32] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a7767cbba8a5c61bf05fe06ee416a4542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80831775aea07c24899ae747d8011bc" id="r_ab80831775aea07c24899ae747d8011bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab80831775aea07c24899ae747d8011bc">_mm_mask_i64gather_ps</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:ab80831775aea07c24899ae747d8011bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers two 32-bit floating-point values, either from the 128-bit vector of [4 x float] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>.  <br /></td></tr>
<tr class="separator:ab80831775aea07c24899ae747d8011bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ab1da963f146144bd78937e561deaf" id="r_a13ab1da963f146144bd78937e561deaf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13ab1da963f146144bd78937e561deaf">_mm256_mask_i64gather_ps</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a13ab1da963f146144bd78937e561deaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers four 32-bit floating-point values, either from the 128-bit vector of [4 x float] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a13ab1da963f146144bd78937e561deaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3078631872478b4855ee95713aa2cd48" id="r_a3078631872478b4855ee95713aa2cd48"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3078631872478b4855ee95713aa2cd48">_mm_mask_i32gather_epi32</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a3078631872478b4855ee95713aa2cd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers four 32-bit integer values, either from the 128-bit vector of [4 x i32] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a3078631872478b4855ee95713aa2cd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3890959d248c67e0307f945f852a28" id="r_a4a3890959d248c67e0307f945f852a28"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a3890959d248c67e0307f945f852a28">_mm256_mask_i32gather_epi32</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a4a3890959d248c67e0307f945f852a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers eight 32-bit integer values, either from the 256-bit vector of [8 x i32] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [8 x i32] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a4a3890959d248c67e0307f945f852a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59acb178be58ad2561eb49b14489800d" id="r_a59acb178be58ad2561eb49b14489800d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59acb178be58ad2561eb49b14489800d">_mm_mask_i64gather_epi32</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a59acb178be58ad2561eb49b14489800d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers two 32-bit integer values, either from the 128-bit vector of [4 x i32] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a59acb178be58ad2561eb49b14489800d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91162e72875b376189127affa7b2bf5c" id="r_a91162e72875b376189127affa7b2bf5c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91162e72875b376189127affa7b2bf5c">_mm256_mask_i64gather_epi32</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a91162e72875b376189127affa7b2bf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers four 32-bit integer values, either from the 128-bit vector of [4 x i32] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a91162e72875b376189127affa7b2bf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825d53d864b1d4d3bb7ab4b6ef457952" id="r_a825d53d864b1d4d3bb7ab4b6ef457952"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a825d53d864b1d4d3bb7ab4b6ef457952">_mm_mask_i32gather_epi64</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a825d53d864b1d4d3bb7ab4b6ef457952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers two 64-bit integer values, either from the 128-bit vector of [2 x i64] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a825d53d864b1d4d3bb7ab4b6ef457952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6618807ebcb4b758d18065b0512b456" id="r_ad6618807ebcb4b758d18065b0512b456"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6618807ebcb4b758d18065b0512b456">_mm256_mask_i32gather_epi64</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:ad6618807ebcb4b758d18065b0512b456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers four 64-bit integer values, either from the 256-bit vector of [4 x i64] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <br /></td></tr>
<tr class="separator:ad6618807ebcb4b758d18065b0512b456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1efa9858c290fe95335119cd657a90" id="r_aeb1efa9858c290fe95335119cd657a90"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb1efa9858c290fe95335119cd657a90">_mm_mask_i64gather_epi64</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:aeb1efa9858c290fe95335119cd657a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers two 64-bit integer values, either from the 128-bit vector of [2 x i64] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>.  <br /></td></tr>
<tr class="separator:aeb1efa9858c290fe95335119cd657a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b171b3af10ce3b58abef775d789f20" id="r_af6b171b3af10ce3b58abef775d789f20"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6b171b3af10ce3b58abef775d789f20">_mm256_mask_i64gather_epi64</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:af6b171b3af10ce3b58abef775d789f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers four 64-bit integer values, either from the 256-bit vector of [4 x i64] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>.  <br /></td></tr>
<tr class="separator:af6b171b3af10ce3b58abef775d789f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afe7e70b1677fd4097166407ae827cb" id="r_a4afe7e70b1677fd4097166407ae827cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4afe7e70b1677fd4097166407ae827cb">_mm_i32gather_pd</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a4afe7e70b1677fd4097166407ae827cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers two 64-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a4afe7e70b1677fd4097166407ae827cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80044451f05309770ce2bf171dbfa0be" id="r_a80044451f05309770ce2bf171dbfa0be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80044451f05309770ce2bf171dbfa0be">_mm256_i32gather_pd</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a80044451f05309770ce2bf171dbfa0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers four 64-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a80044451f05309770ce2bf171dbfa0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc1a3777f51496f53faf452ae31ebfc" id="r_a6fc1a3777f51496f53faf452ae31ebfc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fc1a3777f51496f53faf452ae31ebfc">_mm_i64gather_pd</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a6fc1a3777f51496f53faf452ae31ebfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers two 64-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a6fc1a3777f51496f53faf452ae31ebfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b6cdf024224c2ed44d22717fd80434" id="r_a10b6cdf024224c2ed44d22717fd80434"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10b6cdf024224c2ed44d22717fd80434">_mm256_i64gather_pd</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a10b6cdf024224c2ed44d22717fd80434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers four 64-bit floating-point values from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a10b6cdf024224c2ed44d22717fd80434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192468a06b0104ad516aaca8a4f0eee8" id="r_a192468a06b0104ad516aaca8a4f0eee8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a192468a06b0104ad516aaca8a4f0eee8">_mm_i32gather_ps</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a192468a06b0104ad516aaca8a4f0eee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers four 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a192468a06b0104ad516aaca8a4f0eee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74219a133afddd0577c5a391f041a936" id="r_a74219a133afddd0577c5a391f041a936"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74219a133afddd0577c5a391f041a936">_mm256_i32gather_ps</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a74219a133afddd0577c5a391f041a936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers eight 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 256-bit vector of [8 x i32] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a74219a133afddd0577c5a391f041a936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369276cfeba553776632edd1ee507cec" id="r_a369276cfeba553776632edd1ee507cec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a369276cfeba553776632edd1ee507cec">_mm_i64gather_ps</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a369276cfeba553776632edd1ee507cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers two 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a369276cfeba553776632edd1ee507cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897ba09d00f44657795d12e48beeca0f" id="r_a897ba09d00f44657795d12e48beeca0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a897ba09d00f44657795d12e48beeca0f">_mm256_i64gather_ps</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a897ba09d00f44657795d12e48beeca0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers four 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a897ba09d00f44657795d12e48beeca0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc371417a059f4660f43bb9f70c0420" id="r_a3fc371417a059f4660f43bb9f70c0420"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fc371417a059f4660f43bb9f70c0420">_mm_i32gather_epi32</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a3fc371417a059f4660f43bb9f70c0420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers four 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a3fc371417a059f4660f43bb9f70c0420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1267ffda36b2c13484b36a209e37792" id="r_ad1267ffda36b2c13484b36a209e37792"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1267ffda36b2c13484b36a209e37792">_mm256_i32gather_epi32</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:ad1267ffda36b2c13484b36a209e37792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers eight 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 256-bit vector of [8 x i32] in <em>i</em>.  <br /></td></tr>
<tr class="separator:ad1267ffda36b2c13484b36a209e37792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b68cf22a459a9867218792d42c0b5d" id="r_ad6b68cf22a459a9867218792d42c0b5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6b68cf22a459a9867218792d42c0b5d">_mm_i64gather_epi32</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:ad6b68cf22a459a9867218792d42c0b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers two 32-bit integer values from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>.  <br /></td></tr>
<tr class="separator:ad6b68cf22a459a9867218792d42c0b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ead9a9686d802347c1311dbdb2166de" id="r_a4ead9a9686d802347c1311dbdb2166de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ead9a9686d802347c1311dbdb2166de">_mm256_i64gather_epi32</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a4ead9a9686d802347c1311dbdb2166de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers four 32-bit integer values from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a4ead9a9686d802347c1311dbdb2166de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9f493fcb23d1f0266edb15035bc22f" id="r_a2f9f493fcb23d1f0266edb15035bc22f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f9f493fcb23d1f0266edb15035bc22f">_mm_i32gather_epi64</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a2f9f493fcb23d1f0266edb15035bc22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers two 64-bit integer values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a2f9f493fcb23d1f0266edb15035bc22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16861b116c0624454372064f910c4f80" id="r_a16861b116c0624454372064f910c4f80"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16861b116c0624454372064f910c4f80">_mm256_i32gather_epi64</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a16861b116c0624454372064f910c4f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers four 64-bit integer values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a16861b116c0624454372064f910c4f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a2425c4e406cc767d45cbd063ba7d4" id="r_a76a2425c4e406cc767d45cbd063ba7d4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76a2425c4e406cc767d45cbd063ba7d4">_mm_i64gather_epi64</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a76a2425c4e406cc767d45cbd063ba7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers two 64-bit integer values from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>.  <br /></td></tr>
<tr class="separator:a76a2425c4e406cc767d45cbd063ba7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b484e1a1b32ff73f8857fc02dc8008" id="r_ad1b484e1a1b32ff73f8857fc02dc8008"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1b484e1a1b32ff73f8857fc02dc8008">_mm256_i64gather_epi64</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:ad1b484e1a1b32ff73f8857fc02dc8008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers four 64-bit integer values from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>.  <br /></td></tr>
<tr class="separator:ad1b484e1a1b32ff73f8857fc02dc8008"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a012bc2eed4df0a81ee390af2ef919e9b" id="r_a012bc2eed4df0a81ee390af2ef919e9b"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a012bc2eed4df0a81ee390af2ef919e9b">_mm256_abs_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>)</td></tr>
<tr class="memdesc:a012bc2eed4df0a81ee390af2ef919e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of each signed byte in the 256-bit integer vector <em>__a</em> and returns each value in the corresponding byte of the result.  <br /></td></tr>
<tr class="separator:a012bc2eed4df0a81ee390af2ef919e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af356be486c9c44ff687a24eecb505123" id="r_af356be486c9c44ff687a24eecb505123"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af356be486c9c44ff687a24eecb505123">_mm256_abs_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>)</td></tr>
<tr class="memdesc:af356be486c9c44ff687a24eecb505123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of each signed 16-bit element in the 256-bit vector of [16 x i16] in <em>__a</em> and returns each value in the corresponding element of the result.  <br /></td></tr>
<tr class="separator:af356be486c9c44ff687a24eecb505123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fbd635339f3c30bf181326688a45d1" id="r_ae0fbd635339f3c30bf181326688a45d1"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0fbd635339f3c30bf181326688a45d1">_mm256_abs_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>)</td></tr>
<tr class="memdesc:ae0fbd635339f3c30bf181326688a45d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of each signed 32-bit element in the 256-bit vector of [8 x i32] in <em>__a</em> and returns each value in the corresponding element of the result.  <br /></td></tr>
<tr class="separator:ae0fbd635339f3c30bf181326688a45d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820ba07f5916a602806c2aecd6cd0f69" id="r_a820ba07f5916a602806c2aecd6cd0f69"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a820ba07f5916a602806c2aecd6cd0f69">_mm256_packs_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a820ba07f5916a602806c2aecd6cd0f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the elements of two 256-bit vectors of [16 x i16] to 8-bit integers using signed saturation, and returns the 256-bit result.  <br /></td></tr>
<tr class="separator:a820ba07f5916a602806c2aecd6cd0f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f0a34407f0edaa6728ec94ced2431a" id="r_a18f0a34407f0edaa6728ec94ced2431a"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18f0a34407f0edaa6728ec94ced2431a">_mm256_packs_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a18f0a34407f0edaa6728ec94ced2431a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the elements of two 256-bit vectors of [8 x i32] to 16-bit integers using signed saturation, and returns the resulting 256-bit vector of [16 x i16].  <br /></td></tr>
<tr class="separator:a18f0a34407f0edaa6728ec94ced2431a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54fdcd67534f2defc6f2564d7a031f5" id="r_ac54fdcd67534f2defc6f2564d7a031f5"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac54fdcd67534f2defc6f2564d7a031f5">_mm256_packus_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:ac54fdcd67534f2defc6f2564d7a031f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts elements from two 256-bit vectors of [16 x i16] to 8-bit integers using unsigned saturation, and returns the 256-bit result.  <br /></td></tr>
<tr class="separator:ac54fdcd67534f2defc6f2564d7a031f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67ddfcbac48b6687c29540ba34187da" id="r_aa67ddfcbac48b6687c29540ba34187da"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa67ddfcbac48b6687c29540ba34187da">_mm256_packus_epi32</a> (__m256i __V1, __m256i __V2)</td></tr>
<tr class="memdesc:aa67ddfcbac48b6687c29540ba34187da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts elements from two 256-bit vectors of [8 x i32] to 16-bit integers using unsigned saturation, and returns the resulting 256-bit vector of [16 x i16].  <br /></td></tr>
<tr class="separator:aa67ddfcbac48b6687c29540ba34187da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b923dae009dd42ae05783e0955ee00" id="r_a59b923dae009dd42ae05783e0955ee00"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59b923dae009dd42ae05783e0955ee00">_mm256_add_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a59b923dae009dd42ae05783e0955ee00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 8-bit integers from corresponding bytes of two 256-bit integer vectors and returns the lower 8 bits of each sum in the corresponding byte of the 256-bit integer vector result (overflow is ignored).  <br /></td></tr>
<tr class="separator:a59b923dae009dd42ae05783e0955ee00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1fe2000e40ddd6ccd91f29dfd4ae0d" id="r_a5c1fe2000e40ddd6ccd91f29dfd4ae0d"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c1fe2000e40ddd6ccd91f29dfd4ae0d">_mm256_add_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a5c1fe2000e40ddd6ccd91f29dfd4ae0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] and returns the lower 16 bits of each sum in the corresponding element of the [16 x i16] result (overflow is ignored).  <br /></td></tr>
<tr class="separator:a5c1fe2000e40ddd6ccd91f29dfd4ae0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c017a67c07b606eeaa106c1f7cdf73" id="r_af8c017a67c07b606eeaa106c1f7cdf73"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8c017a67c07b606eeaa106c1f7cdf73">_mm256_add_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:af8c017a67c07b606eeaa106c1f7cdf73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 32-bit integers from corresponding elements of two 256-bit vectors of [8 x i32] and returns the lower 32 bits of each sum in the corresponding element of the [8 x i32] result (overflow is ignored).  <br /></td></tr>
<tr class="separator:af8c017a67c07b606eeaa106c1f7cdf73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67010f3cee987f3dd117a785fc5a8890" id="r_a67010f3cee987f3dd117a785fc5a8890"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67010f3cee987f3dd117a785fc5a8890">_mm256_add_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a67010f3cee987f3dd117a785fc5a8890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 64-bit integers from corresponding elements of two 256-bit vectors of [4 x i64] and returns the lower 64 bits of each sum in the corresponding element of the [4 x i64] result (overflow is ignored).  <br /></td></tr>
<tr class="separator:a67010f3cee987f3dd117a785fc5a8890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd983b6ed3ea7f23bea1deb062b8a72b" id="r_acd983b6ed3ea7f23bea1deb062b8a72b"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd983b6ed3ea7f23bea1deb062b8a72b">_mm256_adds_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:acd983b6ed3ea7f23bea1deb062b8a72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 8-bit integers from corresponding bytes of two 256-bit integer vectors using signed saturation, and returns each sum in the corresponding byte of the 256-bit integer vector result.  <br /></td></tr>
<tr class="separator:acd983b6ed3ea7f23bea1deb062b8a72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52f4d9d816fcdcc2fcd9852c20ccc87" id="r_af52f4d9d816fcdcc2fcd9852c20ccc87"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af52f4d9d816fcdcc2fcd9852c20ccc87">_mm256_adds_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:af52f4d9d816fcdcc2fcd9852c20ccc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] using signed saturation, and returns the [16 x i16] result.  <br /></td></tr>
<tr class="separator:af52f4d9d816fcdcc2fcd9852c20ccc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0d44817e7de48ab8c0774a1d8faae8" id="r_abf0d44817e7de48ab8c0774a1d8faae8"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf0d44817e7de48ab8c0774a1d8faae8">_mm256_adds_epu8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:abf0d44817e7de48ab8c0774a1d8faae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 8-bit integers from corresponding bytes of two 256-bit integer vectors using unsigned saturation, and returns each sum in the corresponding byte of the 256-bit integer vector result.  <br /></td></tr>
<tr class="separator:abf0d44817e7de48ab8c0774a1d8faae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d517ee9448be65c2af608809bab444e" id="r_a4d517ee9448be65c2af608809bab444e"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d517ee9448be65c2af608809bab444e">_mm256_adds_epu16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a4d517ee9448be65c2af608809bab444e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] using unsigned saturation, and returns the [16 x i16] result.  <br /></td></tr>
<tr class="separator:a4d517ee9448be65c2af608809bab444e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b4ece913b92fa300c7fb60a2a70040" id="r_a05b4ece913b92fa300c7fb60a2a70040"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05b4ece913b92fa300c7fb60a2a70040">_mm256_and_si256</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a05b4ece913b92fa300c7fb60a2a70040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise AND of the 256-bit integer vectors in <em>__a</em> and <em>__b</em>.  <br /></td></tr>
<tr class="separator:a05b4ece913b92fa300c7fb60a2a70040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c77b7bf2d8fd2dfb073b14a14b1ba2" id="r_ad3c77b7bf2d8fd2dfb073b14a14b1ba2"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3c77b7bf2d8fd2dfb073b14a14b1ba2">_mm256_andnot_si256</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:ad3c77b7bf2d8fd2dfb073b14a14b1ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise AND of the 256-bit integer vector in <em>__b</em> with the bitwise NOT of the 256-bit integer vector in <em>__a</em>.  <br /></td></tr>
<tr class="separator:ad3c77b7bf2d8fd2dfb073b14a14b1ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bed13563c4899b28a80ee1650f5464" id="r_af8bed13563c4899b28a80ee1650f5464"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8bed13563c4899b28a80ee1650f5464">_mm256_avg_epu8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:af8bed13563c4899b28a80ee1650f5464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the averages of the corresponding unsigned bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns each average in the corresponding byte of the 256-bit result.  <br /></td></tr>
<tr class="separator:af8bed13563c4899b28a80ee1650f5464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22ee1dca08e46d756de99cb7e96969a" id="r_aa22ee1dca08e46d756de99cb7e96969a"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa22ee1dca08e46d756de99cb7e96969a">_mm256_avg_epu16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:aa22ee1dca08e46d756de99cb7e96969a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the averages of the corresponding unsigned 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns each average in the corresponding element of the 256-bit result.  <br /></td></tr>
<tr class="separator:aa22ee1dca08e46d756de99cb7e96969a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62142b089038d77658d0b4b8a0d9cc60" id="r_a62142b089038d77658d0b4b8a0d9cc60"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62142b089038d77658d0b4b8a0d9cc60">_mm256_blendv_epi8</a> (__m256i __V1, __m256i __V2, __m256i __M)</td></tr>
<tr class="memdesc:a62142b089038d77658d0b4b8a0d9cc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges 8-bit integer values from either of the two 256-bit vectors <em>__V1</em> or <em>__V2</em>, as specified by the 256-bit mask <em>__M</em> and returns the resulting 256-bit integer vector.  <br /></td></tr>
<tr class="separator:a62142b089038d77658d0b4b8a0d9cc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c56e14a2dde3eb2c34d1e9d6dcc253d" id="r_a1c56e14a2dde3eb2c34d1e9d6dcc253d"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c56e14a2dde3eb2c34d1e9d6dcc253d">_mm256_cmpeq_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a1c56e14a2dde3eb2c34d1e9d6dcc253d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares corresponding bytes in the 256-bit integer vectors in <em>__a</em> and <em>__b</em> for equality and returns the outcomes in the corresponding bytes of the 256-bit result.  <br /></td></tr>
<tr class="separator:a1c56e14a2dde3eb2c34d1e9d6dcc253d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3995744cd296ba3afe8e63286cc001" id="r_a8d3995744cd296ba3afe8e63286cc001"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d3995744cd296ba3afe8e63286cc001">_mm256_cmpeq_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a8d3995744cd296ba3afe8e63286cc001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares corresponding elements in the 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> for equality and returns the outcomes in the corresponding elements of the 256-bit result.  <br /></td></tr>
<tr class="separator:a8d3995744cd296ba3afe8e63286cc001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08dc58285046d2fcd2f22d810142926" id="r_ab08dc58285046d2fcd2f22d810142926"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab08dc58285046d2fcd2f22d810142926">_mm256_cmpeq_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:ab08dc58285046d2fcd2f22d810142926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares corresponding elements in the 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> for equality and returns the outcomes in the corresponding elements of the 256-bit result.  <br /></td></tr>
<tr class="separator:ab08dc58285046d2fcd2f22d810142926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfc980648d672eb11da414edb750685" id="r_a7dfc980648d672eb11da414edb750685"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dfc980648d672eb11da414edb750685">_mm256_cmpeq_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a7dfc980648d672eb11da414edb750685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares corresponding elements in the 256-bit vectors of [4 x i64] in <em>__a</em> and <em>__b</em> for equality and returns the outcomes in the corresponding elements of the 256-bit result.  <br /></td></tr>
<tr class="separator:a7dfc980648d672eb11da414edb750685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3576feade9f12b451ae0c9c4a0061029" id="r_a3576feade9f12b451ae0c9c4a0061029"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3576feade9f12b451ae0c9c4a0061029">_mm256_cmpgt_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a3576feade9f12b451ae0c9c4a0061029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares corresponding signed bytes in the 256-bit integer vectors in <em>__a</em> and <em>__b</em> for greater-than and returns the outcomes in the corresponding bytes of the 256-bit result.  <br /></td></tr>
<tr class="separator:a3576feade9f12b451ae0c9c4a0061029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786920fc3bb94533373fca034895faec" id="r_a786920fc3bb94533373fca034895faec"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a786920fc3bb94533373fca034895faec">_mm256_cmpgt_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a786920fc3bb94533373fca034895faec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares corresponding signed elements in the 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> for greater-than and returns the outcomes in the corresponding elements of the 256-bit result.  <br /></td></tr>
<tr class="separator:a786920fc3bb94533373fca034895faec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3c233b478906cc78e36cf04610b79a" id="r_a3e3c233b478906cc78e36cf04610b79a"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e3c233b478906cc78e36cf04610b79a">_mm256_cmpgt_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a3e3c233b478906cc78e36cf04610b79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares corresponding signed elements in the 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> for greater-than and returns the outcomes in the corresponding elements of the 256-bit result.  <br /></td></tr>
<tr class="separator:a3e3c233b478906cc78e36cf04610b79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c95c13f7072f5de6a1a81079605e87" id="r_a55c95c13f7072f5de6a1a81079605e87"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55c95c13f7072f5de6a1a81079605e87">_mm256_cmpgt_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a55c95c13f7072f5de6a1a81079605e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares corresponding signed elements in the 256-bit vectors of [4 x i64] in <em>__a</em> and <em>__b</em> for greater-than and returns the outcomes in the corresponding elements of the 256-bit result.  <br /></td></tr>
<tr class="separator:a55c95c13f7072f5de6a1a81079605e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b15ed1ec6a9658484d049d654b4d3f" id="r_a04b15ed1ec6a9658484d049d654b4d3f"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04b15ed1ec6a9658484d049d654b4d3f">_mm256_hadd_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a04b15ed1ec6a9658484d049d654b4d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontally adds the adjacent pairs of 16-bit integers from two 256-bit vectors of [16 x i16] and returns the lower 16 bits of each sum in an element of the [16 x i16] result (overflow is ignored).  <br /></td></tr>
<tr class="separator:a04b15ed1ec6a9658484d049d654b4d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d57af7ba2fcd4ff1fc40bd69a89c1e" id="r_ae2d57af7ba2fcd4ff1fc40bd69a89c1e"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2d57af7ba2fcd4ff1fc40bd69a89c1e">_mm256_hadd_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:ae2d57af7ba2fcd4ff1fc40bd69a89c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontally adds the adjacent pairs of 32-bit integers from two 256-bit vectors of [8 x i32] and returns the lower 32 bits of each sum in an element of the [8 x i32] result (overflow is ignored).  <br /></td></tr>
<tr class="separator:ae2d57af7ba2fcd4ff1fc40bd69a89c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac82b9f1eb9cec755e5bbff0e5a8c9a" id="r_a6ac82b9f1eb9cec755e5bbff0e5a8c9a"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ac82b9f1eb9cec755e5bbff0e5a8c9a">_mm256_hadds_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a6ac82b9f1eb9cec755e5bbff0e5a8c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontally adds the adjacent pairs of 16-bit integers from two 256-bit vectors of [16 x i16] using signed saturation and returns each sum in an element of the [16 x i16] result.  <br /></td></tr>
<tr class="separator:a6ac82b9f1eb9cec755e5bbff0e5a8c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dba9aa45c3b9f52e2acb9016fa2dae" id="r_a47dba9aa45c3b9f52e2acb9016fa2dae"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47dba9aa45c3b9f52e2acb9016fa2dae">_mm256_hsub_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a47dba9aa45c3b9f52e2acb9016fa2dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontally subtracts adjacent pairs of 16-bit integers from two 256-bit vectors of [16 x i16] and returns the lower 16 bits of each difference in an element of the [16 x i16] result (overflow is ignored).  <br /></td></tr>
<tr class="separator:a47dba9aa45c3b9f52e2acb9016fa2dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c77e9df5766726e6bc06112dc97d44" id="r_a72c77e9df5766726e6bc06112dc97d44"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72c77e9df5766726e6bc06112dc97d44">_mm256_hsub_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a72c77e9df5766726e6bc06112dc97d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontally subtracts adjacent pairs of 32-bit integers from two 256-bit vectors of [8 x i32] and returns the lower 32 bits of each difference in an element of the [8 x i32] result (overflow is ignored).  <br /></td></tr>
<tr class="separator:a72c77e9df5766726e6bc06112dc97d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ce513f7958d273eaebafb97d071f4b" id="r_a85ce513f7958d273eaebafb97d071f4b"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85ce513f7958d273eaebafb97d071f4b">_mm256_hsubs_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a85ce513f7958d273eaebafb97d071f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontally subtracts adjacent pairs of 16-bit integers from two 256-bit vectors of [16 x i16] using signed saturation and returns each sum in an element of the [16 x i16] result.  <br /></td></tr>
<tr class="separator:a85ce513f7958d273eaebafb97d071f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1ca72807cf9d112a8db52f1c688400" id="r_a3f1ca72807cf9d112a8db52f1c688400"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f1ca72807cf9d112a8db52f1c688400">_mm256_maddubs_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a3f1ca72807cf9d112a8db52f1c688400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each unsigned byte from the 256-bit integer vector in <em>__a</em> with the corresponding signed byte from the 256-bit integer vector in <em>__b</em>, forming signed 16-bit intermediate products.  <br /></td></tr>
<tr class="separator:a3f1ca72807cf9d112a8db52f1c688400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a736efeb017832345499b28c44af161" id="r_a9a736efeb017832345499b28c44af161"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a736efeb017832345499b28c44af161">_mm256_madd_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a9a736efeb017832345499b28c44af161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies corresponding 16-bit elements of two 256-bit vectors of [16 x i16], forming 32-bit intermediate products, and adds pairs of those products to form 32-bit sums returned as elements of the [8 x i32] result.  <br /></td></tr>
<tr class="separator:a9a736efeb017832345499b28c44af161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b9e0bac773f0d39f3b41ef45d5d68c" id="r_a37b9e0bac773f0d39f3b41ef45d5d68c"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37b9e0bac773f0d39f3b41ef45d5d68c">_mm256_max_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a37b9e0bac773f0d39f3b41ef45d5d68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding signed bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding byte of the 256-bit result.  <br /></td></tr>
<tr class="separator:a37b9e0bac773f0d39f3b41ef45d5d68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5111412077ead099ddee344188839b" id="r_a6c5111412077ead099ddee344188839b"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c5111412077ead099ddee344188839b">_mm256_max_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a6c5111412077ead099ddee344188839b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding signed 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding element of the 256-bit result.  <br /></td></tr>
<tr class="separator:a6c5111412077ead099ddee344188839b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbbe31483e96447c3e05be279bdc57f" id="r_a6fbbe31483e96447c3e05be279bdc57f"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fbbe31483e96447c3e05be279bdc57f">_mm256_max_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a6fbbe31483e96447c3e05be279bdc57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding signed 32-bit integers in the two 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding element of the 256-bit result.  <br /></td></tr>
<tr class="separator:a6fbbe31483e96447c3e05be279bdc57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6210035d203bef654a1f1ade4da7c749" id="r_a6210035d203bef654a1f1ade4da7c749"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6210035d203bef654a1f1ade4da7c749">_mm256_max_epu8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a6210035d203bef654a1f1ade4da7c749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding unsigned bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding byte of the 256-bit result.  <br /></td></tr>
<tr class="separator:a6210035d203bef654a1f1ade4da7c749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075d5a2c501aac700288afa0c508c973" id="r_a075d5a2c501aac700288afa0c508c973"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a075d5a2c501aac700288afa0c508c973">_mm256_max_epu16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a075d5a2c501aac700288afa0c508c973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding unsigned 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding element of the 256-bit result.  <br /></td></tr>
<tr class="separator:a075d5a2c501aac700288afa0c508c973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d1902c5c1b74ba78ba57686e3a5582" id="r_a51d1902c5c1b74ba78ba57686e3a5582"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51d1902c5c1b74ba78ba57686e3a5582">_mm256_max_epu32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a51d1902c5c1b74ba78ba57686e3a5582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding unsigned 32-bit integers in the two 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding element of the 256-bit result.  <br /></td></tr>
<tr class="separator:a51d1902c5c1b74ba78ba57686e3a5582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da8c62a81a77a136d34c0f5b7ee04db" id="r_a2da8c62a81a77a136d34c0f5b7ee04db"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2da8c62a81a77a136d34c0f5b7ee04db">_mm256_min_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a2da8c62a81a77a136d34c0f5b7ee04db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding signed bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding byte of the 256-bit result.  <br /></td></tr>
<tr class="separator:a2da8c62a81a77a136d34c0f5b7ee04db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3167f2bcae02dca2aadba469193eec" id="r_a6a3167f2bcae02dca2aadba469193eec"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a3167f2bcae02dca2aadba469193eec">_mm256_min_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a6a3167f2bcae02dca2aadba469193eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding signed 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding element of the 256-bit result.  <br /></td></tr>
<tr class="separator:a6a3167f2bcae02dca2aadba469193eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96199c8df080cc2b44caf3de79afcd7a" id="r_a96199c8df080cc2b44caf3de79afcd7a"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96199c8df080cc2b44caf3de79afcd7a">_mm256_min_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a96199c8df080cc2b44caf3de79afcd7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding signed 32-bit integers in the two 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding element of the 256-bit result.  <br /></td></tr>
<tr class="separator:a96199c8df080cc2b44caf3de79afcd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa362f07383b28824491e2557d958fbbe" id="r_aa362f07383b28824491e2557d958fbbe"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa362f07383b28824491e2557d958fbbe">_mm256_min_epu8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:aa362f07383b28824491e2557d958fbbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding unsigned bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding byte of the 256-bit result.  <br /></td></tr>
<tr class="separator:aa362f07383b28824491e2557d958fbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189b0c70faa130570dc377be3841baa2" id="r_a189b0c70faa130570dc377be3841baa2"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a189b0c70faa130570dc377be3841baa2">_mm256_min_epu16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a189b0c70faa130570dc377be3841baa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding unsigned 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding element of the 256-bit result.  <br /></td></tr>
<tr class="separator:a189b0c70faa130570dc377be3841baa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20d0653c9d79d3962498325f0a4c65a" id="r_ab20d0653c9d79d3962498325f0a4c65a"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab20d0653c9d79d3962498325f0a4c65a">_mm256_min_epu32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:ab20d0653c9d79d3962498325f0a4c65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding unsigned 32-bit integers in the two 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding element of the 256-bit result.  <br /></td></tr>
<tr class="separator:ab20d0653c9d79d3962498325f0a4c65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0a0e64386916c1945fd80f63800234" id="r_a5e0a0e64386916c1945fd80f63800234"><td class="memItemLeft" align="right" valign="top">static __inline__ <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e0a0e64386916c1945fd80f63800234">_mm256_movemask_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>)</td></tr>
<tr class="separator:a5e0a0e64386916c1945fd80f63800234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1add4929d67f5823d4c81dedfa2d3903" id="r_a1add4929d67f5823d4c81dedfa2d3903"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1add4929d67f5823d4c81dedfa2d3903">_mm256_cvtepi8_epi16</a> (__m128i __V)</td></tr>
<tr class="memdesc:a1add4929d67f5823d4c81dedfa2d3903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extends bytes from the 128-bit integer vector in <em>__V</em> and returns the 16-bit values in the corresponding elements of a 256-bit vector of [16 x i16].  <br /></td></tr>
<tr class="separator:a1add4929d67f5823d4c81dedfa2d3903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f2f0881d66b9de014e6eb8ab3a9dab" id="r_a19f2f0881d66b9de014e6eb8ab3a9dab"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19f2f0881d66b9de014e6eb8ab3a9dab">_mm256_cvtepi8_epi32</a> (__m128i __V)</td></tr>
<tr class="memdesc:a19f2f0881d66b9de014e6eb8ab3a9dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extends bytes from the lower half of the 128-bit integer vector in <em>__V</em> and returns the 32-bit values in the corresponding elements of a 256-bit vector of [8 x i32].  <br /></td></tr>
<tr class="separator:a19f2f0881d66b9de014e6eb8ab3a9dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14d1ebebc75eca235d1f3b8bf5d41c1" id="r_ae14d1ebebc75eca235d1f3b8bf5d41c1"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae14d1ebebc75eca235d1f3b8bf5d41c1">_mm256_cvtepi8_epi64</a> (__m128i __V)</td></tr>
<tr class="memdesc:ae14d1ebebc75eca235d1f3b8bf5d41c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extends the first four bytes from the 128-bit integer vector in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64].  <br /></td></tr>
<tr class="separator:ae14d1ebebc75eca235d1f3b8bf5d41c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061af1a474bed2da900b2cd81a56391c" id="r_a061af1a474bed2da900b2cd81a56391c"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a061af1a474bed2da900b2cd81a56391c">_mm256_cvtepi16_epi32</a> (__m128i __V)</td></tr>
<tr class="memdesc:a061af1a474bed2da900b2cd81a56391c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extends 16-bit elements from the 128-bit vector of [8 x i16] in <em>__V</em> and returns the 32-bit values in the corresponding elements of a 256-bit vector of [8 x i32].  <br /></td></tr>
<tr class="separator:a061af1a474bed2da900b2cd81a56391c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8fb5be9f7b10d9d6370a9d21f27e10" id="r_adb8fb5be9f7b10d9d6370a9d21f27e10"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb8fb5be9f7b10d9d6370a9d21f27e10">_mm256_cvtepi16_epi64</a> (__m128i __V)</td></tr>
<tr class="memdesc:adb8fb5be9f7b10d9d6370a9d21f27e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extends 16-bit elements from the lower half of the 128-bit vector of [8 x i16] in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64].  <br /></td></tr>
<tr class="separator:adb8fb5be9f7b10d9d6370a9d21f27e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc0f7b9b824d94be3162eed4b231f48" id="r_abdc0f7b9b824d94be3162eed4b231f48"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdc0f7b9b824d94be3162eed4b231f48">_mm256_cvtepi32_epi64</a> (__m128i __V)</td></tr>
<tr class="memdesc:abdc0f7b9b824d94be3162eed4b231f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extends 32-bit elements from the 128-bit vector of [4 x i32] in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64].  <br /></td></tr>
<tr class="separator:abdc0f7b9b824d94be3162eed4b231f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae0545e2a12c3e680a30c1ac531f1b9" id="r_a2ae0545e2a12c3e680a30c1ac531f1b9"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ae0545e2a12c3e680a30c1ac531f1b9">_mm256_cvtepu8_epi16</a> (__m128i __V)</td></tr>
<tr class="memdesc:a2ae0545e2a12c3e680a30c1ac531f1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-extends bytes from the 128-bit integer vector in <em>__V</em> and returns the 16-bit values in the corresponding elements of a 256-bit vector of [16 x i16].  <br /></td></tr>
<tr class="separator:a2ae0545e2a12c3e680a30c1ac531f1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046fc39808a85623a1f45aed71d1e16a" id="r_a046fc39808a85623a1f45aed71d1e16a"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a046fc39808a85623a1f45aed71d1e16a">_mm256_cvtepu8_epi32</a> (__m128i __V)</td></tr>
<tr class="memdesc:a046fc39808a85623a1f45aed71d1e16a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-extends bytes from the lower half of the 128-bit integer vector in <em>__V</em> and returns the 32-bit values in the corresponding elements of a 256-bit vector of [8 x i32].  <br /></td></tr>
<tr class="separator:a046fc39808a85623a1f45aed71d1e16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d05a1c6bfc00de679e008cf93f573f" id="r_a97d05a1c6bfc00de679e008cf93f573f"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97d05a1c6bfc00de679e008cf93f573f">_mm256_cvtepu8_epi64</a> (__m128i __V)</td></tr>
<tr class="memdesc:a97d05a1c6bfc00de679e008cf93f573f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-extends the first four bytes from the 128-bit integer vector in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64].  <br /></td></tr>
<tr class="separator:a97d05a1c6bfc00de679e008cf93f573f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b021fb3012738fa4c6dbdfdec1e7ae0" id="r_a7b021fb3012738fa4c6dbdfdec1e7ae0"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b021fb3012738fa4c6dbdfdec1e7ae0">_mm256_cvtepu16_epi32</a> (__m128i __V)</td></tr>
<tr class="memdesc:a7b021fb3012738fa4c6dbdfdec1e7ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-extends 16-bit elements from the 128-bit vector of [8 x i16] in <em>__V</em> and returns the 32-bit values in the corresponding elements of a 256-bit vector of [8 x i32].  <br /></td></tr>
<tr class="separator:a7b021fb3012738fa4c6dbdfdec1e7ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab629f05b42ddb47b7b0928c0799f57e9" id="r_ab629f05b42ddb47b7b0928c0799f57e9"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab629f05b42ddb47b7b0928c0799f57e9">_mm256_cvtepu16_epi64</a> (__m128i __V)</td></tr>
<tr class="memdesc:ab629f05b42ddb47b7b0928c0799f57e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-extends 16-bit elements from the lower half of the 128-bit vector of [8 x i16] in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64].  <br /></td></tr>
<tr class="separator:ab629f05b42ddb47b7b0928c0799f57e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad416d1dc4dc5b103142f8aae139bdf13" id="r_ad416d1dc4dc5b103142f8aae139bdf13"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad416d1dc4dc5b103142f8aae139bdf13">_mm256_cvtepu32_epi64</a> (__m128i __V)</td></tr>
<tr class="memdesc:ad416d1dc4dc5b103142f8aae139bdf13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-extends 32-bit elements from the 128-bit vector of [4 x i32] in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64].  <br /></td></tr>
<tr class="separator:ad416d1dc4dc5b103142f8aae139bdf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f2fd1fb0472301c6f6534fbb2c55b7" id="r_a21f2fd1fb0472301c6f6534fbb2c55b7"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21f2fd1fb0472301c6f6534fbb2c55b7">_mm256_mul_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a21f2fd1fb0472301c6f6534fbb2c55b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies signed 32-bit integers from even-numbered elements of two 256-bit vectors of [8 x i32] and returns the 64-bit products in the [4 x i64] result.  <br /></td></tr>
<tr class="separator:a21f2fd1fb0472301c6f6534fbb2c55b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b7b55f3eed342b5e4054b0625c4b13" id="r_a53b7b55f3eed342b5e4054b0625c4b13"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53b7b55f3eed342b5e4054b0625c4b13">_mm256_mulhrs_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a53b7b55f3eed342b5e4054b0625c4b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies signed 16-bit integer elements of two 256-bit vectors of [16 x i16], truncates the 32-bit results to the most significant 18 bits, rounds by adding 1, and returns bits [16:1] of each rounded product in the [16 x i16] result.  <br /></td></tr>
<tr class="separator:a53b7b55f3eed342b5e4054b0625c4b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901d1db344d0637d0faedf57b68903e8" id="r_a901d1db344d0637d0faedf57b68903e8"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a901d1db344d0637d0faedf57b68903e8">_mm256_mulhi_epu16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a901d1db344d0637d0faedf57b68903e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies unsigned 16-bit integer elements of two 256-bit vectors of [16 x i16], and returns the upper 16 bits of each 32-bit product in the [16 x i16] result.  <br /></td></tr>
<tr class="separator:a901d1db344d0637d0faedf57b68903e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bfbbc6944e651816ee6d43cad179f9" id="r_a77bfbbc6944e651816ee6d43cad179f9"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77bfbbc6944e651816ee6d43cad179f9">_mm256_mulhi_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a77bfbbc6944e651816ee6d43cad179f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies signed 16-bit integer elements of two 256-bit vectors of [16 x i16], and returns the upper 16 bits of each 32-bit product in the [16 x i16] result.  <br /></td></tr>
<tr class="separator:a77bfbbc6944e651816ee6d43cad179f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab877a6985419ea9618d69a329cb88e9f" id="r_ab877a6985419ea9618d69a329cb88e9f"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab877a6985419ea9618d69a329cb88e9f">_mm256_mullo_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:ab877a6985419ea9618d69a329cb88e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies signed 16-bit integer elements of two 256-bit vectors of [16 x i16], and returns the lower 16 bits of each 32-bit product in the [16 x i16] result.  <br /></td></tr>
<tr class="separator:ab877a6985419ea9618d69a329cb88e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c6da5556cf54db6bfc7d51eaf4118b" id="r_a30c6da5556cf54db6bfc7d51eaf4118b"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30c6da5556cf54db6bfc7d51eaf4118b">_mm256_mullo_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a30c6da5556cf54db6bfc7d51eaf4118b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies signed 32-bit integer elements of two 256-bit vectors of [8 x i32], and returns the lower 32 bits of each 64-bit product in the [8 x i32] result.  <br /></td></tr>
<tr class="separator:a30c6da5556cf54db6bfc7d51eaf4118b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82c156df6b966a0780fbf444cf05fac" id="r_ae82c156df6b966a0780fbf444cf05fac"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae82c156df6b966a0780fbf444cf05fac">_mm256_mul_epu32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:ae82c156df6b966a0780fbf444cf05fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies unsigned 32-bit integers from even-numered elements of two 256-bit vectors of [8 x i32] and returns the 64-bit products in the [4 x i64] result.  <br /></td></tr>
<tr class="separator:ae82c156df6b966a0780fbf444cf05fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af941fc48c1c8d082fdfac5df1953156b" id="r_af941fc48c1c8d082fdfac5df1953156b"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af941fc48c1c8d082fdfac5df1953156b">_mm256_or_si256</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:af941fc48c1c8d082fdfac5df1953156b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise OR of the 256-bit integer vectors in <em>__a</em> and <em>__b</em>.  <br /></td></tr>
<tr class="separator:af941fc48c1c8d082fdfac5df1953156b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3080ecebc68a7fcfa068821af41d077" id="r_af3080ecebc68a7fcfa068821af41d077"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3080ecebc68a7fcfa068821af41d077">_mm256_sad_epu8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:af3080ecebc68a7fcfa068821af41d077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes four sum of absolute difference (SAD) operations on sets of eight unsigned 8-bit integers from the 256-bit integer vectors <em>__a</em> and <em>__b</em>.  <br /></td></tr>
<tr class="separator:af3080ecebc68a7fcfa068821af41d077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ead06ffdd788a0be29d1e004cee07a9" id="r_a1ead06ffdd788a0be29d1e004cee07a9"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ead06ffdd788a0be29d1e004cee07a9">_mm256_shuffle_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a1ead06ffdd788a0be29d1e004cee07a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles 8-bit integers in the 256-bit integer vector <em>__a</em> according to control information in the 256-bit integer vector <em>__b</em>, and returns the 256-bit result.  <br /></td></tr>
<tr class="separator:a1ead06ffdd788a0be29d1e004cee07a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77846fd35105eb6f2cbcef08f2b75140" id="r_a77846fd35105eb6f2cbcef08f2b75140"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77846fd35105eb6f2cbcef08f2b75140">_mm256_sign_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a77846fd35105eb6f2cbcef08f2b75140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each byte of the result to the corresponding byte of the 256-bit integer vector in <em>__a</em>, the negative of that byte, or zero, depending on whether the corresponding byte of the 256-bit integer vector in <em>__b</em> is greater than zero, less than zero, or equal to zero, respectively.  <br /></td></tr>
<tr class="separator:a77846fd35105eb6f2cbcef08f2b75140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1cd3c3fea44760c82d99a31a8d830ba" id="r_ae1cd3c3fea44760c82d99a31a8d830ba"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1cd3c3fea44760c82d99a31a8d830ba">_mm256_sign_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:ae1cd3c3fea44760c82d99a31a8d830ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each element of the result to the corresponding element of the 256-bit vector of [16 x i16] in <em>__a</em>, the negative of that element, or zero, depending on whether the corresponding element of the 256-bit vector of [16 x i16] in <em>__b</em> is greater than zero, less than zero, or equal to zero, respectively.  <br /></td></tr>
<tr class="separator:ae1cd3c3fea44760c82d99a31a8d830ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67755b8ffa509f28de03a05df580fbc1" id="r_a67755b8ffa509f28de03a05df580fbc1"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67755b8ffa509f28de03a05df580fbc1">_mm256_sign_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a67755b8ffa509f28de03a05df580fbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each element of the result to the corresponding element of the 256-bit vector of [8 x i32] in <em>__a</em>, the negative of that element, or zero, depending on whether the corresponding element of the 256-bit vector of [8 x i32] in <em>__b</em> is greater than zero, less than zero, or equal to zero, respectively.  <br /></td></tr>
<tr class="separator:a67755b8ffa509f28de03a05df580fbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9142525f9097a70a473365d4819be609" id="r_a9142525f9097a70a473365d4819be609"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9142525f9097a70a473365d4819be609">_mm256_slli_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> __count)</td></tr>
<tr class="memdesc:a9142525f9097a70a473365d4819be609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> left by <em>__count</em> bits, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:a9142525f9097a70a473365d4819be609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5606790c952e969809a59ddf1e3510cf" id="r_a5606790c952e969809a59ddf1e3510cf"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5606790c952e969809a59ddf1e3510cf">_mm256_sll_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m128i __count)</td></tr>
<tr class="memdesc:a5606790c952e969809a59ddf1e3510cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> left by the number of bits specified by the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:a5606790c952e969809a59ddf1e3510cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8e153c8a1e0c5b909a192ccec34187" id="r_a1c8e153c8a1e0c5b909a192ccec34187"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c8e153c8a1e0c5b909a192ccec34187">_mm256_slli_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> __count)</td></tr>
<tr class="memdesc:a1c8e153c8a1e0c5b909a192ccec34187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> left by <em>__count</em> bits, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:a1c8e153c8a1e0c5b909a192ccec34187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bff83b0c5ed8e28733927ba2ab93296" id="r_a0bff83b0c5ed8e28733927ba2ab93296"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bff83b0c5ed8e28733927ba2ab93296">_mm256_sll_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m128i __count)</td></tr>
<tr class="memdesc:a0bff83b0c5ed8e28733927ba2ab93296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> left by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:a0bff83b0c5ed8e28733927ba2ab93296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40e1a7a9fd378072b072fbc369db480" id="r_ad40e1a7a9fd378072b072fbc369db480"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad40e1a7a9fd378072b072fbc369db480">_mm256_slli_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> __count)</td></tr>
<tr class="memdesc:ad40e1a7a9fd378072b072fbc369db480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__a</em> left by <em>__count</em> bits, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:ad40e1a7a9fd378072b072fbc369db480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160466de250277c0621a1914f45cc2a2" id="r_a160466de250277c0621a1914f45cc2a2"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a160466de250277c0621a1914f45cc2a2">_mm256_sll_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m128i __count)</td></tr>
<tr class="memdesc:a160466de250277c0621a1914f45cc2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__a</em> left by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:a160466de250277c0621a1914f45cc2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9640e28a301bd54f3c6eba51e91180" id="r_abb9640e28a301bd54f3c6eba51e91180"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb9640e28a301bd54f3c6eba51e91180">_mm256_srai_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> __count)</td></tr>
<tr class="memdesc:abb9640e28a301bd54f3c6eba51e91180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> right by <em>__count</em> bits, shifting in sign bits, and returns the result.  <br /></td></tr>
<tr class="separator:abb9640e28a301bd54f3c6eba51e91180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6812ecb21f05132dbb5ce31ed82aabe" id="r_ad6812ecb21f05132dbb5ce31ed82aabe"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6812ecb21f05132dbb5ce31ed82aabe">_mm256_sra_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m128i __count)</td></tr>
<tr class="memdesc:ad6812ecb21f05132dbb5ce31ed82aabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in sign bits, and returns the result.  <br /></td></tr>
<tr class="separator:ad6812ecb21f05132dbb5ce31ed82aabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241b64b22d24b260ffb9a7018b1f8cca" id="r_a241b64b22d24b260ffb9a7018b1f8cca"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a241b64b22d24b260ffb9a7018b1f8cca">_mm256_srai_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> __count)</td></tr>
<tr class="memdesc:a241b64b22d24b260ffb9a7018b1f8cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> right by <em>__count</em> bits, shifting in sign bits, and returns the result.  <br /></td></tr>
<tr class="separator:a241b64b22d24b260ffb9a7018b1f8cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933b5cc7264b4572e61702aa385250c6" id="r_a933b5cc7264b4572e61702aa385250c6"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a933b5cc7264b4572e61702aa385250c6">_mm256_sra_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m128i __count)</td></tr>
<tr class="memdesc:a933b5cc7264b4572e61702aa385250c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in sign bits, and returns the result.  <br /></td></tr>
<tr class="separator:a933b5cc7264b4572e61702aa385250c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd37fdb3fd0ebf8b12261a4c5eb325e" id="r_afdd37fdb3fd0ebf8b12261a4c5eb325e"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdd37fdb3fd0ebf8b12261a4c5eb325e">_mm256_srli_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> __count)</td></tr>
<tr class="memdesc:afdd37fdb3fd0ebf8b12261a4c5eb325e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> right by <em>__count</em> bits, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:afdd37fdb3fd0ebf8b12261a4c5eb325e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0204190987d295602363fac8e957bc88" id="r_a0204190987d295602363fac8e957bc88"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0204190987d295602363fac8e957bc88">_mm256_srl_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m128i __count)</td></tr>
<tr class="memdesc:a0204190987d295602363fac8e957bc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:a0204190987d295602363fac8e957bc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa577e01c74cd9071fb09c857fad1c2" id="r_acfa577e01c74cd9071fb09c857fad1c2"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfa577e01c74cd9071fb09c857fad1c2">_mm256_srli_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> __count)</td></tr>
<tr class="memdesc:acfa577e01c74cd9071fb09c857fad1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> right by <em>__count</em> bits, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:acfa577e01c74cd9071fb09c857fad1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006440af4ed63245caff87056b25c3d1" id="r_a006440af4ed63245caff87056b25c3d1"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a006440af4ed63245caff87056b25c3d1">_mm256_srl_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m128i __count)</td></tr>
<tr class="memdesc:a006440af4ed63245caff87056b25c3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:a006440af4ed63245caff87056b25c3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ca9a97310214d3f0e85302dd877dc5" id="r_a00ca9a97310214d3f0e85302dd877dc5"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00ca9a97310214d3f0e85302dd877dc5">_mm256_srli_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> __count)</td></tr>
<tr class="memdesc:a00ca9a97310214d3f0e85302dd877dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__a</em> right by <em>__count</em> bits, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:a00ca9a97310214d3f0e85302dd877dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf26700184b5a83da79aca8f9ade7fc3" id="r_acf26700184b5a83da79aca8f9ade7fc3"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf26700184b5a83da79aca8f9ade7fc3">_mm256_srl_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m128i __count)</td></tr>
<tr class="memdesc:acf26700184b5a83da79aca8f9ade7fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:acf26700184b5a83da79aca8f9ade7fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbe41f0f99a6839f3c4a5d4d992ca2a" id="r_a8fbe41f0f99a6839f3c4a5d4d992ca2a"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fbe41f0f99a6839f3c4a5d4d992ca2a">_mm256_sub_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a8fbe41f0f99a6839f3c4a5d4d992ca2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 8-bit integers from corresponding bytes of two 256-bit integer vectors.  <br /></td></tr>
<tr class="separator:a8fbe41f0f99a6839f3c4a5d4d992ca2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e2c682612c87d32af88011175c7893" id="r_a31e2c682612c87d32af88011175c7893"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31e2c682612c87d32af88011175c7893">_mm256_sub_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a31e2c682612c87d32af88011175c7893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16].  <br /></td></tr>
<tr class="separator:a31e2c682612c87d32af88011175c7893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab606b56493b9e67d5aa9413c66bd27cd" id="r_ab606b56493b9e67d5aa9413c66bd27cd"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab606b56493b9e67d5aa9413c66bd27cd">_mm256_sub_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:ab606b56493b9e67d5aa9413c66bd27cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 32-bit integers from corresponding elements of two 256-bit vectors of [8 x i32].  <br /></td></tr>
<tr class="separator:ab606b56493b9e67d5aa9413c66bd27cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4f41e586cb7b8643ffdee43f3a6ce6" id="r_a3b4f41e586cb7b8643ffdee43f3a6ce6"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b4f41e586cb7b8643ffdee43f3a6ce6">_mm256_sub_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a3b4f41e586cb7b8643ffdee43f3a6ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 64-bit integers from corresponding elements of two 256-bit vectors of [4 x i64].  <br /></td></tr>
<tr class="separator:a3b4f41e586cb7b8643ffdee43f3a6ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9a78b79f3e386367de719217e8b9b1" id="r_a5e9a78b79f3e386367de719217e8b9b1"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e9a78b79f3e386367de719217e8b9b1">_mm256_subs_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a5e9a78b79f3e386367de719217e8b9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 8-bit integers from corresponding bytes of two 256-bit integer vectors using signed saturation, and returns each differences in the corresponding byte of the 256-bit integer vector result.  <br /></td></tr>
<tr class="separator:a5e9a78b79f3e386367de719217e8b9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac62e43e232e2fe74019c3839e22d0ea" id="r_aac62e43e232e2fe74019c3839e22d0ea"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac62e43e232e2fe74019c3839e22d0ea">_mm256_subs_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:aac62e43e232e2fe74019c3839e22d0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] using signed saturation, and returns each difference in the corresponding element of the [16 x i16] result.  <br /></td></tr>
<tr class="separator:aac62e43e232e2fe74019c3839e22d0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af8efc1fee79411d45f2094d6a5bd6b" id="r_a2af8efc1fee79411d45f2094d6a5bd6b"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2af8efc1fee79411d45f2094d6a5bd6b">_mm256_subs_epu8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a2af8efc1fee79411d45f2094d6a5bd6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 8-bit integers from corresponding bytes of two 256-bit integer vectors using unsigned saturation, and returns each difference in the corresponding byte of the 256-bit integer vector result.  <br /></td></tr>
<tr class="separator:a2af8efc1fee79411d45f2094d6a5bd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2bf28cc66f89d73790bcaed2e6e502" id="r_afd2bf28cc66f89d73790bcaed2e6e502"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd2bf28cc66f89d73790bcaed2e6e502">_mm256_subs_epu16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:afd2bf28cc66f89d73790bcaed2e6e502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] using unsigned saturation, and returns each difference in the corresponding element of the [16 x i16] result.  <br /></td></tr>
<tr class="separator:afd2bf28cc66f89d73790bcaed2e6e502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4358789fa27173bf6e2d7b10c73418fd" id="r_a4358789fa27173bf6e2d7b10c73418fd"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4358789fa27173bf6e2d7b10c73418fd">_mm256_unpackhi_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a4358789fa27173bf6e2d7b10c73418fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks and interleaves 8-bit integers from parts of the 256-bit integer vectors in <em>__a</em> and <em>__b</em> to form the 256-bit result.  <br /></td></tr>
<tr class="separator:a4358789fa27173bf6e2d7b10c73418fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bb3e33051c22956a29e267c841ce2c" id="r_a76bb3e33051c22956a29e267c841ce2c"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76bb3e33051c22956a29e267c841ce2c">_mm256_unpackhi_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a76bb3e33051c22956a29e267c841ce2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks and interleaves 16-bit integers from parts of the 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [16 x i16].  <br /></td></tr>
<tr class="separator:a76bb3e33051c22956a29e267c841ce2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4d291187e5354e99a80fa31e0a2599" id="r_a6d4d291187e5354e99a80fa31e0a2599"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d4d291187e5354e99a80fa31e0a2599">_mm256_unpackhi_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a6d4d291187e5354e99a80fa31e0a2599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks and interleaves 32-bit integers from parts of the 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [8 x i32].  <br /></td></tr>
<tr class="separator:a6d4d291187e5354e99a80fa31e0a2599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53f37866e6d12b621cd8dd638dcfe49" id="r_ac53f37866e6d12b621cd8dd638dcfe49"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac53f37866e6d12b621cd8dd638dcfe49">_mm256_unpackhi_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:ac53f37866e6d12b621cd8dd638dcfe49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks and interleaves 64-bit integers from parts of the 256-bit vectors of [4 x i64] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [4 x i64].  <br /></td></tr>
<tr class="separator:ac53f37866e6d12b621cd8dd638dcfe49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1606df7412921d94f00a69091b79fd" id="r_aac1606df7412921d94f00a69091b79fd"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac1606df7412921d94f00a69091b79fd">_mm256_unpacklo_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:aac1606df7412921d94f00a69091b79fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks and interleaves 8-bit integers from parts of the 256-bit integer vectors in <em>__a</em> and <em>__b</em> to form the 256-bit result.  <br /></td></tr>
<tr class="separator:aac1606df7412921d94f00a69091b79fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc29f2b775e0c3d34958e970252c37c0" id="r_abc29f2b775e0c3d34958e970252c37c0"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc29f2b775e0c3d34958e970252c37c0">_mm256_unpacklo_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:abc29f2b775e0c3d34958e970252c37c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks and interleaves 16-bit integers from parts of the 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [16 x i16].  <br /></td></tr>
<tr class="separator:abc29f2b775e0c3d34958e970252c37c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48355543080a7cbf1fcc3d38c8636b3d" id="r_a48355543080a7cbf1fcc3d38c8636b3d"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48355543080a7cbf1fcc3d38c8636b3d">_mm256_unpacklo_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a48355543080a7cbf1fcc3d38c8636b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks and interleaves 32-bit integers from parts of the 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [8 x i32].  <br /></td></tr>
<tr class="separator:a48355543080a7cbf1fcc3d38c8636b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d22290d67e283811757c56bf20ab0f4" id="r_a0d22290d67e283811757c56bf20ab0f4"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d22290d67e283811757c56bf20ab0f4">_mm256_unpacklo_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a0d22290d67e283811757c56bf20ab0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks and interleaves 64-bit integers from parts of the 256-bit vectors of [4 x i64] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [4 x i64].  <br /></td></tr>
<tr class="separator:a0d22290d67e283811757c56bf20ab0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb76d9ee538f1556ce95a0a309224da" id="r_a5cb76d9ee538f1556ce95a0a309224da"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cb76d9ee538f1556ce95a0a309224da">_mm256_xor_si256</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a5cb76d9ee538f1556ce95a0a309224da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise XOR of the 256-bit integer vectors in <em>__a</em> and <em>__b</em>.  <br /></td></tr>
<tr class="separator:a5cb76d9ee538f1556ce95a0a309224da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41588e2cc5a224f9bd0f545d33419f4" id="r_aa41588e2cc5a224f9bd0f545d33419f4"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa41588e2cc5a224f9bd0f545d33419f4">_mm256_stream_load_si256</a> (__m256i const *__V)</td></tr>
<tr class="memdesc:aa41588e2cc5a224f9bd0f545d33419f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the 256-bit integer vector from memory <em>__V</em> using a non-temporal memory hint and returns the vector.  <br /></td></tr>
<tr class="separator:aa41588e2cc5a224f9bd0f545d33419f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7636713aae00b362d71015a3f444d079" id="r_a7636713aae00b362d71015a3f444d079"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128 <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7636713aae00b362d71015a3f444d079">_mm_broadcastss_ps</a> (__m128 __X)</td></tr>
<tr class="memdesc:a7636713aae00b362d71015a3f444d079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the 32-bit floating-point value from the low element of the 128-bit vector of [4 x float] in <em>__X</em> to all elements of the result's 128-bit vector of [4 x float].  <br /></td></tr>
<tr class="separator:a7636713aae00b362d71015a3f444d079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aed0394b1e2f9ff4a0a8099637dd3d3" id="r_a9aed0394b1e2f9ff4a0a8099637dd3d3"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128d <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9aed0394b1e2f9ff4a0a8099637dd3d3">_mm_broadcastsd_pd</a> (__m128d <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>)</td></tr>
<tr class="memdesc:a9aed0394b1e2f9ff4a0a8099637dd3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the 64-bit floating-point value from the low element of the 128-bit vector of [2 x double] in <em>__a</em> to both elements of the result's 128-bit vector of [2 x double].  <br /></td></tr>
<tr class="separator:a9aed0394b1e2f9ff4a0a8099637dd3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5947990d7f735029f6d858c99e76ee0" id="r_af5947990d7f735029f6d858c99e76ee0"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256 <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5947990d7f735029f6d858c99e76ee0">_mm256_broadcastss_ps</a> (__m128 __X)</td></tr>
<tr class="memdesc:af5947990d7f735029f6d858c99e76ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the 32-bit floating-point value from the low element of the 128-bit vector of [4 x float] in <em>__X</em> to all elements of the result's 256-bit vector of [8 x float].  <br /></td></tr>
<tr class="separator:af5947990d7f735029f6d858c99e76ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bea69dd9bbf4de7be8b17aa32918268" id="r_a5bea69dd9bbf4de7be8b17aa32918268"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256d <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bea69dd9bbf4de7be8b17aa32918268">_mm256_broadcastsd_pd</a> (__m128d __X)</td></tr>
<tr class="memdesc:a5bea69dd9bbf4de7be8b17aa32918268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the 64-bit floating-point value from the low element of the 128-bit vector of [2 x double] in <em>__X</em> to all elements of the result's 256-bit vector of [4 x double].  <br /></td></tr>
<tr class="separator:a5bea69dd9bbf4de7be8b17aa32918268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7018cff60b93116947e57eea1f1c63" id="r_a4f7018cff60b93116947e57eea1f1c63"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f7018cff60b93116947e57eea1f1c63">_mm256_broadcastsi128_si256</a> (__m128i __X)</td></tr>
<tr class="memdesc:a4f7018cff60b93116947e57eea1f1c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the 128-bit integer data from <em>__X</em> to both the lower and upper halves of the 256-bit result.  <br /></td></tr>
<tr class="separator:a4f7018cff60b93116947e57eea1f1c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b65c7f74b80298dd753b067bb5ba42" id="r_a75b65c7f74b80298dd753b067bb5ba42"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75b65c7f74b80298dd753b067bb5ba42">_mm256_broadcastb_epi8</a> (__m128i __X)</td></tr>
<tr class="memdesc:a75b65c7f74b80298dd753b067bb5ba42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the low byte from the 128-bit integer vector in <em>__X</em> to all bytes of the 256-bit result.  <br /></td></tr>
<tr class="separator:a75b65c7f74b80298dd753b067bb5ba42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f81e03d536bf939f44b377b365f102" id="r_ab7f81e03d536bf939f44b377b365f102"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7f81e03d536bf939f44b377b365f102">_mm256_broadcastw_epi16</a> (__m128i __X)</td></tr>
<tr class="memdesc:ab7f81e03d536bf939f44b377b365f102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the low element from the 128-bit vector of [8 x i16] in <em>__X</em> to all elements of the result's 256-bit vector of [16 x i16].  <br /></td></tr>
<tr class="separator:ab7f81e03d536bf939f44b377b365f102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad902bf9f90ecbfc92a4ad3fd87b9ceb3" id="r_ad902bf9f90ecbfc92a4ad3fd87b9ceb3"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad902bf9f90ecbfc92a4ad3fd87b9ceb3">_mm256_broadcastd_epi32</a> (__m128i __X)</td></tr>
<tr class="memdesc:ad902bf9f90ecbfc92a4ad3fd87b9ceb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the low element from the 128-bit vector of [4 x i32] in <em>__X</em> to all elements of the result's 256-bit vector of [8 x i32].  <br /></td></tr>
<tr class="separator:ad902bf9f90ecbfc92a4ad3fd87b9ceb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd93adcfd69f94269bd751d664199481" id="r_afd93adcfd69f94269bd751d664199481"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd93adcfd69f94269bd751d664199481">_mm256_broadcastq_epi64</a> (__m128i __X)</td></tr>
<tr class="memdesc:afd93adcfd69f94269bd751d664199481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the low element from the 128-bit vector of [2 x i64] in <em>__X</em> to all elements of the result's 256-bit vector of [4 x i64].  <br /></td></tr>
<tr class="separator:afd93adcfd69f94269bd751d664199481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2719f57e8449edf0a868707685fcbfba" id="r_a2719f57e8449edf0a868707685fcbfba"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2719f57e8449edf0a868707685fcbfba">_mm_broadcastb_epi8</a> (__m128i __X)</td></tr>
<tr class="memdesc:a2719f57e8449edf0a868707685fcbfba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the low byte from the 128-bit integer vector in <em>__X</em> to all bytes of the 128-bit result.  <br /></td></tr>
<tr class="separator:a2719f57e8449edf0a868707685fcbfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865b5e9e77ac8e5f7f639806936c7113" id="r_a865b5e9e77ac8e5f7f639806936c7113"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a865b5e9e77ac8e5f7f639806936c7113">_mm_broadcastw_epi16</a> (__m128i __X)</td></tr>
<tr class="memdesc:a865b5e9e77ac8e5f7f639806936c7113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the low element from the 128-bit vector of [8 x i16] in <em>__X</em> to all elements of the result's 128-bit vector of [8 x i16].  <br /></td></tr>
<tr class="separator:a865b5e9e77ac8e5f7f639806936c7113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f391075669a7b417e83af174398a9b" id="r_a10f391075669a7b417e83af174398a9b"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10f391075669a7b417e83af174398a9b">_mm_broadcastd_epi32</a> (__m128i __X)</td></tr>
<tr class="memdesc:a10f391075669a7b417e83af174398a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the low element from the 128-bit vector of [4 x i32] in <em>__X</em> to all elements of the result's vector of [4 x i32].  <br /></td></tr>
<tr class="separator:a10f391075669a7b417e83af174398a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace283494a6faf8c26cb5553c007a78ef" id="r_ace283494a6faf8c26cb5553c007a78ef"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace283494a6faf8c26cb5553c007a78ef">_mm_broadcastq_epi64</a> (__m128i __X)</td></tr>
<tr class="memdesc:ace283494a6faf8c26cb5553c007a78ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the low element from the 128-bit vector of [2 x i64] in <em>__X</em> to both elements of the result's 128-bit vector of [2 x i64].  <br /></td></tr>
<tr class="separator:ace283494a6faf8c26cb5553c007a78ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d9bff425325a7c8e2a4f857e3d0b22" id="r_a33d9bff425325a7c8e2a4f857e3d0b22"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33d9bff425325a7c8e2a4f857e3d0b22">_mm256_permutevar8x32_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a33d9bff425325a7c8e2a4f857e3d0b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the result's 256-bit vector of [8 x i32] to copies of elements of the 256-bit vector of [8 x i32] in <em>__a</em> as specified by indexes in the elements of the 256-bit vector of [8 x i32] in <em>__b</em>.  <br /></td></tr>
<tr class="separator:a33d9bff425325a7c8e2a4f857e3d0b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4284aa3d71d30c3241c1ea550f4429" id="r_a5c4284aa3d71d30c3241c1ea550f4429"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256 <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c4284aa3d71d30c3241c1ea550f4429">_mm256_permutevar8x32_ps</a> (__m256 <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="altivec_8h.html#a3b7847b4baaef93a94ce8bf3f59f64ab">__b</a>)</td></tr>
<tr class="memdesc:a5c4284aa3d71d30c3241c1ea550f4429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the result's 256-bit vector of [8 x float] to copies of elements of the 256-bit vector of [8 x float] in <em>__a</em> as specified by indexes in the elements of the 256-bit vector of [8 x i32] in <em>__b</em>.  <br /></td></tr>
<tr class="separator:a5c4284aa3d71d30c3241c1ea550f4429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fd743b1c2f9aed720704b10114e42c" id="r_a22fd743b1c2f9aed720704b10114e42c"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22fd743b1c2f9aed720704b10114e42c">_mm256_maskload_epi32</a> (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> const *__X, __m256i __M)</td></tr>
<tr class="memdesc:a22fd743b1c2f9aed720704b10114e42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally loads eight 32-bit integer elements from memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, sets that element of the result to zero.  <br /></td></tr>
<tr class="separator:a22fd743b1c2f9aed720704b10114e42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1997e59ad47611e448defb72da464056" id="r_a1997e59ad47611e448defb72da464056"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1997e59ad47611e448defb72da464056">_mm256_maskload_epi64</a> (long long const *__X, __m256i __M)</td></tr>
<tr class="memdesc:a1997e59ad47611e448defb72da464056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally loads four 64-bit integer elements from memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, sets that element of the result to zero.  <br /></td></tr>
<tr class="separator:a1997e59ad47611e448defb72da464056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694947e72cdcd91cace9252259d8cc9e" id="r_a694947e72cdcd91cace9252259d8cc9e"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a694947e72cdcd91cace9252259d8cc9e">_mm_maskload_epi32</a> (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> const *__X, __m128i __M)</td></tr>
<tr class="memdesc:a694947e72cdcd91cace9252259d8cc9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally loads four 32-bit integer elements from memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, sets that element of the result to zero.  <br /></td></tr>
<tr class="separator:a694947e72cdcd91cace9252259d8cc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf51c2e90947a2569e048166b39e4495" id="r_adf51c2e90947a2569e048166b39e4495"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf51c2e90947a2569e048166b39e4495">_mm_maskload_epi64</a> (long long const *__X, __m128i __M)</td></tr>
<tr class="memdesc:adf51c2e90947a2569e048166b39e4495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally loads two 64-bit integer elements from memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, sets that element of the result to zero.  <br /></td></tr>
<tr class="separator:adf51c2e90947a2569e048166b39e4495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf351469e97da264116eea7952c2aba" id="r_a1bf351469e97da264116eea7952c2aba"><td class="memItemLeft" align="right" valign="top">static __inline__ void <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bf351469e97da264116eea7952c2aba">_mm256_maskstore_epi32</a> (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> *__X, __m256i __M, __m256i <a class="el" href="ppc__wrappers_2bmi2intrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a1bf351469e97da264116eea7952c2aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally stores eight 32-bit integer elements from the 256-bit vector of [8 x i32] in <em>__Y</em> to memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, the memory element is unchanged.  <br /></td></tr>
<tr class="separator:a1bf351469e97da264116eea7952c2aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0559634edb55b319e7ee19baac957c95" id="r_a0559634edb55b319e7ee19baac957c95"><td class="memItemLeft" align="right" valign="top">static __inline__ void <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0559634edb55b319e7ee19baac957c95">_mm256_maskstore_epi64</a> (long long *__X, __m256i __M, __m256i <a class="el" href="ppc__wrappers_2bmi2intrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a0559634edb55b319e7ee19baac957c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally stores four 64-bit integer elements from the 256-bit vector of [4 x i64] in <em>__Y</em> to memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, the memory element is unchanged.  <br /></td></tr>
<tr class="separator:a0559634edb55b319e7ee19baac957c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d960541afa801cef10bec77aac5e258" id="r_a8d960541afa801cef10bec77aac5e258"><td class="memItemLeft" align="right" valign="top">static __inline__ void <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d960541afa801cef10bec77aac5e258">_mm_maskstore_epi32</a> (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> *__X, __m128i __M, __m128i <a class="el" href="ppc__wrappers_2bmi2intrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a8d960541afa801cef10bec77aac5e258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally stores four 32-bit integer elements from the 128-bit vector of [4 x i32] in <em>__Y</em> to memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, the memory element is unchanged.  <br /></td></tr>
<tr class="separator:a8d960541afa801cef10bec77aac5e258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582da479a1ada35c7316c4deab34adfd" id="r_a582da479a1ada35c7316c4deab34adfd"><td class="memItemLeft" align="right" valign="top">static __inline__ void <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a582da479a1ada35c7316c4deab34adfd">_mm_maskstore_epi64</a> (long long *__X, __m128i __M, __m128i <a class="el" href="ppc__wrappers_2bmi2intrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a582da479a1ada35c7316c4deab34adfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally stores two 64-bit integer elements from the 128-bit vector of [2 x i64] in <em>__Y</em> to memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, the memory element is unchanged.  <br /></td></tr>
<tr class="separator:a582da479a1ada35c7316c4deab34adfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d8eebf24183f66e3cd905501948068" id="r_a71d8eebf24183f66e3cd905501948068"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71d8eebf24183f66e3cd905501948068">_mm256_sllv_epi32</a> (__m256i __X, __m256i <a class="el" href="ppc__wrappers_2bmi2intrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a71d8eebf24183f66e3cd905501948068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__X</em> left by the number of bits given in the corresponding element of the 256-bit vector of [8 x i32] in <em>__Y</em>, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:a71d8eebf24183f66e3cd905501948068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699470176eaef166e2a71c026aa85cfc" id="r_a699470176eaef166e2a71c026aa85cfc"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a699470176eaef166e2a71c026aa85cfc">_mm_sllv_epi32</a> (__m128i __X, __m128i <a class="el" href="ppc__wrappers_2bmi2intrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a699470176eaef166e2a71c026aa85cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 128-bit vector of [4 x i32] in <em>__X</em> left by the number of bits given in the corresponding element of the 128-bit vector of [4 x i32] in <em>__Y</em>, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:a699470176eaef166e2a71c026aa85cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d328c38377911cc60da2a7c6d5363f5" id="r_a3d328c38377911cc60da2a7c6d5363f5"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d328c38377911cc60da2a7c6d5363f5">_mm256_sllv_epi64</a> (__m256i __X, __m256i <a class="el" href="ppc__wrappers_2bmi2intrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a3d328c38377911cc60da2a7c6d5363f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__X</em> left by the number of bits given in the corresponding element of the 128-bit vector of [4 x i64] in <em>__Y</em>, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:a3d328c38377911cc60da2a7c6d5363f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec60ec05d6c5e57a8cce91a77f75603d" id="r_aec60ec05d6c5e57a8cce91a77f75603d"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec60ec05d6c5e57a8cce91a77f75603d">_mm_sllv_epi64</a> (__m128i __X, __m128i <a class="el" href="ppc__wrappers_2bmi2intrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:aec60ec05d6c5e57a8cce91a77f75603d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 64-bit element of the 128-bit vector of [2 x i64] in <em>__X</em> left by the number of bits given in the corresponding element of the 128-bit vector of [2 x i64] in <em>__Y</em>, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:aec60ec05d6c5e57a8cce91a77f75603d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58df154a23884308de2be8f1673431bb" id="r_a58df154a23884308de2be8f1673431bb"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58df154a23884308de2be8f1673431bb">_mm256_srav_epi32</a> (__m256i __X, __m256i <a class="el" href="ppc__wrappers_2bmi2intrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a58df154a23884308de2be8f1673431bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__X</em> right by the number of bits given in the corresponding element of the 256-bit vector of [8 x i32] in <em>__Y</em>, shifting in sign bits, and returns the result.  <br /></td></tr>
<tr class="separator:a58df154a23884308de2be8f1673431bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ac7327486a0d44f7f4154ac337bb85" id="r_a95ac7327486a0d44f7f4154ac337bb85"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95ac7327486a0d44f7f4154ac337bb85">_mm_srav_epi32</a> (__m128i __X, __m128i <a class="el" href="ppc__wrappers_2bmi2intrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a95ac7327486a0d44f7f4154ac337bb85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 128-bit vector of [4 x i32] in <em>__X</em> right by the number of bits given in the corresponding element of the 128-bit vector of [4 x i32] in <em>__Y</em>, shifting in sign bits, and returns the result.  <br /></td></tr>
<tr class="separator:a95ac7327486a0d44f7f4154ac337bb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc3e0a1a4e2bbbc72630cf26ed54225" id="r_a9cc3e0a1a4e2bbbc72630cf26ed54225"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cc3e0a1a4e2bbbc72630cf26ed54225">_mm256_srlv_epi32</a> (__m256i __X, __m256i <a class="el" href="ppc__wrappers_2bmi2intrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a9cc3e0a1a4e2bbbc72630cf26ed54225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__X</em> right by the number of bits given in the corresponding element of the 256-bit vector of [8 x i32] in <em>__Y</em>, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:a9cc3e0a1a4e2bbbc72630cf26ed54225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb295f9dbef670b0a134d834e5f279a" id="r_a5eb295f9dbef670b0a134d834e5f279a"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5eb295f9dbef670b0a134d834e5f279a">_mm_srlv_epi32</a> (__m128i __X, __m128i <a class="el" href="ppc__wrappers_2bmi2intrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a5eb295f9dbef670b0a134d834e5f279a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 128-bit vector of [4 x i32] in <em>__X</em> right by the number of bits given in the corresponding element of the 128-bit vector of [4 x i32] in <em>__Y</em>, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:a5eb295f9dbef670b0a134d834e5f279a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77501391ed2c52d990a2c4004e86c36d" id="r_a77501391ed2c52d990a2c4004e86c36d"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77501391ed2c52d990a2c4004e86c36d">_mm256_srlv_epi64</a> (__m256i __X, __m256i <a class="el" href="ppc__wrappers_2bmi2intrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a77501391ed2c52d990a2c4004e86c36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__X</em> right by the number of bits given in the corresponding element of the 128-bit vector of [4 x i64] in <em>__Y</em>, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:a77501391ed2c52d990a2c4004e86c36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619b2e23f9247af334811e4b6ec75f40" id="r_a619b2e23f9247af334811e4b6ec75f40"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a619b2e23f9247af334811e4b6ec75f40">_mm_srlv_epi64</a> (__m128i __X, __m128i <a class="el" href="ppc__wrappers_2bmi2intrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a619b2e23f9247af334811e4b6ec75f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 64-bit element of the 128-bit vector of [2 x i64] in <em>__X</em> right by the number of bits given in the corresponding element of the 128-bit vector of [2 x i64] in <em>__Y</em>, shifting in zero bits, and returns the result.  <br /></td></tr>
<tr class="separator:a619b2e23f9247af334811e4b6ec75f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aa5269551cf777adb9ce7ae4726145df2" name="aa5269551cf777adb9ce7ae4726145df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5269551cf777adb9ce7ae4726145df2">&#9670;&#160;</a></span>__DEFAULT_FN_ATTRS128</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __DEFAULT_FN_ATTRS128&#160;&#160;&#160;<a class="el" href="____clang__hip__libdevice__declares_8h.html#a3da0931a820e46f95754b07f9b413d58">__attribute__</a>((__always_inline__, __nodebug__, __target__(&quot;avx2&quot;), __min_vector_width__(128)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00019">19</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a9c3364b71a7fe0439ba73567fc303fcc" name="a9c3364b71a7fe0439ba73567fc303fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3364b71a7fe0439ba73567fc303fcc">&#9670;&#160;</a></span>__DEFAULT_FN_ATTRS256</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __DEFAULT_FN_ATTRS256&#160;&#160;&#160;<a class="el" href="____clang__hip__libdevice__declares_8h.html#a3da0931a820e46f95754b07f9b413d58">__attribute__</a>((__always_inline__, __nodebug__, __target__(&quot;avx2&quot;), __min_vector_width__(256)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00018">18</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a8fe3521900e672c4655149ced8682d05" name="a8fe3521900e672c4655149ced8682d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe3521900e672c4655149ced8682d05">&#9670;&#160;</a></span>_mm256_alignr_epi8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_alignr_epi8</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_palignr256((__v32qi)(__m256i)(a), \</div>
<div class="line">                                      (__v32qi)(__m256i)(<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>), (n)))</div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_a373e9fc646873cd20f2c9fdb7125a207"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a></div><div class="ttdeci">__device__ __2f16 b</div><div class="ttdef"><b>Definition</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00303">__clang_hip_libdevice_declares.h:303</a></div></div>
</div><!-- fragment -->
<p>Uses the lower half of the 256-bit vector <em>a</em> as the upper half of a temporary 256-bit value, and the lower half of the 256-bit vector <em>b</em> as the lower half of the temporary value. </p>
<p>Right-shifts the temporary value by <em>n</em> bytes, and uses the lower 16 bytes of the shifted value as the lower 16 bytes of the result. Uses the upper halves of <em>a</em> and <em>b</em> to make another temporary value, right shifts by <em>n</em>, and uses the lower 16 bytes of the shifted value as the upper 16 bytes of the result.</p>
<div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#a8fe3521900e672c4655149ced8682d05">_mm256_alignr_epi8</a>(__m256i a, __m256i <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>, <span class="keyword">const</span> <span class="keywordtype">int</span> n);</div>
<div class="ttc" id="aavx2intrin_8h_html_a8fe3521900e672c4655149ced8682d05"><div class="ttname"><a href="#a8fe3521900e672c4655149ced8682d05">_mm256_alignr_epi8</a></div><div class="ttdeci">#define _mm256_alignr_epi8(a, b, n)</div><div class="ttdoc">Uses the lower half of the 256-bit vector a as the upper half of a temporary 256-bit value,...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l00434">avx2intrin.h:434</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPALIGNR</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit integer vector containing source values. </td></tr>
    <tr><td class="paramname">b</td><td>A 256-bit integer vector containing source values. </td></tr>
    <tr><td class="paramname">n</td><td>An immediate value specifying the number of bytes to shift. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00434">434</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ad018a82854ddb7a5c81d00ea72140972" name="ad018a82854ddb7a5c81d00ea72140972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad018a82854ddb7a5c81d00ea72140972">&#9670;&#160;</a></span>_mm256_blend_epi16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_blend_epi16</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>V1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>V2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>M</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_pblendw256((__v16hi)(__m256i)(V1), \</div>
<div class="line">                                      (__v16hi)(__m256i)(V2), (<span class="keywordtype">int</span>)(M)))</div>
</div><!-- fragment -->
<p>Merges 16-bit integer values from either of the two 256-bit vectors <em>V1</em> or <em>V2</em>, as specified by the immediate integer operand <em>M</em>, and returns the resulting 256-bit vector of [16 x i16]. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*16</div>
<div class="line">  IF M[i] == 0</div>
<div class="line">    result[7+j:j] := V1[7+j:j]</div>
<div class="line">    result[135+j:128+j] := V1[135+j:128+j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[7+j:j] := V2[7+j:j]</div>
<div class="line">    result[135+j:128+j] := V2[135+j:128+j]</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#ad018a82854ddb7a5c81d00ea72140972">_mm256_blend_epi16</a>(__m256i V1, __m256i V2, <span class="keyword">const</span> <span class="keywordtype">int</span> M);</div>
<div class="ttc" id="aavx2intrin_8h_html_ad018a82854ddb7a5c81d00ea72140972"><div class="ttname"><a href="#ad018a82854ddb7a5c81d00ea72140972">_mm256_blend_epi16</a></div><div class="ttdeci">#define _mm256_blend_epi16(V1, V2, M)</div><div class="ttdoc">Merges 16-bit integer values from either of the two 256-bit vectors V1 or V2, as specified by the imm...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l00599">avx2intrin.h:599</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPBLENDW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V1</td><td>A 256-bit vector of [16 x i16] containing source values. </td></tr>
    <tr><td class="paramname">V2</td><td>A 256-bit vector of [16 x i16] containing source values. </td></tr>
    <tr><td class="paramname">M</td><td>An immediate 8-bit integer operand, with bits [7:0] specifying the source for each element of the result. The position of the mask bit corresponds to the index of a copied value. When a mask bit is 0, the element is copied from <em>V1</em>; otherwise, it is copied from <em>V2</em>. <em>M</em>[0] determines the source for elements 0 and 8, <em>M</em>[1] for elements 1 and 9, and so forth. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00599">599</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a5f8fd952a7c88dfb5b9437f0cd94b9db" name="a5f8fd952a7c88dfb5b9437f0cd94b9db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8fd952a7c88dfb5b9437f0cd94b9db">&#9670;&#160;</a></span>_mm256_blend_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_blend_epi32</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>V1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>V2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>M</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_pblendd256((__v8si)(__m256i)(V1), \</div>
<div class="line">                                      (__v8si)(__m256i)(V2), (<span class="keywordtype">int</span>)(M)))</div>
</div><!-- fragment -->
<p>Merges 32-bit integer elements from either of the two 256-bit vectors of [8 x i32] in <em>V1</em> or <em>V2</em> to return a 256-bit vector of [8 x i32], as specified by the immediate integer operand <em>M</em>. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*32</div>
<div class="line">  IF M[i] == 0</div>
<div class="line">    result[31+j:j] := V1[31+j:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[31+j:j] := V2[32+j:j]</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#a5f8fd952a7c88dfb5b9437f0cd94b9db">_mm256_blend_epi32</a>(__m256i V1, __m256i V2, <span class="keyword">const</span> <span class="keywordtype">int</span> M);</div>
<div class="ttc" id="aavx2intrin_8h_html_a5f8fd952a7c88dfb5b9437f0cd94b9db"><div class="ttname"><a href="#a5f8fd952a7c88dfb5b9437f0cd94b9db">_mm256_blend_epi32</a></div><div class="ttdeci">#define _mm256_blend_epi32(V1, V2, M)</div><div class="ttdoc">Merges 32-bit integer elements from either of the two 256-bit vectors of [8 x i32] in V1 or V2 to ret...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l03127">avx2intrin.h:3127</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPBLENDDD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V1</td><td>A 256-bit vector of [8 x i32] containing source values. </td></tr>
    <tr><td class="paramname">V2</td><td>A 256-bit vector of [8 x i32] containing source values. </td></tr>
    <tr><td class="paramname">M</td><td>An immediate 8-bit integer operand, with bits [7:0] specifying the source for each element of the result. The position of the mask bit corresponds to the index of a copied value. When a mask bit is 0, the element is copied from <em>V1</em>; otherwise, it is is copied from <em>V2</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03127">3127</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a0adabedfb750d899e60f3685b434c6ad" name="a0adabedfb750d899e60f3685b434c6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0adabedfb750d899e60f3685b434c6ad">&#9670;&#160;</a></span>_mm256_bslli_epi128</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_bslli_epi128</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>imm</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_pslldqi256_byteshift((__v4di)(__m256i)(a), (<span class="keywordtype">int</span>)(imm)))</div>
</div><!-- fragment -->
<p>Shifts each 128-bit half of the 256-bit integer vector <em>a</em> left by <em>imm</em> bytes, shifting in zero bytes, and returns the result. </p>
<p>If <em>imm</em> is greater than 15, the returned result is all zeroes.</p>
<div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#a0adabedfb750d899e60f3685b434c6ad">_mm256_bslli_epi128</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">int</span> imm);</div>
<div class="ttc" id="aavx2intrin_8h_html_a0adabedfb750d899e60f3685b434c6ad"><div class="ttname"><a href="#a0adabedfb750d899e60f3685b434c6ad">_mm256_bslli_epi128</a></div><div class="ttdeci">#define _mm256_bslli_epi128(a, imm)</div><div class="ttdoc">Shifts each 128-bit half of the 256-bit integer vector a left by imm bytes, shifting in zero bytes,...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l02091">avx2intrin.h:2091</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSLLDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit integer vector to be shifted. </td></tr>
    <tr><td class="paramname">imm</td><td>An unsigned immediate value specifying the shift count (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02091">2091</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="acf654837b8bfee81dbdcae53b79e7961" name="acf654837b8bfee81dbdcae53b79e7961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf654837b8bfee81dbdcae53b79e7961">&#9670;&#160;</a></span>_mm256_bsrli_epi128</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_bsrli_epi128</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>imm</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_psrldqi256_byteshift((__m256i)(a), (<span class="keywordtype">int</span>)(imm)))</div>
</div><!-- fragment -->
<p>Shifts each 128-bit half of the 256-bit integer vector in <em>a</em> right by <em>imm</em> bytes, shifting in zero bytes, and returns the result. </p>
<p>If <em>imm</em> is greater than 15, the returned result is all zeroes.</p>
<div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#acf654837b8bfee81dbdcae53b79e7961">_mm256_bsrli_epi128</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">int</span> imm);</div>
<div class="ttc" id="aavx2intrin_8h_html_acf654837b8bfee81dbdcae53b79e7961"><div class="ttname"><a href="#acf654837b8bfee81dbdcae53b79e7961">_mm256_bsrli_epi128</a></div><div class="ttdeci">#define _mm256_bsrli_epi128(a, imm)</div><div class="ttdoc">Shifts each 128-bit half of the 256-bit integer vector in a right by imm bytes, shifting in zero byte...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l02335">avx2intrin.h:2335</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSRLDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit integer vector to be shifted. </td></tr>
    <tr><td class="paramname">imm</td><td>An unsigned immediate value specifying the shift count (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02335">2335</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="aad58b51492bbbb175bcafd021585d930" name="aad58b51492bbbb175bcafd021585d930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad58b51492bbbb175bcafd021585d930">&#9670;&#160;</a></span>_mm256_extracti128_si256</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_extracti128_si256</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>M</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_extract128i256((__v4di)(__m256i)(<a class="code hl_define" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>), (<span class="keywordtype">int</span>)(M)))</div>
<div class="ttc" id="aASTContext_8h_html_ab1457e11becd51c5d0c750caab5446c2"><div class="ttname"><a href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a></div><div class="ttdeci">#define V(N, I)</div><div class="ttdef"><b>Definition</b> <a href="ASTContext_8h_source.html#l03226">ASTContext.h:3226</a></div></div>
</div><!-- fragment -->
<p>Extracts half of the 256-bit vector <em>V</em> to the 128-bit result. </p>
<p>If bit 0 of the immediate <em>M</em> is zero, extracts the lower half of the result; otherwise, extracts the upper half.</p>
<div class="fragment"><div class="line">__m128i <a class="code hl_define" href="#aad58b51492bbbb175bcafd021585d930">_mm256_extracti128_si256</a>(__m256i <a class="code hl_define" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>, <span class="keyword">const</span> <span class="keywordtype">int</span> M);</div>
<div class="ttc" id="aavx2intrin_8h_html_aad58b51492bbbb175bcafd021585d930"><div class="ttname"><a href="#aad58b51492bbbb175bcafd021585d930">_mm256_extracti128_si256</a></div><div class="ttdeci">#define _mm256_extracti128_si256(V, M)</div><div class="ttdoc">Extracts half of the 256-bit vector V to the 128-bit result.</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l03438">avx2intrin.h:3438</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VEXTRACTI128</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>A 256-bit integer vector containing the source values. </td></tr>
    <tr><td class="paramname">M</td><td>An immediate value specifying which half of <em>V</em> to extract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03438">3438</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ad1267ffda36b2c13484b36a209e37792" name="ad1267ffda36b2c13484b36a209e37792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1267ffda36b2c13484b36a209e37792">&#9670;&#160;</a></span>_mm256_i32gather_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_i32gather_epi32</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_gatherd_d256((__v8si)<a class="code hl_function" href="avxintrin_8h.html#a5d03860407459337bbfbc277face762b">_mm256_undefined_si256</a>(), \</div>
<div class="line">                                        (<span class="keywordtype">int</span> <span class="keyword">const</span> *)(m), (__v8si)(__m256i)(i), \</div>
<div class="line">                                        (__v8si)<a class="code hl_function" href="avxintrin_8h.html#af4aae99a61d0c026b106cf4550691dca">_mm256_set1_epi32</a>(-1), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_aa9513b8e157e945e0f9eb68bf6e7e7d7"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></div><div class="ttdeci">__device__ __2f16 float __ockl_bool s</div><div class="ttdef"><b>Definition</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00304">__clang_hip_libdevice_declares.h:304</a></div></div>
<div class="ttc" id="aavxintrin_8h_html_a5d03860407459337bbfbc277face762b"><div class="ttname"><a href="avxintrin_8h.html#a5d03860407459337bbfbc277face762b">_mm256_undefined_si256</a></div><div class="ttdeci">static __inline__ __m256i __DEFAULT_FN_ATTRS _mm256_undefined_si256(void)</div><div class="ttdoc">Create a 256-bit integer vector with undefined values.</div><div class="ttdef"><b>Definition</b> <a href="avxintrin_8h_source.html#l03648">avxintrin.h:3648</a></div></div>
<div class="ttc" id="aavxintrin_8h_html_af4aae99a61d0c026b106cf4550691dca"><div class="ttname"><a href="avxintrin_8h.html#af4aae99a61d0c026b106cf4550691dca">_mm256_set1_epi32</a></div><div class="ttdeci">static __inline __m256i __DEFAULT_FN_ATTRS _mm256_set1_epi32(int __i)</div><div class="ttdoc">Constructs a 256-bit integer vector of [8 x i32], with each of the 32-bit integral vector elements se...</div><div class="ttdef"><b>Definition</b> <a href="avxintrin_8h_source.html#l04236">avxintrin.h:4236</a></div></div>
</div><!-- fragment -->
<p>Gathers eight 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 256-bit vector of [8 x i32] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 7</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*32</div>
<div class="line">  result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#ad1267ffda36b2c13484b36a209e37792">_mm256_i32gather_epi32</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> *m, __m256i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_ad1267ffda36b2c13484b36a209e37792"><div class="ttname"><a href="#ad1267ffda36b2c13484b36a209e37792">_mm256_i32gather_epi32</a></div><div class="ttdeci">#define _mm256_i32gather_epi32(m, i, s)</div><div class="ttdoc">Gathers eight 32-bit floating-point values from memory m using scaled indexes from the 256-bit vector...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l05056">avx2intrin.h:5056</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERDD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [8 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l05056">5056</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a16861b116c0624454372064f910c4f80" name="a16861b116c0624454372064f910c4f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16861b116c0624454372064f910c4f80">&#9670;&#160;</a></span>_mm256_i32gather_epi64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_i32gather_epi64</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_gatherd_q256((__v4di)<a class="code hl_function" href="avxintrin_8h.html#a5d03860407459337bbfbc277face762b">_mm256_undefined_si256</a>(), \</div>
<div class="line">                                        (<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v4si)(__m128i)(i), \</div>
<div class="line">                                        (__v4di)<a class="code hl_function" href="avxintrin_8h.html#a62a0e00da40e99bd0112ab77186984cf">_mm256_set1_epi64x</a>(-1), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
<div class="ttc" id="aavxintrin_8h_html_a62a0e00da40e99bd0112ab77186984cf"><div class="ttname"><a href="avxintrin_8h.html#a62a0e00da40e99bd0112ab77186984cf">_mm256_set1_epi64x</a></div><div class="ttdeci">static __inline __m256i __DEFAULT_FN_ATTRS _mm256_set1_epi64x(long long __q)</div><div class="ttdoc">Constructs a 256-bit integer vector of [4 x i64], with each of the 64-bit integral vector elements se...</div><div class="ttdef"><b>Definition</b> <a href="avxintrin_8h_source.html#l04293">avxintrin.h:4293</a></div></div>
</div><!-- fragment -->
<p>Gathers four 64-bit integer values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*32</div>
<div class="line">  result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#a16861b116c0624454372064f910c4f80">_mm256_i32gather_epi64</a>(<span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a16861b116c0624454372064f910c4f80"><div class="ttname"><a href="#a16861b116c0624454372064f910c4f80">_mm256_i32gather_epi64</a></div><div class="ttdeci">#define _mm256_i32gather_epi64(m, i, s)</div><div class="ttdoc">Gathers four 64-bit integer values from memory m using scaled indexes from the 128-bit vector of [4 x...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l05188">avx2intrin.h:5188</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l05188">5188</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a80044451f05309770ce2bf171dbfa0be" name="a80044451f05309770ce2bf171dbfa0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80044451f05309770ce2bf171dbfa0be">&#9670;&#160;</a></span>_mm256_i32gather_pd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_i32gather_pd</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256d)__builtin_ia32_gatherd_pd256((__v4df)<a class="code hl_function" href="avxintrin_8h.html#a483d5f7ab8caca878e4be157e3d07f62">_mm256_undefined_pd</a>(), \</div>
<div class="line">                                         (<span class="keywordtype">double</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                         (__v4si)(__m128i)(i), \</div>
<div class="line">                                         (__v4df)<a class="code hl_define" href="avxintrin_8h.html#a65f0cd8e0a33a987b052a60b03249077">_mm256_cmp_pd</a>(<a class="code hl_function" href="avxintrin_8h.html#aac4a2ce03fb26132483fae2f6bf3e734">_mm256_setzero_pd</a>(), \</div>
<div class="line">                                                               <a class="code hl_function" href="avxintrin_8h.html#aac4a2ce03fb26132483fae2f6bf3e734">_mm256_setzero_pd</a>(), \</div>
<div class="line">                                                               <a class="code hl_define" href="avxintrin_8h.html#a9dac2ea83695373391286f7f38cf3741">_CMP_EQ_OQ</a>), \</div>
<div class="line">                                         (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
<div class="ttc" id="aavxintrin_8h_html_a483d5f7ab8caca878e4be157e3d07f62"><div class="ttname"><a href="avxintrin_8h.html#a483d5f7ab8caca878e4be157e3d07f62">_mm256_undefined_pd</a></div><div class="ttdeci">static __inline__ __m256d __DEFAULT_FN_ATTRS _mm256_undefined_pd(void)</div><div class="ttdoc">Create a 256-bit vector of [4 x double] with undefined values.</div><div class="ttdef"><b>Definition</b> <a href="avxintrin_8h_source.html#l03622">avxintrin.h:3622</a></div></div>
<div class="ttc" id="aavxintrin_8h_html_a65f0cd8e0a33a987b052a60b03249077"><div class="ttname"><a href="avxintrin_8h.html#a65f0cd8e0a33a987b052a60b03249077">_mm256_cmp_pd</a></div><div class="ttdeci">#define _mm256_cmp_pd(a, b, c)</div><div class="ttdoc">Compares each of the corresponding double-precision values of two 256-bit vectors of [4 x double],...</div><div class="ttdef"><b>Definition</b> <a href="avxintrin_8h_source.html#l01782">avxintrin.h:1782</a></div></div>
<div class="ttc" id="aavxintrin_8h_html_a9dac2ea83695373391286f7f38cf3741"><div class="ttname"><a href="avxintrin_8h.html#a9dac2ea83695373391286f7f38cf3741">_CMP_EQ_OQ</a></div><div class="ttdeci">#define _CMP_EQ_OQ</div><div class="ttdef"><b>Definition</b> <a href="avxintrin_8h_source.html#l01573">avxintrin.h:1573</a></div></div>
<div class="ttc" id="aavxintrin_8h_html_aac4a2ce03fb26132483fae2f6bf3e734"><div class="ttname"><a href="avxintrin_8h.html#aac4a2ce03fb26132483fae2f6bf3e734">_mm256_setzero_pd</a></div><div class="ttdeci">static __inline __m256d __DEFAULT_FN_ATTRS _mm256_setzero_pd(void)</div><div class="ttdoc">Constructs a 256-bit floating-point vector of [4 x double] with all vector elements initialized to ze...</div><div class="ttdef"><b>Definition</b> <a href="avxintrin_8h_source.html#l04308">avxintrin.h:4308</a></div></div>
</div><!-- fragment -->
<p>Gathers four 64-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*32</div>
<div class="line">  result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256d <a class="code hl_define" href="#a80044451f05309770ce2bf171dbfa0be">_mm256_i32gather_pd</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a80044451f05309770ce2bf171dbfa0be"><div class="ttname"><a href="#a80044451f05309770ce2bf171dbfa0be">_mm256_i32gather_pd</a></div><div class="ttdeci">#define _mm256_i32gather_pd(m, i, s)</div><div class="ttdoc">Gathers four 64-bit floating-point values from memory m using scaled indexes from the 128-bit vector ...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04774">avx2intrin.h:4774</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERDPD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x double] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04774">4774</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a74219a133afddd0577c5a391f041a936" name="a74219a133afddd0577c5a391f041a936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74219a133afddd0577c5a391f041a936">&#9670;&#160;</a></span>_mm256_i32gather_ps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_i32gather_ps</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256)__builtin_ia32_gatherd_ps256((__v8sf)<a class="code hl_function" href="avxintrin_8h.html#a21b240c99046705ad915ee3d5abcd03c">_mm256_undefined_ps</a>(), \</div>
<div class="line">                                        (<span class="keywordtype">float</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v8si)(__m256i)(i), \</div>
<div class="line">                                        (__v8sf)<a class="code hl_define" href="avxintrin_8h.html#a017a59237c66c74e4bccb10fed2d66c4">_mm256_cmp_ps</a>(<a class="code hl_function" href="avxintrin_8h.html#a210663317b1495683ea4e42ddc297da5">_mm256_setzero_ps</a>(), \</div>
<div class="line">                                                              <a class="code hl_function" href="avxintrin_8h.html#a210663317b1495683ea4e42ddc297da5">_mm256_setzero_ps</a>(), \</div>
<div class="line">                                                              <a class="code hl_define" href="avxintrin_8h.html#a9dac2ea83695373391286f7f38cf3741">_CMP_EQ_OQ</a>), \</div>
<div class="line">                                        (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
<div class="ttc" id="aavxintrin_8h_html_a017a59237c66c74e4bccb10fed2d66c4"><div class="ttname"><a href="avxintrin_8h.html#a017a59237c66c74e4bccb10fed2d66c4">_mm256_cmp_ps</a></div><div class="ttdeci">#define _mm256_cmp_ps(a, b, c)</div><div class="ttdoc">Compares each of the corresponding values of two 256-bit vectors of [8 x float], using the operation ...</div><div class="ttdef"><b>Definition</b> <a href="avxintrin_8h_source.html#l01842">avxintrin.h:1842</a></div></div>
<div class="ttc" id="aavxintrin_8h_html_a210663317b1495683ea4e42ddc297da5"><div class="ttname"><a href="avxintrin_8h.html#a210663317b1495683ea4e42ddc297da5">_mm256_setzero_ps</a></div><div class="ttdeci">static __inline __m256 __DEFAULT_FN_ATTRS _mm256_setzero_ps(void)</div><div class="ttdoc">Constructs a 256-bit floating-point vector of [8 x float] with all vector elements initialized to zer...</div><div class="ttdef"><b>Definition</b> <a href="avxintrin_8h_source.html#l04322">avxintrin.h:4322</a></div></div>
<div class="ttc" id="aavxintrin_8h_html_a21b240c99046705ad915ee3d5abcd03c"><div class="ttname"><a href="avxintrin_8h.html#a21b240c99046705ad915ee3d5abcd03c">_mm256_undefined_ps</a></div><div class="ttdeci">static __inline__ __m256 __DEFAULT_FN_ATTRS _mm256_undefined_ps(void)</div><div class="ttdoc">Create a 256-bit vector of [8 x float] with undefined values.</div><div class="ttdef"><b>Definition</b> <a href="avxintrin_8h_source.html#l03635">avxintrin.h:3635</a></div></div>
</div><!-- fragment -->
<p>Gathers eight 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 256-bit vector of [8 x i32] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 7</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*32</div>
<div class="line">  result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256 <a class="code hl_define" href="#a74219a133afddd0577c5a391f041a936">_mm256_i32gather_ps</a>(<span class="keyword">const</span> <span class="keywordtype">float</span> *m, __m256i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a74219a133afddd0577c5a391f041a936"><div class="ttname"><a href="#a74219a133afddd0577c5a391f041a936">_mm256_i32gather_ps</a></div><div class="ttdeci">#define _mm256_i32gather_ps(m, i, s)</div><div class="ttdoc">Gathers eight 32-bit floating-point values from memory m using scaled indexes from the 256-bit vector...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04916">avx2intrin.h:4916</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERDPS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [8 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x float] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04916">4916</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a4ead9a9686d802347c1311dbdb2166de" name="a4ead9a9686d802347c1311dbdb2166de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ead9a9686d802347c1311dbdb2166de">&#9670;&#160;</a></span>_mm256_i64gather_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_i64gather_epi32</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherq_d256((__v4si)<a class="code hl_function" href="emmintrin_8h.html#a745e2e4ca5292bf5f9ba85e0e1e34de1">_mm_undefined_si128</a>(), \</div>
<div class="line">                                        (<span class="keywordtype">int</span> <span class="keyword">const</span> *)(m), (__v4di)(__m256i)(i), \</div>
<div class="line">                                        (__v4si)<a class="code hl_function" href="emmintrin_8h.html#a9e143edcb574e990a3762ef8044cf20a">_mm_set1_epi32</a>(-1), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
<div class="ttc" id="aemmintrin_8h_html_a745e2e4ca5292bf5f9ba85e0e1e34de1"><div class="ttname"><a href="emmintrin_8h.html#a745e2e4ca5292bf5f9ba85e0e1e34de1">_mm_undefined_si128</a></div><div class="ttdeci">static __inline__ __m128i __DEFAULT_FN_ATTRS _mm_undefined_si128(void)</div><div class="ttdoc">Generates a 128-bit vector of [4 x i32] with unspecified content.</div><div class="ttdef"><b>Definition</b> <a href="emmintrin_8h_source.html#l03406">emmintrin.h:3406</a></div></div>
<div class="ttc" id="aemmintrin_8h_html_a9e143edcb574e990a3762ef8044cf20a"><div class="ttname"><a href="emmintrin_8h.html#a9e143edcb574e990a3762ef8044cf20a">_mm_set1_epi32</a></div><div class="ttdeci">static __inline__ __m128i __DEFAULT_FN_ATTRS _mm_set1_epi32(int __i)</div><div class="ttdoc">Initializes all values in a 128-bit vector of [4 x i32] with the specified 32-bit value.</div><div class="ttdef"><b>Definition</b> <a href="emmintrin_8h_source.html#l03618">emmintrin.h:3618</a></div></div>
</div><!-- fragment -->
<p>Gathers four 32-bit integer values from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*64</div>
<div class="line">  result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code hl_define" href="#a4ead9a9686d802347c1311dbdb2166de">_mm256_i64gather_epi32</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> *m, __m256i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a4ead9a9686d802347c1311dbdb2166de"><div class="ttname"><a href="#a4ead9a9686d802347c1311dbdb2166de">_mm256_i64gather_epi32</a></div><div class="ttdeci">#define _mm256_i64gather_epi32(m, i, s)</div><div class="ttdoc">Gathers four 32-bit integer values from memory m using scaled indexes from the 256-bit vector of [4 x...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l05122">avx2intrin.h:5122</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERQD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [4 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l05122">5122</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ad1b484e1a1b32ff73f8857fc02dc8008" name="ad1b484e1a1b32ff73f8857fc02dc8008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b484e1a1b32ff73f8857fc02dc8008">&#9670;&#160;</a></span>_mm256_i64gather_epi64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_i64gather_epi64</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_gatherq_q256((__v4di)<a class="code hl_function" href="avxintrin_8h.html#a5d03860407459337bbfbc277face762b">_mm256_undefined_si256</a>(), \</div>
<div class="line">                                        (<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v4di)(__m256i)(i), \</div>
<div class="line">                                        (__v4di)<a class="code hl_function" href="avxintrin_8h.html#a62a0e00da40e99bd0112ab77186984cf">_mm256_set1_epi64x</a>(-1), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Gathers four 64-bit integer values from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*64</div>
<div class="line">  result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#ad1b484e1a1b32ff73f8857fc02dc8008">_mm256_i64gather_epi64</a>(<span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *m, __m256i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_ad1b484e1a1b32ff73f8857fc02dc8008"><div class="ttname"><a href="#ad1b484e1a1b32ff73f8857fc02dc8008">_mm256_i64gather_epi64</a></div><div class="ttdeci">#define _mm256_i64gather_epi64(m, i, s)</div><div class="ttdoc">Gathers four 64-bit integer values from memory m using scaled indexes from the 256-bit vector of [4 x...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l05254">avx2intrin.h:5254</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERQQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [4 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l05254">5254</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a10b6cdf024224c2ed44d22717fd80434" name="a10b6cdf024224c2ed44d22717fd80434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b6cdf024224c2ed44d22717fd80434">&#9670;&#160;</a></span>_mm256_i64gather_pd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_i64gather_pd</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256d)__builtin_ia32_gatherq_pd256((__v4df)<a class="code hl_function" href="avxintrin_8h.html#a483d5f7ab8caca878e4be157e3d07f62">_mm256_undefined_pd</a>(), \</div>
<div class="line">                                         (<span class="keywordtype">double</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                         (__v4di)(__m256i)(i), \</div>
<div class="line">                                         (__v4df)<a class="code hl_define" href="avxintrin_8h.html#a65f0cd8e0a33a987b052a60b03249077">_mm256_cmp_pd</a>(<a class="code hl_function" href="avxintrin_8h.html#aac4a2ce03fb26132483fae2f6bf3e734">_mm256_setzero_pd</a>(), \</div>
<div class="line">                                                               <a class="code hl_function" href="avxintrin_8h.html#aac4a2ce03fb26132483fae2f6bf3e734">_mm256_setzero_pd</a>(), \</div>
<div class="line">                                                               <a class="code hl_define" href="avxintrin_8h.html#a9dac2ea83695373391286f7f38cf3741">_CMP_EQ_OQ</a>), \</div>
<div class="line">                                         (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Gathers four 64-bit floating-point values from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*64</div>
<div class="line">  result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256d <a class="code hl_define" href="#a10b6cdf024224c2ed44d22717fd80434">_mm256_i64gather_pd</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> *m, __m256i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a10b6cdf024224c2ed44d22717fd80434"><div class="ttname"><a href="#a10b6cdf024224c2ed44d22717fd80434">_mm256_i64gather_pd</a></div><div class="ttdeci">#define _mm256_i64gather_pd(m, i, s)</div><div class="ttdoc">Gathers four 64-bit floating-point values from memory m using scaled indexes from the 256-bit vector ...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04845">avx2intrin.h:4845</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERQPD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [4 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x double] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04845">4845</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a897ba09d00f44657795d12e48beeca0f" name="a897ba09d00f44657795d12e48beeca0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897ba09d00f44657795d12e48beeca0f">&#9670;&#160;</a></span>_mm256_i64gather_ps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_i64gather_ps</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128)__builtin_ia32_gatherq_ps256((__v4sf)<a class="code hl_function" href="xmmintrin_8h.html#a2bb31df1ff50f696cce94e88075184c1">_mm_undefined_ps</a>(), \</div>
<div class="line">                                        (<span class="keywordtype">float</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v4di)(__m256i)(i), \</div>
<div class="line">                                        (__v4sf)<a class="code hl_function" href="xmmintrin_8h.html#a100921ec3d30feb9bdf0d661186b4df6">_mm_cmpeq_ps</a>(<a class="code hl_function" href="xmmintrin_8h.html#a10ea459352416f5ae50823116d1d2a58">_mm_setzero_ps</a>(), \</div>
<div class="line">                                                             <a class="code hl_function" href="xmmintrin_8h.html#a10ea459352416f5ae50823116d1d2a58">_mm_setzero_ps</a>()), \</div>
<div class="line">                                        (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
<div class="ttc" id="axmmintrin_8h_html_a100921ec3d30feb9bdf0d661186b4df6"><div class="ttname"><a href="xmmintrin_8h.html#a100921ec3d30feb9bdf0d661186b4df6">_mm_cmpeq_ps</a></div><div class="ttdeci">static __inline__ __m128 __DEFAULT_FN_ATTRS _mm_cmpeq_ps(__m128 __a, __m128 __b)</div><div class="ttdoc">Compares each of the corresponding 32-bit float values of the 128-bit vectors of [4 x float] for equa...</div><div class="ttdef"><b>Definition</b> <a href="xmmintrin_8h_source.html#l00507">xmmintrin.h:507</a></div></div>
<div class="ttc" id="axmmintrin_8h_html_a10ea459352416f5ae50823116d1d2a58"><div class="ttname"><a href="xmmintrin_8h.html#a10ea459352416f5ae50823116d1d2a58">_mm_setzero_ps</a></div><div class="ttdeci">static __inline__ __m128 __DEFAULT_FN_ATTRS _mm_setzero_ps(void)</div><div class="ttdoc">Constructs a 128-bit floating-point vector of [4 x float] initialized to zero.</div><div class="ttdef"><b>Definition</b> <a href="xmmintrin_8h_source.html#l01907">xmmintrin.h:1907</a></div></div>
<div class="ttc" id="axmmintrin_8h_html_a2bb31df1ff50f696cce94e88075184c1"><div class="ttname"><a href="xmmintrin_8h.html#a2bb31df1ff50f696cce94e88075184c1">_mm_undefined_ps</a></div><div class="ttdeci">static __inline__ __m128 __DEFAULT_FN_ATTRS _mm_undefined_ps(void)</div><div class="ttdoc">Create a 128-bit vector of [4 x float] with undefined values.</div><div class="ttdef"><b>Definition</b> <a href="xmmintrin_8h_source.html#l01780">xmmintrin.h:1780</a></div></div>
</div><!-- fragment -->
<p>Gathers four 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*64</div>
<div class="line">  result[j+31:j] := Load32(m + SignExtend(i[k+64:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128 <a class="code hl_define" href="#a897ba09d00f44657795d12e48beeca0f">_mm256_i64gather_ps</a>(<span class="keyword">const</span> <span class="keywordtype">float</span> *m, __m256i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a897ba09d00f44657795d12e48beeca0f"><div class="ttname"><a href="#a897ba09d00f44657795d12e48beeca0f">_mm256_i64gather_ps</a></div><div class="ttdeci">#define _mm256_i64gather_ps(m, i, s)</div><div class="ttdoc">Gathers four 32-bit floating-point values from memory m using scaled indexes from the 256-bit vector ...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04989">avx2intrin.h:4989</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERQPS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [4 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x float] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04989">4989</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a8406778aad3e2dac47927d38a6689714" name="a8406778aad3e2dac47927d38a6689714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8406778aad3e2dac47927d38a6689714">&#9670;&#160;</a></span>_mm256_inserti128_si256</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_inserti128_si256</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>V1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>V2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>M</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_insert128i256((__v4di)(__m256i)(V1), \</div>
<div class="line">                                         (__v2di)(__m128i)(V2), (<span class="keywordtype">int</span>)(M)))</div>
</div><!-- fragment -->
<p>Copies the 256-bit vector <em>V1</em> to the result, then overwrites half of the result with the 128-bit vector <em>V2</em>. </p>
<p>If bit 0 of the immediate <em>M</em> is zero, overwrites the lower half of the result; otherwise, overwrites the upper half.</p>
<div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#a8406778aad3e2dac47927d38a6689714">_mm256_inserti128_si256</a>(__m256i V1, __m128i V2, <span class="keyword">const</span> <span class="keywordtype">int</span> M);</div>
<div class="ttc" id="aavx2intrin_8h_html_a8406778aad3e2dac47927d38a6689714"><div class="ttname"><a href="#a8406778aad3e2dac47927d38a6689714">_mm256_inserti128_si256</a></div><div class="ttdeci">#define _mm256_inserti128_si256(V1, V2, M)</div><div class="ttdoc">Copies the 256-bit vector V1 to the result, then overwrites half of the result with the 128-bit vecto...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l03461">avx2intrin.h:3461</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VINSERTI128</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V1</td><td>A 256-bit integer vector containing a source value. </td></tr>
    <tr><td class="paramname">V2</td><td>A 128-bit integer vector containing a source value. </td></tr>
    <tr><td class="paramname">M</td><td>An immediate value specifying where to put <em>V2</em> in the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03461">3461</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a4a3890959d248c67e0307f945f852a28" name="a4a3890959d248c67e0307f945f852a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3890959d248c67e0307f945f852a28">&#9670;&#160;</a></span>_mm256_mask_i32gather_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_mask_i32gather_epi32</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_gatherd_d256((__v8si)(__m256i)(a), \</div>
<div class="line">                                        (<span class="keywordtype">int</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v8si)(__m256i)(i), \</div>
<div class="line">                                        (__v8si)(__m256i)(mask), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers eight 32-bit integer values, either from the 256-bit vector of [8 x i32] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [8 x i32] in <em>i</em>. </p>
<p>The 256-bit vector of [8 x i32] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 7</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*32</div>
<div class="line">  IF mask[j+31] == 0</div>
<div class="line">    result[j+31:j] := a[j+31:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#a4a3890959d248c67e0307f945f852a28">_mm256_mask_i32gather_epi32</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">int</span> *m, __m256i i,</div>
<div class="line">                                    __m256i mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a4a3890959d248c67e0307f945f852a28"><div class="ttname"><a href="#a4a3890959d248c67e0307f945f852a28">_mm256_mask_i32gather_epi32</a></div><div class="ttdeci">#define _mm256_mask_i32gather_epi32(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers eight 32-bit integer values, either from the 256-bit vector of [8 x i32] in a,...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04413">avx2intrin.h:4413</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERDD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit vector of [8 x i32] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [8 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 256-bit vector of [8 x i32] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04413">4413</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ad6618807ebcb4b758d18065b0512b456" name="ad6618807ebcb4b758d18065b0512b456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6618807ebcb4b758d18065b0512b456">&#9670;&#160;</a></span>_mm256_mask_i32gather_epi64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_mask_i32gather_epi64</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_gatherd_q256((__v4di)(__m256i)(a), \</div>
<div class="line">                                        (<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v4si)(__m128i)(i), \</div>
<div class="line">                                        (__v4di)(__m256i)(mask), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers four 64-bit integer values, either from the 256-bit vector of [4 x i64] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<p>The 256-bit vector of [4 x i64] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*32</div>
<div class="line">  IF mask[j+63] == 0</div>
<div class="line">    result[j+63:j] := a[j+63:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#ad6618807ebcb4b758d18065b0512b456">_mm256_mask_i32gather_epi64</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *m,</div>
<div class="line">                                    __m128i i, __m256i mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_ad6618807ebcb4b758d18065b0512b456"><div class="ttname"><a href="#ad6618807ebcb4b758d18065b0512b456">_mm256_mask_i32gather_epi64</a></div><div class="ttdeci">#define _mm256_mask_i32gather_epi64(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers four 64-bit integer values, either from the 256-bit vector of [4 x i64] in a,...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04609">avx2intrin.h:4609</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit vector of [4 x i64] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 256-bit vector of [4 x i64] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04609">4609</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a8a9ef334e167c132b6a9f13770b77f01" name="a8a9ef334e167c132b6a9f13770b77f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9ef334e167c132b6a9f13770b77f01">&#9670;&#160;</a></span>_mm256_mask_i32gather_pd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_mask_i32gather_pd</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256d)__builtin_ia32_gatherd_pd256((__v4df)(__m256d)(a), \</div>
<div class="line">                                         (<span class="keywordtype">double</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                         (__v4si)(__m128i)(i), \</div>
<div class="line">                                         (__v4df)(__m256d)(mask), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers four 64-bit floating-point values, either from the 256-bit vector of [4 x double] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<p>The 256-bit vector of [4 x double] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*32</div>
<div class="line">  IF mask[j+63] == 0</div>
<div class="line">    result[j+63:j] := a[j+63:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256d <a class="code hl_define" href="#a8a9ef334e167c132b6a9f13770b77f01">_mm256_mask_i32gather_pd</a>(__m256d a, <span class="keyword">const</span> <span class="keywordtype">double</span> *m, __m128i i,</div>
<div class="line">                                 __m256d mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a8a9ef334e167c132b6a9f13770b77f01"><div class="ttname"><a href="#a8a9ef334e167c132b6a9f13770b77f01">_mm256_mask_i32gather_pd</a></div><div class="ttdeci">#define _mm256_mask_i32gather_pd(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers four 64-bit floating-point values, either from the 256-bit vector of [4 x doubl...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04026">avx2intrin.h:4026</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERDPD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit vector of [4 x double] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 256-bit vector of [4 x double] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x double] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04026">4026</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a7767cbba8a5c61bf05fe06ee416a4542" name="a7767cbba8a5c61bf05fe06ee416a4542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7767cbba8a5c61bf05fe06ee416a4542">&#9670;&#160;</a></span>_mm256_mask_i32gather_ps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_mask_i32gather_ps</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256)__builtin_ia32_gatherd_ps256((__v8sf)(__m256)(a), \</div>
<div class="line">                                        (<span class="keywordtype">float</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v8si)(__m256i)(i), \</div>
<div class="line">                                        (__v8sf)(__m256)(mask), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers eight 32-bit floating-point values, either from the 256-bit vector of [8 x float] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [8 x i32] in <em>i</em>. </p>
<p>The 256-bit vector of [8 x float] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 7</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*32</div>
<div class="line">  IF mask[j+31] == 0</div>
<div class="line">    result[j+31:j] := a[j+31:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256 <a class="code hl_define" href="#a7767cbba8a5c61bf05fe06ee416a4542">_mm256_mask_i32gather_ps</a>(__m256 a, <span class="keyword">const</span> <span class="keywordtype">float</span> *m, __m256i i,</div>
<div class="line">                                __m256 mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a7767cbba8a5c61bf05fe06ee416a4542"><div class="ttname"><a href="#a7767cbba8a5c61bf05fe06ee416a4542">_mm256_mask_i32gather_ps</a></div><div class="ttdeci">#define _mm256_mask_i32gather_ps(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers eight 32-bit floating-point values, either from the 256-bit vector of [8 x floa...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04218">avx2intrin.h:4218</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERDPS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit vector of [8 x float] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [8 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 256-bit vector of [8 x float] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x float] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04218">4218</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a91162e72875b376189127affa7b2bf5c" name="a91162e72875b376189127affa7b2bf5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91162e72875b376189127affa7b2bf5c">&#9670;&#160;</a></span>_mm256_mask_i64gather_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_mask_i64gather_epi32</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherq_d256((__v4si)(__m128i)(a), \</div>
<div class="line">                                        (<span class="keywordtype">int</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v4di)(__m256i)(i), \</div>
<div class="line">                                        (__v4si)(__m128i)(mask), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers four 32-bit integer values, either from the 128-bit vector of [4 x i32] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>. </p>
<p>The 128-bit vector of [4 x i32] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*64</div>
<div class="line">  IF mask[j+31] == 0</div>
<div class="line">    result[j+31:j] := a[j+31:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code hl_define" href="#a91162e72875b376189127affa7b2bf5c">_mm256_mask_i64gather_epi32</a>(__m128i a, <span class="keyword">const</span> <span class="keywordtype">int</span> *m, __m256i i,</div>
<div class="line">                                    __m128i mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a91162e72875b376189127affa7b2bf5c"><div class="ttname"><a href="#a91162e72875b376189127affa7b2bf5c">_mm256_mask_i64gather_epi32</a></div><div class="ttdeci">#define _mm256_mask_i64gather_epi32(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers four 32-bit integer values, either from the 128-bit vector of [4 x i32] in a,...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04512">avx2intrin.h:4512</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERQD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [4 x i32] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [4 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [4 x i32] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04512">4512</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="af6b171b3af10ce3b58abef775d789f20" name="af6b171b3af10ce3b58abef775d789f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b171b3af10ce3b58abef775d789f20">&#9670;&#160;</a></span>_mm256_mask_i64gather_epi64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_mask_i64gather_epi64</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_gatherq_q256((__v4di)(__m256i)(a), \</div>
<div class="line">                                        (<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v4di)(__m256i)(i), \</div>
<div class="line">                                        (__v4di)(__m256i)(mask), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers four 64-bit integer values, either from the 256-bit vector of [4 x i64] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>. </p>
<p>The 256-bit vector of [4 x i64] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*64</div>
<div class="line">  IF mask[j+63] == 0</div>
<div class="line">    result[j+63:j] := a[j+63:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#af6b171b3af10ce3b58abef775d789f20">_mm256_mask_i64gather_epi64</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *m,</div>
<div class="line">                                    __m256i i, __m256i mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_af6b171b3af10ce3b58abef775d789f20"><div class="ttname"><a href="#af6b171b3af10ce3b58abef775d789f20">_mm256_mask_i64gather_epi64</a></div><div class="ttdeci">#define _mm256_mask_i64gather_epi64(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers four 64-bit integer values, either from the 256-bit vector of [4 x i64] in a,...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04705">avx2intrin.h:4705</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERQQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit vector of [4 x i64] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [4 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 256-bit vector of [4 x i64] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04705">4705</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="acf5b86b0ba922eb270ec2b545c8a537d" name="acf5b86b0ba922eb270ec2b545c8a537d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5b86b0ba922eb270ec2b545c8a537d">&#9670;&#160;</a></span>_mm256_mask_i64gather_pd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_mask_i64gather_pd</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256d)__builtin_ia32_gatherq_pd256((__v4df)(__m256d)(a), \</div>
<div class="line">                                         (<span class="keywordtype">double</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                         (__v4di)(__m256i)(i), \</div>
<div class="line">                                         (__v4df)(__m256d)(mask), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers four 64-bit floating-point values, either from the 256-bit vector of [4 x double] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>. </p>
<p>The 256-bit vector of [4 x double] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*64</div>
<div class="line">  IF mask[j+63] == 0</div>
<div class="line">    result[j+63:j] := a[j+63:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256d <a class="code hl_define" href="#acf5b86b0ba922eb270ec2b545c8a537d">_mm256_mask_i64gather_pd</a>(__m256d a, <span class="keyword">const</span> <span class="keywordtype">double</span> *m, __m256i i,</div>
<div class="line">                                 __m256d mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_acf5b86b0ba922eb270ec2b545c8a537d"><div class="ttname"><a href="#acf5b86b0ba922eb270ec2b545c8a537d">_mm256_mask_i64gather_pd</a></div><div class="ttdeci">#define _mm256_mask_i64gather_pd(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers four 64-bit floating-point values, either from the 256-bit vector of [4 x doubl...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04122">avx2intrin.h:4122</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERQPD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit vector of [4 x double] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [4 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 256-bit vector of [4 x double] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x double] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04122">4122</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a13ab1da963f146144bd78937e561deaf" name="a13ab1da963f146144bd78937e561deaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ab1da963f146144bd78937e561deaf">&#9670;&#160;</a></span>_mm256_mask_i64gather_ps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_mask_i64gather_ps</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128)__builtin_ia32_gatherq_ps256((__v4sf)(__m128)(a), \</div>
<div class="line">                                        (<span class="keywordtype">float</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v4di)(__m256i)(i), \</div>
<div class="line">                                        (__v4sf)(__m128)(mask), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers four 32-bit floating-point values, either from the 128-bit vector of [4 x float] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>. </p>
<p>The 128-bit vector of [4 x float] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*64</div>
<div class="line">  IF mask[j+31] == 0</div>
<div class="line">    result[j+31:j] := a[j+31:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128 <a class="code hl_define" href="#a13ab1da963f146144bd78937e561deaf">_mm256_mask_i64gather_ps</a>(__m128 a, <span class="keyword">const</span> <span class="keywordtype">float</span> *m, __m256i i,</div>
<div class="line">                                __m128 mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a13ab1da963f146144bd78937e561deaf"><div class="ttname"><a href="#a13ab1da963f146144bd78937e561deaf">_mm256_mask_i64gather_ps</a></div><div class="ttdeci">#define _mm256_mask_i64gather_ps(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers four 32-bit floating-point values, either from the 128-bit vector of [4 x float...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04317">avx2intrin.h:4317</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERQPS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [4 x float] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [4 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [4 x float] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x float] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04317">4317</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ac139092f30e8322e5d76257b5bac2886" name="ac139092f30e8322e5d76257b5bac2886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac139092f30e8322e5d76257b5bac2886">&#9670;&#160;</a></span>_mm256_mpsadbw_epu8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_mpsadbw_epu8</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>M</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_mpsadbw256((__v32qi)(__m256i)(<a class="code hl_define" href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a>), \</div>
<div class="line">                                      (__v32qi)(__m256i)(Y), (<span class="keywordtype">int</span>)(M)))</div>
<div class="ttc" id="aInterpreter_2Value_8h_html_a094c3d875c5b3d55fb5307c29cfc2c18"><div class="ttname"><a href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a></div><div class="ttdeci">#define X(type, name)</div><div class="ttdef"><b>Definition</b> <a href="Interpreter_2Value_8h_source.html#l00094">Value.h:94</a></div></div>
</div><!-- fragment -->
<p>Computes sixteen sum of absolute difference (SAD) operations on sets of four unsigned 8-bit integers from the 256-bit integer vectors <em>X</em> and <em>Y</em>. </p>
<p>Eight SAD results are computed using the lower half of the input vectors, and another eight using the upper half. These 16-bit values are returned in the lower and upper halves of the 256-bit result, respectively.</p>
<p>A single SAD operation selects four bytes from <em>X</em> and four bytes from <em>Y</em> as input. It computes the differences between each <em>X</em> byte and the corresponding <em>Y</em> byte, takes the absolute value of each difference, and sums these four values to form one 16-bit result. The intrinsic computes 16 of these results with different sets of input bytes.</p>
<p>For each set of eight results, the SAD operations use the same four bytes from <em>Y</em>; the starting bit position for these four bytes is specified by <em>M</em>[1:0] times 32. The eight operations use successive sets of four bytes from <em>X</em>; the starting bit position for the first set of four bytes is specified by <em>M</em>[2] times 32. These bit positions are all relative to the 128-bit lane for each set of eight operations.</p>
<div class="fragment"><div class="line">r := 0</div>
<div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*3</div>
<div class="line">  Ybase := M[j+1:j]*32 + i*128</div>
<div class="line">  Xbase := M[j+2]*32 + i*128</div>
<div class="line">  FOR k := 0 TO 3</div>
<div class="line">    temp0 := ABS(X[Xbase+7:Xbase] - Y[Ybase+7:Ybase])</div>
<div class="line">    temp1 := ABS(X[Xbase+15:Xbase+8] - Y[Ybase+15:Ybase+8])</div>
<div class="line">    temp2 := ABS(X[Xbase+23:Xbase+16] - Y[Ybase+23:Ybase+16])</div>
<div class="line">    temp3 := ABS(X[Xbase+31:Xbase+24] - Y[Ybase+31:Ybase+24])</div>
<div class="line">    result[r+15:r] := temp0 + temp1 + temp2 + temp3</div>
<div class="line">    Xbase := Xbase + 8</div>
<div class="line">    r := r + 16</div>
<div class="line">  ENDFOR</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#ac139092f30e8322e5d76257b5bac2886">_mm256_mpsadbw_epu8</a>(__m256i <a class="code hl_define" href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a>, __m256i Y, <span class="keyword">const</span> <span class="keywordtype">int</span> M);</div>
<div class="ttc" id="aavx2intrin_8h_html_ac139092f30e8322e5d76257b5bac2886"><div class="ttname"><a href="#ac139092f30e8322e5d76257b5bac2886">_mm256_mpsadbw_epu8</a></div><div class="ttdeci">#define _mm256_mpsadbw_epu8(X, Y, M)</div><div class="ttdoc">Computes sixteen sum of absolute difference (SAD) operations on sets of four unsigned 8-bit integers ...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l00079">avx2intrin.h:79</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VMPSADBW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>A 256-bit integer vector containing one of the inputs. </td></tr>
    <tr><td class="paramname">Y</td><td>A 256-bit integer vector containing one of the inputs. </td></tr>
    <tr><td class="paramname">M</td><td>An unsigned immediate value specifying the starting positions of the bytes to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00079">79</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="aa42c8a9ffd50a4d2e392dc16043f3be2" name="aa42c8a9ffd50a4d2e392dc16043f3be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42c8a9ffd50a4d2e392dc16043f3be2">&#9670;&#160;</a></span>_mm256_permute2x128_si256</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_permute2x128_si256</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>V1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>V2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>M</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_permti256((__m256i)(V1), (__m256i)(V2), (<span class="keywordtype">int</span>)(M)))</div>
</div><!-- fragment -->
<p>Sets each half of the 256-bit result either to zero or to one of the four possible 128-bit halves of the 256-bit vectors <em>V1</em> and <em>V2</em>, as specified by the immediate value <em>M</em>. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*128</div>
<div class="line">  k := M &gt;&gt; (i*4)</div>
<div class="line">  IF k[3] == 0</div>
<div class="line">    CASE (k[1:0]) OF</div>
<div class="line">    0: result[127+j:j] := V1[127:0]</div>
<div class="line">    1: result[127+j:j] := V1[255:128]</div>
<div class="line">    2: result[127+j:j] := V2[127:0]</div>
<div class="line">    3: result[127+j:j] := V2[255:128]</div>
<div class="line">    ESAC</div>
<div class="line">  ELSE</div>
<div class="line">    result[127+j:j] := 0</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#aa42c8a9ffd50a4d2e392dc16043f3be2">_mm256_permute2x128_si256</a>(__m256i V1, __m256i V2, <span class="keyword">const</span> <span class="keywordtype">int</span> M);</div>
<div class="ttc" id="aavx2intrin_8h_html_aa42c8a9ffd50a4d2e392dc16043f3be2"><div class="ttname"><a href="#aa42c8a9ffd50a4d2e392dc16043f3be2">_mm256_permute2x128_si256</a></div><div class="ttdeci">#define _mm256_permute2x128_si256(V1, V2, M)</div><div class="ttdoc">Sets each half of the 256-bit result either to zero or to one of the four possible 128-bit halves of ...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l03418">avx2intrin.h:3418</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPERM2I128</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V1</td><td>A 256-bit integer vector containing source values. </td></tr>
    <tr><td class="paramname">V2</td><td>A 256-bit integer vector containing source values. </td></tr>
    <tr><td class="paramname">M</td><td>An immediate value specifying how to form the result. Bits [3:0] control the lower half of the result, bits [7:4] control the upper half. Within each 4-bit control value, if bit 3 is 1, the result is zero, otherwise bits [1:0] determine the source as follows. <br  />
 0: the lower half of <em>V1</em> <br  />
 1: the upper half of <em>V1</em> <br  />
 2: the lower half of <em>V2</em> <br  />
 3: the upper half of <em>V2</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03418">3418</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a68537aee7b7c35974ea46b32d6be8539" name="a68537aee7b7c35974ea46b32d6be8539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68537aee7b7c35974ea46b32d6be8539">&#9670;&#160;</a></span>_mm256_permute4x64_epi64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_permute4x64_epi64</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>M</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_permdi256((__v4di)(__m256i)(<a class="code hl_define" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>), (<span class="keywordtype">int</span>)(M)))</div>
</div><!-- fragment -->
<p>Sets the result's 256-bit vector of [4 x i64] result to copies of elements of the 256-bit vector of [4 x i64] in <em>V</em> as specified by the immediate value <em>M</em>. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*64</div>
<div class="line">  k := (M &gt;&gt; i*2)[1:0] * 64</div>
<div class="line">  result[j+63:j] := V[k+63:k]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#a68537aee7b7c35974ea46b32d6be8539">_mm256_permute4x64_epi64</a>(__m256i <a class="code hl_define" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>, <span class="keyword">const</span> <span class="keywordtype">int</span> M);</div>
<div class="ttc" id="aavx2intrin_8h_html_a68537aee7b7c35974ea46b32d6be8539"><div class="ttname"><a href="#a68537aee7b7c35974ea46b32d6be8539">_mm256_permute4x64_epi64</a></div><div class="ttdeci">#define _mm256_permute4x64_epi64(V, M)</div><div class="ttdoc">Sets the result's 256-bit vector of [4 x i64] result to copies of elements of the 256-bit vector of [...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l03372">avx2intrin.h:3372</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPERMQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>A 256-bit vector of [4 x i64] containing the source values. </td></tr>
    <tr><td class="paramname">M</td><td>An immediate 8-bit value specifying which elements to copy from <em>V</em>. <em>M</em>[1:0] specifies the index in <em>a</em> for element 0 of the result, <em>M</em>[3:2] specifies the index for element 1, and so forth. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03372">3372</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a6e712383837346afed6b8bb7980d1ed1" name="a6e712383837346afed6b8bb7980d1ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e712383837346afed6b8bb7980d1ed1">&#9670;&#160;</a></span>_mm256_permute4x64_pd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_permute4x64_pd</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>M</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256d)__builtin_ia32_permdf256((__v4df)(__m256d)(<a class="code hl_define" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>), (<span class="keywordtype">int</span>)(M)))</div>
</div><!-- fragment -->
<p>Sets the result's 256-bit vector of [4 x double] to copies of elements of the 256-bit vector of [4 x double] in <em>V</em> as specified by the immediate value <em>M</em>. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*64</div>
<div class="line">  k := (M &gt;&gt; i*2)[1:0] * 64</div>
<div class="line">  result[j+63:j] := V[k+63:k]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256d <a class="code hl_define" href="#a6e712383837346afed6b8bb7980d1ed1">_mm256_permute4x64_pd</a>(__m256d <a class="code hl_define" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>, <span class="keyword">const</span> <span class="keywordtype">int</span> M);</div>
<div class="ttc" id="aavx2intrin_8h_html_a6e712383837346afed6b8bb7980d1ed1"><div class="ttname"><a href="#a6e712383837346afed6b8bb7980d1ed1">_mm256_permute4x64_pd</a></div><div class="ttdeci">#define _mm256_permute4x64_pd(V, M)</div><div class="ttdoc">Sets the result's 256-bit vector of [4 x double] to copies of elements of the 256-bit vector of [4 x ...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l03314">avx2intrin.h:3314</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPERMPD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>A 256-bit vector of [4 x double] containing the source values. </td></tr>
    <tr><td class="paramname">M</td><td>An immediate 8-bit value specifying which elements to copy from <em>V</em>. <em>M</em>[1:0] specifies the index in <em>a</em> for element 0 of the result, <em>M</em>[3:2] specifies the index for element 1, and so forth. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x double] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03314">3314</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ac0e537a750e453f44a0ed29eeeba6c88" name="ac0e537a750e453f44a0ed29eeeba6c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e537a750e453f44a0ed29eeeba6c88">&#9670;&#160;</a></span>_mm256_shuffle_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_shuffle_epi32</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>imm</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_pshufd256((__v8si)(__m256i)(a), (<span class="keywordtype">int</span>)(imm)))</div>
</div><!-- fragment -->
<p>Shuffles 32-bit integers from the 256-bit vector of [8 x i32] in <em>a</em> according to control information in the integer literal <em>imm</em>, and returns the 256-bit result. </p>
<p>In effect there are two parallel 128-bit shuffles in the lower and upper halves.</p>
<div class="fragment"><div class="line">FOR i := 0 to 3</div>
<div class="line">  j := i*32</div>
<div class="line">  k := (imm &gt;&gt; i*2)[1:0] * 32</div>
<div class="line">  result[j+31:j] := a[k+31:k]</div>
<div class="line">  result[128+j+31:128+j] := a[128+k+31:128+k]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#ac0e537a750e453f44a0ed29eeeba6c88">_mm256_shuffle_epi32</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">int</span> imm);</div>
<div class="ttc" id="aavx2intrin_8h_html_ac0e537a750e453f44a0ed29eeeba6c88"><div class="ttname"><a href="#ac0e537a750e453f44a0ed29eeeba6c88">_mm256_shuffle_epi32</a></div><div class="ttdeci">#define _mm256_shuffle_epi32(a, imm)</div><div class="ttdoc">Shuffles 32-bit integers from the 256-bit vector of [8 x i32] in a according to control information i...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l01915">avx2intrin.h:1915</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSHUFB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit vector of [8 x i32] containing source values. </td></tr>
    <tr><td class="paramname">imm</td><td>An immediate 8-bit value specifying which elements to copy from <em>a</em>. <em>imm</em>[1:0] specifies the index in <em>a</em> for elements 0 and 4 of the result, <em>imm</em>[3:2] specifies the index for elements 1 and 5, and so forth. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01915">1915</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a067971162dbcfead4d820ccda94fc850" name="a067971162dbcfead4d820ccda94fc850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067971162dbcfead4d820ccda94fc850">&#9670;&#160;</a></span>_mm256_shufflehi_epi16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_shufflehi_epi16</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>imm</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_pshufhw256((__v16hi)(__m256i)(a), (<span class="keywordtype">int</span>)(imm)))</div>
</div><!-- fragment -->
<p>Shuffles 16-bit integers from the 256-bit vector of [16 x i16] in <em>a</em> according to control information in the integer literal <em>imm</em>, and returns the 256-bit result. </p>
<p>The upper 64 bits of each 128-bit half are shuffled in parallel; the lower 64 bits of each 128-bit half are copied from <em>a</em> unchanged.</p>
<div class="fragment"><div class="line">result[63:0] := a[63:0]</div>
<div class="line">result[191:128] := a[191:128]</div>
<div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i * 16 + 64</div>
<div class="line">  k := (imm &gt;&gt; i*2)[1:0] * 16 + 64</div>
<div class="line">  result[j+15:j] := a[k+15:k]</div>
<div class="line">  result[128+j+15:128+j] := a[128+k+15:128+k]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#a067971162dbcfead4d820ccda94fc850">_mm256_shufflehi_epi16</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">int</span> imm);</div>
<div class="ttc" id="aavx2intrin_8h_html_a067971162dbcfead4d820ccda94fc850"><div class="ttname"><a href="#a067971162dbcfead4d820ccda94fc850">_mm256_shufflehi_epi16</a></div><div class="ttdeci">#define _mm256_shufflehi_epi16(a, imm)</div><div class="ttdoc">Shuffles 16-bit integers from the 256-bit vector of [16 x i16] in a according to control information ...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l01951">avx2intrin.h:1951</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSHUFHW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit vector of [16 x i16] containing source values. </td></tr>
    <tr><td class="paramname">imm</td><td>An immediate 8-bit value specifying which elements to copy from <em>a</em>. <em>imm</em>[1:0] specifies the index in <em>a</em> for elements 4 and 8 of the result, <em>imm</em>[3:2] specifies the index for elements 5 and 9, and so forth. Indexes are offset by 4 (so 0 means index 4, and so forth). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01951">1951</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ad3ebb6cfdddfb1692373d6cf70ac8ccf" name="ad3ebb6cfdddfb1692373d6cf70ac8ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ebb6cfdddfb1692373d6cf70ac8ccf">&#9670;&#160;</a></span>_mm256_shufflelo_epi16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_shufflelo_epi16</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>imm</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_pshuflw256((__v16hi)(__m256i)(a), (<span class="keywordtype">int</span>)(imm)))</div>
</div><!-- fragment -->
<p>Shuffles 16-bit integers from the 256-bit vector of [16 x i16] <em>a</em> according to control information in the integer literal <em>imm</em>, and returns the 256-bit [16 x i16] result. </p>
<p>The lower 64 bits of each 128-bit half are shuffled; the upper 64 bits of each 128-bit half are copied from <em>a</em> unchanged.</p>
<div class="fragment"><div class="line">result[127:64] := a[127:64]</div>
<div class="line">result[255:192] := a[255:192]</div>
<div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i * 16</div>
<div class="line">  k := (imm &gt;&gt; i*2)[1:0] * 16</div>
<div class="line">  result[j+15:j] := a[k+15:k]</div>
<div class="line">  result[128+j+15:128+j] := a[128+k+15:128+k]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#ad3ebb6cfdddfb1692373d6cf70ac8ccf">_mm256_shufflelo_epi16</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">int</span> imm);</div>
<div class="ttc" id="aavx2intrin_8h_html_ad3ebb6cfdddfb1692373d6cf70ac8ccf"><div class="ttname"><a href="#ad3ebb6cfdddfb1692373d6cf70ac8ccf">_mm256_shufflelo_epi16</a></div><div class="ttdeci">#define _mm256_shufflelo_epi16(a, imm)</div><div class="ttdoc">Shuffles 16-bit integers from the 256-bit vector of [16 x i16] a according to control information in ...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l01988">avx2intrin.h:1988</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSHUFLW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit vector of [16 x i16] to use as a source of data for the result. </td></tr>
    <tr><td class="paramname">imm</td><td>An immediate 8-bit value specifying which elements to copy from <em>a</em>. <em>imm</em>[1:0] specifies the index in <em>a</em> for elements 0 and 8 of the result, <em>imm</em>[3:2] specifies the index for elements 1 and 9, and so forth. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01988">1988</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ac2f1212570d0e3dee4a64ef6e8a19693" name="ac2f1212570d0e3dee4a64ef6e8a19693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f1212570d0e3dee4a64ef6e8a19693">&#9670;&#160;</a></span>_mm256_slli_si256</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_slli_si256</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>imm</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_pslldqi256_byteshift((__v4di)(__m256i)(a), (<span class="keywordtype">int</span>)(imm)))</div>
</div><!-- fragment -->
<p>Shifts each 128-bit half of the 256-bit integer vector <em>a</em> left by <em>imm</em> bytes, shifting in zero bytes, and returns the result. </p>
<p>If <em>imm</em> is greater than 15, the returned result is all zeroes.</p>
<div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#ac2f1212570d0e3dee4a64ef6e8a19693">_mm256_slli_si256</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">int</span> imm);</div>
<div class="ttc" id="aavx2intrin_8h_html_ac2f1212570d0e3dee4a64ef6e8a19693"><div class="ttname"><a href="#ac2f1212570d0e3dee4a64ef6e8a19693">_mm256_slli_si256</a></div><div class="ttdeci">#define _mm256_slli_si256(a, imm)</div><div class="ttdoc">Shifts each 128-bit half of the 256-bit integer vector a left by imm bytes, shifting in zero bytes,...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l02071">avx2intrin.h:2071</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSLLDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit integer vector to be shifted. </td></tr>
    <tr><td class="paramname">imm</td><td>An unsigned immediate value specifying the shift count (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02071">2071</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a59a707f6f1a0cc3039cacb54fb420d4b" name="a59a707f6f1a0cc3039cacb54fb420d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a707f6f1a0cc3039cacb54fb420d4b">&#9670;&#160;</a></span>_mm256_srli_si256</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_srli_si256</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>imm</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_psrldqi256_byteshift((__m256i)(a), (<span class="keywordtype">int</span>)(imm)))</div>
</div><!-- fragment -->
<p>Shifts each 128-bit half of the 256-bit integer vector in <em>a</em> right by <em>imm</em> bytes, shifting in zero bytes, and returns the result. </p>
<p>If <em>imm</em> is greater than 15, the returned result is all zeroes.</p>
<div class="fragment"><div class="line">__m256i <a class="code hl_define" href="#a59a707f6f1a0cc3039cacb54fb420d4b">_mm256_srli_si256</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">int</span> imm);</div>
<div class="ttc" id="aavx2intrin_8h_html_a59a707f6f1a0cc3039cacb54fb420d4b"><div class="ttname"><a href="#a59a707f6f1a0cc3039cacb54fb420d4b">_mm256_srli_si256</a></div><div class="ttdeci">#define _mm256_srli_si256(a, imm)</div><div class="ttdoc">Shifts each 128-bit half of the 256-bit integer vector in a right by imm bytes, shifting in zero byte...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l02315">avx2intrin.h:2315</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSRLDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit integer vector to be shifted. </td></tr>
    <tr><td class="paramname">imm</td><td>An unsigned immediate value specifying the shift count (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02315">2315</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a51a2ff86a16a4fc5a9e3c94a817064ea" name="a51a2ff86a16a4fc5a9e3c94a817064ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a2ff86a16a4fc5a9e3c94a817064ea">&#9670;&#160;</a></span>_mm_blend_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_blend_epi32</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>V1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>V2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>M</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_pblendd128((__v4si)(__m128i)(V1), \</div>
<div class="line">                                      (__v4si)(__m128i)(V2), (<span class="keywordtype">int</span>)(M)))</div>
</div><!-- fragment -->
<p>Merges 32-bit integer elements from either of the two 128-bit vectors of [4 x i32] in <em>V1</em> or <em>V2</em> to the result's 128-bit vector of [4 x i32], as specified by the immediate integer operand <em>M</em>. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*32</div>
<div class="line">  IF M[i] == 0</div>
<div class="line">    result[31+j:j] := V1[31+j:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[31+j:j] := V2[32+j:j]</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code hl_define" href="#a51a2ff86a16a4fc5a9e3c94a817064ea">_mm_blend_epi32</a>(__m128i V1, __m128i V2, <span class="keyword">const</span> <span class="keywordtype">int</span> M);</div>
<div class="ttc" id="aavx2intrin_8h_html_a51a2ff86a16a4fc5a9e3c94a817064ea"><div class="ttname"><a href="#a51a2ff86a16a4fc5a9e3c94a817064ea">_mm_blend_epi32</a></div><div class="ttdeci">#define _mm_blend_epi32(V1, V2, M)</div><div class="ttdoc">Merges 32-bit integer elements from either of the two 128-bit vectors of [4 x i32] in V1 or V2 to the...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l03090">avx2intrin.h:3090</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPBLENDDD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V1</td><td>A 128-bit vector of [4 x i32] containing source values. </td></tr>
    <tr><td class="paramname">V2</td><td>A 128-bit vector of [4 x i32] containing source values. </td></tr>
    <tr><td class="paramname">M</td><td>An immediate 8-bit integer operand, with bits [3:0] specifying the source for each element of the result. The position of the mask bit corresponds to the index of a copied value. When a mask bit is 0, the element is copied from <em>V1</em>; otherwise, it is copied from <em>V2</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03090">3090</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a2c7c90e2a3c140bd5828be66dd00450c" name="a2c7c90e2a3c140bd5828be66dd00450c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7c90e2a3c140bd5828be66dd00450c">&#9670;&#160;</a></span>_mm_broadcastsi128_si256</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_broadcastsi128_si256</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_function" href="#a4f7018cff60b93116947e57eea1f1c63">_mm256_broadcastsi128_si256</a>(<a class="code hl_define" href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a>)</div>
<div class="ttc" id="aavx2intrin_8h_html_a4f7018cff60b93116947e57eea1f1c63"><div class="ttname"><a href="#a4f7018cff60b93116947e57eea1f1c63">_mm256_broadcastsi128_si256</a></div><div class="ttdeci">static __inline__ __m256i __DEFAULT_FN_ATTRS256 _mm256_broadcastsi128_si256(__m128i __X)</div><div class="ttdoc">Broadcasts the 128-bit integer data from __X to both the lower and upper halves of the 256-bit result...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l03050">avx2intrin.h:3050</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03055">3055</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a3fc371417a059f4660f43bb9f70c0420" name="a3fc371417a059f4660f43bb9f70c0420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc371417a059f4660f43bb9f70c0420">&#9670;&#160;</a></span>_mm_i32gather_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_i32gather_epi32</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherd_d((__v4si)<a class="code hl_function" href="emmintrin_8h.html#a745e2e4ca5292bf5f9ba85e0e1e34de1">_mm_undefined_si128</a>(), \</div>
<div class="line">                                     (<span class="keywordtype">int</span> <span class="keyword">const</span> *)(m), (__v4si)(__m128i)(i), \</div>
<div class="line">                                     (__v4si)<a class="code hl_function" href="emmintrin_8h.html#a9e143edcb574e990a3762ef8044cf20a">_mm_set1_epi32</a>(-1), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Gathers four 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*32</div>
<div class="line">  result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code hl_define" href="#a3fc371417a059f4660f43bb9f70c0420">_mm_i32gather_epi32</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a3fc371417a059f4660f43bb9f70c0420"><div class="ttname"><a href="#a3fc371417a059f4660f43bb9f70c0420">_mm_i32gather_epi32</a></div><div class="ttdeci">#define _mm_i32gather_epi32(m, i, s)</div><div class="ttdoc">Gathers four 32-bit floating-point values from memory m using scaled indexes from the 128-bit vector ...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l05024">avx2intrin.h:5024</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERDD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l05024">5024</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a2f9f493fcb23d1f0266edb15035bc22f" name="a2f9f493fcb23d1f0266edb15035bc22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9f493fcb23d1f0266edb15035bc22f">&#9670;&#160;</a></span>_mm_i32gather_epi64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_i32gather_epi64</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherd_q((__v2di)<a class="code hl_function" href="emmintrin_8h.html#a745e2e4ca5292bf5f9ba85e0e1e34de1">_mm_undefined_si128</a>(), \</div>
<div class="line">                                     (<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v4si)(__m128i)(i), \</div>
<div class="line">                                     (__v2di)<a class="code hl_function" href="emmintrin_8h.html#ae179f6bcfa4da66b9833da96fec21c2c">_mm_set1_epi64x</a>(-1), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
<div class="ttc" id="aemmintrin_8h_html_ae179f6bcfa4da66b9833da96fec21c2c"><div class="ttname"><a href="emmintrin_8h.html#ae179f6bcfa4da66b9833da96fec21c2c">_mm_set1_epi64x</a></div><div class="ttdeci">static __inline__ __m128i __DEFAULT_FN_ATTRS _mm_set1_epi64x(long long __q)</div><div class="ttdoc">Initializes both values in a 128-bit integer vector with the specified 64-bit integer value.</div><div class="ttdef"><b>Definition</b> <a href="emmintrin_8h_source.html#l03584">emmintrin.h:3584</a></div></div>
</div><!-- fragment -->
<p>Gathers two 64-bit integer values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*32</div>
<div class="line">  result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code hl_define" href="#a2f9f493fcb23d1f0266edb15035bc22f">_mm_i32gather_epi64</a>(<span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a2f9f493fcb23d1f0266edb15035bc22f"><div class="ttname"><a href="#a2f9f493fcb23d1f0266edb15035bc22f">_mm_i32gather_epi64</a></div><div class="ttdeci">#define _mm_i32gather_epi64(m, i, s)</div><div class="ttdoc">Gathers two 64-bit integer values from memory m using scaled indexes from the 128-bit vector of [4 x ...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l05155">avx2intrin.h:5155</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. Only the first two elements are used. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x i64] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l05155">5155</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a4afe7e70b1677fd4097166407ae827cb" name="a4afe7e70b1677fd4097166407ae827cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afe7e70b1677fd4097166407ae827cb">&#9670;&#160;</a></span>_mm_i32gather_pd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_i32gather_pd</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128d)__builtin_ia32_gatherd_pd((__v2df)<a class="code hl_function" href="emmintrin_8h.html#a8873e2c5dba429d4f4386c2fe6e479f7">_mm_undefined_pd</a>(), \</div>
<div class="line">                                      (<span class="keywordtype">double</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                      (__v4si)(__m128i)(i), \</div>
<div class="line">                                      (__v2df)<a class="code hl_function" href="emmintrin_8h.html#ad7c5c50dc07e64e82ef8852bcb093fa6">_mm_cmpeq_pd</a>(<a class="code hl_function" href="emmintrin_8h.html#abb21a22f10c4f15dab5aa34e9886c598">_mm_setzero_pd</a>(), \</div>
<div class="line">                                                           <a class="code hl_function" href="emmintrin_8h.html#abb21a22f10c4f15dab5aa34e9886c598">_mm_setzero_pd</a>()), \</div>
<div class="line">                                      (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
<div class="ttc" id="aemmintrin_8h_html_a8873e2c5dba429d4f4386c2fe6e479f7"><div class="ttname"><a href="emmintrin_8h.html#a8873e2c5dba429d4f4386c2fe6e479f7">_mm_undefined_pd</a></div><div class="ttdeci">static __inline__ __m128d __DEFAULT_FN_ATTRS _mm_undefined_pd(void)</div><div class="ttdoc">Constructs a 128-bit floating-point vector of [2 x double] with unspecified content.</div><div class="ttdef"><b>Definition</b> <a href="emmintrin_8h_source.html#l01719">emmintrin.h:1719</a></div></div>
<div class="ttc" id="aemmintrin_8h_html_abb21a22f10c4f15dab5aa34e9886c598"><div class="ttname"><a href="emmintrin_8h.html#abb21a22f10c4f15dab5aa34e9886c598">_mm_setzero_pd</a></div><div class="ttdeci">static __inline__ __m128d __DEFAULT_FN_ATTRS _mm_setzero_pd(void)</div><div class="ttdoc">Constructs a 128-bit floating-point vector of [2 x double] initialized to zero.</div><div class="ttdef"><b>Definition</b> <a href="emmintrin_8h_source.html#l01821">emmintrin.h:1821</a></div></div>
<div class="ttc" id="aemmintrin_8h_html_ad7c5c50dc07e64e82ef8852bcb093fa6"><div class="ttname"><a href="emmintrin_8h.html#ad7c5c50dc07e64e82ef8852bcb093fa6">_mm_cmpeq_pd</a></div><div class="ttdeci">static __inline__ __m128d __DEFAULT_FN_ATTRS _mm_cmpeq_pd(__m128d __a, __m128d __b)</div><div class="ttdoc">Compares each of the corresponding double-precision values of the 128-bit vectors of [2 x double] for...</div><div class="ttdef"><b>Definition</b> <a href="emmintrin_8h_source.html#l00425">emmintrin.h:425</a></div></div>
</div><!-- fragment -->
<p>Gathers two 64-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*32</div>
<div class="line">  result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128d <a class="code hl_define" href="#a4afe7e70b1677fd4097166407ae827cb">_mm_i32gather_pd</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a4afe7e70b1677fd4097166407ae827cb"><div class="ttname"><a href="#a4afe7e70b1677fd4097166407ae827cb">_mm_i32gather_pd</a></div><div class="ttdeci">#define _mm_i32gather_pd(m, i, s)</div><div class="ttdoc">Gathers two 64-bit floating-point values from memory m using scaled indexes from the 128-bit vector o...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04739">avx2intrin.h:4739</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERDPD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. Only the first two elements are used. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x double] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04739">4739</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a192468a06b0104ad516aaca8a4f0eee8" name="a192468a06b0104ad516aaca8a4f0eee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192468a06b0104ad516aaca8a4f0eee8">&#9670;&#160;</a></span>_mm_i32gather_ps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_i32gather_ps</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128)__builtin_ia32_gatherd_ps((__v4sf)<a class="code hl_function" href="xmmintrin_8h.html#a2bb31df1ff50f696cce94e88075184c1">_mm_undefined_ps</a>(), \</div>
<div class="line">                                     (<span class="keywordtype">float</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v4si)(__m128i)(i), \</div>
<div class="line">                                     (__v4sf)<a class="code hl_function" href="xmmintrin_8h.html#a100921ec3d30feb9bdf0d661186b4df6">_mm_cmpeq_ps</a>(<a class="code hl_function" href="xmmintrin_8h.html#a10ea459352416f5ae50823116d1d2a58">_mm_setzero_ps</a>(), \</div>
<div class="line">                                                          <a class="code hl_function" href="xmmintrin_8h.html#a10ea459352416f5ae50823116d1d2a58">_mm_setzero_ps</a>()), \</div>
<div class="line">                                     (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Gathers four 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*32</div>
<div class="line">  result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128 <a class="code hl_define" href="#a192468a06b0104ad516aaca8a4f0eee8">_mm_i32gather_ps</a>(<span class="keyword">const</span> <span class="keywordtype">float</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a192468a06b0104ad516aaca8a4f0eee8"><div class="ttname"><a href="#a192468a06b0104ad516aaca8a4f0eee8">_mm_i32gather_ps</a></div><div class="ttdeci">#define _mm_i32gather_ps(m, i, s)</div><div class="ttdoc">Gathers four 32-bit floating-point values from memory m using scaled indexes from the 128-bit vector ...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04881">avx2intrin.h:4881</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERDPS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x float] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04881">4881</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ad6b68cf22a459a9867218792d42c0b5d" name="ad6b68cf22a459a9867218792d42c0b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b68cf22a459a9867218792d42c0b5d">&#9670;&#160;</a></span>_mm_i64gather_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_i64gather_epi32</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherq_d((__v4si)<a class="code hl_function" href="emmintrin_8h.html#a745e2e4ca5292bf5f9ba85e0e1e34de1">_mm_undefined_si128</a>(), \</div>
<div class="line">                                     (<span class="keywordtype">int</span> <span class="keyword">const</span> *)(m), (__v2di)(__m128i)(i), \</div>
<div class="line">                                     (__v4si)<a class="code hl_function" href="emmintrin_8h.html#a9e143edcb574e990a3762ef8044cf20a">_mm_set1_epi32</a>(-1), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Gathers two 32-bit integer values from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>. </p>
<p>The upper two elements of the result are zeroed.</p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*64</div>
<div class="line">  result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">ENDFOR</div>
<div class="line">result[127:64] := 0</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code hl_define" href="#ad6b68cf22a459a9867218792d42c0b5d">_mm_i64gather_epi32</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_ad6b68cf22a459a9867218792d42c0b5d"><div class="ttname"><a href="#ad6b68cf22a459a9867218792d42c0b5d">_mm_i64gather_epi32</a></div><div class="ttdeci">#define _mm_i64gather_epi32(m, i, s)</div><div class="ttdoc">Gathers two 32-bit integer values from memory m using scaled indexes from the 128-bit vector of [2 x ...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l05090">avx2intrin.h:5090</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERQD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [2 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l05090">5090</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a76a2425c4e406cc767d45cbd063ba7d4" name="a76a2425c4e406cc767d45cbd063ba7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a2425c4e406cc767d45cbd063ba7d4">&#9670;&#160;</a></span>_mm_i64gather_epi64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_i64gather_epi64</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherq_q((__v2di)<a class="code hl_function" href="emmintrin_8h.html#a745e2e4ca5292bf5f9ba85e0e1e34de1">_mm_undefined_si128</a>(), \</div>
<div class="line">                                     (<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v2di)(__m128i)(i), \</div>
<div class="line">                                     (__v2di)<a class="code hl_function" href="emmintrin_8h.html#ae179f6bcfa4da66b9833da96fec21c2c">_mm_set1_epi64x</a>(-1), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Gathers two 64-bit integer values from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*64</div>
<div class="line">  result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code hl_define" href="#a76a2425c4e406cc767d45cbd063ba7d4">_mm_i64gather_epi64</a>(<span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a76a2425c4e406cc767d45cbd063ba7d4"><div class="ttname"><a href="#a76a2425c4e406cc767d45cbd063ba7d4">_mm_i64gather_epi64</a></div><div class="ttdeci">#define _mm_i64gather_epi64(m, i, s)</div><div class="ttdoc">Gathers two 64-bit integer values from memory m using scaled indexes from the 128-bit vector of [2 x ...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l05221">avx2intrin.h:5221</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERQQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [2 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x i64] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l05221">5221</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a6fc1a3777f51496f53faf452ae31ebfc" name="a6fc1a3777f51496f53faf452ae31ebfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc1a3777f51496f53faf452ae31ebfc">&#9670;&#160;</a></span>_mm_i64gather_pd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_i64gather_pd</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128d)__builtin_ia32_gatherq_pd((__v2df)<a class="code hl_function" href="emmintrin_8h.html#a8873e2c5dba429d4f4386c2fe6e479f7">_mm_undefined_pd</a>(), \</div>
<div class="line">                                      (<span class="keywordtype">double</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                      (__v2di)(__m128i)(i), \</div>
<div class="line">                                      (__v2df)<a class="code hl_function" href="emmintrin_8h.html#ad7c5c50dc07e64e82ef8852bcb093fa6">_mm_cmpeq_pd</a>(<a class="code hl_function" href="emmintrin_8h.html#abb21a22f10c4f15dab5aa34e9886c598">_mm_setzero_pd</a>(), \</div>
<div class="line">                                                           <a class="code hl_function" href="emmintrin_8h.html#abb21a22f10c4f15dab5aa34e9886c598">_mm_setzero_pd</a>()), \</div>
<div class="line">                                      (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Gathers two 64-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*64</div>
<div class="line">  result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128d <a class="code hl_define" href="#a6fc1a3777f51496f53faf452ae31ebfc">_mm_i64gather_pd</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a6fc1a3777f51496f53faf452ae31ebfc"><div class="ttname"><a href="#a6fc1a3777f51496f53faf452ae31ebfc">_mm_i64gather_pd</a></div><div class="ttdeci">#define _mm_i64gather_pd(m, i, s)</div><div class="ttdoc">Gathers two 64-bit floating-point values from memory m using scaled indexes from the 128-bit vector o...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04810">avx2intrin.h:4810</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERQPD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [2 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x double] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04810">4810</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a369276cfeba553776632edd1ee507cec" name="a369276cfeba553776632edd1ee507cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369276cfeba553776632edd1ee507cec">&#9670;&#160;</a></span>_mm_i64gather_ps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_i64gather_ps</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128)__builtin_ia32_gatherq_ps((__v4sf)<a class="code hl_function" href="xmmintrin_8h.html#a2bb31df1ff50f696cce94e88075184c1">_mm_undefined_ps</a>(), \</div>
<div class="line">                                     (<span class="keywordtype">float</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v2di)(__m128i)(i), \</div>
<div class="line">                                     (__v4sf)<a class="code hl_function" href="xmmintrin_8h.html#a100921ec3d30feb9bdf0d661186b4df6">_mm_cmpeq_ps</a>(<a class="code hl_function" href="xmmintrin_8h.html#a10ea459352416f5ae50823116d1d2a58">_mm_setzero_ps</a>(), \</div>
<div class="line">                                                          <a class="code hl_function" href="xmmintrin_8h.html#a10ea459352416f5ae50823116d1d2a58">_mm_setzero_ps</a>()), \</div>
<div class="line">                                     (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Gathers two 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>. </p>
<p>The upper two elements of the result are zeroed.</p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*64</div>
<div class="line">  result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">ENDFOR</div>
<div class="line">result[127:64] := 0</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128 <a class="code hl_define" href="#a369276cfeba553776632edd1ee507cec">_mm_i64gather_ps</a>(<span class="keyword">const</span> <span class="keywordtype">float</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a369276cfeba553776632edd1ee507cec"><div class="ttname"><a href="#a369276cfeba553776632edd1ee507cec">_mm_i64gather_ps</a></div><div class="ttdeci">#define _mm_i64gather_ps(m, i, s)</div><div class="ttdoc">Gathers two 32-bit floating-point values from memory m using scaled indexes from the 128-bit vector o...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04954">avx2intrin.h:4954</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERQPS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [2 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x float] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04954">4954</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a3078631872478b4855ee95713aa2cd48" name="a3078631872478b4855ee95713aa2cd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3078631872478b4855ee95713aa2cd48">&#9670;&#160;</a></span>_mm_mask_i32gather_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_mask_i32gather_epi32</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherd_d((__v4si)(__m128i)(a), \</div>
<div class="line">                                     (<span class="keywordtype">int</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v4si)(__m128i)(i), \</div>
<div class="line">                                     (__v4si)(__m128i)(mask), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers four 32-bit integer values, either from the 128-bit vector of [4 x i32] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<p>The 128-bit vector of [4 x i32] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*32</div>
<div class="line">  IF mask[j+31] == 0</div>
<div class="line">    result[j+31:j] := a[j+31:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code hl_define" href="#a3078631872478b4855ee95713aa2cd48">_mm_mask_i32gather_epi32</a>(__m128i a, <span class="keyword">const</span> <span class="keywordtype">int</span> *m, __m128i i,</div>
<div class="line">                                 __m128i mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a3078631872478b4855ee95713aa2cd48"><div class="ttname"><a href="#a3078631872478b4855ee95713aa2cd48">_mm_mask_i32gather_epi32</a></div><div class="ttdeci">#define _mm_mask_i32gather_epi32(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers four 32-bit integer values, either from the 128-bit vector of [4 x i32] in a,...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04365">avx2intrin.h:4365</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERDD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [4 x i32] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [4 x i32] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04365">4365</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a825d53d864b1d4d3bb7ab4b6ef457952" name="a825d53d864b1d4d3bb7ab4b6ef457952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825d53d864b1d4d3bb7ab4b6ef457952">&#9670;&#160;</a></span>_mm_mask_i32gather_epi64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_mask_i32gather_epi64</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherd_q((__v2di)(__m128i)(a), \</div>
<div class="line">                                     (<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v4si)(__m128i)(i), \</div>
<div class="line">                                     (__v2di)(__m128i)(mask), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers two 64-bit integer values, either from the 128-bit vector of [2 x i64] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<p>The 128-bit vector of [2 x i64] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*32</div>
<div class="line">  IF mask[j+63] == 0</div>
<div class="line">    result[j+63:j] := a[j+63:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code hl_define" href="#a825d53d864b1d4d3bb7ab4b6ef457952">_mm_mask_i32gather_epi64</a>(__m128i a, <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *m, __m128i i,</div>
<div class="line">                                 __m128i mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a825d53d864b1d4d3bb7ab4b6ef457952"><div class="ttname"><a href="#a825d53d864b1d4d3bb7ab4b6ef457952">_mm_mask_i32gather_epi64</a></div><div class="ttdeci">#define _mm_mask_i32gather_epi64(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers two 64-bit integer values, either from the 128-bit vector of [2 x i64] in a,...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04561">avx2intrin.h:4561</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [2 x i64] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. Only the first two elements are used. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [2 x i64] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x i64] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04561">4561</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="af2af56dc678cba90344c8efc51e42fef" name="af2af56dc678cba90344c8efc51e42fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2af56dc678cba90344c8efc51e42fef">&#9670;&#160;</a></span>_mm_mask_i32gather_pd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_mask_i32gather_pd</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128d)__builtin_ia32_gatherd_pd((__v2df)(__m128i)(a), \</div>
<div class="line">                                      (<span class="keywordtype">double</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                      (__v4si)(__m128i)(i), \</div>
<div class="line">                                      (__v2df)(__m128d)(mask), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers two 64-bit floating-point values, either from the 128-bit vector of [2 x double] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<p>The 128-bit vector of [2 x double] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*32</div>
<div class="line">  IF mask[j+63] == 0</div>
<div class="line">    result[j+63:j] := a[j+63:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128d <a class="code hl_define" href="#af2af56dc678cba90344c8efc51e42fef">_mm_mask_i32gather_pd</a>(__m128d a, <span class="keyword">const</span> <span class="keywordtype">double</span> *m, __m128i i,</div>
<div class="line">                              __m128d mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_af2af56dc678cba90344c8efc51e42fef"><div class="ttname"><a href="#af2af56dc678cba90344c8efc51e42fef">_mm_mask_i32gather_pd</a></div><div class="ttdeci">#define _mm_mask_i32gather_pd(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers two 64-bit floating-point values, either from the 128-bit vector of [2 x double...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l03978">avx2intrin.h:3978</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERDPD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [2 x double] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. Only the first two elements are used. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [2 x double] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x double] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03978">3978</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a66d9ce668f45c18f008ccb4ba4920880" name="a66d9ce668f45c18f008ccb4ba4920880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d9ce668f45c18f008ccb4ba4920880">&#9670;&#160;</a></span>_mm_mask_i32gather_ps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_mask_i32gather_ps</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128)__builtin_ia32_gatherd_ps((__v4sf)(__m128)(a), \</div>
<div class="line">                                     (<span class="keywordtype">float</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v4si)(__m128i)(i), \</div>
<div class="line">                                     (__v4sf)(__m128)(mask), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers four 32-bit floating-point values, either from the 128-bit vector of [4 x float] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<p>The 128-bit vector of [4 x float] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*32</div>
<div class="line">  IF mask[j+31] == 0</div>
<div class="line">    result[j+31:j] := a[j+31:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128 <a class="code hl_define" href="#a66d9ce668f45c18f008ccb4ba4920880">_mm_mask_i32gather_ps</a>(__m128 a, <span class="keyword">const</span> <span class="keywordtype">float</span> *m, __m128i i,</div>
<div class="line">                             __m128 mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a66d9ce668f45c18f008ccb4ba4920880"><div class="ttname"><a href="#a66d9ce668f45c18f008ccb4ba4920880">_mm_mask_i32gather_ps</a></div><div class="ttdeci">#define _mm_mask_i32gather_ps(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers four 32-bit floating-point values, either from the 128-bit vector of [4 x float...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04170">avx2intrin.h:4170</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERDPS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [4 x float] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [4 x float] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x float] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04170">4170</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a59acb178be58ad2561eb49b14489800d" name="a59acb178be58ad2561eb49b14489800d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59acb178be58ad2561eb49b14489800d">&#9670;&#160;</a></span>_mm_mask_i64gather_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_mask_i64gather_epi32</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherq_d((__v4si)(__m128i)(a), \</div>
<div class="line">                                     (<span class="keywordtype">int</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v2di)(__m128i)(i), \</div>
<div class="line">                                     (__v4si)(__m128i)(mask), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers two 32-bit integer values, either from the 128-bit vector of [4 x i32] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>. </p>
<p>The 128-bit vector of [4 x i32] in <em>mask</em> determines the source for the lower two elements. The upper two elements of the result are zeroed.</p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*64</div>
<div class="line">  IF mask[j+31] == 0</div>
<div class="line">    result[j+31:j] := a[j+31:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
<div class="line">result[127:64] := 0</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code hl_define" href="#a59acb178be58ad2561eb49b14489800d">_mm_mask_i64gather_epi32</a>(__m128i a, <span class="keyword">const</span> <span class="keywordtype">int</span> *m, __m128i i,</div>
<div class="line">                                 __m128i mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a59acb178be58ad2561eb49b14489800d"><div class="ttname"><a href="#a59acb178be58ad2561eb49b14489800d">_mm_mask_i64gather_epi32</a></div><div class="ttdeci">#define _mm_mask_i64gather_epi32(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers two 32-bit integer values, either from the 128-bit vector of [4 x i32] in a,...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04464">avx2intrin.h:4464</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERQD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [4 x i32] used as the source when a mask bit is zero. Only the first two elements are used. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [2 x i64] containing indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [4 x i32] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. Only the first two elements are used. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04464">4464</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="aeb1efa9858c290fe95335119cd657a90" name="aeb1efa9858c290fe95335119cd657a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1efa9858c290fe95335119cd657a90">&#9670;&#160;</a></span>_mm_mask_i64gather_epi64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_mask_i64gather_epi64</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherq_q((__v2di)(__m128i)(a), \</div>
<div class="line">                                     (<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v2di)(__m128i)(i), \</div>
<div class="line">                                     (__v2di)(__m128i)(mask), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers two 64-bit integer values, either from the 128-bit vector of [2 x i64] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>. </p>
<p>The 128-bit vector of [2 x i64] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*64</div>
<div class="line">  IF mask[j+63] == 0</div>
<div class="line">    result[j+63:j] := a[j+63:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code hl_define" href="#aeb1efa9858c290fe95335119cd657a90">_mm_mask_i64gather_epi64</a>(__m128i a, <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *m, __m128i i,</div>
<div class="line">                                 __m128i mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_aeb1efa9858c290fe95335119cd657a90"><div class="ttname"><a href="#aeb1efa9858c290fe95335119cd657a90">_mm_mask_i64gather_epi64</a></div><div class="ttdeci">#define _mm_mask_i64gather_epi64(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers two 64-bit integer values, either from the 128-bit vector of [2 x i64] in a,...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04657">avx2intrin.h:4657</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERQQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [2 x i64] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [2 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [2 x i64] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x i64] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04657">4657</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="abb2e967b6fb85089168a6887111c1320" name="abb2e967b6fb85089168a6887111c1320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2e967b6fb85089168a6887111c1320">&#9670;&#160;</a></span>_mm_mask_i64gather_pd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_mask_i64gather_pd</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128d)__builtin_ia32_gatherq_pd((__v2df)(__m128d)(a), \</div>
<div class="line">                                      (<span class="keywordtype">double</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                      (__v2di)(__m128i)(i), \</div>
<div class="line">                                      (__v2df)(__m128d)(mask), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers two 64-bit floating-point values, either from the 128-bit vector of [2 x double] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>. </p>
<p>The 128-bit vector of [2 x double] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*64</div>
<div class="line">  IF mask[j+63] == 0</div>
<div class="line">    result[j+63:j] := a[j+63:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128d <a class="code hl_define" href="#abb2e967b6fb85089168a6887111c1320">_mm_mask_i64gather_pd</a>(__m128d a, <span class="keyword">const</span> <span class="keywordtype">double</span> *m, __m128i i,</div>
<div class="line">                              __m128d mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_abb2e967b6fb85089168a6887111c1320"><div class="ttname"><a href="#abb2e967b6fb85089168a6887111c1320">_mm_mask_i64gather_pd</a></div><div class="ttdeci">#define _mm_mask_i64gather_pd(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers two 64-bit floating-point values, either from the 128-bit vector of [2 x double...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04074">avx2intrin.h:4074</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERQPD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [2 x double] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [2 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [2 x double] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x double] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04074">4074</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ab80831775aea07c24899ae747d8011bc" name="ab80831775aea07c24899ae747d8011bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80831775aea07c24899ae747d8011bc">&#9670;&#160;</a></span>_mm_mask_i64gather_ps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_mask_i64gather_ps</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128)__builtin_ia32_gatherq_ps((__v4sf)(__m128)(a), \</div>
<div class="line">                                     (<span class="keywordtype">float</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v2di)(__m128i)(i), \</div>
<div class="line">                                     (__v4sf)(__m128)(mask), (<a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers two 32-bit floating-point values, either from the 128-bit vector of [4 x float] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>. </p>
<p>The 128-bit vector of [4 x float] in <em>mask</em> determines the source for the lower two elements. The upper two elements of the result are zeroed.</p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*64</div>
<div class="line">  IF mask[j+31] == 0</div>
<div class="line">    result[j+31:j] := a[j+31:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
<div class="line">result[127:64] := 0</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128 <a class="code hl_define" href="#ab80831775aea07c24899ae747d8011bc">_mm_mask_i64gather_ps</a>(__m128 a, <span class="keyword">const</span> <span class="keywordtype">float</span> *m, __m128i i,</div>
<div class="line">                             __m128 mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_ab80831775aea07c24899ae747d8011bc"><div class="ttname"><a href="#ab80831775aea07c24899ae747d8011bc">_mm_mask_i64gather_ps</a></div><div class="ttdeci">#define _mm_mask_i64gather_ps(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers two 32-bit floating-point values, either from the 128-bit vector of [4 x float]...</div><div class="ttdef"><b>Definition</b> <a href="avx2intrin_8h_source.html#l04269">avx2intrin.h:4269</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERQPS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [4 x float] used as the source when a mask bit is zero. Only the first two elements are used. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [2 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [4 x float] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. Only the first two elements are used. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x float] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04269">4269</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af356be486c9c44ff687a24eecb505123" name="af356be486c9c44ff687a24eecb505123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af356be486c9c44ff687a24eecb505123">&#9670;&#160;</a></span>_mm256_abs_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_abs_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of each signed 16-bit element in the 256-bit vector of [16 x i16] in <em>__a</em> and returns each value in the corresponding element of the result. </p>
<p>This intrinsic corresponds to the <code>VPABSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00112">112</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00524">_mm256_mask_abs_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00532">_mm256_maskz_abs_epi16()</a>.</p>

</div>
</div>
<a id="ae0fbd635339f3c30bf181326688a45d1" name="ae0fbd635339f3c30bf181326688a45d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0fbd635339f3c30bf181326688a45d1">&#9670;&#160;</a></span>_mm256_abs_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_abs_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of each signed 32-bit element in the 256-bit vector of [8 x i32] in <em>__a</em> and returns each value in the corresponding element of the result. </p>
<p>This intrinsic corresponds to the <code>VPABSD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00129">129</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l02976">_mm256_mask_abs_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l02983">_mm256_maskz_abs_epi32()</a>.</p>

</div>
</div>
<a id="a012bc2eed4df0a81ee390af2ef919e9b" name="a012bc2eed4df0a81ee390af2ef919e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012bc2eed4df0a81ee390af2ef919e9b">&#9670;&#160;</a></span>_mm256_abs_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_abs_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of each signed byte in the 256-bit integer vector <em>__a</em> and returns each value in the corresponding byte of the result. </p>
<p>This intrinsic corresponds to the <code>VPABSB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00095">95</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00492">_mm256_mask_abs_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00500">_mm256_maskz_abs_epi8()</a>.</p>

</div>
</div>
<a id="a5c1fe2000e40ddd6ccd91f29dfd4ae0d" name="a5c1fe2000e40ddd6ccd91f29dfd4ae0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1fe2000e40ddd6ccd91f29dfd4ae0d">&#9670;&#160;</a></span>_mm256_add_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_add_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] and returns the lower 16 bits of each sum in the corresponding element of the [16 x i16] result (overflow is ignored). </p>
<p>This intrinsic corresponds to the <code>VPADDW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00293">293</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00318">_mm256_mask_add_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00325">_mm256_maskz_add_epi16()</a>.</p>

</div>
</div>
<a id="af8c017a67c07b606eeaa106c1f7cdf73" name="af8c017a67c07b606eeaa106c1f7cdf73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c017a67c07b606eeaa106c1f7cdf73">&#9670;&#160;</a></span>_mm256_add_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_add_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds 32-bit integers from corresponding elements of two 256-bit vectors of [8 x i32] and returns the lower 32 bits of each sum in the corresponding element of the [8 x i32] result (overflow is ignored). </p>
<p>This intrinsic corresponds to the <code>VPADDD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00312">312</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l00227">_mm256_mask_add_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l00235">_mm256_maskz_add_epi32()</a>.</p>

</div>
</div>
<a id="a67010f3cee987f3dd117a785fc5a8890" name="a67010f3cee987f3dd117a785fc5a8890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67010f3cee987f3dd117a785fc5a8890">&#9670;&#160;</a></span>_mm256_add_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_add_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds 64-bit integers from corresponding elements of two 256-bit vectors of [4 x i64] and returns the lower 64 bits of each sum in the corresponding element of the [4 x i64] result (overflow is ignored). </p>
<p>This intrinsic corresponds to the <code>VPADDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [4 x i64] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00331">331</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l00243">_mm256_mask_add_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l00251">_mm256_maskz_add_epi64()</a>.</p>

</div>
</div>
<a id="a59b923dae009dd42ae05783e0955ee00" name="a59b923dae009dd42ae05783e0955ee00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b923dae009dd42ae05783e0955ee00">&#9670;&#160;</a></span>_mm256_add_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_add_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds 8-bit integers from corresponding bytes of two 256-bit integer vectors and returns the lower 8 bits of each sum in the corresponding byte of the 256-bit integer vector result (overflow is ignored). </p>
<p>This intrinsic corresponds to the <code>VPADDB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00274">274</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00304">_mm256_mask_add_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00311">_mm256_maskz_add_epi8()</a>.</p>

</div>
</div>
<a id="af52f4d9d816fcdcc2fcd9852c20ccc87" name="af52f4d9d816fcdcc2fcd9852c20ccc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52f4d9d816fcdcc2fcd9852c20ccc87">&#9670;&#160;</a></span>_mm256_adds_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_adds_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] using signed saturation, and returns the [16 x i16] result. </p>
<p>This intrinsic corresponds to the <code>VPADDSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00368">368</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00715">_mm256_mask_adds_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00723">_mm256_maskz_adds_epi16()</a>.</p>

</div>
</div>
<a id="acd983b6ed3ea7f23bea1deb062b8a72b" name="acd983b6ed3ea7f23bea1deb062b8a72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd983b6ed3ea7f23bea1deb062b8a72b">&#9670;&#160;</a></span>_mm256_adds_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_adds_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds 8-bit integers from corresponding bytes of two 256-bit integer vectors using signed saturation, and returns each sum in the corresponding byte of the 256-bit integer vector result. </p>
<p>This intrinsic corresponds to the <code>VPADDSB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00350">350</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00683">_mm256_mask_adds_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00691">_mm256_maskz_adds_epi8()</a>.</p>

</div>
</div>
<a id="a4d517ee9448be65c2af608809bab444e" name="a4d517ee9448be65c2af608809bab444e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d517ee9448be65c2af608809bab444e">&#9670;&#160;</a></span>_mm256_adds_epu16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_adds_epu16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] using unsigned saturation, and returns the [16 x i16] result. </p>
<p>This intrinsic corresponds to the <code>VPADDUSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00405">405</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00779">_mm256_mask_adds_epu16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00787">_mm256_maskz_adds_epu16()</a>.</p>

</div>
</div>
<a id="abf0d44817e7de48ab8c0774a1d8faae8" name="abf0d44817e7de48ab8c0774a1d8faae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0d44817e7de48ab8c0774a1d8faae8">&#9670;&#160;</a></span>_mm256_adds_epu8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_adds_epu8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds 8-bit integers from corresponding bytes of two 256-bit integer vectors using unsigned saturation, and returns each sum in the corresponding byte of the 256-bit integer vector result. </p>
<p>This intrinsic corresponds to the <code>VPADDUSB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00387">387</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00747">_mm256_mask_adds_epu8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00755">_mm256_maskz_adds_epu8()</a>.</p>

</div>
</div>
<a id="a05b4ece913b92fa300c7fb60a2a70040" name="a05b4ece913b92fa300c7fb60a2a70040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b4ece913b92fa300c7fb60a2a70040">&#9670;&#160;</a></span>_mm256_and_si256()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_and_si256 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise AND of the 256-bit integer vectors in <em>__a</em> and <em>__b</em>. </p>
<p>This intrinsic corresponds to the <code>VPAND</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00451">451</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l02508">_mm256_mask_test_epi16_mask()</a>, <a class="el" href="avx512vlintrin_8h_source.html#l06160">_mm256_mask_test_epi32_mask()</a>, <a class="el" href="avx512vlintrin_8h_source.html#l06187">_mm256_mask_test_epi64_mask()</a>, <a class="el" href="avx512vlbwintrin_8h_source.html#l02481">_mm256_mask_test_epi8_mask()</a>, <a class="el" href="avx512vlbwintrin_8h_source.html#l02561">_mm256_mask_testn_epi16_mask()</a>, <a class="el" href="avx512vlintrin_8h_source.html#l06214">_mm256_mask_testn_epi32_mask()</a>, <a class="el" href="avx512vlintrin_8h_source.html#l06241">_mm256_mask_testn_epi64_mask()</a>, <a class="el" href="avx512vlbwintrin_8h_source.html#l02535">_mm256_mask_testn_epi8_mask()</a>, <a class="el" href="avx512vlbwintrin_8h_source.html#l02501">_mm256_test_epi16_mask()</a>, <a class="el" href="avx512vlintrin_8h_source.html#l06153">_mm256_test_epi32_mask()</a>, <a class="el" href="avx512vlintrin_8h_source.html#l06180">_mm256_test_epi64_mask()</a>, <a class="el" href="avx512vlbwintrin_8h_source.html#l02474">_mm256_test_epi8_mask()</a>, <a class="el" href="avx512vlbwintrin_8h_source.html#l02554">_mm256_testn_epi16_mask()</a>, <a class="el" href="avx512vlintrin_8h_source.html#l06207">_mm256_testn_epi32_mask()</a>, <a class="el" href="avx512vlintrin_8h_source.html#l06234">_mm256_testn_epi64_mask()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l02528">_mm256_testn_epi8_mask()</a>.</p>

</div>
</div>
<a id="ad3c77b7bf2d8fd2dfb073b14a14b1ba2" name="ad3c77b7bf2d8fd2dfb073b14a14b1ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c77b7bf2d8fd2dfb073b14a14b1ba2">&#9670;&#160;</a></span>_mm256_andnot_si256()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_andnot_si256 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise AND of the 256-bit integer vector in <em>__b</em> with the bitwise NOT of the 256-bit integer vector in <em>__a</em>. </p>
<p>This intrinsic corresponds to the <code>VPANDN</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00469">469</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="aa22ee1dca08e46d756de99cb7e96969a" name="aa22ee1dca08e46d756de99cb7e96969a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22ee1dca08e46d756de99cb7e96969a">&#9670;&#160;</a></span>_mm256_avg_epu16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_avg_epu16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the averages of the corresponding unsigned 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns each average in the corresponding element of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*16</div>
<div class="line">  result[j+15:j] := (__a[j+15:j] + __b[j+15:j] + 1) &gt;&gt; 1</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPAVGW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00521">521</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00843">_mm256_mask_avg_epu16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00851">_mm256_maskz_avg_epu16()</a>.</p>

</div>
</div>
<a id="af8bed13563c4899b28a80ee1650f5464" name="af8bed13563c4899b28a80ee1650f5464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bed13563c4899b28a80ee1650f5464">&#9670;&#160;</a></span>_mm256_avg_epu8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_avg_epu8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the averages of the corresponding unsigned bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns each average in the corresponding byte of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 31</div>
<div class="line">  j := i*8</div>
<div class="line">  result[j+7:j] := (__a[j+7:j] + __b[j+7:j] + 1) &gt;&gt; 1</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPAVGB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00495">495</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00811">_mm256_mask_avg_epu8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00819">_mm256_maskz_avg_epu8()</a>.</p>

</div>
</div>
<a id="a62142b089038d77658d0b4b8a0d9cc60" name="a62142b089038d77658d0b4b8a0d9cc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62142b089038d77658d0b4b8a0d9cc60">&#9670;&#160;</a></span>_mm256_blendv_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_blendv_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__V1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__V2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__M</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges 8-bit integer values from either of the two 256-bit vectors <em>__V1</em> or <em>__V2</em>, as specified by the 256-bit mask <em>__M</em> and returns the resulting 256-bit integer vector. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 31</div>
<div class="line">  j := i*8</div>
<div class="line">  IF __M[7+i] == 0</div>
<div class="line">    result[7+j:j] := __V1[7+j:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[7+j:j] := __V2[7+j:j]</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPBLENDVB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V1</td><td>A 256-bit integer vector containing source values. </td></tr>
    <tr><td class="paramname">__V2</td><td>A 256-bit integer vector containing source values. </td></tr>
    <tr><td class="paramname">__M</td><td>A 256-bit integer vector, with bit [7] of each byte specifying the source for each corresponding byte of the result. When the mask bit is 0, the byte is copied from <em>__V1</em>; otherwise, it is copied from <em>__V2</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00556">556</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a75b65c7f74b80298dd753b067bb5ba42" name="a75b65c7f74b80298dd753b067bb5ba42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b65c7f74b80298dd753b067bb5ba42">&#9670;&#160;</a></span>_mm256_broadcastb_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_broadcastb_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the low byte from the 128-bit integer vector in <em>__X</em> to all bytes of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPBROADCASTB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit integer vector whose low byte will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03142">3142</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l02632">_mm256_mask_broadcastb_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l02640">_mm256_maskz_broadcastb_epi8()</a>.</p>

</div>
</div>
<a id="ad902bf9f90ecbfc92a4ad3fd87b9ceb3" name="ad902bf9f90ecbfc92a4ad3fd87b9ceb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad902bf9f90ecbfc92a4ad3fd87b9ceb3">&#9670;&#160;</a></span>_mm256_broadcastd_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_broadcastd_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the low element from the 128-bit vector of [4 x i32] in <em>__X</em> to all elements of the result's 256-bit vector of [8 x i32]. </p>
<p>This intrinsic corresponds to the <code>VPBROADCASTD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [4 x i32] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03174">3174</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06900">_mm256_mask_broadcastd_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06908">_mm256_maskz_broadcastd_epi32()</a>.</p>

</div>
</div>
<a id="afd93adcfd69f94269bd751d664199481" name="afd93adcfd69f94269bd751d664199481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd93adcfd69f94269bd751d664199481">&#9670;&#160;</a></span>_mm256_broadcastq_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_broadcastq_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the low element from the 128-bit vector of [2 x i64] in <em>__X</em> to all elements of the result's 256-bit vector of [4 x i64]. </p>
<p>This intrinsic corresponds to the <code>VPBROADCASTQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [2 x i64] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03190">3190</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06932">_mm256_mask_broadcastq_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06940">_mm256_maskz_broadcastq_epi64()</a>.</p>

</div>
</div>
<a id="a5bea69dd9bbf4de7be8b17aa32918268" name="a5bea69dd9bbf4de7be8b17aa32918268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bea69dd9bbf4de7be8b17aa32918268">&#9670;&#160;</a></span>_mm256_broadcastsd_pd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256d <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_broadcastsd_pd </td>
          <td>(</td>
          <td class="paramtype">__m128d</td>          <td class="paramname"><span class="paramname"><em>__X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the 64-bit floating-point value from the low element of the 128-bit vector of [2 x double] in <em>__X</em> to all elements of the result's 256-bit vector of [4 x double]. </p>
<p>This intrinsic corresponds to the <code>VBROADCASTSD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [2 x double] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x double] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03034">3034</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06836">_mm256_mask_broadcastsd_pd()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06844">_mm256_maskz_broadcastsd_pd()</a>.</p>

</div>
</div>
<a id="a4f7018cff60b93116947e57eea1f1c63" name="a4f7018cff60b93116947e57eea1f1c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7018cff60b93116947e57eea1f1c63">&#9670;&#160;</a></span>_mm256_broadcastsi128_si256()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_broadcastsi128_si256 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the 128-bit integer data from <em>__X</em> to both the lower and upper halves of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VBROADCASTI128</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit integer vector to be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03050">3050</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="af5947990d7f735029f6d858c99e76ee0" name="af5947990d7f735029f6d858c99e76ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5947990d7f735029f6d858c99e76ee0">&#9670;&#160;</a></span>_mm256_broadcastss_ps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256 <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_broadcastss_ps </td>
          <td>(</td>
          <td class="paramtype">__m128</td>          <td class="paramname"><span class="paramname"><em>__X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the 32-bit floating-point value from the low element of the 128-bit vector of [4 x float] in <em>__X</em> to all elements of the result's 256-bit vector of [8 x float]. </p>
<p>This intrinsic corresponds to the <code>VBROADCASTSS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [4 x float] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x float] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03017">3017</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06868">_mm256_mask_broadcastss_ps()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06876">_mm256_maskz_broadcastss_ps()</a>.</p>

</div>
</div>
<a id="ab7f81e03d536bf939f44b377b365f102" name="ab7f81e03d536bf939f44b377b365f102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f81e03d536bf939f44b377b365f102">&#9670;&#160;</a></span>_mm256_broadcastw_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_broadcastw_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the low element from the 128-bit vector of [8 x i16] in <em>__X</em> to all elements of the result's 256-bit vector of [16 x i16]. </p>
<p>This intrinsic corresponds to the <code>VPBROADCASTW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [8 x i16] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03158">3158</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l02664">_mm256_mask_broadcastw_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l02672">_mm256_maskz_broadcastw_epi16()</a>.</p>

</div>
</div>
<a id="a8d3995744cd296ba3afe8e63286cc001" name="a8d3995744cd296ba3afe8e63286cc001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3995744cd296ba3afe8e63286cc001">&#9670;&#160;</a></span>_mm256_cmpeq_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cmpeq_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares corresponding elements in the 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> for equality and returns the outcomes in the corresponding elements of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*16</div>
<div class="line">  result[j+15:j] := (__a[j+15:j] == __b[j+15:j]) ? 0xFFFF : 0</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPCMPEQW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the inputs. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00650">650</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="ab08dc58285046d2fcd2f22d810142926" name="ab08dc58285046d2fcd2f22d810142926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08dc58285046d2fcd2f22d810142926">&#9670;&#160;</a></span>_mm256_cmpeq_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cmpeq_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares corresponding elements in the 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> for equality and returns the outcomes in the corresponding elements of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*32</div>
<div class="line">  result[j+31:j] := (__a[j+31:j] == __b[j+31:j]) ? 0xFFFFFFFF : 0</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPCMPEQD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing one of the inputs. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing one of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00676">676</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a7dfc980648d672eb11da414edb750685" name="a7dfc980648d672eb11da414edb750685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dfc980648d672eb11da414edb750685">&#9670;&#160;</a></span>_mm256_cmpeq_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cmpeq_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares corresponding elements in the 256-bit vectors of [4 x i64] in <em>__a</em> and <em>__b</em> for equality and returns the outcomes in the corresponding elements of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*64</div>
<div class="line">  result[j+63:j] := (__a[j+63:j] == __b[j+63:j]) ? 0xFFFFFFFFFFFFFFFF : 0</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPCMPEQQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] containing one of the inputs. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [4 x i64] containing one of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00702">702</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a1c56e14a2dde3eb2c34d1e9d6dcc253d" name="a1c56e14a2dde3eb2c34d1e9d6dcc253d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c56e14a2dde3eb2c34d1e9d6dcc253d">&#9670;&#160;</a></span>_mm256_cmpeq_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cmpeq_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares corresponding bytes in the 256-bit integer vectors in <em>__a</em> and <em>__b</em> for equality and returns the outcomes in the corresponding bytes of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 31</div>
<div class="line">  j := i*8</div>
<div class="line">  result[j+7:j] := (__a[j+7:j] == __b[j+7:j]) ? 0xFF : 0</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPCMPEQB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing one of the inputs. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector containing one of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00624">624</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a786920fc3bb94533373fca034895faec" name="a786920fc3bb94533373fca034895faec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786920fc3bb94533373fca034895faec">&#9670;&#160;</a></span>_mm256_cmpgt_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cmpgt_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares corresponding signed elements in the 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> for greater-than and returns the outcomes in the corresponding elements of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*16</div>
<div class="line">  result[j+15:j] := (__a[j+15:j] &gt; __b[j+15:j]) ? 0xFFFF : 0</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPCMPGTW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the inputs. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00756">756</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a3e3c233b478906cc78e36cf04610b79a" name="a3e3c233b478906cc78e36cf04610b79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3c233b478906cc78e36cf04610b79a">&#9670;&#160;</a></span>_mm256_cmpgt_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cmpgt_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares corresponding signed elements in the 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> for greater-than and returns the outcomes in the corresponding elements of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*32</div>
<div class="line">  result[j+31:j] := (__a[j+31:j] &gt; __b[j+31:j]) ? 0xFFFFFFFF : 0</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPCMPGTD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing one of the inputs. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing one of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00782">782</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a55c95c13f7072f5de6a1a81079605e87" name="a55c95c13f7072f5de6a1a81079605e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c95c13f7072f5de6a1a81079605e87">&#9670;&#160;</a></span>_mm256_cmpgt_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cmpgt_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares corresponding signed elements in the 256-bit vectors of [4 x i64] in <em>__a</em> and <em>__b</em> for greater-than and returns the outcomes in the corresponding elements of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*64</div>
<div class="line">  result[j+63:j] := (__a[j+63:j] &gt; __b[j+63:j]) ? 0xFFFFFFFFFFFFFFFF : 0</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPCMPGTQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] containing one of the inputs. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [4 x i64] containing one of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00808">808</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a3576feade9f12b451ae0c9c4a0061029" name="a3576feade9f12b451ae0c9c4a0061029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3576feade9f12b451ae0c9c4a0061029">&#9670;&#160;</a></span>_mm256_cmpgt_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cmpgt_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares corresponding signed bytes in the 256-bit integer vectors in <em>__a</em> and <em>__b</em> for greater-than and returns the outcomes in the corresponding bytes of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 31</div>
<div class="line">  j := i*8</div>
<div class="line">  result[j+7:j] := (__a[j+7:j] &gt; __b[j+7:j]) ? 0xFF : 0</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPCMPGTB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing one of the inputs. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector containing one of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00728">728</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a061af1a474bed2da900b2cd81a56391c" name="a061af1a474bed2da900b2cd81a56391c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061af1a474bed2da900b2cd81a56391c">&#9670;&#160;</a></span>_mm256_cvtepi16_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepi16_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extends 16-bit elements from the 128-bit vector of [8 x i16] in <em>__V</em> and returns the 32-bit values in the corresponding elements of a 256-bit vector of [8 x i32]. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*16</div>
<div class="line">  k := i*32</div>
<div class="line">  result[k+31:k] := SignExtend(__V[j+15:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVSXWD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit vector of [8 x i16] containing the source values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the sign-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01420">1420</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04091">_mm256_mask_cvtepi16_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04099">_mm256_maskz_cvtepi16_epi32()</a>.</p>

</div>
</div>
<a id="adb8fb5be9f7b10d9d6370a9d21f27e10" name="adb8fb5be9f7b10d9d6370a9d21f27e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8fb5be9f7b10d9d6370a9d21f27e10">&#9670;&#160;</a></span>_mm256_cvtepi16_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepi16_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extends 16-bit elements from the lower half of the 128-bit vector of [8 x i16] in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64]. </p>
<div class="fragment"><div class="line">result[63:0] := SignExtend(__V[15:0])</div>
<div class="line">result[127:64] := SignExtend(__V[31:16])</div>
<div class="line">result[191:128] := SignExtend(__V[47:32])</div>
<div class="line">result[255:192] := SignExtend(__V[64:48])</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVSXWQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit vector of [8 x i16] containing the source values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the sign-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01445">1445</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04123">_mm256_mask_cvtepi16_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04131">_mm256_maskz_cvtepi16_epi64()</a>.</p>

</div>
</div>
<a id="abdc0f7b9b824d94be3162eed4b231f48" name="abdc0f7b9b824d94be3162eed4b231f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc0f7b9b824d94be3162eed4b231f48">&#9670;&#160;</a></span>_mm256_cvtepi32_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepi32_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extends 32-bit elements from the 128-bit vector of [4 x i32] in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64]. </p>
<div class="fragment"><div class="line">result[63:0] := SignExtend(__V[31:0])</div>
<div class="line">result[127:64] := SignExtend(__V[63:32])</div>
<div class="line">result[191:128] := SignExtend(__V[95:64])</div>
<div class="line">result[255:192] := SignExtend(__V[127:96])</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVSXDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit vector of [4 x i32] containing the source values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the sign-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01470">1470</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04059">_mm256_mask_cvtepi32_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04067">_mm256_maskz_cvtepi32_epi64()</a>.</p>

</div>
</div>
<a id="a1add4929d67f5823d4c81dedfa2d3903" name="a1add4929d67f5823d4c81dedfa2d3903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1add4929d67f5823d4c81dedfa2d3903">&#9670;&#160;</a></span>_mm256_cvtepi8_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepi8_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extends bytes from the 128-bit integer vector in <em>__V</em> and returns the 16-bit values in the corresponding elements of a 256-bit vector of [16 x i16]. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*8</div>
<div class="line">  k := i*16</div>
<div class="line">  result[k+15:k] := SignExtend(__V[j+7:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVSXBW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit integer vector containing the source bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the sign-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01337">1337</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01774">_mm256_mask_cvtepi8_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01782">_mm256_maskz_cvtepi8_epi16()</a>.</p>

</div>
</div>
<a id="a19f2f0881d66b9de014e6eb8ab3a9dab" name="a19f2f0881d66b9de014e6eb8ab3a9dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f2f0881d66b9de014e6eb8ab3a9dab">&#9670;&#160;</a></span>_mm256_cvtepi8_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepi8_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extends bytes from the lower half of the 128-bit integer vector in <em>__V</em> and returns the 32-bit values in the corresponding elements of a 256-bit vector of [8 x i32]. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*8</div>
<div class="line">  k := i*32</div>
<div class="line">  result[k+31:k] := SignExtend(__V[j+7:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVSXBD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit integer vector containing the source bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the sign-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01365">1365</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l03995">_mm256_mask_cvtepi8_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04003">_mm256_maskz_cvtepi8_epi32()</a>.</p>

</div>
</div>
<a id="ae14d1ebebc75eca235d1f3b8bf5d41c1" name="ae14d1ebebc75eca235d1f3b8bf5d41c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14d1ebebc75eca235d1f3b8bf5d41c1">&#9670;&#160;</a></span>_mm256_cvtepi8_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepi8_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extends the first four bytes from the 128-bit integer vector in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64]. </p>
<div class="fragment"><div class="line">result[63:0] := SignExtend(__V[7:0])</div>
<div class="line">result[127:64] := SignExtend(__V[15:8])</div>
<div class="line">result[191:128] := SignExtend(__V[23:16])</div>
<div class="line">result[255:192] := SignExtend(__V[31:24])</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVSXBQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit integer vector containing the source bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the sign-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01392">1392</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04027">_mm256_mask_cvtepi8_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04035">_mm256_maskz_cvtepi8_epi64()</a>.</p>

</div>
</div>
<a id="a7b021fb3012738fa4c6dbdfdec1e7ae0" name="a7b021fb3012738fa4c6dbdfdec1e7ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b021fb3012738fa4c6dbdfdec1e7ae0">&#9670;&#160;</a></span>_mm256_cvtepu16_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepu16_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero-extends 16-bit elements from the 128-bit vector of [8 x i16] in <em>__V</em> and returns the 32-bit values in the corresponding elements of a 256-bit vector of [8 x i32]. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*16</div>
<div class="line">  k := i*32</div>
<div class="line">  result[k+31:k] := ZeroExtend(__V[j+15:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVZXWD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit vector of [8 x i16] containing the source values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the zero-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01573">1573</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04252">_mm256_mask_cvtepu16_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04260">_mm256_maskz_cvtepu16_epi32()</a>.</p>

</div>
</div>
<a id="ab629f05b42ddb47b7b0928c0799f57e9" name="ab629f05b42ddb47b7b0928c0799f57e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab629f05b42ddb47b7b0928c0799f57e9">&#9670;&#160;</a></span>_mm256_cvtepu16_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepu16_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero-extends 16-bit elements from the lower half of the 128-bit vector of [8 x i16] in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64]. </p>
<div class="fragment"><div class="line">result[63:0] := ZeroExtend(__V[15:0])</div>
<div class="line">result[127:64] := ZeroExtend(__V[31:16])</div>
<div class="line">result[191:128] := ZeroExtend(__V[47:32])</div>
<div class="line">result[255:192] := ZeroExtend(__V[64:48])</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVSXWQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit vector of [8 x i16] containing the source values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the zero-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01598">1598</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04284">_mm256_mask_cvtepu16_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04292">_mm256_maskz_cvtepu16_epi64()</a>.</p>

</div>
</div>
<a id="ad416d1dc4dc5b103142f8aae139bdf13" name="ad416d1dc4dc5b103142f8aae139bdf13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad416d1dc4dc5b103142f8aae139bdf13">&#9670;&#160;</a></span>_mm256_cvtepu32_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepu32_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero-extends 32-bit elements from the 128-bit vector of [4 x i32] in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64]. </p>
<div class="fragment"><div class="line">result[63:0] := ZeroExtend(__V[31:0])</div>
<div class="line">result[127:64] := ZeroExtend(__V[63:32])</div>
<div class="line">result[191:128] := ZeroExtend(__V[95:64])</div>
<div class="line">result[255:192] := ZeroExtend(__V[127:96])</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVZXDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit vector of [4 x i32] containing the source values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the zero-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01623">1623</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04220">_mm256_mask_cvtepu32_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04228">_mm256_maskz_cvtepu32_epi64()</a>.</p>

</div>
</div>
<a id="a2ae0545e2a12c3e680a30c1ac531f1b9" name="a2ae0545e2a12c3e680a30c1ac531f1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae0545e2a12c3e680a30c1ac531f1b9">&#9670;&#160;</a></span>_mm256_cvtepu8_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepu8_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero-extends bytes from the 128-bit integer vector in <em>__V</em> and returns the 16-bit values in the corresponding elements of a 256-bit vector of [16 x i16]. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*8</div>
<div class="line">  k := i*16</div>
<div class="line">  result[k+15:k] := ZeroExtend(__V[j+7:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVZXBW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit integer vector containing the source bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the zero-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01496">1496</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01807">_mm256_mask_cvtepu8_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01815">_mm256_maskz_cvtepu8_epi16()</a>.</p>

</div>
</div>
<a id="a046fc39808a85623a1f45aed71d1e16a" name="a046fc39808a85623a1f45aed71d1e16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046fc39808a85623a1f45aed71d1e16a">&#9670;&#160;</a></span>_mm256_cvtepu8_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepu8_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero-extends bytes from the lower half of the 128-bit integer vector in <em>__V</em> and returns the 32-bit values in the corresponding elements of a 256-bit vector of [8 x i32]. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*8</div>
<div class="line">  k := i*32</div>
<div class="line">  result[k+31:k] := ZeroExtend(__V[j+7:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVZXBD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit integer vector containing the source bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the zero-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01522">1522</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04156">_mm256_mask_cvtepu8_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04164">_mm256_maskz_cvtepu8_epi32()</a>.</p>

</div>
</div>
<a id="a97d05a1c6bfc00de679e008cf93f573f" name="a97d05a1c6bfc00de679e008cf93f573f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d05a1c6bfc00de679e008cf93f573f">&#9670;&#160;</a></span>_mm256_cvtepu8_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepu8_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero-extends the first four bytes from the 128-bit integer vector in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64]. </p>
<div class="fragment"><div class="line">result[63:0] := ZeroExtend(__V[7:0])</div>
<div class="line">result[127:64] := ZeroExtend(__V[15:8])</div>
<div class="line">result[191:128] := ZeroExtend(__V[23:16])</div>
<div class="line">result[255:192] := ZeroExtend(__V[31:24])</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVZXBQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit integer vector containing the source bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the zero-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01547">1547</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04188">_mm256_mask_cvtepu8_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04196">_mm256_maskz_cvtepu8_epi64()</a>.</p>

</div>
</div>
<a id="a04b15ed1ec6a9658484d049d654b4d3f" name="a04b15ed1ec6a9658484d049d654b4d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b15ed1ec6a9658484d049d654b4d3f">&#9670;&#160;</a></span>_mm256_hadd_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_hadd_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Horizontally adds the adjacent pairs of 16-bit integers from two 256-bit vectors of [16 x i16] and returns the lower 16 bits of each sum in an element of the [16 x i16] result (overflow is ignored). </p>
<p>Sums from <em>__a</em> are returned in the lower 64 bits of each 128-bit half of the result; sums from <em>__b</em> are returned in the upper 64 bits of each 128-bit half of the result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*128</div>
<div class="line">  result[j+15:j] := __a[j+15:j] + __a[j+31:j+16]</div>
<div class="line">  result[j+31:j+16] := __a[j+47:j+32] + __a[j+63:j+48]</div>
<div class="line">  result[j+47:j+32] := __a[j+79:j+64] + __a[j+95:j+80]</div>
<div class="line">  result[j+63:j+48] := __a[j+111:j+96] + __a[j+127:j+112]</div>
<div class="line">  result[j+79:j+64] := __b[j+15:j] + __b[j+31:j+16]</div>
<div class="line">  result[j+95:j+80] := __b[j+47:j+32] + __b[j+63:j+48]</div>
<div class="line">  result[j+111:j+96] := __b[j+79:j+64] + __b[j+95:j+80]</div>
<div class="line">  result[j+127:j+112] := __b[j+111:j+96] + __b[j+127:j+112]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPHADDW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00844">844</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="ae2d57af7ba2fcd4ff1fc40bd69a89c1e" name="ae2d57af7ba2fcd4ff1fc40bd69a89c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d57af7ba2fcd4ff1fc40bd69a89c1e">&#9670;&#160;</a></span>_mm256_hadd_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_hadd_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Horizontally adds the adjacent pairs of 32-bit integers from two 256-bit vectors of [8 x i32] and returns the lower 32 bits of each sum in an element of the [8 x i32] result (overflow is ignored). </p>
<p>Sums from <em>__a</em> are returned in the lower 64 bits of each 128-bit half of the result; sums from <em>__b</em> are returned in the upper 64 bits of each 128-bit half of the result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*128</div>
<div class="line">  result[j+31:j] := __a[j+31:j] + __a[j+63:j+32]</div>
<div class="line">  result[j+63:j+32] := __a[j+95:j+64] + __a[j+127:j+96]</div>
<div class="line">  result[j+95:j+64] := __b[j+31:j] + __b[j+63:j+32]</div>
<div class="line">  result[j+127:j+96] := __b[j+95:j+64] + __b[j+127:j+96]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPHADDD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00876">876</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a6ac82b9f1eb9cec755e5bbff0e5a8c9a" name="a6ac82b9f1eb9cec755e5bbff0e5a8c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac82b9f1eb9cec755e5bbff0e5a8c9a">&#9670;&#160;</a></span>_mm256_hadds_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_hadds_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Horizontally adds the adjacent pairs of 16-bit integers from two 256-bit vectors of [16 x i16] using signed saturation and returns each sum in an element of the [16 x i16] result. </p>
<p>Sums from <em>__a</em> are returned in the lower 64 bits of each 128-bit half of the result; sums from <em>__b</em> are returned in the upper 64 bits of each 128-bit half of the result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*128</div>
<div class="line">  result[j+15:j] := SATURATE16(__a[j+15:j] + __a[j+31:j+16])</div>
<div class="line">  result[j+31:j+16] := SATURATE16(__a[j+47:j+32] + __a[j+63:j+48])</div>
<div class="line">  result[j+47:j+32] := SATURATE16(__a[j+79:j+64] + __a[j+95:j+80])</div>
<div class="line">  result[j+63:j+48] := SATURATE16(__a[j+111:j+96] + __a[j+127:j+112])</div>
<div class="line">  result[j+79:j+64] := SATURATE16(__b[j+15:j] + __b[j+31:j+16])</div>
<div class="line">  result[j+95:j+80] := SATURATE16(__b[j+47:j+32] + __b[j+63:j+48])</div>
<div class="line">  result[j+111:j+96] := SATURATE16(__b[j+79:j+64] + __b[j+95:j+80])</div>
<div class="line">  result[j+127:j+112] := SATURATE16(__b[j+111:j+96] + __b[j+127:j+112])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPHADDSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00911">911</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a47dba9aa45c3b9f52e2acb9016fa2dae" name="a47dba9aa45c3b9f52e2acb9016fa2dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47dba9aa45c3b9f52e2acb9016fa2dae">&#9670;&#160;</a></span>_mm256_hsub_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_hsub_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Horizontally subtracts adjacent pairs of 16-bit integers from two 256-bit vectors of [16 x i16] and returns the lower 16 bits of each difference in an element of the [16 x i16] result (overflow is ignored). </p>
<p>Differences from <em>__a</em> are returned in the lower 64 bits of each 128-bit half of the result; differences from <em>__b</em> are returned in the upper 64 bits of each 128-bit half of the result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*128</div>
<div class="line">  result[j+15:j] := __a[j+15:j] - __a[j+31:j+16]</div>
<div class="line">  result[j+31:j+16] := __a[j+47:j+32] - __a[j+63:j+48]</div>
<div class="line">  result[j+47:j+32] := __a[j+79:j+64] - __a[j+95:j+80]</div>
<div class="line">  result[j+63:j+48] := __a[j+111:j+96] - __a[j+127:j+112]</div>
<div class="line">  result[j+79:j+64] := __b[j+15:j] - __b[j+31:j+16]</div>
<div class="line">  result[j+95:j+80] := __b[j+47:j+32] - __b[j+63:j+48]</div>
<div class="line">  result[j+111:j+96] := __b[j+79:j+64] - __b[j+95:j+80]</div>
<div class="line">  result[j+127:j+112] := __b[j+111:j+96] - __b[j+127:j+112]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPHSUBW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00947">947</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a72c77e9df5766726e6bc06112dc97d44" name="a72c77e9df5766726e6bc06112dc97d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c77e9df5766726e6bc06112dc97d44">&#9670;&#160;</a></span>_mm256_hsub_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_hsub_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Horizontally subtracts adjacent pairs of 32-bit integers from two 256-bit vectors of [8 x i32] and returns the lower 32 bits of each difference in an element of the [8 x i32] result (overflow is ignored). </p>
<p>Differences from <em>__a</em> are returned in the lower 64 bits of each 128-bit half of the result; differences from <em>__b</em> are returned in the upper 64 bits of each 128-bit half of the result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*128</div>
<div class="line">  result[j+31:j] := __a[j+31:j] - __a[j+63:j+32]</div>
<div class="line">  result[j+63:j+32] := __a[j+95:j+64] - __a[j+127:j+96]</div>
<div class="line">  result[j+95:j+64] := __b[j+31:j] - __b[j+63:j+32]</div>
<div class="line">  result[j+127:j+96] := __b[j+95:j+64] - __b[j+127:j+96]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPHSUBD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00979">979</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a85ce513f7958d273eaebafb97d071f4b" name="a85ce513f7958d273eaebafb97d071f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ce513f7958d273eaebafb97d071f4b">&#9670;&#160;</a></span>_mm256_hsubs_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_hsubs_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Horizontally subtracts adjacent pairs of 16-bit integers from two 256-bit vectors of [16 x i16] using signed saturation and returns each sum in an element of the [16 x i16] result. </p>
<p>Differences from <em>__a</em> are returned in the lower 64 bits of each 128-bit half of the result; differences from <em>__b</em> are returned in the upper 64 bits of each 128-bit half of the result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*128</div>
<div class="line">  result[j+15:j] := SATURATE16(__a[j+15:j] - __a[j+31:j+16])</div>
<div class="line">  result[j+31:j+16] := SATURATE16(__a[j+47:j+32] - __a[j+63:j+48])</div>
<div class="line">  result[j+47:j+32] := SATURATE16(__a[j+79:j+64] - __a[j+95:j+80])</div>
<div class="line">  result[j+63:j+48] := SATURATE16(__a[j+111:j+96] - __a[j+127:j+112])</div>
<div class="line">  result[j+79:j+64] := SATURATE16(__b[j+15:j] - __b[j+31:j+16])</div>
<div class="line">  result[j+95:j+80] := SATURATE16(__b[j+47:j+32] - __b[j+63:j+48])</div>
<div class="line">  result[j+111:j+96] := SATURATE16(__b[j+79:j+64] - __b[j+95:j+80])</div>
<div class="line">  result[j+127:j+112] := SATURATE16(__b[j+111:j+96] - __b[j+127:j+112])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPHSUBSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01015">1015</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a9a736efeb017832345499b28c44af161" name="a9a736efeb017832345499b28c44af161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a736efeb017832345499b28c44af161">&#9670;&#160;</a></span>_mm256_madd_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_madd_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies corresponding 16-bit elements of two 256-bit vectors of [16 x i16], forming 32-bit intermediate products, and adds pairs of those products to form 32-bit sums returned as elements of the [8 x i32] result. </p>
<p>There is only one wraparound case: when all four of the 16-bit sources are <code>0x8000</code>, the result will be <code>0x80000000</code>.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*32</div>
<div class="line">  temp1 := __a[j+15:j] * __b[j+15:j]</div>
<div class="line">  temp2 := __a[j+31:j+16] * __b[j+31:j+16]</div>
<div class="line">  result[j+31:j] := temp1 + temp2</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMADDWD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01077">1077</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01386">_mm256_mask_madd_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01393">_mm256_maskz_madd_epi16()</a>.</p>

</div>
</div>
<a id="a3f1ca72807cf9d112a8db52f1c688400" name="a3f1ca72807cf9d112a8db52f1c688400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1ca72807cf9d112a8db52f1c688400">&#9670;&#160;</a></span>_mm256_maddubs_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_maddubs_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies each unsigned byte from the 256-bit integer vector in <em>__a</em> with the corresponding signed byte from the 256-bit integer vector in <em>__b</em>, forming signed 16-bit intermediate products. </p>
<p>Adds adjacent pairs of those products using signed saturation to form 16-bit sums returned as elements of the [16 x i16] result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*16</div>
<div class="line">  temp1 := __a[j+7:j] * __b[j+7:j]</div>
<div class="line">  temp2 := __a[j+15:j+8] * __b[j+15:j+8]</div>
<div class="line">  result[j+15:j] := SATURATE16(temp1 + temp2)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMADDUBSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01045">1045</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01357">_mm256_mask_maddubs_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01365">_mm256_maskz_maddubs_epi16()</a>.</p>

</div>
</div>
<a id="a22fd743b1c2f9aed720704b10114e42c" name="a22fd743b1c2f9aed720704b10114e42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fd743b1c2f9aed720704b10114e42c">&#9670;&#160;</a></span>_mm256_maskload_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_maskload_epi32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> const *</td>          <td class="paramname"><span class="paramname"><em>__X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__M</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally loads eight 32-bit integer elements from memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, sets that element of the result to zero. </p>
<p>Returns the 256-bit [8 x i32] result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*32</div>
<div class="line">  IF __M[j+31] == 1</div>
<div class="line">    result[j+31:j] := Load32(__X+(i*4))</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := 0</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMASKMOVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">__M</td><td>A 256-bit vector of [8 x i32] containing the mask bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the loaded or zeroed elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03492">3492</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a1997e59ad47611e448defb72da464056" name="a1997e59ad47611e448defb72da464056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1997e59ad47611e448defb72da464056">&#9670;&#160;</a></span>_mm256_maskload_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_maskload_epi64 </td>
          <td>(</td>
          <td class="paramtype">long long const *</td>          <td class="paramname"><span class="paramname"><em>__X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__M</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally loads four 64-bit integer elements from memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, sets that element of the result to zero. </p>
<p>Returns the 256-bit [4 x i64] result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*64</div>
<div class="line">  IF __M[j+63] == 1</div>
<div class="line">    result[j+63:j] := Load64(__X+(i*8))</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := 0</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMASKMOVQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">__M</td><td>A 256-bit vector of [4 x i64] containing the mask bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the loaded or zeroed elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03524">3524</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a1bf351469e97da264116eea7952c2aba" name="a1bf351469e97da264116eea7952c2aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf351469e97da264116eea7952c2aba">&#9670;&#160;</a></span>_mm256_maskstore_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ void <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_maskstore_epi32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> *</td>          <td class="paramname"><span class="paramname"><em>__X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__Y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally stores eight 32-bit integer elements from the 256-bit vector of [8 x i32] in <em>__Y</em> to memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, the memory element is unchanged. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*32</div>
<div class="line">  IF __M[j+31] == 1</div>
<div class="line">    Store32(__X+(i*4), __Y[j+31:j])</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMASKMOVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A pointer to the memory used for storing values. </td></tr>
    <tr><td class="paramname">__M</td><td>A 256-bit vector of [8 x i32] containing the mask bits. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 256-bit vector of [8 x i32] containing the values to store. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03618">3618</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

</div>
</div>
<a id="a0559634edb55b319e7ee19baac957c95" name="a0559634edb55b319e7ee19baac957c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0559634edb55b319e7ee19baac957c95">&#9670;&#160;</a></span>_mm256_maskstore_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ void <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_maskstore_epi64 </td>
          <td>(</td>
          <td class="paramtype">long long *</td>          <td class="paramname"><span class="paramname"><em>__X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__Y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally stores four 64-bit integer elements from the 256-bit vector of [4 x i64] in <em>__Y</em> to memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, the memory element is unchanged. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*64</div>
<div class="line">  IF __M[j+63] == 1</div>
<div class="line">    Store64(__X+(i*8), __Y[j+63:j])</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMASKMOVQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A pointer to the memory used for storing values. </td></tr>
    <tr><td class="paramname">__M</td><td>A 256-bit vector of [4 x i64] containing the mask bits. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 256-bit vector of [4 x i64] containing the values to store. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03648">3648</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

</div>
</div>
<a id="a6c5111412077ead099ddee344188839b" name="a6c5111412077ead099ddee344188839b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5111412077ead099ddee344188839b">&#9670;&#160;</a></span>_mm256_max_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_max_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding signed 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding element of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMAXSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01115">1115</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00915">_mm256_mask_max_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00907">_mm256_maskz_max_epi16()</a>.</p>

</div>
</div>
<a id="a6fbbe31483e96447c3e05be279bdc57f" name="a6fbbe31483e96447c3e05be279bdc57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbbe31483e96447c3e05be279bdc57f">&#9670;&#160;</a></span>_mm256_max_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_max_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding signed 32-bit integers in the two 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding element of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMAXSD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01134">1134</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l03049">_mm256_mask_max_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l03042">_mm256_maskz_max_epi32()</a>.</p>

</div>
</div>
<a id="a37b9e0bac773f0d39f3b41ef45d5d68c" name="a37b9e0bac773f0d39f3b41ef45d5d68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b9e0bac773f0d39f3b41ef45d5d68c">&#9670;&#160;</a></span>_mm256_max_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_max_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding signed bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding byte of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMAXSB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01096">1096</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00883">_mm256_mask_max_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00875">_mm256_maskz_max_epi8()</a>.</p>

</div>
</div>
<a id="a075d5a2c501aac700288afa0c508c973" name="a075d5a2c501aac700288afa0c508c973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075d5a2c501aac700288afa0c508c973">&#9670;&#160;</a></span>_mm256_max_epu16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_max_epu16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding unsigned 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding element of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMAXUW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01172">1172</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00979">_mm256_mask_max_epu16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00971">_mm256_maskz_max_epu16()</a>.</p>

</div>
</div>
<a id="a51d1902c5c1b74ba78ba57686e3a5582" name="a51d1902c5c1b74ba78ba57686e3a5582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d1902c5c1b74ba78ba57686e3a5582">&#9670;&#160;</a></span>_mm256_max_epu32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_max_epu32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding unsigned 32-bit integers in the two 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding element of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMAXUD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01191">1191</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l03115">_mm256_mask_max_epu32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l03108">_mm256_maskz_max_epu32()</a>.</p>

</div>
</div>
<a id="a6210035d203bef654a1f1ade4da7c749" name="a6210035d203bef654a1f1ade4da7c749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6210035d203bef654a1f1ade4da7c749">&#9670;&#160;</a></span>_mm256_max_epu8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_max_epu8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding unsigned bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding byte of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMAXUB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01153">1153</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00947">_mm256_mask_max_epu8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00939">_mm256_maskz_max_epu8()</a>.</p>

</div>
</div>
<a id="a6a3167f2bcae02dca2aadba469193eec" name="a6a3167f2bcae02dca2aadba469193eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3167f2bcae02dca2aadba469193eec">&#9670;&#160;</a></span>_mm256_min_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_min_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding signed 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding element of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMINSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01229">1229</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01043">_mm256_mask_min_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01035">_mm256_maskz_min_epi16()</a>.</p>

</div>
</div>
<a id="a96199c8df080cc2b44caf3de79afcd7a" name="a96199c8df080cc2b44caf3de79afcd7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96199c8df080cc2b44caf3de79afcd7a">&#9670;&#160;</a></span>_mm256_min_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_min_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding signed 32-bit integers in the two 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding element of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMINSD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01248">1248</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l03181">_mm256_mask_min_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l03174">_mm256_maskz_min_epi32()</a>.</p>

</div>
</div>
<a id="a2da8c62a81a77a136d34c0f5b7ee04db" name="a2da8c62a81a77a136d34c0f5b7ee04db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da8c62a81a77a136d34c0f5b7ee04db">&#9670;&#160;</a></span>_mm256_min_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_min_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding signed bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding byte of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMINSB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01210">1210</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01011">_mm256_mask_min_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01003">_mm256_maskz_min_epi8()</a>.</p>

</div>
</div>
<a id="a189b0c70faa130570dc377be3841baa2" name="a189b0c70faa130570dc377be3841baa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189b0c70faa130570dc377be3841baa2">&#9670;&#160;</a></span>_mm256_min_epu16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_min_epu16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding unsigned 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding element of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMINUW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01286">1286</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01107">_mm256_mask_min_epu16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01099">_mm256_maskz_min_epu16()</a>.</p>

</div>
</div>
<a id="ab20d0653c9d79d3962498325f0a4c65a" name="ab20d0653c9d79d3962498325f0a4c65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20d0653c9d79d3962498325f0a4c65a">&#9670;&#160;</a></span>_mm256_min_epu32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_min_epu32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding unsigned 32-bit integers in the two 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding element of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMINUD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01305">1305</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l03247">_mm256_mask_min_epu32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l03240">_mm256_maskz_min_epu32()</a>.</p>

</div>
</div>
<a id="aa362f07383b28824491e2557d958fbbe" name="aa362f07383b28824491e2557d958fbbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa362f07383b28824491e2557d958fbbe">&#9670;&#160;</a></span>_mm256_min_epu8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_min_epu8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding unsigned bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding byte of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMINUB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01267">1267</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01075">_mm256_mask_min_epu8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01067">_mm256_maskz_min_epu8()</a>.</p>

</div>
</div>
<a id="a5e0a0e64386916c1945fd80f63800234" name="a5e0a0e64386916c1945fd80f63800234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0a0e64386916c1945fd80f63800234">&#9670;&#160;</a></span>_mm256_movemask_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_movemask_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01311">1311</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

</div>
</div>
<a id="a21f2fd1fb0472301c6f6534fbb2c55b7" name="a21f2fd1fb0472301c6f6534fbb2c55b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f2fd1fb0472301c6f6534fbb2c55b7">&#9670;&#160;</a></span>_mm256_mul_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_mul_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies signed 32-bit integers from even-numbered elements of two 256-bit vectors of [8 x i32] and returns the 64-bit products in the [4 x i64] result. </p>
<div class="fragment"><div class="line">result[63:0] := __a[31:0] * __b[31:0]</div>
<div class="line">result[127:64] := __a[95:64] * __b[95:64]</div>
<div class="line">result[191:128] := __a[159:128] * __b[159:128]</div>
<div class="line">result[255:192] := __a[223:192] * __b[223:192]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMULDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the products. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01649">1649</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l00355">_mm256_mask_mul_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l00363">_mm256_maskz_mul_epi32()</a>.</p>

</div>
</div>
<a id="ae82c156df6b966a0780fbf444cf05fac" name="ae82c156df6b966a0780fbf444cf05fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82c156df6b966a0780fbf444cf05fac">&#9670;&#160;</a></span>_mm256_mul_epu32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_mul_epu32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies unsigned 32-bit integers from even-numered elements of two 256-bit vectors of [8 x i32] and returns the 64-bit products in the [4 x i64] result. </p>
<div class="fragment"><div class="line">result[63:0] := __a[31:0] * __b[31:0]</div>
<div class="line">result[127:64] := __a[95:64] * __b[95:64]</div>
<div class="line">result[191:128] := __a[159:128] * __b[159:128]</div>
<div class="line">result[255:192] := __a[223:192] * __b[223:192]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMULUDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the products. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01778">1778</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l00387">_mm256_mask_mul_epu32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l00395">_mm256_maskz_mul_epu32()</a>.</p>

</div>
</div>
<a id="a77bfbbc6944e651816ee6d43cad179f9" name="a77bfbbc6944e651816ee6d43cad179f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bfbbc6944e651816ee6d43cad179f9">&#9670;&#160;</a></span>_mm256_mulhi_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_mulhi_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies signed 16-bit integer elements of two 256-bit vectors of [16 x i16], and returns the upper 16 bits of each 32-bit product in the [16 x i16] result. </p>
<p>This intrinsic corresponds to the <code>VPMULHW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the products. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01714">1714</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01632">_mm256_mask_mulhi_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01639">_mm256_maskz_mulhi_epi16()</a>.</p>

</div>
</div>
<a id="a901d1db344d0637d0faedf57b68903e8" name="a901d1db344d0637d0faedf57b68903e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901d1db344d0637d0faedf57b68903e8">&#9670;&#160;</a></span>_mm256_mulhi_epu16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_mulhi_epu16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies unsigned 16-bit integer elements of two 256-bit vectors of [16 x i16], and returns the upper 16 bits of each 32-bit product in the [16 x i16] result. </p>
<p>This intrinsic corresponds to the <code>VPMULHUW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the products. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01695">1695</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01604">_mm256_mask_mulhi_epu16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01611">_mm256_maskz_mulhi_epu16()</a>.</p>

</div>
</div>
<a id="a53b7b55f3eed342b5e4054b0625c4b13" name="a53b7b55f3eed342b5e4054b0625c4b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b7b55f3eed342b5e4054b0625c4b13">&#9670;&#160;</a></span>_mm256_mulhrs_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_mulhrs_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies signed 16-bit integer elements of two 256-bit vectors of [16 x i16], truncates the 32-bit results to the most significant 18 bits, rounds by adding 1, and returns bits [16:1] of each rounded product in the [16 x i16] result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*16</div>
<div class="line">  temp := ((__a[j+15:j] * __b[j+15:j]) &gt;&gt; 14) + 1</div>
<div class="line">  result[j+15:j] := temp[16:1]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMULHRSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the rounded products. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01676">1676</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01576">_mm256_mask_mulhrs_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01583">_mm256_maskz_mulhrs_epi16()</a>.</p>

</div>
</div>
<a id="ab877a6985419ea9618d69a329cb88e9f" name="ab877a6985419ea9618d69a329cb88e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab877a6985419ea9618d69a329cb88e9f">&#9670;&#160;</a></span>_mm256_mullo_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_mullo_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies signed 16-bit integer elements of two 256-bit vectors of [16 x i16], and returns the lower 16 bits of each 32-bit product in the [16 x i16] result. </p>
<p>This intrinsic corresponds to the <code>VPMULLW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the products. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01733">1733</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00416">_mm256_mask_mullo_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00423">_mm256_maskz_mullo_epi16()</a>.</p>

</div>
</div>
<a id="a30c6da5556cf54db6bfc7d51eaf4118b" name="a30c6da5556cf54db6bfc7d51eaf4118b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c6da5556cf54db6bfc7d51eaf4118b">&#9670;&#160;</a></span>_mm256_mullo_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_mullo_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies signed 32-bit integer elements of two 256-bit vectors of [8 x i32], and returns the lower 32 bits of each 64-bit product in the [8 x i32] result. </p>
<p>This intrinsic corresponds to the <code>VPMULLD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the products. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01752">1752</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l00427">_mm256_mask_mullo_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l00419">_mm256_maskz_mullo_epi32()</a>.</p>

</div>
</div>
<a id="af941fc48c1c8d082fdfac5df1953156b" name="af941fc48c1c8d082fdfac5df1953156b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af941fc48c1c8d082fdfac5df1953156b">&#9670;&#160;</a></span>_mm256_or_si256()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_or_si256 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise OR of the 256-bit integer vectors in <em>__a</em> and <em>__b</em>. </p>
<p>This intrinsic corresponds to the <code>VPOR</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01796">1796</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a820ba07f5916a602806c2aecd6cd0f69" name="a820ba07f5916a602806c2aecd6cd0f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820ba07f5916a602806c2aecd6cd0f69">&#9670;&#160;</a></span>_mm256_packs_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_packs_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the elements of two 256-bit vectors of [16 x i16] to 8-bit integers using signed saturation, and returns the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*16</div>
<div class="line">  k := i*8</div>
<div class="line">  result[7+k:k] := SATURATE8(__a[15+j:j])</div>
<div class="line">  result[71+k:64+k] := SATURATE8(__b[15+j:j])</div>
<div class="line">  result[135+k:128+k] := SATURATE8(__a[143+j:128+j])</div>
<div class="line">  result[199+k:192+k] := SATURATE8(__b[143+j:128+j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPACKSSWB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] used to generate result[63:0] and result[191:128]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] used to generate result[127:64] and result[255:192]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00160">160</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00595">_mm256_mask_packs_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00587">_mm256_maskz_packs_epi16()</a>.</p>

</div>
</div>
<a id="a18f0a34407f0edaa6728ec94ced2431a" name="a18f0a34407f0edaa6728ec94ced2431a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f0a34407f0edaa6728ec94ced2431a">&#9670;&#160;</a></span>_mm256_packs_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_packs_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the elements of two 256-bit vectors of [8 x i32] to 16-bit integers using signed saturation, and returns the resulting 256-bit vector of [16 x i16]. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*32</div>
<div class="line">  k := i*16</div>
<div class="line">  result[15+k:k] := SATURATE16(__a[31+j:j])</div>
<div class="line">  result[79+k:64+k] := SATURATE16(__b[31+j:j])</div>
<div class="line">  result[143+k:128+k] := SATURATE16(__a[159+j:128+j])</div>
<div class="line">  result[207+k:192+k] := SATURATE16(__b[159+j:128+j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPACKSSDW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] used to generate result[63:0] and result[191:128]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] used to generate result[127:64] and result[255:192]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00192">192</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00563">_mm256_mask_packs_epi32()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00555">_mm256_maskz_packs_epi32()</a>.</p>

</div>
</div>
<a id="ac54fdcd67534f2defc6f2564d7a031f5" name="ac54fdcd67534f2defc6f2564d7a031f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54fdcd67534f2defc6f2564d7a031f5">&#9670;&#160;</a></span>_mm256_packus_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_packus_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts elements from two 256-bit vectors of [16 x i16] to 8-bit integers using unsigned saturation, and returns the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*16</div>
<div class="line">  k := i*8</div>
<div class="line">  result[7+k:k] := SATURATE8U(__a[15+j:j])</div>
<div class="line">  result[71+k:64+k] := SATURATE8U(__b[15+j:j])</div>
<div class="line">  result[135+k:128+k] := SATURATE8U(__a[143+j:128+j])</div>
<div class="line">  result[199+k:192+k] := SATURATE8U(__b[143+j:128+j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPACKUSWB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] used to generate result[63:0] and result[191:128]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] used to generate result[127:64] and result[255:192]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00223">223</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00659">_mm256_mask_packus_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00651">_mm256_maskz_packus_epi16()</a>.</p>

</div>
</div>
<a id="aa67ddfcbac48b6687c29540ba34187da" name="aa67ddfcbac48b6687c29540ba34187da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67ddfcbac48b6687c29540ba34187da">&#9670;&#160;</a></span>_mm256_packus_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_packus_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__V1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__V2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts elements from two 256-bit vectors of [8 x i32] to 16-bit integers using unsigned saturation, and returns the resulting 256-bit vector of [16 x i16]. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*32</div>
<div class="line">  k := i*16</div>
<div class="line">  result[15+k:k] := SATURATE16U(__V1[31+j:j])</div>
<div class="line">  result[79+k:64+k] := SATURATE16U(__V2[31+j:j])</div>
<div class="line">  result[143+k:128+k] := SATURATE16U(__V1[159+j:128+j])</div>
<div class="line">  result[207+k:192+k] := SATURATE16U(__V2[159+j:128+j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPACKUSDW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V1</td><td>A 256-bit vector of [8 x i32] used to generate result[63:0] and result[191:128]. </td></tr>
    <tr><td class="paramname">__V2</td><td>A 256-bit vector of [8 x i32] used to generate result[127:64] and result[255:192]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00255">255</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00627">_mm256_mask_packus_epi32()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00619">_mm256_maskz_packus_epi32()</a>.</p>

</div>
</div>
<a id="a33d9bff425325a7c8e2a4f857e3d0b22" name="a33d9bff425325a7c8e2a4f857e3d0b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d9bff425325a7c8e2a4f857e3d0b22">&#9670;&#160;</a></span>_mm256_permutevar8x32_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_permutevar8x32_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the result's 256-bit vector of [8 x i32] to copies of elements of the 256-bit vector of [8 x i32] in <em>__a</em> as specified by indexes in the elements of the 256-bit vector of [8 x i32] in <em>__b</em>. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*32</div>
<div class="line">  k := __b[j+2:j] * 32</div>
<div class="line">  result[j+31:j] := __a[k+31:k]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPERMD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing the source values. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing indexes of values to use from <em>__a</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03282">3282</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a5c4284aa3d71d30c3241c1ea550f4429" name="a5c4284aa3d71d30c3241c1ea550f4429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4284aa3d71d30c3241c1ea550f4429">&#9670;&#160;</a></span>_mm256_permutevar8x32_ps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256 <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_permutevar8x32_ps </td>
          <td>(</td>
          <td class="paramtype">__m256</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the result's 256-bit vector of [8 x float] to copies of elements of the 256-bit vector of [8 x float] in <em>__a</em> as specified by indexes in the elements of the 256-bit vector of [8 x i32] in <em>__b</em>. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*32</div>
<div class="line">  k := __b[j+2:j] * 32</div>
<div class="line">  result[j+31:j] := __a[k+31:k]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPERMPS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x float] containing the source values. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing indexes of values to use from <em>__a</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x float] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03340">3340</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="af3080ecebc68a7fcfa068821af41d077" name="af3080ecebc68a7fcfa068821af41d077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3080ecebc68a7fcfa068821af41d077">&#9670;&#160;</a></span>_mm256_sad_epu8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sad_epu8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes four sum of absolute difference (SAD) operations on sets of eight unsigned 8-bit integers from the 256-bit integer vectors <em>__a</em> and <em>__b</em>. </p>
<p>One SAD result is computed for each set of eight bytes from <em>__a</em> and eight bytes from <em>__b</em>. The zero-extended SAD value is returned in the corresponding 64-bit element of the result.</p>
<p>A single SAD operation takes the differences between the corresponding bytes of <em>__a</em> and <em>__b</em>, takes the absolute value of each difference, and sums these eight values to form one 16-bit result. This operation is repeated four times with successive sets of eight bytes.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*64</div>
<div class="line">  temp0 := ABS(__a[j+7:j] - __b[j+7:j])</div>
<div class="line">  temp1 := ABS(__a[j+15:j+8] - __b[j+15:j+8])</div>
<div class="line">  temp2 := ABS(__a[j+23:j+16] - __b[j+23:j+16])</div>
<div class="line">  temp3 := ABS(__a[j+31:j+24] - __b[j+31:j+24])</div>
<div class="line">  temp4 := ABS(__a[j+39:j+32] - __b[j+39:j+32])</div>
<div class="line">  temp5 := ABS(__a[j+47:j+40] - __b[j+47:j+40])</div>
<div class="line">  temp6 := ABS(__a[j+55:j+48] - __b[j+55:j+48])</div>
<div class="line">  temp7 := ABS(__a[j+63:j+56] - __b[j+63:j+56])</div>
<div class="line">  result[j+15:j] := temp0 + temp1 + temp2 + temp3 +</div>
<div class="line">                    temp4 + temp5 + temp6 + temp7</div>
<div class="line">  result[j+63:j+16] := 0</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSADBW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01841">1841</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a1ead06ffdd788a0be29d1e004cee07a9" name="a1ead06ffdd788a0be29d1e004cee07a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ead06ffdd788a0be29d1e004cee07a9">&#9670;&#160;</a></span>_mm256_shuffle_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_shuffle_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shuffles 8-bit integers in the 256-bit integer vector <em>__a</em> according to control information in the 256-bit integer vector <em>__b</em>, and returns the 256-bit result. </p>
<p>In effect there are two separate 128-bit shuffles in the lower and upper halves.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 31</div>
<div class="line">  j := i*8</div>
<div class="line">  IF __b[j+7] == 1</div>
<div class="line">    result[j+7:j] := 0</div>
<div class="line">  ELSE</div>
<div class="line">    k := __b[j+3:j] * 8</div>
<div class="line">    IF i &gt; 15</div>
<div class="line">      k := k + 128</div>
<div class="line">    FI</div>
<div class="line">    result[j+7:j] := __a[k+7:k]</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSHUFB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing source values. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector containing control information to determine what goes into the corresponding byte of the result. If bit 7 of the control byte is 1, the result byte is 0; otherwise, bits 3:0 of the control byte specify the index (within the same 128-bit half) of <em>__a</em> to copy to the result byte. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01880">1880</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01131">_mm256_mask_shuffle_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01139">_mm256_maskz_shuffle_epi8()</a>.</p>

</div>
</div>
<a id="ae1cd3c3fea44760c82d99a31a8d830ba" name="ae1cd3c3fea44760c82d99a31a8d830ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1cd3c3fea44760c82d99a31a8d830ba">&#9670;&#160;</a></span>_mm256_sign_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sign_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets each element of the result to the corresponding element of the 256-bit vector of [16 x i16] in <em>__a</em>, the negative of that element, or zero, depending on whether the corresponding element of the 256-bit vector of [16 x i16] in <em>__b</em> is greater than zero, less than zero, or equal to zero, respectively. </p>
<p>This intrinsic corresponds to the <code>VPSIGNW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02028">2028</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a67755b8ffa509f28de03a05df580fbc1" name="a67755b8ffa509f28de03a05df580fbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67755b8ffa509f28de03a05df580fbc1">&#9670;&#160;</a></span>_mm256_sign_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sign_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets each element of the result to the corresponding element of the 256-bit vector of [8 x i32] in <em>__a</em>, the negative of that element, or zero, depending on whether the corresponding element of the 256-bit vector of [8 x i32] in <em>__b</em> is greater than zero, less than zero, or equal to zero, respectively. </p>
<p>This intrinsic corresponds to the <code>VPSIGND</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02049">2049</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a77846fd35105eb6f2cbcef08f2b75140" name="a77846fd35105eb6f2cbcef08f2b75140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77846fd35105eb6f2cbcef08f2b75140">&#9670;&#160;</a></span>_mm256_sign_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sign_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets each byte of the result to the corresponding byte of the 256-bit integer vector in <em>__a</em>, the negative of that byte, or zero, depending on whether the corresponding byte of the 256-bit integer vector in <em>__b</em> is greater than zero, less than zero, or equal to zero, respectively. </p>
<p>This intrinsic corresponds to the <code>VPSIGNB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02007">2007</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a5606790c952e969809a59ddf1e3510cf" name="a5606790c952e969809a59ddf1e3510cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5606790c952e969809a59ddf1e3510cf">&#9670;&#160;</a></span>_mm256_sll_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sll_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> left by the number of bits specified by the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 15, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSLLW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>A 128-bit vector of [2 x i64] whose lower element gives the unsigned shift count (in bits). The upper element is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02129">2129</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01926">_mm256_mask_sll_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01934">_mm256_maskz_sll_epi16()</a>.</p>

</div>
</div>
<a id="a0bff83b0c5ed8e28733927ba2ab93296" name="a0bff83b0c5ed8e28733927ba2ab93296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bff83b0c5ed8e28733927ba2ab93296">&#9670;&#160;</a></span>_mm256_sll_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sll_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> left by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 31, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSLLD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>A 128-bit vector of [2 x i64] whose lower element gives the unsigned shift count (in bits). The upper element is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02169">2169</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04509">_mm256_mask_sll_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04517">_mm256_maskz_sll_epi32()</a>.</p>

</div>
</div>
<a id="a160466de250277c0621a1914f45cc2a2" name="a160466de250277c0621a1914f45cc2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160466de250277c0621a1914f45cc2a2">&#9670;&#160;</a></span>_mm256_sll_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sll_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__a</em> left by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 63, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSLLQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>A 128-bit vector of [2 x i64] whose lower element gives the unsigned shift count (in bits). The upper element is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02209">2209</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04573">_mm256_mask_sll_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04581">_mm256_maskz_sll_epi64()</a>.</p>

</div>
</div>
<a id="a9142525f9097a70a473365d4819be609" name="a9142525f9097a70a473365d4819be609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9142525f9097a70a473365d4819be609">&#9670;&#160;</a></span>_mm256_slli_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_slli_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a></td>          <td class="paramname"><span class="paramname"><em>__count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> left by <em>__count</em> bits, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 15, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSLLW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>An unsigned integer value specifying the shift count (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02108">2108</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01958">_mm256_mask_slli_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01967">_mm256_maskz_slli_epi16()</a>.</p>

</div>
</div>
<a id="a1c8e153c8a1e0c5b909a192ccec34187" name="a1c8e153c8a1e0c5b909a192ccec34187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8e153c8a1e0c5b909a192ccec34187">&#9670;&#160;</a></span>_mm256_slli_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_slli_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a></td>          <td class="paramname"><span class="paramname"><em>__count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> left by <em>__count</em> bits, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 31, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSLLD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>An unsigned integer value specifying the shift count (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02148">2148</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04541">_mm256_mask_slli_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04549">_mm256_maskz_slli_epi32()</a>.</p>

</div>
</div>
<a id="ad40e1a7a9fd378072b072fbc369db480" name="ad40e1a7a9fd378072b072fbc369db480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40e1a7a9fd378072b072fbc369db480">&#9670;&#160;</a></span>_mm256_slli_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_slli_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a></td>          <td class="paramname"><span class="paramname"><em>__count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__a</em> left by <em>__count</em> bits, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 63, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSLLQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>An unsigned integer value specifying the shift count (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02188">2188</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04605">_mm256_mask_slli_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04613">_mm256_maskz_slli_epi64()</a>.</p>

</div>
</div>
<a id="a71d8eebf24183f66e3cd905501948068" name="a71d8eebf24183f66e3cd905501948068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d8eebf24183f66e3cd905501948068">&#9670;&#160;</a></span>_mm256_sllv_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sllv_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__Y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__X</em> left by the number of bits given in the corresponding element of the 256-bit vector of [8 x i32] in <em>__Y</em>, shifting in zero bits, and returns the result. </p>
<p>If the shift count for any element is greater than 31, the result for that element is zero.</p>
<p>This intrinsic corresponds to the <code>VPSLLVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 256-bit vector of [8 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 256-bit vector of [8 x i32] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03730">3730</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04757">_mm256_mask_sllv_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04765">_mm256_maskz_sllv_epi32()</a>.</p>

</div>
</div>
<a id="a3d328c38377911cc60da2a7c6d5363f5" name="a3d328c38377911cc60da2a7c6d5363f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d328c38377911cc60da2a7c6d5363f5">&#9670;&#160;</a></span>_mm256_sllv_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sllv_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__Y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__X</em> left by the number of bits given in the corresponding element of the 128-bit vector of [4 x i64] in <em>__Y</em>, shifting in zero bits, and returns the result. </p>
<p>If the shift count for any element is greater than 63, the result for that element is zero.</p>
<p>This intrinsic corresponds to the <code>VPSLLVQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 256-bit vector of [4 x i64] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 256-bit vector of [4 x i64] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03774">3774</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04725">_mm256_mask_sllv_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04733">_mm256_maskz_sllv_epi64()</a>.</p>

</div>
</div>
<a id="ad6812ecb21f05132dbb5ce31ed82aabe" name="ad6812ecb21f05132dbb5ce31ed82aabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6812ecb21f05132dbb5ce31ed82aabe">&#9670;&#160;</a></span>_mm256_sra_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sra_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in sign bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 15, each element of the result is either 0 or -1 according to the corresponding input sign bit.</p>
<p>This intrinsic corresponds to the <code>VPSRAW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>A 128-bit vector of [2 x i64] whose lower element gives the unsigned shift count (in bits). The upper element is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02251">2251</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l02079">_mm256_mask_sra_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l02087">_mm256_maskz_sra_epi16()</a>.</p>

</div>
</div>
<a id="a933b5cc7264b4572e61702aa385250c6" name="a933b5cc7264b4572e61702aa385250c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933b5cc7264b4572e61702aa385250c6">&#9670;&#160;</a></span>_mm256_sra_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sra_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in sign bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 31, each element of the result is either 0 or -1 according to the corresponding input sign bit.</p>
<p>This intrinsic corresponds to the <code>VPSRAD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>A 128-bit vector of [2 x i64] whose lower element gives the unsigned shift count (in bits). The upper element is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02293">2293</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06392">_mm256_mask_sra_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06400">_mm256_maskz_sra_epi32()</a>.</p>

</div>
</div>
<a id="abb9640e28a301bd54f3c6eba51e91180" name="abb9640e28a301bd54f3c6eba51e91180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9640e28a301bd54f3c6eba51e91180">&#9670;&#160;</a></span>_mm256_srai_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srai_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a></td>          <td class="paramname"><span class="paramname"><em>__count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> right by <em>__count</em> bits, shifting in sign bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 15, each element of the result is either 0 or -1 according to the corresponding input sign bit.</p>
<p>This intrinsic corresponds to the <code>VPSRAW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>An unsigned integer value specifying the shift count (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02229">2229</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l02111">_mm256_mask_srai_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l02120">_mm256_maskz_srai_epi16()</a>.</p>

</div>
</div>
<a id="a241b64b22d24b260ffb9a7018b1f8cca" name="a241b64b22d24b260ffb9a7018b1f8cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241b64b22d24b260ffb9a7018b1f8cca">&#9670;&#160;</a></span>_mm256_srai_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srai_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a></td>          <td class="paramname"><span class="paramname"><em>__count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> right by <em>__count</em> bits, shifting in sign bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 31, each element of the result is either 0 or -1 according to the corresponding input sign bit.</p>
<p>This intrinsic corresponds to the <code>VPSRAD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>An unsigned integer value specifying the shift count (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02271">2271</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06424">_mm256_mask_srai_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06432">_mm256_maskz_srai_epi32()</a>.</p>

</div>
</div>
<a id="a58df154a23884308de2be8f1673431bb" name="a58df154a23884308de2be8f1673431bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58df154a23884308de2be8f1673431bb">&#9670;&#160;</a></span>_mm256_srav_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srav_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__Y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__X</em> right by the number of bits given in the corresponding element of the 256-bit vector of [8 x i32] in <em>__Y</em>, shifting in sign bits, and returns the result. </p>
<p>If the shift count for any element is greater than 31, the result for that element is 0 or -1 according to the sign bit for that element.</p>
<p>This intrinsic corresponds to the <code>VPSRAVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 256-bit vector of [8 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 256-bit vector of [8 x i32] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03819">3819</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04981">_mm256_mask_srav_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04989">_mm256_maskz_srav_epi32()</a>.</p>

</div>
</div>
<a id="a0204190987d295602363fac8e957bc88" name="a0204190987d295602363fac8e957bc88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0204190987d295602363fac8e957bc88">&#9670;&#160;</a></span>_mm256_srl_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srl_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 15, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSRLW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>A 128-bit vector of [2 x i64] whose lower element gives the unsigned shift count (in bits). The upper element is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02373">2373</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l02144">_mm256_mask_srl_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l02152">_mm256_maskz_srl_epi16()</a>.</p>

</div>
</div>
<a id="a006440af4ed63245caff87056b25c3d1" name="a006440af4ed63245caff87056b25c3d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006440af4ed63245caff87056b25c3d1">&#9670;&#160;</a></span>_mm256_srl_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srl_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 31, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSRLD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>A 128-bit vector of [2 x i64] whose lower element gives the unsigned shift count (in bits). The upper element is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02413">2413</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04853">_mm256_mask_srl_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04861">_mm256_maskz_srl_epi32()</a>.</p>

</div>
</div>
<a id="acf26700184b5a83da79aca8f9ade7fc3" name="acf26700184b5a83da79aca8f9ade7fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf26700184b5a83da79aca8f9ade7fc3">&#9670;&#160;</a></span>_mm256_srl_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srl_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 63, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSRLQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>A 128-bit vector of [2 x i64] whose lower element gives the unsigned shift count (in bits). The upper element is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02453">2453</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04917">_mm256_mask_srl_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04925">_mm256_maskz_srl_epi64()</a>.</p>

</div>
</div>
<a id="afdd37fdb3fd0ebf8b12261a4c5eb325e" name="afdd37fdb3fd0ebf8b12261a4c5eb325e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd37fdb3fd0ebf8b12261a4c5eb325e">&#9670;&#160;</a></span>_mm256_srli_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srli_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a></td>          <td class="paramname"><span class="paramname"><em>__count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> right by <em>__count</em> bits, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 15, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSRLW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>An unsigned integer value specifying the shift count (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02352">2352</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l02176">_mm256_mask_srli_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l02184">_mm256_maskz_srli_epi16()</a>.</p>

</div>
</div>
<a id="acfa577e01c74cd9071fb09c857fad1c2" name="acfa577e01c74cd9071fb09c857fad1c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa577e01c74cd9071fb09c857fad1c2">&#9670;&#160;</a></span>_mm256_srli_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srli_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a></td>          <td class="paramname"><span class="paramname"><em>__count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> right by <em>__count</em> bits, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 31, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSRLD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>An unsigned integer value specifying the shift count (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02392">2392</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04885">_mm256_mask_srli_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04893">_mm256_maskz_srli_epi32()</a>.</p>

</div>
</div>
<a id="a00ca9a97310214d3f0e85302dd877dc5" name="a00ca9a97310214d3f0e85302dd877dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ca9a97310214d3f0e85302dd877dc5">&#9670;&#160;</a></span>_mm256_srli_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srli_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a></td>          <td class="paramname"><span class="paramname"><em>__count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__a</em> right by <em>__count</em> bits, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 63, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSRLQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>An unsigned integer value specifying the shift count (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02432">2432</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04949">_mm256_mask_srli_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04957">_mm256_maskz_srli_epi64()</a>.</p>

</div>
</div>
<a id="a9cc3e0a1a4e2bbbc72630cf26ed54225" name="a9cc3e0a1a4e2bbbc72630cf26ed54225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc3e0a1a4e2bbbc72630cf26ed54225">&#9670;&#160;</a></span>_mm256_srlv_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srlv_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__Y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__X</em> right by the number of bits given in the corresponding element of the 256-bit vector of [8 x i32] in <em>__Y</em>, shifting in zero bits, and returns the result. </p>
<p>If the shift count for any element is greater than 31, the result for that element is zero.</p>
<p>This intrinsic corresponds to the <code>VPSRLVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 256-bit vector of [8 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 256-bit vector of [8 x i32] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03864">3864</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04821">_mm256_mask_srlv_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04829">_mm256_maskz_srlv_epi32()</a>.</p>

</div>
</div>
<a id="a77501391ed2c52d990a2c4004e86c36d" name="a77501391ed2c52d990a2c4004e86c36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77501391ed2c52d990a2c4004e86c36d">&#9670;&#160;</a></span>_mm256_srlv_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srlv_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__Y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__X</em> right by the number of bits given in the corresponding element of the 128-bit vector of [4 x i64] in <em>__Y</em>, shifting in zero bits, and returns the result. </p>
<p>If the shift count for any element is greater than 63, the result for that element is zero.</p>
<p>This intrinsic corresponds to the <code>VPSRLVQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 256-bit vector of [4 x i64] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 256-bit vector of [4 x i64] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03908">3908</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04789">_mm256_mask_srlv_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04797">_mm256_maskz_srlv_epi64()</a>.</p>

</div>
</div>
<a id="aa41588e2cc5a224f9bd0f545d33419f4" name="aa41588e2cc5a224f9bd0f545d33419f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41588e2cc5a224f9bd0f545d33419f4">&#9670;&#160;</a></span>_mm256_stream_load_si256()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_stream_load_si256 </td>
          <td>(</td>
          <td class="paramtype">__m256i const *</td>          <td class="paramname"><span class="paramname"><em>__V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads the 256-bit integer vector from memory <em>__V</em> using a non-temporal memory hint and returns the vector. </p>
<p><em>__V</em> must be aligned on a 32-byte boundary.</p>
<p>This intrinsic corresponds to the <code>VMOVNTDQA</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A pointer to the 32-byte aligned memory containing the vector to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector loaded from memory. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02965">2965</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a31e2c682612c87d32af88011175c7893" name="a31e2c682612c87d32af88011175c7893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e2c682612c87d32af88011175c7893">&#9670;&#160;</a></span>_mm256_sub_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sub_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16]. </p>
<p>Returns the lower 16 bits of each difference in the corresponding element of the [16 x i16] result (overflow is ignored).</p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*16</div>
<div class="line">  result[j+15:j] := __a[j+15:j] - __b[j+15:j]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSUBW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing the minuends. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing the subtrahends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02507">2507</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00346">_mm256_mask_sub_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00353">_mm256_maskz_sub_epi16()</a>.</p>

</div>
</div>
<a id="ab606b56493b9e67d5aa9413c66bd27cd" name="ab606b56493b9e67d5aa9413c66bd27cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab606b56493b9e67d5aa9413c66bd27cd">&#9670;&#160;</a></span>_mm256_sub_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sub_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts 32-bit integers from corresponding elements of two 256-bit vectors of [8 x i32]. </p>
<p>Returns the lower 32 bits of each difference in the corresponding element of the [8 x i32] result (overflow is ignored).</p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*32</div>
<div class="line">  result[j+31:j] := __a[j+31:j] - __b[j+31:j]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSUBD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing the minuends. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing the subtrahends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02533">2533</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l00259">_mm256_mask_sub_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l00267">_mm256_maskz_sub_epi32()</a>.</p>

</div>
</div>
<a id="a3b4f41e586cb7b8643ffdee43f3a6ce6" name="a3b4f41e586cb7b8643ffdee43f3a6ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4f41e586cb7b8643ffdee43f3a6ce6">&#9670;&#160;</a></span>_mm256_sub_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sub_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts 64-bit integers from corresponding elements of two 256-bit vectors of [4 x i64]. </p>
<p>Returns the lower 64 bits of each difference in the corresponding element of the [4 x i64] result (overflow is ignored).</p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*64</div>
<div class="line">  result[j+63:j] := __a[j+63:j] - __b[j+63:j]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSUBQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] containing the minuends. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [4 x i64] containing the subtrahends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02559">2559</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l00275">_mm256_mask_sub_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l00283">_mm256_maskz_sub_epi64()</a>.</p>

</div>
</div>
<a id="a8fbe41f0f99a6839f3c4a5d4d992ca2a" name="a8fbe41f0f99a6839f3c4a5d4d992ca2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbe41f0f99a6839f3c4a5d4d992ca2a">&#9670;&#160;</a></span>_mm256_sub_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sub_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts 8-bit integers from corresponding bytes of two 256-bit integer vectors. </p>
<p>Returns the lower 8 bits of each difference in the corresponding byte of the 256-bit integer vector result (overflow is ignored).</p>
<div class="fragment"><div class="line">FOR i := 0 TO 31</div>
<div class="line">  j := i*8</div>
<div class="line">  result[j+7:j] := __a[j+7:j] - __b[j+7:j]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSUBB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing the minuends. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector containing the subtrahends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02480">2480</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00332">_mm256_mask_sub_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00339">_mm256_maskz_sub_epi8()</a>.</p>

</div>
</div>
<a id="aac62e43e232e2fe74019c3839e22d0ea" name="aac62e43e232e2fe74019c3839e22d0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac62e43e232e2fe74019c3839e22d0ea">&#9670;&#160;</a></span>_mm256_subs_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_subs_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] using signed saturation, and returns each difference in the corresponding element of the [16 x i16] result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*16</div>
<div class="line">  result[j+7:j] := SATURATE16(__a[j+7:j] - __b[j+7:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSUBSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing the minuends. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing the subtrahends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02611">2611</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01195">_mm256_mask_subs_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01203">_mm256_maskz_subs_epi16()</a>.</p>

</div>
</div>
<a id="a5e9a78b79f3e386367de719217e8b9b1" name="a5e9a78b79f3e386367de719217e8b9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9a78b79f3e386367de719217e8b9b1">&#9670;&#160;</a></span>_mm256_subs_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_subs_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts 8-bit integers from corresponding bytes of two 256-bit integer vectors using signed saturation, and returns each differences in the corresponding byte of the 256-bit integer vector result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 31</div>
<div class="line">  j := i*8</div>
<div class="line">  result[j+7:j] := SATURATE8(__a[j+7:j] - __b[j+7:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSUBSB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing the minuends. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector containing the subtrahends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02585">2585</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01163">_mm256_mask_subs_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01171">_mm256_maskz_subs_epi8()</a>.</p>

</div>
</div>
<a id="afd2bf28cc66f89d73790bcaed2e6e502" name="afd2bf28cc66f89d73790bcaed2e6e502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2bf28cc66f89d73790bcaed2e6e502">&#9670;&#160;</a></span>_mm256_subs_epu16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_subs_epu16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] using unsigned saturation, and returns each difference in the corresponding element of the [16 x i16] result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*16</div>
<div class="line">  result[j+15:j] := SATURATE16U(__a[j+15:j] - __b[j+15:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSUBUSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing the minuends. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing the subtrahends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02664">2664</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01259">_mm256_mask_subs_epu16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01267">_mm256_maskz_subs_epu16()</a>.</p>

</div>
</div>
<a id="a2af8efc1fee79411d45f2094d6a5bd6b" name="a2af8efc1fee79411d45f2094d6a5bd6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af8efc1fee79411d45f2094d6a5bd6b">&#9670;&#160;</a></span>_mm256_subs_epu8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_subs_epu8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts 8-bit integers from corresponding bytes of two 256-bit integer vectors using unsigned saturation, and returns each difference in the corresponding byte of the 256-bit integer vector result. </p>
<p>For each byte, computes <code> result = __a - __b </code>.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 31</div>
<div class="line">  j := i*8</div>
<div class="line">  result[j+7:j] := SATURATE8U(__a[j+7:j] - __b[j+7:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSUBUSB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing the minuends. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector containing the subtrahends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02638">2638</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01227">_mm256_mask_subs_epu8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01235">_mm256_maskz_subs_epu8()</a>.</p>

</div>
</div>
<a id="a76bb3e33051c22956a29e267c841ce2c" name="a76bb3e33051c22956a29e267c841ce2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bb3e33051c22956a29e267c841ce2c">&#9670;&#160;</a></span>_mm256_unpackhi_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_unpackhi_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpacks and interleaves 16-bit integers from parts of the 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [16 x i16]. </p>
<p>Specifically, uses the upper 64 bits of each 128-bit half of <em>__a</em> and <em>__b</em> as input; other bits in these parameters are ignored.</p>
<div class="fragment"><div class="line">result[15:0] := __a[79:64]</div>
<div class="line">result[31:16] := __b[79:64]</div>
<div class="line">result[47:32] := __a[95:80]</div>
<div class="line">result[63:48] := __b[95:80]</div>
<div class="line">. . .</div>
<div class="line">result[127:112] := __b[127:112]</div>
<div class="line">result[143:128] := __a[211:196]</div>
<div class="line">. . .</div>
<div class="line">result[255:240] := __b[255:240]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPUNPCKHWD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] used as the source for the even-numbered elements of the result. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] used as the source for the odd-numbered elements of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02733">2733</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01688">_mm256_mask_unpackhi_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01695">_mm256_maskz_unpackhi_epi16()</a>.</p>

</div>
</div>
<a id="a6d4d291187e5354e99a80fa31e0a2599" name="a6d4d291187e5354e99a80fa31e0a2599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4d291187e5354e99a80fa31e0a2599">&#9670;&#160;</a></span>_mm256_unpackhi_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_unpackhi_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpacks and interleaves 32-bit integers from parts of the 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [8 x i32]. </p>
<p>Specifically, uses the upper 64 bits of each 128-bit half of <em>__a</em> and <em>__b</em> as input; other bits in these parameters are ignored.</p>
<div class="fragment"><div class="line">result[31:0] := __a[95:64]</div>
<div class="line">result[63:32] := __b[95:64]</div>
<div class="line">result[95:64] := __a[127:96]</div>
<div class="line">result[127:96] := __b[127:96]</div>
<div class="line">result[159:128] := __a[223:192]</div>
<div class="line">result[191:160] := __b[223:192]</div>
<div class="line">result[223:192] := __a[255:224]</div>
<div class="line">result[255:224] := __b[255:224]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPUNPCKHDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] used as the source for the even-numbered elements of the result. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] used as the source for the odd-numbered elements of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02767">2767</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06264">_mm256_mask_unpackhi_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06272">_mm256_maskz_unpackhi_epi32()</a>.</p>

</div>
</div>
<a id="ac53f37866e6d12b621cd8dd638dcfe49" name="ac53f37866e6d12b621cd8dd638dcfe49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53f37866e6d12b621cd8dd638dcfe49">&#9670;&#160;</a></span>_mm256_unpackhi_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_unpackhi_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpacks and interleaves 64-bit integers from parts of the 256-bit vectors of [4 x i64] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [4 x i64]. </p>
<p>Specifically, uses the upper 64 bits of each 128-bit half of <em>__a</em> and <em>__b</em> as input; other bits in these parameters are ignored.</p>
<div class="fragment"><div class="line">result[63:0] := __a[127:64]</div>
<div class="line">result[127:64] := __b[127:64]</div>
<div class="line">result[191:128] := __a[255:192]</div>
<div class="line">result[255:192] := __b[255:192]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPUNPCKHQDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] used as the source for the even-numbered elements of the result. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [4 x i64] used as the source for the odd-numbered elements of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02797">2797</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06296">_mm256_mask_unpackhi_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06304">_mm256_maskz_unpackhi_epi64()</a>.</p>

</div>
</div>
<a id="a4358789fa27173bf6e2d7b10c73418fd" name="a4358789fa27173bf6e2d7b10c73418fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4358789fa27173bf6e2d7b10c73418fd">&#9670;&#160;</a></span>_mm256_unpackhi_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_unpackhi_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpacks and interleaves 8-bit integers from parts of the 256-bit integer vectors in <em>__a</em> and <em>__b</em> to form the 256-bit result. </p>
<p>Specifically, uses the upper 64 bits of each 128-bit half of <em>__a</em> and <em>__b</em> as input; other bits in these parameters are ignored.</p>
<div class="fragment"><div class="line">result[7:0] := __a[71:64]</div>
<div class="line">result[15:8] := __b[71:64]</div>
<div class="line">result[23:16] := __a[79:72]</div>
<div class="line">result[31:24] := __b[79:72]</div>
<div class="line">. . .</div>
<div class="line">result[127:120] := __b[127:120]</div>
<div class="line">result[135:128] := __a[199:192]</div>
<div class="line">. . .</div>
<div class="line">result[255:248] := __b[255:248]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPUNPCKHBW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector used as the source for the even-numbered bytes of the result. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector used as the source for the odd-numbered bytes of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02698">2698</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01660">_mm256_mask_unpackhi_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01667">_mm256_maskz_unpackhi_epi8()</a>.</p>

</div>
</div>
<a id="abc29f2b775e0c3d34958e970252c37c0" name="abc29f2b775e0c3d34958e970252c37c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc29f2b775e0c3d34958e970252c37c0">&#9670;&#160;</a></span>_mm256_unpacklo_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_unpacklo_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpacks and interleaves 16-bit integers from parts of the 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [16 x i16]. </p>
<p>Specifically, uses the lower 64 bits of each 128-bit half of <em>__a</em> and <em>__b</em> as input; other bits in these parameters are ignored.</p>
<div class="fragment"><div class="line">result[15:0] := __a[15:0]</div>
<div class="line">result[31:16] := __b[15:0]</div>
<div class="line">result[47:32] := __a[31:16]</div>
<div class="line">result[63:48] := __b[31:16]</div>
<div class="line">. . .</div>
<div class="line">result[127:112] := __b[63:48]</div>
<div class="line">result[143:128] := __a[143:128]</div>
<div class="line">. . .</div>
<div class="line">result[255:239] := __b[191:176]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPUNPCKLWD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] used as the source for the even-numbered elements of the result. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] used as the source for the odd-numbered elements of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02866">2866</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01744">_mm256_mask_unpacklo_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01751">_mm256_maskz_unpacklo_epi16()</a>.</p>

</div>
</div>
<a id="a48355543080a7cbf1fcc3d38c8636b3d" name="a48355543080a7cbf1fcc3d38c8636b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48355543080a7cbf1fcc3d38c8636b3d">&#9670;&#160;</a></span>_mm256_unpacklo_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_unpacklo_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpacks and interleaves 32-bit integers from parts of the 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [8 x i32]. </p>
<p>Specifically, uses the lower 64 bits of each 128-bit half of <em>__a</em> and <em>__b</em> as input; other bits in these parameters are ignored.</p>
<div class="fragment"><div class="line">result[31:0] := __a[31:0]</div>
<div class="line">result[63:32] := __b[31:0]</div>
<div class="line">result[95:64] := __a[63:32]</div>
<div class="line">result[127:96] := __b[63:32]</div>
<div class="line">result[159:128] := __a[159:128]</div>
<div class="line">result[191:160] := __b[159:128]</div>
<div class="line">result[223:192] := __a[191:160]</div>
<div class="line">result[255:224] := __b[191:190]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPUNPCKLDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] used as the source for the even-numbered elements of the result. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] used as the source for the odd-numbered elements of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02900">2900</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06328">_mm256_mask_unpacklo_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06336">_mm256_maskz_unpacklo_epi32()</a>.</p>

</div>
</div>
<a id="a0d22290d67e283811757c56bf20ab0f4" name="a0d22290d67e283811757c56bf20ab0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d22290d67e283811757c56bf20ab0f4">&#9670;&#160;</a></span>_mm256_unpacklo_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_unpacklo_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpacks and interleaves 64-bit integers from parts of the 256-bit vectors of [4 x i64] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [4 x i64]. </p>
<p>Specifically, uses the lower 64 bits of each 128-bit half of <em>__a</em> and <em>__b</em> as input; other bits in these parameters are ignored.</p>
<div class="fragment"><div class="line">result[63:0] := __a[63:0]</div>
<div class="line">result[127:64] := __b[63:0]</div>
<div class="line">result[191:128] := __a[191:128]</div>
<div class="line">result[255:192] := __b[191:128]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPUNPCKLQDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] used as the source for the even-numbered elements of the result. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [4 x i64] used as the source for the odd-numbered elements of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02930">2930</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06360">_mm256_mask_unpacklo_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06368">_mm256_maskz_unpacklo_epi64()</a>.</p>

</div>
</div>
<a id="aac1606df7412921d94f00a69091b79fd" name="aac1606df7412921d94f00a69091b79fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1606df7412921d94f00a69091b79fd">&#9670;&#160;</a></span>_mm256_unpacklo_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_unpacklo_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpacks and interleaves 8-bit integers from parts of the 256-bit integer vectors in <em>__a</em> and <em>__b</em> to form the 256-bit result. </p>
<p>Specifically, uses the lower 64 bits of each 128-bit half of <em>__a</em> and <em>__b</em> as input; other bits in these parameters are ignored.</p>
<div class="fragment"><div class="line">result[7:0] := __a[7:0]</div>
<div class="line">result[15:8] := __b[7:0]</div>
<div class="line">result[23:16] := __a[15:8]</div>
<div class="line">result[31:24] := __b[15:8]</div>
<div class="line">. . .</div>
<div class="line">result[127:120] := __b[63:56]</div>
<div class="line">result[135:128] := __a[135:128]</div>
<div class="line">. . .</div>
<div class="line">result[255:248] := __b[191:184]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPUNPCKLBW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector used as the source for the even-numbered bytes of the result. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector used as the source for the odd-numbered bytes of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02831">2831</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01716">_mm256_mask_unpacklo_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01723">_mm256_maskz_unpacklo_epi8()</a>.</p>

</div>
</div>
<a id="a5cb76d9ee538f1556ce95a0a309224da" name="a5cb76d9ee538f1556ce95a0a309224da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb76d9ee538f1556ce95a0a309224da">&#9670;&#160;</a></span>_mm256_xor_si256()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_xor_si256 </td>
          <td>(</td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i</td>          <td class="paramname"><span class="paramname"><em>__b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise XOR of the 256-bit integer vectors in <em>__a</em> and <em>__b</em>. </p>
<p>This intrinsic corresponds to the <code>VPXOR</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02948">2948</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a2719f57e8449edf0a868707685fcbfba" name="a2719f57e8449edf0a868707685fcbfba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2719f57e8449edf0a868707685fcbfba">&#9670;&#160;</a></span>_mm_broadcastb_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_broadcastb_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the low byte from the 128-bit integer vector in <em>__X</em> to all bytes of the 128-bit result. </p>
<p>This intrinsic corresponds to the <code>VPBROADCASTB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit integer vector whose low byte will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03206">3206</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l02616">_mm_mask_broadcastb_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l02624">_mm_maskz_broadcastb_epi8()</a>.</p>

</div>
</div>
<a id="a10f391075669a7b417e83af174398a9b" name="a10f391075669a7b417e83af174398a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f391075669a7b417e83af174398a9b">&#9670;&#160;</a></span>_mm_broadcastd_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_broadcastd_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the low element from the 128-bit vector of [4 x i32] in <em>__X</em> to all elements of the result's vector of [4 x i32]. </p>
<p>This intrinsic corresponds to the <code>VPBROADCASTD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [4 x i32] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03238">3238</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06884">_mm_mask_broadcastd_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06892">_mm_maskz_broadcastd_epi32()</a>.</p>

</div>
</div>
<a id="ace283494a6faf8c26cb5553c007a78ef" name="ace283494a6faf8c26cb5553c007a78ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace283494a6faf8c26cb5553c007a78ef">&#9670;&#160;</a></span>_mm_broadcastq_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_broadcastq_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the low element from the 128-bit vector of [2 x i64] in <em>__X</em> to both elements of the result's 128-bit vector of [2 x i64]. </p>
<p>This intrinsic corresponds to the <code>VPBROADCASTQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [2 x i64] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03254">3254</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06916">_mm_mask_broadcastq_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06924">_mm_maskz_broadcastq_epi64()</a>.</p>

</div>
</div>
<a id="a9aed0394b1e2f9ff4a0a8099637dd3d3" name="a9aed0394b1e2f9ff4a0a8099637dd3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aed0394b1e2f9ff4a0a8099637dd3d3">&#9670;&#160;</a></span>_mm_broadcastsd_pd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128d <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_broadcastsd_pd </td>
          <td>(</td>
          <td class="paramtype">__m128d</td>          <td class="paramname"><span class="paramname"><em>__a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the 64-bit floating-point value from the low element of the 128-bit vector of [2 x double] in <em>__a</em> to both elements of the result's 128-bit vector of [2 x double]. </p>
<p>This intrinsic corresponds to the <code>MOVDDUP</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 128-bit vector of [2 x double] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x double] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03000">3000</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l03986">__a</a>.</p>

</div>
</div>
<a id="a7636713aae00b362d71015a3f444d079" name="a7636713aae00b362d71015a3f444d079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7636713aae00b362d71015a3f444d079">&#9670;&#160;</a></span>_mm_broadcastss_ps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128 <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_broadcastss_ps </td>
          <td>(</td>
          <td class="paramtype">__m128</td>          <td class="paramname"><span class="paramname"><em>__X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the 32-bit floating-point value from the low element of the 128-bit vector of [4 x float] in <em>__X</em> to all elements of the result's 128-bit vector of [4 x float]. </p>
<p>This intrinsic corresponds to the <code>VBROADCASTSS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [4 x float] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x float] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02983">2983</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06852">_mm_mask_broadcastss_ps()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06860">_mm_maskz_broadcastss_ps()</a>.</p>

</div>
</div>
<a id="a865b5e9e77ac8e5f7f639806936c7113" name="a865b5e9e77ac8e5f7f639806936c7113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865b5e9e77ac8e5f7f639806936c7113">&#9670;&#160;</a></span>_mm_broadcastw_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_broadcastw_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the low element from the 128-bit vector of [8 x i16] in <em>__X</em> to all elements of the result's 128-bit vector of [8 x i16]. </p>
<p>This intrinsic corresponds to the <code>VPBROADCASTW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [8 x i16] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [8 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03222">3222</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l02648">_mm_mask_broadcastw_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l02656">_mm_maskz_broadcastw_epi16()</a>.</p>

</div>
</div>
<a id="a694947e72cdcd91cace9252259d8cc9e" name="a694947e72cdcd91cace9252259d8cc9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694947e72cdcd91cace9252259d8cc9e">&#9670;&#160;</a></span>_mm_maskload_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_maskload_epi32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> const *</td>          <td class="paramname"><span class="paramname"><em>__X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__M</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally loads four 32-bit integer elements from memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, sets that element of the result to zero. </p>
<p>Returns the 128-bit [4 x i32] result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*32</div>
<div class="line">  IF __M[j+31] == 1</div>
<div class="line">    result[j+31:j] := Load32(__X+(i*4))</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := 0</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMASKMOVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">__M</td><td>A 128-bit vector of [4 x i32] containing the mask bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the loaded or zeroed elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03556">3556</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="adf51c2e90947a2569e048166b39e4495" name="adf51c2e90947a2569e048166b39e4495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf51c2e90947a2569e048166b39e4495">&#9670;&#160;</a></span>_mm_maskload_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_maskload_epi64 </td>
          <td>(</td>
          <td class="paramtype">long long const *</td>          <td class="paramname"><span class="paramname"><em>__X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__M</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally loads two 64-bit integer elements from memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, sets that element of the result to zero. </p>
<p>Returns the 128-bit [2 x i64] result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*64</div>
<div class="line">  IF __M[j+63] == 1</div>
<div class="line">    result[j+63:j] := Load64(__X+(i*8))</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := 0</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMASKMOVQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">__M</td><td>A 128-bit vector of [2 x i64] containing the mask bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x i64] containing the loaded or zeroed elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03588">3588</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a8d960541afa801cef10bec77aac5e258" name="a8d960541afa801cef10bec77aac5e258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d960541afa801cef10bec77aac5e258">&#9670;&#160;</a></span>_mm_maskstore_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ void <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_maskstore_epi32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> *</td>          <td class="paramname"><span class="paramname"><em>__X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__Y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally stores four 32-bit integer elements from the 128-bit vector of [4 x i32] in <em>__Y</em> to memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, the memory element is unchanged. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*32</div>
<div class="line">  IF __M[j+31] == 1</div>
<div class="line">    Store32(__X+(i*4), __Y[j+31:j])</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMASKMOVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A pointer to the memory used for storing values. </td></tr>
    <tr><td class="paramname">__M</td><td>A 128-bit vector of [4 x i32] containing the mask bits. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 128-bit vector of [4 x i32] containing the values to store. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03678">3678</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

</div>
</div>
<a id="a582da479a1ada35c7316c4deab34adfd" name="a582da479a1ada35c7316c4deab34adfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582da479a1ada35c7316c4deab34adfd">&#9670;&#160;</a></span>_mm_maskstore_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ void <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_maskstore_epi64 </td>
          <td>(</td>
          <td class="paramtype">long long *</td>          <td class="paramname"><span class="paramname"><em>__X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__Y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally stores two 64-bit integer elements from the 128-bit vector of [2 x i64] in <em>__Y</em> to memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, the memory element is unchanged. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*64</div>
<div class="line">  IF __M[j+63] == 1</div>
<div class="line">    Store64(__X+(i*8), __Y[j+63:j])</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMASKMOVQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A pointer to the memory used for storing values. </td></tr>
    <tr><td class="paramname">__M</td><td>A 128-bit vector of [2 x i64] containing the mask bits. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 128-bit vector of [2 x i64] containing the values to store. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03708">3708</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

</div>
</div>
<a id="a699470176eaef166e2a71c026aa85cfc" name="a699470176eaef166e2a71c026aa85cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699470176eaef166e2a71c026aa85cfc">&#9670;&#160;</a></span>_mm_sllv_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_sllv_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__Y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 128-bit vector of [4 x i32] in <em>__X</em> left by the number of bits given in the corresponding element of the 128-bit vector of [4 x i32] in <em>__Y</em>, shifting in zero bits, and returns the result. </p>
<p>If the shift count for any element is greater than 31, the result for that element is zero.</p>
<p>This intrinsic corresponds to the <code>VPSLLVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [4 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 128-bit vector of [4 x i32] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03752">3752</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04741">_mm_mask_sllv_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04749">_mm_maskz_sllv_epi32()</a>.</p>

</div>
</div>
<a id="aec60ec05d6c5e57a8cce91a77f75603d" name="aec60ec05d6c5e57a8cce91a77f75603d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec60ec05d6c5e57a8cce91a77f75603d">&#9670;&#160;</a></span>_mm_sllv_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_sllv_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__Y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 64-bit element of the 128-bit vector of [2 x i64] in <em>__X</em> left by the number of bits given in the corresponding element of the 128-bit vector of [2 x i64] in <em>__Y</em>, shifting in zero bits, and returns the result. </p>
<p>If the shift count for any element is greater than 63, the result for that element is zero.</p>
<p>This intrinsic corresponds to the <code>VPSLLVQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [2 x i64] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 128-bit vector of [2 x i64] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03796">3796</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04709">_mm_mask_sllv_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04717">_mm_maskz_sllv_epi64()</a>.</p>

</div>
</div>
<a id="a95ac7327486a0d44f7f4154ac337bb85" name="a95ac7327486a0d44f7f4154ac337bb85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ac7327486a0d44f7f4154ac337bb85">&#9670;&#160;</a></span>_mm_srav_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_srav_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__Y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 128-bit vector of [4 x i32] in <em>__X</em> right by the number of bits given in the corresponding element of the 128-bit vector of [4 x i32] in <em>__Y</em>, shifting in sign bits, and returns the result. </p>
<p>If the shift count for any element is greater than 31, the result for that element is 0 or -1 according to the sign bit for that element.</p>
<p>This intrinsic corresponds to the <code>VPSRAVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [4 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 128-bit vector of [4 x i32] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03842">3842</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04965">_mm_mask_srav_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04973">_mm_maskz_srav_epi32()</a>.</p>

</div>
</div>
<a id="a5eb295f9dbef670b0a134d834e5f279a" name="a5eb295f9dbef670b0a134d834e5f279a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb295f9dbef670b0a134d834e5f279a">&#9670;&#160;</a></span>_mm_srlv_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_srlv_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__Y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 128-bit vector of [4 x i32] in <em>__X</em> right by the number of bits given in the corresponding element of the 128-bit vector of [4 x i32] in <em>__Y</em>, shifting in zero bits, and returns the result. </p>
<p>If the shift count for any element is greater than 31, the result for that element is zero.</p>
<p>This intrinsic corresponds to the <code>VPSRLVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [4 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 128-bit vector of [4 x i32] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03886">3886</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04805">_mm_mask_srlv_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04813">_mm_maskz_srlv_epi32()</a>.</p>

</div>
</div>
<a id="a619b2e23f9247af334811e4b6ec75f40" name="a619b2e23f9247af334811e4b6ec75f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619b2e23f9247af334811e4b6ec75f40">&#9670;&#160;</a></span>_mm_srlv_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_srlv_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i</td>          <td class="paramname"><span class="paramname"><em>__Y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 64-bit element of the 128-bit vector of [2 x i64] in <em>__X</em> right by the number of bits given in the corresponding element of the 128-bit vector of [2 x i64] in <em>__Y</em>, shifting in zero bits, and returns the result. </p>
<p>If the shift count for any element is greater than 63, the result for that element is zero.</p>
<p>This intrinsic corresponds to the <code>VPSRLVQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [2 x i64] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 128-bit vector of [2 x i64] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03930">3930</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04773">_mm_mask_srlv_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04781">_mm_maskz_srlv_epi64()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 8 2024 17:02:10 for clang by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
