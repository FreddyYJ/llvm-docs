<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: clang::format Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">clang<span id="projectnumber">&#160;12.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceclang.html">clang</a></li><li class="navelem"><a class="el" href="namespaceclang_1_1format.html">format</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">clang::format Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1format_1_1encoding.html">encoding</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1format_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1AffectedRangeManager.html">AffectedRangeManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1AnnotatedLine.html">AnnotatedLine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1BreakableBlockComment.html">BreakableBlockComment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1BreakableComment.html">BreakableComment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1BreakableLineCommentSection.html">BreakableLineCommentSection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1BreakableStringLiteral.html">BreakableStringLiteral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1BreakableToken.html">BreakableToken</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classBase.html">Base</a> class for tokens / ranges of tokens that can allow breaking within the tokens - for example, to avoid whitespace beyond the column limit, or to reflow text.  <a href="classclang_1_1format_1_1BreakableToken.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1CompoundStatementIndenter.html">CompoundStatementIndenter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1ContinuationIndenter.html">ContinuationIndenter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1Environment.html">Environment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around a <code><a class="el" href="classclang_1_1Token.html" title="Token - This structure provides full information about a lexed token.">Token</a></code> storing information about the whitespace characters preceding it.  <a href="structclang_1_1format_1_1FormatToken.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1FormatTokenLexer.html">FormatTokenLexer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1FormatTokenSource.html">FormatTokenSource</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1JavaScriptImportSorter.html">JavaScriptImportSorter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1JsImportedSymbol.html">JsImportedSymbol</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1JsModuleReference.html">JsModuleReference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1LineState.html">LineState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current state when indenting a unwrapped line.  <a href="structclang_1_1format_1_1LineState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1MacroExpander.html">MacroExpander</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a set of macro definitions as strings and allows expanding calls to those macros.  <a href="classclang_1_1format_1_1MacroExpander.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1MacroExpansion.html">MacroExpansion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains information on the token's role in a macro expansion.  <a href="structclang_1_1format_1_1MacroExpansion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1NamespaceEndCommentsFixer.html">NamespaceEndCommentsFixer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1ParenState.html">ParenState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1ParseErrorCategory.html">ParseErrorCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1RawStringFormatStyleManager.html">RawStringFormatStyleManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1ScopedLineState.html">ScopedLineState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1TokenAnalyzer.html">TokenAnalyzer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1TokenAnnotator.html">TokenAnnotator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines extra information about the tokens comprising an <code><a class="el" href="structclang_1_1format_1_1UnwrappedLine.html" title="An unwrapped line is a sequence of Token, that we would like to put on a single line if there was no ...">UnwrappedLine</a></code>.  <a href="classclang_1_1format_1_1TokenAnnotator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1UnwrappedLine.html">UnwrappedLine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unwrapped line is a sequence of <code><a class="el" href="classclang_1_1Token.html" title="Token - This structure provides full information about a lexed token.">Token</a></code>, that we would like to put on a single line if there was no column limit.  <a href="structclang_1_1format_1_1UnwrappedLine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1UnwrappedLineConsumer.html">UnwrappedLineConsumer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1UnwrappedLineFormatter.html">UnwrappedLineFormatter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1UnwrappedLineNode.html">UnwrappedLineNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1UnwrappedLineParser.html">UnwrappedLineParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1UsingDeclarationsSorter.html">UsingDeclarationsSorter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1format_1_1WhitespaceManager.html">WhitespaceManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages the whitespaces around tokens and their replacements.  <a href="classclang_1_1format_1_1WhitespaceManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8361fae3448126045290df1a4506c954" id="r_a8361fae3448126045290df1a4506c954"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8361fae3448126045290df1a4506c954">ParseError</a> { <a class="el" href="#a8361fae3448126045290df1a4506c954a505a83f220c02df2f85c3810cd9ceb38">Success</a> = 0
, <a class="el" href="#a8361fae3448126045290df1a4506c954a902b0d55fddef6f8d651fe1035b7d4bd">Error</a>
, <a class="el" href="#a8361fae3448126045290df1a4506c954a91957bd1005afd35f28861fe81992ee0">Unsuitable</a>
, <a class="el" href="#a8361fae3448126045290df1a4506c954aa9b40ec5afeefed5b4c02dddfef2a294">BinPackTrailingCommaConflict</a>
 }</td></tr>
<tr class="separator:a8361fae3448126045290df1a4506c954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b610ca9f97cde157e9b4a864f588d7" id="r_ad4b610ca9f97cde157e9b4a864f588d7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4b610ca9f97cde157e9b4a864f588d7">TokenType</a> : uint8_t { <a class="el" href="#ad4b610ca9f97cde157e9b4a864f588d7abdc4c1181516faf4ac1d450badd2669c">NUM_TOKEN_TYPES</a>
 }</td></tr>
<tr class="memdesc:ad4b610ca9f97cde157e9b4a864f588d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the semantic type of a syntactic token, e.g.  <a href="#ad4b610ca9f97cde157e9b4a864f588d7">More...</a><br /></td></tr>
<tr class="separator:ad4b610ca9f97cde157e9b4a864f588d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3efd684dd7c9ad4cd48fd4d28ecaaea" id="r_af3efd684dd7c9ad4cd48fd4d28ecaaea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3efd684dd7c9ad4cd48fd4d28ecaaea">BraceBlockKind</a> { <a class="el" href="#af3efd684dd7c9ad4cd48fd4d28ecaaeaabc206459d88deb858f2709556db71017">BK_Unknown</a>
, <a class="el" href="#af3efd684dd7c9ad4cd48fd4d28ecaaeaac0cd3adbed48a71039a2855df3fe8036">BK_Block</a>
, <a class="el" href="#af3efd684dd7c9ad4cd48fd4d28ecaaeaae56a45f3e07dfba04c28c70b668c2bdd">BK_BracedInit</a>
 }</td></tr>
<tr class="separator:af3efd684dd7c9ad4cd48fd4d28ecaaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452b34c08537cab02deca443e342bec6" id="r_a452b34c08537cab02deca443e342bec6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a452b34c08537cab02deca443e342bec6">ParameterPackingKind</a> { <a class="el" href="#a452b34c08537cab02deca443e342bec6a3e1e85534f0f7b91f01b7574f4d4adf5">PPK_BinPacked</a>
, <a class="el" href="#a452b34c08537cab02deca443e342bec6af698c50de2f16b48e6eec09e447ebf99">PPK_OnePerLine</a>
, <a class="el" href="#a452b34c08537cab02deca443e342bec6aa198a0d4cbb39979341cb7388e93e97b">PPK_Inconclusive</a>
 }</td></tr>
<tr class="separator:a452b34c08537cab02deca443e342bec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3409598f12699626b6997dfdd18c6929" id="r_a3409598f12699626b6997dfdd18c6929"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3409598f12699626b6997dfdd18c6929">FormatDecision</a> { <a class="el" href="#a3409598f12699626b6997dfdd18c6929a8da12d86e1be42ee8d8d458d1f5dfc25">FD_Unformatted</a>
, <a class="el" href="#a3409598f12699626b6997dfdd18c6929a98df366120a9a0c1f0eaec09b1555cff">FD_Continue</a>
, <a class="el" href="#a3409598f12699626b6997dfdd18c6929a77ad2a14db7203e0c45a0e9aacf50745">FD_Break</a>
 }</td></tr>
<tr class="separator:a3409598f12699626b6997dfdd18c6929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14684d2db0efbadbe649c3f984097e67" id="r_a14684d2db0efbadbe649c3f984097e67"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14684d2db0efbadbe649c3f984097e67">MacroRole</a> { <a class="el" href="#a14684d2db0efbadbe649c3f984097e67a88be99a74a3e2782e6ee791cb345338a">MR_ExpandedArg</a>
, <a class="el" href="#a14684d2db0efbadbe649c3f984097e67a0321a1b9bc8ae2cc2db8668991190f3d">MR_UnexpandedArg</a>
, <a class="el" href="#a14684d2db0efbadbe649c3f984097e67a37aac8d105a06e843003bbc5c043f778">MR_Hidden</a>
 }</td></tr>
<tr class="memdesc:a14684d2db0efbadbe649c3f984097e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Roles a token can take in a configured macro expansion.  <a href="#a14684d2db0efbadbe649c3f984097e67">More...</a><br /></td></tr>
<tr class="separator:a14684d2db0efbadbe649c3f984097e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6cf7cf51bbe9654709043db7a72468" id="r_aef6cf7cf51bbe9654709043db7a72468"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef6cf7cf51bbe9654709043db7a72468">LexerState</a> { <a class="el" href="#aef6cf7cf51bbe9654709043db7a72468a5d7c6d1e20cfb893ee7c0963529b9c35">NORMAL</a>
, <a class="el" href="#aef6cf7cf51bbe9654709043db7a72468afac6123425d4426efc2ae0ecd6b2dce9">TEMPLATE_STRING</a>
, <a class="el" href="#aef6cf7cf51bbe9654709043db7a72468a31bdb814ec375214324ead465f67212a">TOKEN_STASHED</a>
 }</td></tr>
<tr class="separator:aef6cf7cf51bbe9654709043db7a72468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1aa248193ce0aa256a43af928d62171" id="r_af1aa248193ce0aa256a43af928d62171"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1aa248193ce0aa256a43af928d62171">LineType</a> { <br />
&#160;&#160;<a class="el" href="#af1aa248193ce0aa256a43af928d62171acc4ddb995bb9dcfb69eddbd787f39df4">LT_Invalid</a>
, <a class="el" href="#af1aa248193ce0aa256a43af928d62171afe0fe969ae9ec530e48d260e8ffb45b9">LT_ImportStatement</a>
, <a class="el" href="#af1aa248193ce0aa256a43af928d62171a693e828dfa10c6ee94325795f3e5b93f">LT_ObjCDecl</a>
, <a class="el" href="#af1aa248193ce0aa256a43af928d62171a40123db8fe0709b9f77c1601517b2359">LT_ObjCMethodDecl</a>
, <br />
&#160;&#160;<a class="el" href="#af1aa248193ce0aa256a43af928d62171a1a1da9aba4cbb0696cecdd94b73a2794">LT_ObjCProperty</a>
, <a class="el" href="#af1aa248193ce0aa256a43af928d62171a8e57e20cdb286891185517baa935a4b7">LT_Other</a>
, <a class="el" href="#af1aa248193ce0aa256a43af928d62171adb46bb49ded6cdf9747d8d17cf5c482c">LT_PreprocessorDirective</a>
, <a class="el" href="#af1aa248193ce0aa256a43af928d62171ade202d78e75d69b85c740777408eafaf">LT_VirtualFunctionDecl</a>
<br />
 }</td></tr>
<tr class="separator:af1aa248193ce0aa256a43af928d62171"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5d73a9a775aba4993b85370531b2c24a" id="r_a5d73a9a775aba4993b85370531b2c24a"><td class="memItemLeft" align="right" valign="top">const std::error_category &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d73a9a775aba4993b85370531b2c24a">getParseCategory</a> ()</td></tr>
<tr class="separator:a5d73a9a775aba4993b85370531b2c24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3204de8fb2e07d16a22f24fb7ad9395c" id="r_a3204de8fb2e07d16a22f24fb7ad9395c"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3204de8fb2e07d16a22f24fb7ad9395c">make_error_code</a> (<a class="el" href="#a8361fae3448126045290df1a4506c954">ParseError</a> e)</td></tr>
<tr class="separator:a3204de8fb2e07d16a22f24fb7ad9395c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea89987ef7b6d6607e29b13f19fe4e8" id="r_afea89987ef7b6d6607e29b13f19fe4e8"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afea89987ef7b6d6607e29b13f19fe4e8">getLanguageName</a> (FormatStyle::LanguageKind <a class="el" href="namespaceclang.html#a6f904bf7056cbce941d51eeebe3bfd5c">Language</a>)</td></tr>
<tr class="memdesc:afea89987ef7b6d6607e29b13f19fe4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>FormatStyle</code> is used to configure the formatting to follow / specific guidelines.  <br /></td></tr>
<tr class="separator:afea89987ef7b6d6607e29b13f19fe4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a774e5ca1bcf315304bfc2af80b066" id="r_a73a774e5ca1bcf315304bfc2af80b066"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73a774e5ca1bcf315304bfc2af80b066">IsBlank</a> (char <a class="el" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a>)</td></tr>
<tr class="separator:a73a774e5ca1bcf315304bfc2af80b066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ac2b085f545d66e5426ea4b9be2b39" id="r_aa5ac2b085f545d66e5426ea4b9be2b39"><td class="memItemLeft" align="right" valign="top">static StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5ac2b085f545d66e5426ea4b9be2b39">getLineCommentIndentPrefix</a> (StringRef Comment, const FormatStyle &amp;Style)</td></tr>
<tr class="separator:aa5ac2b085f545d66e5426ea4b9be2b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe1e3b98940dd6e22b3a62167c0720f" id="r_acbe1e3b98940dd6e22b3a62167c0720f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1format_1_1BreakableToken.html#a0fce9f5e13cf25199ff58a96c5eb7882">BreakableToken::Split</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbe1e3b98940dd6e22b3a62167c0720f">getCommentSplit</a> (StringRef <a class="el" href="Format_8cpp.html#a30c618d2023710328101d60cbe97beb8">Text</a>, <a class="el" href="classunsigned.html">unsigned</a> ContentStartColumn, <a class="el" href="classunsigned.html">unsigned</a> ColumnLimit, <a class="el" href="classunsigned.html">unsigned</a> TabWidth, <a class="el" href="namespaceclang_1_1format_1_1encoding.html#a7e8496e9d93edf497ca8100b48b12492">encoding::Encoding</a> Encoding, const FormatStyle &amp;Style, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> DecorationEndsWithStar=<a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="separator:acbe1e3b98940dd6e22b3a62167c0720f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9788e485bda7513ea5602e1ea2fca23f" id="r_a9788e485bda7513ea5602e1ea2fca23f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1format_1_1BreakableToken.html#a0fce9f5e13cf25199ff58a96c5eb7882">BreakableToken::Split</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9788e485bda7513ea5602e1ea2fca23f">getStringSplit</a> (StringRef <a class="el" href="Format_8cpp.html#a30c618d2023710328101d60cbe97beb8">Text</a>, <a class="el" href="classunsigned.html">unsigned</a> UsedColumns, <a class="el" href="classunsigned.html">unsigned</a> ColumnLimit, <a class="el" href="classunsigned.html">unsigned</a> TabWidth, <a class="el" href="namespaceclang_1_1format_1_1encoding.html#a7e8496e9d93edf497ca8100b48b12492">encoding::Encoding</a> Encoding)</td></tr>
<tr class="separator:a9788e485bda7513ea5602e1ea2fca23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc087ad9babe720e69f71329042d17d" id="r_a5fc087ad9babe720e69f71329042d17d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fc087ad9babe720e69f71329042d17d">switchesFormatting</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;<a class="el" href="classclang_1_1Token.html">Token</a>)</td></tr>
<tr class="memdesc:a5fc087ad9babe720e69f71329042d17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code><a class="el" href="classclang_1_1Token.html" title="Token - This structure provides full information about a lexed token.">Token</a></code> switches formatting, like /* clang-format off *&zwj;/.  <br /></td></tr>
<tr class="separator:a5fc087ad9babe720e69f71329042d17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc23931ee38e4d74c645786b0ff5b476" id="r_abc23931ee38e4d74c645786b0ff5b476"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc23931ee38e4d74c645786b0ff5b476">mayReflowContent</a> (StringRef Content)</td></tr>
<tr class="separator:abc23931ee38e4d74c645786b0ff5b476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8445c626e0e6239a9c10931ae56700" id="r_a8b8445c626e0e6239a9c10931ae56700"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b8445c626e0e6239a9c10931ae56700">shouldIndentWrappedSelectorName</a> (const FormatStyle &amp;Style, <a class="el" href="#af1aa248193ce0aa256a43af928d62171">LineType</a> <a class="el" href="#af1aa248193ce0aa256a43af928d62171">LineType</a>)</td></tr>
<tr class="separator:a8b8445c626e0e6239a9c10931ae56700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c208d8905d23732c90471fe6520e232" id="r_a6c208d8905d23732c90471fe6520e232"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c208d8905d23732c90471fe6520e232">getLengthToMatchingParen</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;<a class="el" href="FormatToken_8h.html#aaf3e42cecb4cc18e3d79250e82b642ea">Tok</a>, const std::vector&lt; <a class="el" href="structclang_1_1format_1_1ParenState.html">ParenState</a> &gt; &amp;Stack)</td></tr>
<tr class="separator:a6c208d8905d23732c90471fe6520e232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8628c2728c82f335dfb3f1ce5af1e3f7" id="r_a8628c2728c82f335dfb3f1ce5af1e3f7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8628c2728c82f335dfb3f1ce5af1e3f7">getLengthToNextOperator</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;<a class="el" href="FormatToken_8h.html#aaf3e42cecb4cc18e3d79250e82b642ea">Tok</a>)</td></tr>
<tr class="separator:a8628c2728c82f335dfb3f1ce5af1e3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77277e89c12de4c668b790cd02b9ae14" id="r_a77277e89c12de4c668b790cd02b9ae14"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77277e89c12de4c668b790cd02b9ae14">startsSegmentOfBuilderTypeCall</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;<a class="el" href="FormatToken_8h.html#aaf3e42cecb4cc18e3d79250e82b642ea">Tok</a>)</td></tr>
<tr class="separator:a77277e89c12de4c668b790cd02b9ae14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863a7a3fcf1022607339341a698df78d" id="r_a863a7a3fcf1022607339341a698df78d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a863a7a3fcf1022607339341a698df78d">startsNextParameter</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;Current, const FormatStyle &amp;Style)</td></tr>
<tr class="separator:a863a7a3fcf1022607339341a698df78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b2615bf03f2292639e2905a27f0929" id="r_ad1b2615bf03f2292639e2905a27f0929"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1b2615bf03f2292639e2905a27f0929">opensProtoMessageField</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;LessTok, const FormatStyle &amp;Style)</td></tr>
<tr class="separator:ad1b2615bf03f2292639e2905a27f0929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5395fabc4580c3e956307f9ddac9d6b" id="r_af5395fabc4580c3e956307f9ddac9d6b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; StringRef &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5395fabc4580c3e956307f9ddac9d6b">getRawStringDelimiter</a> (StringRef <a class="el" href="FormatToken_8h.html#a631bb180b80725779d401949a4642cf2">TokenText</a>)</td></tr>
<tr class="separator:af5395fabc4580c3e956307f9ddac9d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97f413c244cbc021b63bfe0a3db938a" id="r_ab97f413c244cbc021b63bfe0a3db938a"><td class="memItemLeft" align="right" valign="top">static StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab97f413c244cbc021b63bfe0a3db938a">getCanonicalRawStringDelimiter</a> (const FormatStyle &amp;Style, FormatStyle::LanguageKind <a class="el" href="namespaceclang.html#a6f904bf7056cbce941d51eeebe3bfd5c">Language</a>)</td></tr>
<tr class="separator:ab97f413c244cbc021b63bfe0a3db938a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ec9ad8d6fa166cd74ced3ad3a73cad" id="r_a76ec9ad8d6fa166cd74ced3ad3a73cad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76ec9ad8d6fa166cd74ced3ad3a73cad">hasNestedBlockInlined</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> *<a class="el" href="FormatToken_8h.html#adbec21d3b03511d6f0240730c7e3631c">Previous</a>, const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;Current, const FormatStyle &amp;Style)</td></tr>
<tr class="separator:a76ec9ad8d6fa166cd74ced3ad3a73cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6645664f6b3d404af5f479ecbe1b2b" id="r_a1b6645664f6b3d404af5f479ecbe1b2b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b6645664f6b3d404af5f479ecbe1b2b">getLastLineEndColumn</a> (StringRef <a class="el" href="Format_8cpp.html#a30c618d2023710328101d60cbe97beb8">Text</a>, <a class="el" href="classunsigned.html">unsigned</a> StartColumn, <a class="el" href="classunsigned.html">unsigned</a> TabWidth, <a class="el" href="namespaceclang_1_1format_1_1encoding.html#a7e8496e9d93edf497ca8100b48b12492">encoding::Encoding</a> Encoding)</td></tr>
<tr class="separator:a1b6645664f6b3d404af5f479ecbe1b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bd9cb14c30b33377cc246fbe5e9573" id="r_ad7bd9cb14c30b33377cc246fbe5e9573"><td class="memItemLeft" align="right" valign="top">static StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7bd9cb14c30b33377cc246fbe5e9573">getEnclosingFunctionName</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;Current)</td></tr>
<tr class="separator:ad7bd9cb14c30b33377cc246fbe5e9573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253f0600906434207ea8e9a704ca53cf" id="r_a253f0600906434207ea8e9a704ca53cf"><td class="memItemLeft" align="right" valign="top">llvm::Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a253f0600906434207ea8e9a704ca53cf">make_string_error</a> (const llvm::Twine &amp;Message)</td></tr>
<tr class="separator:a253f0600906434207ea8e9a704ca53cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ff1b1ab007a48b246da6c654cbf293" id="r_a40ff1b1ab007a48b246da6c654cbf293"><td class="memItemLeft" align="right" valign="top">static FormatStyle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40ff1b1ab007a48b246da6c654cbf293">expandPresets</a> (const FormatStyle &amp;Style)</td></tr>
<tr class="separator:a40ff1b1ab007a48b246da6c654cbf293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3979a01708870992df724a9845e731f" id="r_ac3979a01708870992df724a9845e731f"><td class="memItemLeft" align="right" valign="top">FormatStyle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3979a01708870992df724a9845e731f">getLLVMStyle</a> (FormatStyle::LanguageKind <a class="el" href="namespaceclang.html#a6f904bf7056cbce941d51eeebe3bfd5c">Language</a>)</td></tr>
<tr class="separator:ac3979a01708870992df724a9845e731f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dec822e6f8985e433a49d9a2e322c7c" id="r_a4dec822e6f8985e433a49d9a2e322c7c"><td class="memItemLeft" align="right" valign="top">FormatStyle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dec822e6f8985e433a49d9a2e322c7c">getGoogleStyle</a> (FormatStyle::LanguageKind <a class="el" href="namespaceclang.html#a6f904bf7056cbce941d51eeebe3bfd5c">Language</a>)</td></tr>
<tr class="separator:a4dec822e6f8985e433a49d9a2e322c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cb4770ecc9217cc26baf529e0e72a4" id="r_ad9cb4770ecc9217cc26baf529e0e72a4"><td class="memItemLeft" align="right" valign="top">FormatStyle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9cb4770ecc9217cc26baf529e0e72a4">getChromiumStyle</a> (FormatStyle::LanguageKind <a class="el" href="namespaceclang.html#a6f904bf7056cbce941d51eeebe3bfd5c">Language</a>)</td></tr>
<tr class="separator:ad9cb4770ecc9217cc26baf529e0e72a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa342c0dc9c7831f9b8571c3ef81637d6" id="r_aa342c0dc9c7831f9b8571c3ef81637d6"><td class="memItemLeft" align="right" valign="top">FormatStyle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa342c0dc9c7831f9b8571c3ef81637d6">getMozillaStyle</a> ()</td></tr>
<tr class="separator:aa342c0dc9c7831f9b8571c3ef81637d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1614d4d536703b03a0b101ec206b4ea8" id="r_a1614d4d536703b03a0b101ec206b4ea8"><td class="memItemLeft" align="right" valign="top">FormatStyle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1614d4d536703b03a0b101ec206b4ea8">getWebKitStyle</a> ()</td></tr>
<tr class="separator:a1614d4d536703b03a0b101ec206b4ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962486c55900a9550fc495817bc4bd23" id="r_a962486c55900a9550fc495817bc4bd23"><td class="memItemLeft" align="right" valign="top">FormatStyle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a962486c55900a9550fc495817bc4bd23">getGNUStyle</a> ()</td></tr>
<tr class="separator:a962486c55900a9550fc495817bc4bd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0434ecbb4bf08a1adb94ac6b9d5c13" id="r_a5b0434ecbb4bf08a1adb94ac6b9d5c13"><td class="memItemLeft" align="right" valign="top">FormatStyle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b0434ecbb4bf08a1adb94ac6b9d5c13">getMicrosoftStyle</a> (FormatStyle::LanguageKind <a class="el" href="namespaceclang.html#a6f904bf7056cbce941d51eeebe3bfd5c">Language</a>)</td></tr>
<tr class="separator:a5b0434ecbb4bf08a1adb94ac6b9d5c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bbd5b0ec7bc869e80febca4a395c85" id="r_ae7bbd5b0ec7bc869e80febca4a395c85"><td class="memItemLeft" align="right" valign="top">FormatStyle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7bbd5b0ec7bc869e80febca4a395c85">getNoStyle</a> ()</td></tr>
<tr class="separator:ae7bbd5b0ec7bc869e80febca4a395c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d51fc3e0f96d7e36a07a99c12636d0" id="r_aa4d51fc3e0f96d7e36a07a99c12636d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4d51fc3e0f96d7e36a07a99c12636d0">getPredefinedStyle</a> (StringRef Name, FormatStyle::LanguageKind <a class="el" href="namespaceclang.html#a6f904bf7056cbce941d51eeebe3bfd5c">Language</a>, FormatStyle *Style)</td></tr>
<tr class="separator:aa4d51fc3e0f96d7e36a07a99c12636d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf0f004f086333441812832af92aadc" id="r_a7cf0f004f086333441812832af92aadc"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cf0f004f086333441812832af92aadc">parseConfiguration</a> (llvm::MemoryBufferRef Config, FormatStyle *Style, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> AllowUnknownOptions)</td></tr>
<tr class="separator:a7cf0f004f086333441812832af92aadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b4c945b9f6b5e81279ad3c83c981f1" id="r_a55b4c945b9f6b5e81279ad3c83c981f1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55b4c945b9f6b5e81279ad3c83c981f1">configurationAsText</a> (const FormatStyle &amp;Style)</td></tr>
<tr class="separator:a55b4c945b9f6b5e81279ad3c83c981f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9a2f037830def9c9a494c5e0ae7b4e" id="r_a0e9a2f037830def9c9a494c5e0ae7b4e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e9a2f037830def9c9a494c5e0ae7b4e">affectsRange</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt; Ranges, <a class="el" href="classunsigned.html">unsigned</a> Start, <a class="el" href="classunsigned.html">unsigned</a> End)</td></tr>
<tr class="separator:a0e9a2f037830def9c9a494c5e0ae7b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3063a53d7e0612003febb48755f4114c" id="r_a3063a53d7e0612003febb48755f4114c"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3063a53d7e0612003febb48755f4114c">FindCursorIndex</a> (const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; IncludeDirective &gt; &amp;Includes, const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;Indices, <a class="el" href="classunsigned.html">unsigned</a> Cursor)</td></tr>
<tr class="separator:a3063a53d7e0612003febb48755f4114c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e43d46c0fc19789278de9a6e926dcab" id="r_a2e43d46c0fc19789278de9a6e926dcab"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e43d46c0fc19789278de9a6e926dcab">replaceCRLF</a> (const std::string &amp;Code)</td></tr>
<tr class="separator:a2e43d46c0fc19789278de9a6e926dcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af102889ff4692be283f2164fe7106c11" id="r_af102889ff4692be283f2164fe7106c11"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af102889ff4692be283f2164fe7106c11">sortCppIncludes</a> (const FormatStyle &amp;Style, const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; IncludeDirective &gt; &amp;Includes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt; Ranges, StringRef FileName, StringRef Code, <a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &amp;Replaces, <a class="el" href="classunsigned.html">unsigned</a> *Cursor)</td></tr>
<tr class="separator:af102889ff4692be283f2164fe7106c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666e2d158cd26ea76bc7583887a65a0e" id="r_a666e2d158cd26ea76bc7583887a65a0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a666e2d158cd26ea76bc7583887a65a0e">sortCppIncludes</a> (const FormatStyle &amp;Style, StringRef Code, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt; Ranges, StringRef FileName, <a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &amp;Replaces, <a class="el" href="classunsigned.html">unsigned</a> *Cursor)</td></tr>
<tr class="separator:a666e2d158cd26ea76bc7583887a65a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5ab3e4f145c4f220ced43c4086dccc" id="r_a2c5ab3e4f145c4f220ced43c4086dccc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c5ab3e4f145c4f220ced43c4086dccc">findJavaImportGroup</a> (const FormatStyle &amp;Style, StringRef ImportIdentifier)</td></tr>
<tr class="separator:a2c5ab3e4f145c4f220ced43c4086dccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51fc90a80b779f1af6ac93704d3b275" id="r_ab51fc90a80b779f1af6ac93704d3b275"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab51fc90a80b779f1af6ac93704d3b275">sortJavaImports</a> (const FormatStyle &amp;Style, const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; JavaImportDirective &gt; &amp;Imports, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt; Ranges, StringRef FileName, StringRef Code, <a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &amp;Replaces)</td></tr>
<tr class="separator:ab51fc90a80b779f1af6ac93704d3b275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab55f9f5072a8256c6e413fea200c66c" id="r_aab55f9f5072a8256c6e413fea200c66c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab55f9f5072a8256c6e413fea200c66c">sortJavaImports</a> (const FormatStyle &amp;Style, StringRef Code, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt; Ranges, StringRef FileName, <a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &amp;Replaces)</td></tr>
<tr class="separator:aab55f9f5072a8256c6e413fea200c66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8d4347555541a74523c231b5d8cdb1" id="r_a6c8d4347555541a74523c231b5d8cdb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c8d4347555541a74523c231b5d8cdb1">isMpegTS</a> (StringRef Code)</td></tr>
<tr class="separator:a6c8d4347555541a74523c231b5d8cdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2051628b228736f5032642207d89b208" id="r_a2051628b228736f5032642207d89b208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2051628b228736f5032642207d89b208">isLikelyXml</a> (StringRef Code)</td></tr>
<tr class="separator:a2051628b228736f5032642207d89b208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10c25d07fe088e876a859f227e7eb86" id="r_ab10c25d07fe088e876a859f227e7eb86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab10c25d07fe088e876a859f227e7eb86">sortIncludes</a> (const FormatStyle &amp;Style, StringRef Code, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt; Ranges, StringRef FileName, <a class="el" href="classunsigned.html">unsigned</a> *Cursor)</td></tr>
<tr class="separator:ab10c25d07fe088e876a859f227e7eb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1aa262e52e1123db1dc04d007423e5" id="r_a4b1aa262e52e1123db1dc04d007423e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b1aa262e52e1123db1dc04d007423e5"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Expected.html">llvm::Expected</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b1aa262e52e1123db1dc04d007423e5">processReplacements</a> (T ProcessFunc, StringRef Code, const <a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &amp;Replaces, const FormatStyle &amp;Style)</td></tr>
<tr class="separator:a4b1aa262e52e1123db1dc04d007423e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb183420a2ad22d30e195f394cee34a0" id="r_afb183420a2ad22d30e195f394cee34a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Expected.html">llvm::Expected</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb183420a2ad22d30e195f394cee34a0">formatReplacements</a> (StringRef Code, const <a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &amp;Replaces, const FormatStyle &amp;Style)</td></tr>
<tr class="separator:afb183420a2ad22d30e195f394cee34a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7b58332eaeaf555434a72be83f7891" id="r_a2c7b58332eaeaf555434a72be83f7891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Expected.html">llvm::Expected</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c7b58332eaeaf555434a72be83f7891">cleanupAroundReplacements</a> (StringRef Code, const <a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &amp;Replaces, const FormatStyle &amp;Style)</td></tr>
<tr class="separator:a2c7b58332eaeaf555434a72be83f7891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277c8b4d6e86b42cfc60b2fdd51652de" id="r_a277c8b4d6e86b42cfc60b2fdd51652de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a277c8b4d6e86b42cfc60b2fdd51652de">reformat</a> (const FormatStyle &amp;Style, StringRef Code, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt; Ranges, StringRef FileName, FormattingAttemptStatus *Status)</td></tr>
<tr class="separator:a277c8b4d6e86b42cfc60b2fdd51652de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fc4fece61bb269636db5dc2064ffa9" id="r_a85fc4fece61bb269636db5dc2064ffa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85fc4fece61bb269636db5dc2064ffa9">cleanup</a> (const FormatStyle &amp;Style, StringRef Code, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt; Ranges, StringRef FileName)</td></tr>
<tr class="separator:a85fc4fece61bb269636db5dc2064ffa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e601c265faac6784717f9cfb0aad6d" id="r_a89e601c265faac6784717f9cfb0aad6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89e601c265faac6784717f9cfb0aad6d">reformat</a> (const FormatStyle &amp;Style, StringRef Code, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt; Ranges, StringRef FileName, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> *IncompleteFormat)</td></tr>
<tr class="separator:a89e601c265faac6784717f9cfb0aad6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d33178d1b5a8dfa9c7db6ae25b88299" id="r_a6d33178d1b5a8dfa9c7db6ae25b88299"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d33178d1b5a8dfa9c7db6ae25b88299">fixNamespaceEndComments</a> (const FormatStyle &amp;Style, StringRef Code, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt; Ranges, StringRef FileName)</td></tr>
<tr class="separator:a6d33178d1b5a8dfa9c7db6ae25b88299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8b00f65922e74228424df219c28489" id="r_a2b8b00f65922e74228424df219c28489"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b8b00f65922e74228424df219c28489">sortUsingDeclarations</a> (const FormatStyle &amp;Style, StringRef Code, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt; Ranges, StringRef FileName)</td></tr>
<tr class="separator:a2b8b00f65922e74228424df219c28489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3384ed49864897bfa0d7f91dc556ce" id="r_aeb3384ed49864897bfa0d7f91dc556ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1LangOptions.html">LangOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb3384ed49864897bfa0d7f91dc556ce">getFormattingLangOpts</a> (const FormatStyle &amp;Style)</td></tr>
<tr class="separator:aeb3384ed49864897bfa0d7f91dc556ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b93d99676649e72e8c4d321be526ad" id="r_a24b93d99676649e72e8c4d321be526ad"><td class="memItemLeft" align="right" valign="top">static FormatStyle::LanguageKind&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24b93d99676649e72e8c4d321be526ad">getLanguageByFileName</a> (StringRef FileName)</td></tr>
<tr class="separator:a24b93d99676649e72e8c4d321be526ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673110731b1bee34155d96c81e4e1129" id="r_a673110731b1bee34155d96c81e4e1129"><td class="memItemLeft" align="right" valign="top">FormatStyle::LanguageKind&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a673110731b1bee34155d96c81e4e1129">guessLanguage</a> (StringRef FileName, StringRef Code)</td></tr>
<tr class="separator:a673110731b1bee34155d96c81e4e1129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc311b0133dd54184578648d406528f6" id="r_afc311b0133dd54184578648d406528f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Expected.html">llvm::Expected</a>&lt; FormatStyle &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc311b0133dd54184578648d406528f6">getStyle</a> (StringRef StyleName, StringRef FileName, StringRef FallbackStyleName, StringRef Code, llvm::vfs::FileSystem *FS, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> AllowUnknownOptions)</td></tr>
<tr class="separator:afc311b0133dd54184578648d406528f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e0d3865faed44e2cc12fb794f30fa8" id="r_a11e0d3865faed44e2cc12fb794f30fa8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11e0d3865faed44e2cc12fb794f30fa8">getTokenTypeName</a> (<a class="el" href="#ad4b610ca9f97cde157e9b4a864f588d7">TokenType</a> <a class="el" href="classclang_1_1Type.html">Type</a>)</td></tr>
<tr class="memdesc:a11e0d3865faed44e2cc12fb794f30fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the name of a token type.  <br /></td></tr>
<tr class="separator:a11e0d3865faed44e2cc12fb794f30fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5d1d387154b424ef2498d5d64739c1" id="r_aae5d1d387154b424ef2498d5d64739c1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae5d1d387154b424ef2498d5d64739c1">CodePointsBetween</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> *<a class="el" href="USRLocFinder_8cpp.html#ab81f7a8ff866f4df2160fa7b1f2cf182">Begin</a>, const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> *End)</td></tr>
<tr class="separator:aae5d1d387154b424ef2498d5d64739c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cf486e8836b20a423db5d02331b745" id="r_a73cf486e8836b20a423db5d02331b745"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structclang_1_1format_1_1FormatToken.html">clang::format::FormatToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73cf486e8836b20a423db5d02331b745">getPreviousNonComment</a> () const</td></tr>
<tr class="memdesc:a73cf486e8836b20a423db5d02331b745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the previous token ignoring comments.  <br /></td></tr>
<tr class="separator:a73cf486e8836b20a423db5d02331b745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150e750831c1fe938ffa8676b27ba8ab" id="r_a150e750831c1fe938ffa8676b27ba8ab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a150e750831c1fe938ffa8676b27ba8ab">getNextNonComment</a> () const</td></tr>
<tr class="memdesc:a150e750831c1fe938ffa8676b27ba8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next token ignoring comments.  <br /></td></tr>
<tr class="separator:a150e750831c1fe938ffa8676b27ba8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d340642f13213a59fae88b75ba90a4" id="r_ac5d340642f13213a59fae88b75ba90a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5d340642f13213a59fae88b75ba90a4">opensBlockOrBlockTypeList</a> (const FormatStyle &amp;Style) const</td></tr>
<tr class="memdesc:ac5d340642f13213a59fae88b75ba90a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this tokens starts a block-type list, i.e. a list that should be indented with a block indent.  <br /></td></tr>
<tr class="separator:ac5d340642f13213a59fae88b75ba90a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacb102c3f35a5682f4fd19018b72400" id="r_abacb102c3f35a5682f4fd19018b72400"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abacb102c3f35a5682f4fd19018b72400">isCppStructuredBinding</a> (const FormatStyle &amp;Style) const</td></tr>
<tr class="memdesc:abacb102c3f35a5682f4fd19018b72400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the token is the left square bracket of a C++ structured binding declaration.  <br /></td></tr>
<tr class="separator:abacb102c3f35a5682f4fd19018b72400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200096dbe98bfde59772bf9109be8f66" id="r_a200096dbe98bfde59772bf9109be8f66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a200096dbe98bfde59772bf9109be8f66">closesBlockOrBlockTypeList</a> (const FormatStyle &amp;Style) const</td></tr>
<tr class="memdesc:a200096dbe98bfde59772bf9109be8f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as opensBlockOrBlockTypeList, but for the closing token.  <br /></td></tr>
<tr class="separator:a200096dbe98bfde59772bf9109be8f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b13b0f837586ebe2744424f447dcf2" id="r_a10b13b0f837586ebe2744424f447dcf2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10b13b0f837586ebe2744424f447dcf2">getNamespaceToken</a> () const</td></tr>
<tr class="memdesc:a10b13b0f837586ebe2744424f447dcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the actual namespace token, if this token starts a namespace block.  <br /></td></tr>
<tr class="separator:a10b13b0f837586ebe2744424f447dcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3881f4733c03f7ca5d8e4036f88c539d" id="r_a3881f4733c03f7ca5d8e4036f88c539d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3881f4733c03f7ca5d8e4036f88c539d">copyFrom</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;<a class="el" href="FormatToken_8h.html#aaf3e42cecb4cc18e3d79250e82b642ea">Tok</a>)</td></tr>
<tr class="separator:a3881f4733c03f7ca5d8e4036f88c539d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dda1cac8cf4e3121ef1c0716ddc8ca0" id="r_a1dda1cac8cf4e3121ef1c0716ddc8ca0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dda1cac8cf4e3121ef1c0716ddc8ca0">getNamespaceToken</a> (const <a class="el" href="classclang_1_1format_1_1AnnotatedLine.html">AnnotatedLine</a> *Line, const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classclang_1_1format_1_1AnnotatedLine.html">AnnotatedLine</a> * &gt; &amp;AnnotatedLines)</td></tr>
<tr class="separator:a1dda1cac8cf4e3121ef1c0716ddc8ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ad169fedb393886bc74c65a6a809c7" id="r_ae5ad169fedb393886bc74c65a6a809c7"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5ad169fedb393886bc74c65a6a809c7">getNamespaceTokenText</a> (const <a class="el" href="classclang_1_1format_1_1AnnotatedLine.html">AnnotatedLine</a> *Line, const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classclang_1_1format_1_1AnnotatedLine.html">AnnotatedLine</a> * &gt; &amp;AnnotatedLines)</td></tr>
<tr class="separator:ae5ad169fedb393886bc74c65a6a809c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d089be8c5aab299d138d9df155fcef" id="r_a95d089be8c5aab299d138d9df155fcef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95d089be8c5aab299d138d9df155fcef">operator&lt;</a> (const <a class="el" href="structclang_1_1format_1_1JsModuleReference.html">JsModuleReference</a> &amp;LHS, const <a class="el" href="structclang_1_1format_1_1JsModuleReference.html">JsModuleReference</a> &amp;RHS)</td></tr>
<tr class="separator:a95d089be8c5aab299d138d9df155fcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2651f32d54bc0e73608c207815ef665" id="r_aa2651f32d54bc0e73608c207815ef665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2651f32d54bc0e73608c207815ef665">sortJavaScriptImports</a> (const FormatStyle &amp;Style, StringRef Code, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt; Ranges, StringRef FileName)</td></tr>
<tr class="separator:aa2651f32d54bc0e73608c207815ef665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5deb7cdaa47a8e54572bc893220e2ea1" id="r_a5deb7cdaa47a8e54572bc893220e2ea1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5deb7cdaa47a8e54572bc893220e2ea1">maxNestingDepth</a> (const <a class="el" href="classclang_1_1format_1_1AnnotatedLine.html">AnnotatedLine</a> &amp;Line)</td></tr>
<tr class="separator:a5deb7cdaa47a8e54572bc893220e2ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12134c25628ef1ab55ec3df3810cfc8" id="r_ad12134c25628ef1ab55ec3df3810cfc8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad12134c25628ef1ab55ec3df3810cfc8">isFunctionDeclarationName</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;Current, const <a class="el" href="classclang_1_1format_1_1AnnotatedLine.html">AnnotatedLine</a> &amp;Line)</td></tr>
<tr class="separator:ad12134c25628ef1ab55ec3df3810cfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97c3cb18694cf466a4953bef844d985" id="r_ab97c3cb18694cf466a4953bef844d985"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab97c3cb18694cf466a4953bef844d985">isAllmanBrace</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;<a class="el" href="FormatToken_8h.html#aaf3e42cecb4cc18e3d79250e82b642ea">Tok</a>)</td></tr>
<tr class="separator:ab97c3cb18694cf466a4953bef844d985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498b137cf49b30963e804194bfdc0f2d" id="r_a498b137cf49b30963e804194bfdc0f2d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a498b137cf49b30963e804194bfdc0f2d">IsFunctionArgument</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;<a class="el" href="FormatToken_8h.html#aaf3e42cecb4cc18e3d79250e82b642ea">Tok</a>)</td></tr>
<tr class="separator:a498b137cf49b30963e804194bfdc0f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa200af6deb5a9b431c5307385d1231a2" id="r_aa200af6deb5a9b431c5307385d1231a2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa200af6deb5a9b431c5307385d1231a2">isItAnEmptyLambdaAllowed</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;<a class="el" href="FormatToken_8h.html#aaf3e42cecb4cc18e3d79250e82b642ea">Tok</a>, FormatStyle::ShortLambdaStyle ShortLambdaOption)</td></tr>
<tr class="separator:aa200af6deb5a9b431c5307385d1231a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e091a48e0380b420039080323011210" id="r_a4e091a48e0380b420039080323011210"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e091a48e0380b420039080323011210">isItAInlineLambdaAllowed</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;<a class="el" href="FormatToken_8h.html#aaf3e42cecb4cc18e3d79250e82b642ea">Tok</a>, FormatStyle::ShortLambdaStyle ShortLambdaOption)</td></tr>
<tr class="separator:a4e091a48e0380b420039080323011210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9e36e82249b31bbc11ca7bc5f41667" id="r_aed9e36e82249b31bbc11ca7bc5f41667"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed9e36e82249b31bbc11ca7bc5f41667">isOneChildWithoutMustBreakBefore</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;<a class="el" href="FormatToken_8h.html#aaf3e42cecb4cc18e3d79250e82b642ea">Tok</a>)</td></tr>
<tr class="separator:aed9e36e82249b31bbc11ca7bc5f41667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1759d7f24425968404daf6c41e6cc1e0" id="r_a1759d7f24425968404daf6c41e6cc1e0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1759d7f24425968404daf6c41e6cc1e0">isAllmanLambdaBrace</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;<a class="el" href="FormatToken_8h.html#aaf3e42cecb4cc18e3d79250e82b642ea">Tok</a>)</td></tr>
<tr class="separator:a1759d7f24425968404daf6c41e6cc1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1b939670689969ce90f608897a7e07" id="r_a7e1b939670689969ce90f608897a7e07"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e1b939670689969ce90f608897a7e07">isAllmanBraceIncludedBreakableLambda</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;<a class="el" href="FormatToken_8h.html#aaf3e42cecb4cc18e3d79250e82b642ea">Tok</a>, FormatStyle::ShortLambdaStyle ShortLambdaOption)</td></tr>
<tr class="separator:a7e1b939670689969ce90f608897a7e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3a04b1e5e97440ce32f4dad85899c0" id="r_a0f3a04b1e5e97440ce32f4dad85899c0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0f3a04b1e5e97440ce32f4dad85899c0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f3a04b1e5e97440ce32f4dad85899c0">hash_combine</a> (std::size_t &amp;seed, const T &amp;<a class="el" href="arm__acle_8h.html#a8603782009ff58be0587ea58013b3e52">v</a>)</td></tr>
<tr class="separator:a0f3a04b1e5e97440ce32f4dad85899c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8b6875cc50576cc30019f782e8d422" id="r_ace8b6875cc50576cc30019f782e8d422"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace8b6875cc50576cc30019f782e8d422">isGoogScope</a> (const <a class="el" href="structclang_1_1format_1_1UnwrappedLine.html">UnwrappedLine</a> &amp;Line)</td></tr>
<tr class="separator:ace8b6875cc50576cc30019f782e8d422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1331e1d97b5082959f33946d788eeda" id="r_ab1331e1d97b5082959f33946d788eeda"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1331e1d97b5082959f33946d788eeda">isIIFE</a> (const <a class="el" href="structclang_1_1format_1_1UnwrappedLine.html">UnwrappedLine</a> &amp;Line, const <a class="el" href="structclang_1_1AdditionalKeywords.html">AdditionalKeywords</a> &amp;Keywords)</td></tr>
<tr class="separator:ab1331e1d97b5082959f33946d788eeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af388270e2a22fe9447e697ead1a941" id="r_a9af388270e2a22fe9447e697ead1a941"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9af388270e2a22fe9447e697ead1a941">ShouldBreakBeforeBrace</a> (const FormatStyle &amp;Style, const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;InitialToken)</td></tr>
<tr class="separator:a9af388270e2a22fe9447e697ead1a941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4170e2033d41c34c0b47ab551b8110d1" id="r_a4170e2033d41c34c0b47ab551b8110d1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4170e2033d41c34c0b47ab551b8110d1">tokenCanStartNewLine</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;<a class="el" href="FormatToken_8h.html#aaf3e42cecb4cc18e3d79250e82b642ea">Tok</a>)</td></tr>
<tr class="separator:a4170e2033d41c34c0b47ab551b8110d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8eae2e84b1c07b32ceabe61a991e76" id="r_aae8eae2e84b1c07b32ceabe61a991e76"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae8eae2e84b1c07b32ceabe61a991e76">mustBeJSIdent</a> (const <a class="el" href="structclang_1_1AdditionalKeywords.html">AdditionalKeywords</a> &amp;Keywords, const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> *FormatTok)</td></tr>
<tr class="separator:aae8eae2e84b1c07b32ceabe61a991e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d6f2b231494481c6c272127678bcda" id="r_a11d6f2b231494481c6c272127678bcda"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11d6f2b231494481c6c272127678bcda">mustBeJSIdentOrValue</a> (const <a class="el" href="structclang_1_1AdditionalKeywords.html">AdditionalKeywords</a> &amp;Keywords, const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> *FormatTok)</td></tr>
<tr class="separator:a11d6f2b231494481c6c272127678bcda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950e7a8451edd9827e1b944757d93f31" id="r_a950e7a8451edd9827e1b944757d93f31"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a950e7a8451edd9827e1b944757d93f31">isJSDeclOrStmt</a> (const <a class="el" href="structclang_1_1AdditionalKeywords.html">AdditionalKeywords</a> &amp;Keywords, const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> *FormatTok)</td></tr>
<tr class="separator:a950e7a8451edd9827e1b944757d93f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2036244f1c590e57ecacc143ba9a79" id="r_a5f2036244f1c590e57ecacc143ba9a79"><td class="memItemLeft" align="right" valign="top">static LLVM_ATTRIBUTE_UNUSED void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f2036244f1c590e57ecacc143ba9a79">printDebugInfo</a> (const <a class="el" href="structclang_1_1format_1_1UnwrappedLine.html">UnwrappedLine</a> &amp;Line, StringRef Prefix=&quot;&quot;)</td></tr>
<tr class="separator:a5f2036244f1c590e57ecacc143ba9a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa4338505bf76a6e3099862b9b5db5e" id="r_a2fa4338505bf76a6e3099862b9b5db5e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fa4338505bf76a6e3099862b9b5db5e">continuesLineCommentSection</a> (const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;FormatTok, const <a class="el" href="structclang_1_1format_1_1UnwrappedLine.html">UnwrappedLine</a> &amp;Line, const llvm::Regex &amp;CommentPragmasRegex)</td></tr>
<tr class="separator:a2fa4338505bf76a6e3099862b9b5db5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dbce45c31962432764b9769217d177" id="r_ab7dbce45c31962432764b9769217d177"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ab7dbce45c31962432764b9769217d177"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7dbce45c31962432764b9769217d177">AlignTokenSequence</a> (<a class="el" href="classunsigned.html">unsigned</a> Start, <a class="el" href="classunsigned.html">unsigned</a> End, <a class="el" href="classunsigned.html">unsigned</a> Column, F &amp;&amp;Matches, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structclang_1_1format_1_1WhitespaceManager_1_1Change.html">WhitespaceManager::Change</a>, 16 &gt; &amp;Changes)</td></tr>
<tr class="separator:ab7dbce45c31962432764b9769217d177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb8c782522850387d7779b591ca989b" id="r_a2eb8c782522850387d7779b591ca989b"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a2eb8c782522850387d7779b591ca989b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2eb8c782522850387d7779b591ca989b">AlignTokens</a> (const FormatStyle &amp;Style, F &amp;&amp;Matches, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structclang_1_1format_1_1WhitespaceManager_1_1Change.html">WhitespaceManager::Change</a>, 16 &gt; &amp;Changes, <a class="el" href="classunsigned.html">unsigned</a> StartAt, const FormatStyle::AlignConsecutiveStyle &amp;ACS=FormatStyle::ACS_None)</td></tr>
<tr class="separator:a2eb8c782522850387d7779b591ca989b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3583d7e5e575dae5d9b447255df3b2e" id="r_aa3583d7e5e575dae5d9b447255df3b2e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3583d7e5e575dae5d9b447255df3b2e">AlignMacroSequence</a> (<a class="el" href="classunsigned.html">unsigned</a> &amp;StartOfSequence, <a class="el" href="classunsigned.html">unsigned</a> &amp;EndOfSequence, <a class="el" href="classunsigned.html">unsigned</a> &amp;MinColumn, <a class="el" href="classunsigned.html">unsigned</a> &amp;MaxColumn, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &amp;FoundMatchOnLine, std::function&lt; <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>(const <a class="el" href="structclang_1_1format_1_1WhitespaceManager_1_1Change.html">WhitespaceManager::Change</a> &amp;<a class="el" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a>)&gt; AlignMacrosMatches, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structclang_1_1format_1_1WhitespaceManager_1_1Change.html">WhitespaceManager::Change</a>, 16 &gt; &amp;Changes)</td></tr>
<tr class="separator:aa3583d7e5e575dae5d9b447255df3b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0139f59128492a6bf38328cf67a8cc82" id="r_a0139f59128492a6bf38328cf67a8cc82"><td class="memItemLeft" align="right" valign="top">static constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0139f59128492a6bf38328cf67a8cc82">Blanks</a> = &quot; \t\v\f\r&quot;</td></tr>
<tr class="separator:a0139f59128492a6bf38328cf67a8cc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad333f1c207f36ba93dedefbec3bd81" id="r_a2ad333f1c207f36ba93dedefbec3bd81"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ad333f1c207f36ba93dedefbec3bd81">StyleOptionHelpDescription</a></td></tr>
<tr class="separator:a2ad333f1c207f36ba93dedefbec3bd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47454fe750136909d455c39ac6c3fa59" id="r_a47454fe750136909d455c39ac6c3fa59"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47454fe750136909d455c39ac6c3fa59">DefaultFormatStyle</a> = &quot;file&quot;</td></tr>
<tr class="separator:a47454fe750136909d455c39ac6c3fa59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335725622d34fd0f5d0caec296010195" id="r_a335725622d34fd0f5d0caec296010195"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a335725622d34fd0f5d0caec296010195">DefaultFallbackStyle</a> = &quot;LLVM&quot;</td></tr>
<tr class="separator:a335725622d34fd0f5d0caec296010195"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="af3efd684dd7c9ad4cd48fd4d28ecaaea" name="af3efd684dd7c9ad4cd48fd4d28ecaaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3efd684dd7c9ad4cd48fd4d28ecaaea">&#9670;&#160;</a></span>BraceBlockKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#af3efd684dd7c9ad4cd48fd4d28ecaaea">clang::format::BraceBlockKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af3efd684dd7c9ad4cd48fd4d28ecaaeaabc206459d88deb858f2709556db71017" name="af3efd684dd7c9ad4cd48fd4d28ecaaeaabc206459d88deb858f2709556db71017"></a>BK_Unknown&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af3efd684dd7c9ad4cd48fd4d28ecaaeaac0cd3adbed48a71039a2855df3fe8036" name="af3efd684dd7c9ad4cd48fd4d28ecaaeaac0cd3adbed48a71039a2855df3fe8036"></a>BK_Block&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af3efd684dd7c9ad4cd48fd4d28ecaaeaae56a45f3e07dfba04c28c70b668c2bdd" name="af3efd684dd7c9ad4cd48fd4d28ecaaeaae56a45f3e07dfba04c28c70b668c2bdd"></a>BK_BracedInit&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="FormatToken_8h_source.html#l00137">137</a> of file <a class="el" href="FormatToken_8h_source.html">FormatToken.h</a>.</p>

</div>
</div>
<a id="a3409598f12699626b6997dfdd18c6929" name="a3409598f12699626b6997dfdd18c6929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3409598f12699626b6997dfdd18c6929">&#9670;&#160;</a></span>FormatDecision</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a3409598f12699626b6997dfdd18c6929">clang::format::FormatDecision</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3409598f12699626b6997dfdd18c6929a8da12d86e1be42ee8d8d458d1f5dfc25" name="a3409598f12699626b6997dfdd18c6929a8da12d86e1be42ee8d8d458d1f5dfc25"></a>FD_Unformatted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3409598f12699626b6997dfdd18c6929a98df366120a9a0c1f0eaec09b1555cff" name="a3409598f12699626b6997dfdd18c6929a98df366120a9a0c1f0eaec09b1555cff"></a>FD_Continue&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3409598f12699626b6997dfdd18c6929a77ad2a14db7203e0c45a0e9aacf50745" name="a3409598f12699626b6997dfdd18c6929a77ad2a14db7203e0c45a0e9aacf50745"></a>FD_Break&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="FormatToken_8h_source.html#l00142">142</a> of file <a class="el" href="FormatToken_8h_source.html">FormatToken.h</a>.</p>

</div>
</div>
<a id="aef6cf7cf51bbe9654709043db7a72468" name="aef6cf7cf51bbe9654709043db7a72468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6cf7cf51bbe9654709043db7a72468">&#9670;&#160;</a></span>LexerState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#aef6cf7cf51bbe9654709043db7a72468">clang::format::LexerState</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aef6cf7cf51bbe9654709043db7a72468a5d7c6d1e20cfb893ee7c0963529b9c35" name="aef6cf7cf51bbe9654709043db7a72468a5d7c6d1e20cfb893ee7c0963529b9c35"></a>NORMAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aef6cf7cf51bbe9654709043db7a72468afac6123425d4426efc2ae0ecd6b2dce9" name="aef6cf7cf51bbe9654709043db7a72468afac6123425d4426efc2ae0ecd6b2dce9"></a>TEMPLATE_STRING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aef6cf7cf51bbe9654709043db7a72468a31bdb814ec375214324ead465f67212a" name="aef6cf7cf51bbe9654709043db7a72468a31bdb814ec375214324ead465f67212a"></a>TOKEN_STASHED&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="FormatTokenLexer_8h_source.html#l00032">32</a> of file <a class="el" href="FormatTokenLexer_8h_source.html">FormatTokenLexer.h</a>.</p>

</div>
</div>
<a id="af1aa248193ce0aa256a43af928d62171" name="af1aa248193ce0aa256a43af928d62171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1aa248193ce0aa256a43af928d62171">&#9670;&#160;</a></span>LineType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#af1aa248193ce0aa256a43af928d62171">clang::format::LineType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af1aa248193ce0aa256a43af928d62171acc4ddb995bb9dcfb69eddbd787f39df4" name="af1aa248193ce0aa256a43af928d62171acc4ddb995bb9dcfb69eddbd787f39df4"></a>LT_Invalid&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af1aa248193ce0aa256a43af928d62171afe0fe969ae9ec530e48d260e8ffb45b9" name="af1aa248193ce0aa256a43af928d62171afe0fe969ae9ec530e48d260e8ffb45b9"></a>LT_ImportStatement&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af1aa248193ce0aa256a43af928d62171a693e828dfa10c6ee94325795f3e5b93f" name="af1aa248193ce0aa256a43af928d62171a693e828dfa10c6ee94325795f3e5b93f"></a>LT_ObjCDecl&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af1aa248193ce0aa256a43af928d62171a40123db8fe0709b9f77c1601517b2359" name="af1aa248193ce0aa256a43af928d62171a40123db8fe0709b9f77c1601517b2359"></a>LT_ObjCMethodDecl&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af1aa248193ce0aa256a43af928d62171a1a1da9aba4cbb0696cecdd94b73a2794" name="af1aa248193ce0aa256a43af928d62171a1a1da9aba4cbb0696cecdd94b73a2794"></a>LT_ObjCProperty&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af1aa248193ce0aa256a43af928d62171a8e57e20cdb286891185517baa935a4b7" name="af1aa248193ce0aa256a43af928d62171a8e57e20cdb286891185517baa935a4b7"></a>LT_Other&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af1aa248193ce0aa256a43af928d62171adb46bb49ded6cdf9747d8d17cf5c482c" name="af1aa248193ce0aa256a43af928d62171adb46bb49ded6cdf9747d8d17cf5c482c"></a>LT_PreprocessorDirective&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af1aa248193ce0aa256a43af928d62171ade202d78e75d69b85c740777408eafaf" name="af1aa248193ce0aa256a43af928d62171ade202d78e75d69b85c740777408eafaf"></a>LT_VirtualFunctionDecl&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TokenAnnotator_8h_source.html#l00026">26</a> of file <a class="el" href="TokenAnnotator_8h_source.html">TokenAnnotator.h</a>.</p>

</div>
</div>
<a id="a14684d2db0efbadbe649c3f984097e67" name="a14684d2db0efbadbe649c3f984097e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14684d2db0efbadbe649c3f984097e67">&#9670;&#160;</a></span>MacroRole</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a14684d2db0efbadbe649c3f984097e67">clang::format::MacroRole</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Roles a token can take in a configured macro expansion. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a14684d2db0efbadbe649c3f984097e67a88be99a74a3e2782e6ee791cb345338a" name="a14684d2db0efbadbe649c3f984097e67a88be99a74a3e2782e6ee791cb345338a"></a>MR_ExpandedArg&#160;</td><td class="fielddoc"><p>The token was expanded from a macro argument when formatting the expanded token sequence. </p>
</td></tr>
<tr><td class="fieldname"><a id="a14684d2db0efbadbe649c3f984097e67a0321a1b9bc8ae2cc2db8668991190f3d" name="a14684d2db0efbadbe649c3f984097e67a0321a1b9bc8ae2cc2db8668991190f3d"></a>MR_UnexpandedArg&#160;</td><td class="fielddoc"><p>The token is part of a macro argument that was previously formatted as expansion when formatting the unexpanded macro call. </p>
</td></tr>
<tr><td class="fieldname"><a id="a14684d2db0efbadbe649c3f984097e67a37aac8d105a06e843003bbc5c043f778" name="a14684d2db0efbadbe649c3f984097e67a37aac8d105a06e843003bbc5c043f778"></a>MR_Hidden&#160;</td><td class="fielddoc"><p>The token was expanded from a macro definition, and is not visible as part of the macro call. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="FormatToken_8h_source.html#l00145">145</a> of file <a class="el" href="FormatToken_8h_source.html">FormatToken.h</a>.</p>

</div>
</div>
<a id="a452b34c08537cab02deca443e342bec6" name="a452b34c08537cab02deca443e342bec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452b34c08537cab02deca443e342bec6">&#9670;&#160;</a></span>ParameterPackingKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a452b34c08537cab02deca443e342bec6">clang::format::ParameterPackingKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a452b34c08537cab02deca443e342bec6a3e1e85534f0f7b91f01b7574f4d4adf5" name="a452b34c08537cab02deca443e342bec6a3e1e85534f0f7b91f01b7574f4d4adf5"></a>PPK_BinPacked&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a452b34c08537cab02deca443e342bec6af698c50de2f16b48e6eec09e447ebf99" name="a452b34c08537cab02deca443e342bec6af698c50de2f16b48e6eec09e447ebf99"></a>PPK_OnePerLine&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a452b34c08537cab02deca443e342bec6aa198a0d4cbb39979341cb7388e93e97b" name="a452b34c08537cab02deca443e342bec6aa198a0d4cbb39979341cb7388e93e97b"></a>PPK_Inconclusive&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="FormatToken_8h_source.html#l00140">140</a> of file <a class="el" href="FormatToken_8h_source.html">FormatToken.h</a>.</p>

</div>
</div>
<a id="a8361fae3448126045290df1a4506c954" name="a8361fae3448126045290df1a4506c954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8361fae3448126045290df1a4506c954">&#9670;&#160;</a></span>ParseError</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a8361fae3448126045290df1a4506c954">clang::format::ParseError</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8361fae3448126045290df1a4506c954a505a83f220c02df2f85c3810cd9ceb38" name="a8361fae3448126045290df1a4506c954a505a83f220c02df2f85c3810cd9ceb38"></a>Success&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8361fae3448126045290df1a4506c954a902b0d55fddef6f8d651fe1035b7d4bd" name="a8361fae3448126045290df1a4506c954a902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8361fae3448126045290df1a4506c954a91957bd1005afd35f28861fe81992ee0" name="a8361fae3448126045290df1a4506c954a91957bd1005afd35f28861fe81992ee0"></a>Unsuitable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8361fae3448126045290df1a4506c954aa9b40ec5afeefed5b4c02dddfef2a294" name="a8361fae3448126045290df1a4506c954aa9b40ec5afeefed5b4c02dddfef2a294"></a>BinPackTrailingCommaConflict&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00038">38</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="ad4b610ca9f97cde157e9b4a864f588d7" name="ad4b610ca9f97cde157e9b4a864f588d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b610ca9f97cde157e9b4a864f588d7">&#9670;&#160;</a></span>TokenType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ad4b610ca9f97cde157e9b4a864f588d7">clang::format::TokenType</a> : uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the semantic type of a syntactic token, e.g. </p>
<p>whether "&lt;" is a template opener or binary operator. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad4b610ca9f97cde157e9b4a864f588d7abdc4c1181516faf4ac1d450badd2669c" name="ad4b610ca9f97cde157e9b4a864f588d7abdc4c1181516faf4ac1d450badd2669c"></a>NUM_TOKEN_TYPES&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="FormatToken_8h_source.html#l00126">126</a> of file <a class="el" href="FormatToken_8h_source.html">FormatToken.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0e9a2f037830def9c9a494c5e0ae7b4e" name="a0e9a2f037830def9c9a494c5e0ae7b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9a2f037830def9c9a494c5e0ae7b4e">&#9670;&#160;</a></span>affectsRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::affectsRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Ranges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>End</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02129">2129</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l02196">sortCppIncludes()</a>, and <a class="el" href="Format_8cpp_source.html#l02385">sortJavaImports()</a>.</p>

</div>
</div>
<a id="aa3583d7e5e575dae5d9b447255df3b2e" name="aa3583d7e5e575dae5d9b447255df3b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3583d7e5e575dae5d9b447255df3b2e">&#9670;&#160;</a></span>AlignMacroSequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void clang::format::AlignMacroSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>StartOfSequence</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>EndOfSequence</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MinColumn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MaxColumn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>FoundMatchOnLine</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>(const <a class="el" href="structclang_1_1format_1_1WhitespaceManager_1_1Change.html">WhitespaceManager::Change</a> &amp;<a class="el" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">C</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>AlignMacrosMatches</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structclang_1_1format_1_1WhitespaceManager_1_1Change.html">WhitespaceManager::Change</a>, 16 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Changes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="WhitespaceManager_8cpp_source.html#l00505">505</a> of file <a class="el" href="WhitespaceManager_8cpp_source.html">WhitespaceManager.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00758">NewlinesBefore</a>, and <a class="el" href="limits_8h_source.html#l00056">UINT_MAX</a>.</p>

</div>
</div>
<a id="a2eb8c782522850387d7779b591ca989b" name="a2eb8c782522850387d7779b591ca989b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb8c782522850387d7779b591ca989b">&#9670;&#160;</a></span>AlignTokens()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classunsigned.html">unsigned</a> clang::format::AlignTokens </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>Matches</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structclang_1_1format_1_1WhitespaceManager_1_1Change.html">WhitespaceManager::Change</a>, 16 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Changes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>StartAt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FormatStyle::AlignConsecutiveStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>ACS</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FormatStyle::ACS_None</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="WhitespaceManager_8cpp_source.html#l00364">364</a> of file <a class="el" href="WhitespaceManager_8cpp_source.html">WhitespaceManager.cpp</a>.</p>

<p class="reference">References <a class="el" href="WhitespaceManager_8cpp_source.html#l00364">AlignTokens()</a>, <a class="el" href="WhitespaceManager_8cpp_source.html#l00265">AlignTokenSequence()</a>, <a class="el" href="FormatToken_8h_source.html#l00758">NewlinesBefore</a>, <a class="el" href="FormatToken_8h_source.html#l00643">Tok</a>, and <a class="el" href="limits_8h_source.html#l00056">UINT_MAX</a>.</p>

<p class="reference">Referenced by <a class="el" href="WhitespaceManager_8cpp_source.html#l00364">AlignTokens()</a>.</p>

</div>
</div>
<a id="ab7dbce45c31962432764b9769217d177" name="ab7dbce45c31962432764b9769217d177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7dbce45c31962432764b9769217d177">&#9670;&#160;</a></span>AlignTokenSequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void clang::format::AlignTokenSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>End</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Column</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>Matches</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structclang_1_1format_1_1WhitespaceManager_1_1Change.html">WhitespaceManager::Change</a>, 16 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Changes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="WhitespaceManager_8cpp_source.html#l00265">265</a> of file <a class="el" href="WhitespaceManager_8cpp_source.html">WhitespaceManager.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00758">NewlinesBefore</a>, and <a class="el" href="FormatToken_8h_source.html#l00643">Tok</a>.</p>

<p class="reference">Referenced by <a class="el" href="WhitespaceManager_8cpp_source.html#l00364">AlignTokens()</a>.</p>

</div>
</div>
<a id="a85fc4fece61bb269636db5dc2064ffa9" name="a85fc4fece61bb269636db5dc2064ffa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85fc4fece61bb269636db5dc2064ffa9">&#9670;&#160;</a></span>cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> clang::format::cleanup </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Ranges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>FileName</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02776">2776</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l02676">cleanupAroundReplacements()</a>.</p>

</div>
</div>
<a id="a2c7b58332eaeaf555434a72be83f7891" name="a2c7b58332eaeaf555434a72be83f7891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7b58332eaeaf555434a72be83f7891">&#9670;&#160;</a></span>cleanupAroundReplacements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Expected.html">llvm::Expected</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &gt; clang::format::cleanupAroundReplacements </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Replaces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02676">2676</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l02776">cleanup()</a>, and <a class="el" href="Format_8cpp_source.html#l02547">processReplacements()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AtomicChange_8cpp_source.html#l00301">clang::tooling::applyAtomicChanges()</a>.</p>

</div>
</div>
<a id="a200096dbe98bfde59772bf9109be8f66" name="a200096dbe98bfde59772bf9109be8f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200096dbe98bfde59772bf9109be8f66">&#9670;&#160;</a></span>closesBlockOrBlockTypeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::closesBlockOrBlockTypeList </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as opensBlockOrBlockTypeList, but for the closing token. </p>

<p class="definition">Definition at line <a class="el" href="FormatToken_8h_source.html#l00677">677</a> of file <a class="el" href="FormatToken_8h_source.html">FormatToken.h</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00444">clang::format::FormatToken::is()</a>.</p>

</div>
</div>
<a id="aae5d1d387154b424ef2498d5d64739c1" name="aae5d1d387154b424ef2498d5d64739c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5d1d387154b424ef2498d5d64739c1">&#9670;&#160;</a></span>CodePointsBetween()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classunsigned.html">unsigned</a> clang::format::CodePointsBetween </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> *</td>          <td class="paramname"><span class="paramname"><em>Begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> *</td>          <td class="paramname"><span class="paramname"><em>End</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FormatToken_8cpp_source.html#l00147">147</a> of file <a class="el" href="FormatToken_8cpp_source.html">FormatToken.cpp</a>.</p>

<p class="reference">References <a class="el" href="USRLocFinder_8cpp_source.html#l00165">Begin</a>.</p>

<p class="reference">Referenced by <a class="el" href="FormatToken_8cpp_source.html#l00153">clang::CommaSeparatedList::precomputeFormattingInfos()</a>.</p>

</div>
</div>
<a id="a55b4c945b9f6b5e81279ad3c83c981f1" name="a55b4c945b9f6b5e81279ad3c83c981f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b4c945b9f6b5e81279ad3c83c981f1">&#9670;&#160;</a></span>configurationAsText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string clang::format::configurationAsText </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l01426">1426</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l00775">expandPresets()</a>, and <a class="el" href="Format_8cpp_source.html#l02112">Text</a>.</p>

</div>
</div>
<a id="a2fa4338505bf76a6e3099862b9b5db5e" name="a2fa4338505bf76a6e3099862b9b5db5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa4338505bf76a6e3099862b9b5db5e">&#9670;&#160;</a></span>continuesLineCommentSection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::continuesLineCommentSection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>FormatTok</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1UnwrappedLine.html">UnwrappedLine</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::Regex &amp;</td>          <td class="paramname"><span class="paramname"><em>CommentPragmasRegex</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UnwrappedLineParser_8cpp_source.html#l02997">2997</a> of file <a class="el" href="UnwrappedLineParser_8cpp_source.html">UnwrappedLineParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00444">clang::format::FormatToken::is()</a>, <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>, and <a class="el" href="FormatToken_8h_source.html#l00228">clang::format::FormatToken::TokenText</a>.</p>

</div>
</div>
<a id="a3881f4733c03f7ca5d8e4036f88c539d" name="a3881f4733c03f7ca5d8e4036f88c539d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3881f4733c03f7ca5d8e4036f88c539d">&#9670;&#160;</a></span>copyFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clang::format::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Tok</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FormatToken_8h_source.html#l00698">698</a> of file <a class="el" href="FormatToken_8h_source.html">FormatToken.h</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00222">clang::format::FormatToken::Tok</a>.</p>

</div>
</div>
<a id="a40ff1b1ab007a48b246da6c654cbf293" name="a40ff1b1ab007a48b246da6c654cbf293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ff1b1ab007a48b246da6c654cbf293">&#9670;&#160;</a></span>expandPresets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FormatStyle clang::format::expandPresets </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l00775">775</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01426">configurationAsText()</a>, and <a class="el" href="Format_8cpp_source.html#l02693">clang::format::internal::reformat()</a>.</p>

</div>
</div>
<a id="a3063a53d7e0612003febb48755f4114c" name="a3063a53d7e0612003febb48755f4114c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3063a53d7e0612003febb48755f4114c">&#9670;&#160;</a></span>FindCursorIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt; clang::format::FindCursorIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; IncludeDirective &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Includes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Cursor</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02147">2147</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l02112">Text</a>, and <a class="el" href="limits_8h_source.html#l00056">UINT_MAX</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l02196">sortCppIncludes()</a>.</p>

</div>
</div>
<a id="a2c5ab3e4f145c4f220ced43c4086dccc" name="a2c5ab3e4f145c4f220ced43c4086dccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5ab3e4f145c4f220ced43c4086dccc">&#9670;&#160;</a></span>findJavaImportGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classunsigned.html">unsigned</a> clang::format::findJavaImportGroup </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>ImportIdentifier</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02365">2365</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="limits_8h_source.html#l00056">UINT_MAX</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l02385">sortJavaImports()</a>.</p>

</div>
</div>
<a id="a6d33178d1b5a8dfa9c7db6ae25b88299" name="a6d33178d1b5a8dfa9c7db6ae25b88299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d33178d1b5a8dfa9c7db6ae25b88299">&#9670;&#160;</a></span>fixNamespaceEndComments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> clang::format::fixNamespaceEndComments </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Ranges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>FileName</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02795">2795</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="TokenAnalyzer_8cpp_source.html#l00065">clang::format::TokenAnalyzer::process()</a>.</p>

</div>
</div>
<a id="afb183420a2ad22d30e195f394cee34a0" name="afb183420a2ad22d30e195f394cee34a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb183420a2ad22d30e195f394cee34a0">&#9670;&#160;</a></span>formatReplacements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Expected.html">llvm::Expected</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &gt; clang::format::formatReplacements </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Replaces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02566">2566</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l02547">processReplacements()</a>, <a class="el" href="Format_8cpp_source.html#l02765">reformat()</a>, and <a class="el" href="Format_8cpp_source.html#l02526">sortIncludes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Refactoring_8cpp_source.html#l00069">clang::tooling::formatAndApplyAllReplacements()</a>.</p>

</div>
</div>
<a id="ab97f413c244cbc021b63bfe0a3db938a" name="ab97f413c244cbc021b63bfe0a3db938a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97f413c244cbc021b63bfe0a3db938a">&#9670;&#160;</a></span>getCanonicalRawStringDelimiter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static StringRef clang::format::getCanonicalRawStringDelimiter </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FormatStyle::LanguageKind</td>          <td class="paramname"><span class="paramname"><em>Language</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ContinuationIndenter_8cpp_source.html#l00174">174</a> of file <a class="el" href="ContinuationIndenter_8cpp_source.html">ContinuationIndenter.cpp</a>.</p>

</div>
</div>
<a id="ad9cb4770ecc9217cc26baf529e0e72a4" name="ad9cb4770ecc9217cc26baf529e0e72a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9cb4770ecc9217cc26baf529e0e72a4">&#9670;&#160;</a></span>getChromiumStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FormatStyle clang::format::getChromiumStyle </td>
          <td>(</td>
          <td class="paramtype">FormatStyle::LanguageKind</td>          <td class="paramname"><span class="paramname"><em>Language</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l01176">1176</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l01036">getGoogleStyle()</a>, and <a class="el" href="IncludeStyle_8h_source.html#l00030">clang::tooling::IncludeStyle::IBS_Preserve</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01338">getPredefinedStyle()</a>.</p>

</div>
</div>
<a id="acbe1e3b98940dd6e22b3a62167c0720f" name="acbe1e3b98940dd6e22b3a62167c0720f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe1e3b98940dd6e22b3a62167c0720f">&#9670;&#160;</a></span>getCommentSplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1format_1_1BreakableToken.html#a0fce9f5e13cf25199ff58a96c5eb7882">BreakableToken::Split</a> clang::format::getCommentSplit </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ContentStartColumn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ColumnLimit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>TabWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1format_1_1encoding.html#a7e8496e9d93edf497ca8100b48b12492">encoding::Encoding</a></td>          <td class="paramname"><span class="paramname"><em>Encoding</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>DecorationEndsWithStar</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BreakableToken_8cpp_source.html#l00068">68</a> of file <a class="el" href="BreakableToken_8cpp_source.html">BreakableToken.cpp</a>.</p>

<p class="reference">References <a class="el" href="BreakableToken_8cpp_source.html#l00028">Blanks</a>, <a class="el" href="Encoding_8h_source.html#l00061">clang::format::encoding::columnWidthWithTabs()</a>, <a class="el" href="Encoding_8h_source.html#l00078">clang::format::encoding::getCodePointNumBytes()</a>, and <a class="el" href="Format_8cpp_source.html#l02112">Text</a>.</p>

<p class="reference">Referenced by <a class="el" href="BreakableToken_8cpp_source.html#l00492">clang::format::BreakableBlockComment::getSplit()</a>, and <a class="el" href="BreakableToken_8cpp_source.html#l00305">clang::format::BreakableComment::getSplit()</a>.</p>

</div>
</div>
<a id="ad7bd9cb14c30b33377cc246fbe5e9573" name="ad7bd9cb14c30b33377cc246fbe5e9573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bd9cb14c30b33377cc246fbe5e9573">&#9670;&#160;</a></span>getEnclosingFunctionName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static StringRef clang::format::getEnclosingFunctionName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Current</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ContinuationIndenter_8cpp_source.html#l01868">1868</a> of file <a class="el" href="ContinuationIndenter_8cpp_source.html">ContinuationIndenter.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00643">Tok</a>, and <a class="el" href="FormatToken_8h_source.html#l00228">clang::format::FormatToken::TokenText</a>.</p>

</div>
</div>
<a id="aeb3384ed49864897bfa0d7f91dc556ce" name="aeb3384ed49864897bfa0d7f91dc556ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3384ed49864897bfa0d7f91dc556ce">&#9670;&#160;</a></span>getFormattingLangOpts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> clang::format::getFormattingLangOpts </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02813">2813</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TokenAnalyzer_8cpp_source.html#l00065">clang::format::TokenAnalyzer::process()</a>.</p>

</div>
</div>
<a id="a962486c55900a9550fc495817bc4bd23" name="a962486c55900a9550fc495817bc4bd23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962486c55900a9550fc495817bc4bd23">&#9670;&#160;</a></span>getGNUStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FormatStyle clang::format::getGNUStyle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l01285">1285</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l00881">getLLVMStyle()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01338">getPredefinedStyle()</a>.</p>

</div>
</div>
<a id="a4dec822e6f8985e433a49d9a2e322c7c" name="a4dec822e6f8985e433a49d9a2e322c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dec822e6f8985e433a49d9a2e322c7c">&#9670;&#160;</a></span>getGoogleStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FormatStyle clang::format::getGoogleStyle </td>
          <td>(</td>
          <td class="paramtype">FormatStyle::LanguageKind</td>          <td class="paramname"><span class="paramname"><em>Language</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l01036">1036</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l01036">getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l00881">getLLVMStyle()</a>, <a class="el" href="IncludeStyle_8h_source.html#l00030">clang::tooling::IncludeStyle::IBS_Preserve</a>, and <a class="el" href="IncludeStyle_8h_source.html#l00048">clang::tooling::IncludeStyle::IBS_Regroup</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01176">getChromiumStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01036">getGoogleStyle()</a>, and <a class="el" href="Format_8cpp_source.html#l01338">getPredefinedStyle()</a>.</p>

</div>
</div>
<a id="a24b93d99676649e72e8c4d321be526ad" name="a24b93d99676649e72e8c4d321be526ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b93d99676649e72e8c4d321be526ad">&#9670;&#160;</a></span>getLanguageByFileName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FormatStyle::LanguageKind clang::format::getLanguageByFileName </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>FileName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02850">2850</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l02873">guessLanguage()</a>.</p>

</div>
</div>
<a id="afea89987ef7b6d6607e29b13f19fe4e8" name="afea89987ef7b6d6607e29b13f19fe4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea89987ef7b6d6607e29b13f19fe4e8">&#9670;&#160;</a></span>getLanguageName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringRef clang::format::getLanguageName </td>
          <td>(</td>
          <td class="paramtype">FormatStyle::LanguageKind</td>          <td class="paramname"><span class="paramname"><em>Language</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <code>FormatStyle</code> is used to configure the formatting to follow / specific guidelines. </p>
<p>struct FormatStyle { / The extra indent or outdent of access modifiers, e.g. <code>public:</code>. int AccessModifierOffset;</p>
<p>/ Different styles for aligning after open brackets. enum BracketAlignmentStyle : unsigned char { / Align parameters on the open bracket, e.g.: / </p><div class="fragment"><div class="line"><span class="comment">///   someLongFunction(argument1,</span><span class="comment"></span></div>
<div class="line"><span class="comment">///                    argument2);</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BAS_Align, / Don't align, instead use <code>ContinuationIndentWidth</code>, e.g.: / </p><div class="fragment"><div class="line"><span class="comment">///   someLongFunction(argument1,</span><span class="comment"></span></div>
<div class="line"><span class="comment">///       argument2);</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BAS_DontAlign, / Always break after an open bracket, if the parameters don't fit / on a single line, e.g.: / </p><div class="fragment"><div class="line"><span class="comment">///   someLongFunction(</span><span class="comment"></span></div>
<div class="line"><span class="comment">///       argument1, argument2);</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BAS_AlwaysBreak, };</p>
<p>/ If <code>true</code>, horizontally aligns arguments after an open bracket. / / This applies to round brackets (parentheses), angle brackets and square / brackets. BracketAlignmentStyle AlignAfterOpenBracket;</p>
<p>/ Styles for alignment of consecutive tokens. Tokens can be assignment signs / (see / <code>AlignConsecutiveAssignments</code>), bitfield member separators (see / <code>AlignConsecutiveBitFields</code>), names in declarations (see / <code>AlignConsecutiveDeclarations</code>) or macro definitions (see / <code>AlignConsecutiveMacros</code>). enum AlignConsecutiveStyle { ACS_None, ACS_Consecutive, ACS_AcrossEmptyLines, ACS_AcrossComments, ACS_AcrossEmptyLinesAndComments };</p>
<p>/ Style of aligning consecutive macro definitions. / / <code>Consecutive</code> will result in formattings like: / </p><div class="fragment"><div class="line"><span class="comment">///   #define SHORT_NAME       42</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   #define LONGER_NAME      0x007f</span></div>
<div class="line"><span class="comment">///   #define EVEN_LONGER_NAME (2)</span></div>
<div class="line"><span class="comment">///   #define foo(x)           (x * x)</span></div>
<div class="line"><span class="comment">///   #define bar(y, z)        (y + z)</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / Possible values: / / * <code>ACS_None</code> (in configuration: <code>None</code>) / Do not align macro definitions on consecutive lines. / / * <code>ACS_Consecutive</code> (in configuration: <code>Consecutive</code>) / Align macro definitions on consecutive lines. This will result in / formattings like: / </p><div class="fragment"><div class="line"><span class="comment">///      #define SHORT_NAME       42</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      #define LONGER_NAME      0x007f</span></div>
<div class="line"><span class="comment">///      #define EVEN_LONGER_NAME (2)</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///      #define foo(x) (x * x)</span></div>
<div class="line"><span class="comment">///      /* some comment */</span></div>
<div class="line"><span class="comment">///      #define bar(y, z) (y + z)</span></div>
<div class="line"><span class="comment"></span><span class="comment">///    </span></div>
</div><!-- fragment --><p> / / * <code>ACS_AcrossEmptyLines</code> (in configuration: <code>AcrossEmptyLines</code>) / Same as ACS_Consecutive, but also spans over empty lines, e.g. / </p><div class="fragment"><div class="line"><span class="comment">///      #define SHORT_NAME       42</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      #define LONGER_NAME      0x007f</span></div>
<div class="line"><span class="comment">///      #define EVEN_LONGER_NAME (2)</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///      #define foo(x)           (x * x)</span></div>
<div class="line"><span class="comment">///      /* some comment */</span></div>
<div class="line"><span class="comment">///      #define bar(y, z) (y + z)</span></div>
<div class="line"><span class="comment"></span><span class="comment">///    </span></div>
</div><!-- fragment --><p> / / * <code>ACS_AcrossComments</code> (in configuration: <code>AcrossComments</code>) / Same as ACS_Consecutive, but also spans over lines only containing / comments, e.g. / </p><div class="fragment"><div class="line"><span class="comment">///      #define SHORT_NAME       42</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      #define LONGER_NAME      0x007f</span></div>
<div class="line"><span class="comment">///      #define EVEN_LONGER_NAME (2)</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///      #define foo(x)    (x * x)</span></div>
<div class="line"><span class="comment">///      /* some comment */</span></div>
<div class="line"><span class="comment">///      #define bar(y, z) (y + z)</span></div>
<div class="line"><span class="comment"></span><span class="comment">///    </span></div>
</div><!-- fragment --><p> / / * <code>ACS_AcrossEmptyLinesAndComments</code> / (in configuration: <code>AcrossEmptyLinesAndComments</code>) / / Same as ACS_Consecutive, but also spans over lines only containing / comments and empty lines, e.g. / </p><div class="fragment"><div class="line"><span class="comment">///      #define SHORT_NAME       42</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      #define LONGER_NAME      0x007f</span></div>
<div class="line"><span class="comment">///      #define EVEN_LONGER_NAME (2)</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///      #define foo(x)           (x * x)</span></div>
<div class="line"><span class="comment">///      /* some comment */</span></div>
<div class="line"><span class="comment">///      #define bar(y, z)        (y + z)</span></div>
<div class="line"><span class="comment"></span><span class="comment">///    </span></div>
</div><!-- fragment --><p> AlignConsecutiveStyle AlignConsecutiveMacros;</p>
<p>/ Style of aligning consecutive assignments. / / <code>Consecutive</code> will result in formattings like: / </p><div class="fragment"><div class="line"><span class="comment">///   int a            = 1;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   int somelongname = 2;</span></div>
<div class="line"><span class="comment">///   double c         = 3;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / Possible values: / / * <code>ACS_None</code> (in configuration: <code>None</code>) / Do not align assignments on consecutive lines. / / * <code>ACS_Consecutive</code> (in configuration: <code>Consecutive</code>) / Align assignments on consecutive lines. This will result in / formattings like: / </p><div class="fragment"><div class="line"><span class="comment">///      int a            = 1;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      int somelongname = 2;</span></div>
<div class="line"><span class="comment">///      double c         = 3;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///      int d = 3;</span></div>
<div class="line"><span class="comment">///      /* A comment. */</span></div>
<div class="line"><span class="comment">///      double e = 4;</span></div>
<div class="line"><span class="comment"></span><span class="comment">///    </span></div>
</div><!-- fragment --><p> / / * <code>ACS_AcrossEmptyLines</code> (in configuration: <code>AcrossEmptyLines</code>) / Same as ACS_Consecutive, but also spans over empty lines, e.g. / </p><div class="fragment"><div class="line"><span class="comment">///      int a            = 1;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      int somelongname = 2;</span></div>
<div class="line"><span class="comment">///      double c         = 3;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///      int d            = 3;</span></div>
<div class="line"><span class="comment">///      /* A comment. */</span></div>
<div class="line"><span class="comment">///      double e = 4;</span></div>
<div class="line"><span class="comment"></span><span class="comment">///    </span></div>
</div><!-- fragment --><p> / / * <code>ACS_AcrossComments</code> (in configuration: <code>AcrossComments</code>) / Same as ACS_Consecutive, but also spans over lines only containing / comments, e.g. / </p><div class="fragment"><div class="line"><span class="comment">///      int a            = 1;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      int somelongname = 2;</span></div>
<div class="line"><span class="comment">///      double c         = 3;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///      int d    = 3;</span></div>
<div class="line"><span class="comment">///      /* A comment. */</span></div>
<div class="line"><span class="comment">///      double e = 4;</span></div>
<div class="line"><span class="comment"></span><span class="comment">///    </span></div>
</div><!-- fragment --><p> / / * <code>ACS_AcrossEmptyLinesAndComments</code> / (in configuration: <code>AcrossEmptyLinesAndComments</code>) / / Same as ACS_Consecutive, but also spans over lines only containing / comments and empty lines, e.g. / </p><div class="fragment"><div class="line"><span class="comment">///      int a            = 1;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      int somelongname = 2;</span></div>
<div class="line"><span class="comment">///      double c         = 3;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///      int d            = 3;</span></div>
<div class="line"><span class="comment">///      /* A comment. */</span></div>
<div class="line"><span class="comment">///      double e         = 4;</span></div>
<div class="line"><span class="comment"></span><span class="comment">///    </span></div>
</div><!-- fragment --><p> AlignConsecutiveStyle AlignConsecutiveAssignments;</p>
<p>/ Style of aligning consecutive bit field. / / <code>Consecutive</code> will align the bitfield separators of consecutive lines. / This will result in formattings like: / </p><div class="fragment"><div class="line"><span class="comment">///   int aaaa : 1;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   int b    : 12;</span></div>
<div class="line"><span class="comment">///   int ccc  : 8;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / Possible values: / / * <code>ACS_None</code> (in configuration: <code>None</code>) / Do not align bit fields on consecutive lines. / / * <code>ACS_Consecutive</code> (in configuration: <code>Consecutive</code>) / Align bit fields on consecutive lines. This will result in / formattings like: / </p><div class="fragment"><div class="line"><span class="comment">///      int aaaa : 1;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      int b    : 12;</span></div>
<div class="line"><span class="comment">///      int ccc  : 8;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///      int d : 2;</span></div>
<div class="line"><span class="comment">///      /* A comment. */</span></div>
<div class="line"><span class="comment">///      int ee : 3;</span></div>
<div class="line"><span class="comment"></span><span class="comment">///    </span></div>
</div><!-- fragment --><p> / / * <code>ACS_AcrossEmptyLines</code> (in configuration: <code>AcrossEmptyLines</code>) / Same as ACS_Consecutive, but also spans over empty lines, e.g. / </p><div class="fragment"><div class="line"><span class="comment">///      int aaaa : 1;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      int b    : 12;</span></div>
<div class="line"><span class="comment">///      int ccc  : 8;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///      int d    : 2;</span></div>
<div class="line"><span class="comment">///      /* A comment. */</span></div>
<div class="line"><span class="comment">///      int ee : 3;</span></div>
<div class="line"><span class="comment"></span><span class="comment">///    </span></div>
</div><!-- fragment --><p> / / * <code>ACS_AcrossComments</code> (in configuration: <code>AcrossComments</code>) / Same as ACS_Consecutive, but also spans over lines only containing / comments, e.g. / </p><div class="fragment"><div class="line"><span class="comment">///      int aaaa : 1;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      int b    : 12;</span></div>
<div class="line"><span class="comment">///      int ccc  : 8;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///      int d  : 2;</span></div>
<div class="line"><span class="comment">///      /* A comment. */</span></div>
<div class="line"><span class="comment">///      int ee : 3;</span></div>
<div class="line"><span class="comment"></span><span class="comment">///    </span></div>
</div><!-- fragment --><p> / / * <code>ACS_AcrossEmptyLinesAndComments</code> / (in configuration: <code>AcrossEmptyLinesAndComments</code>) / / Same as ACS_Consecutive, but also spans over lines only containing / comments and empty lines, e.g. / </p><div class="fragment"><div class="line"><span class="comment">///      int aaaa : 1;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      int b    : 12;</span></div>
<div class="line"><span class="comment">///      int ccc  : 8;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///      int d    : 2;</span></div>
<div class="line"><span class="comment">///      /* A comment. */</span></div>
<div class="line"><span class="comment">///      int ee   : 3;</span></div>
<div class="line"><span class="comment"></span><span class="comment">///    </span></div>
</div><!-- fragment --><p> AlignConsecutiveStyle AlignConsecutiveBitFields;</p>
<p>/ Style of aligning consecutive declarations. / / <code>Consecutive</code> will align the declaration names of consecutive lines. / This will result in formattings like: / </p><div class="fragment"><div class="line"><span class="comment">///   int         aaaa = 12;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   float       b = 23;</span></div>
<div class="line"><span class="comment">///   std::string ccc;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / Possible values: / / * <code>ACS_None</code> (in configuration: <code>None</code>) / Do not align bit declarations on consecutive lines. / / * <code>ACS_Consecutive</code> (in configuration: <code>Consecutive</code>) / Align declarations on consecutive lines. This will result in / formattings like: / </p><div class="fragment"><div class="line"><span class="comment">///      int         aaaa = 12;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      float       b = 23;</span></div>
<div class="line"><span class="comment">///      std::string ccc;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///      int a = 42;</span></div>
<div class="line"><span class="comment">///      /* A comment. */</span></div>
<div class="line"><span class="comment">///      bool c = false;</span></div>
<div class="line"><span class="comment"></span><span class="comment">///    </span></div>
</div><!-- fragment --><p> / / * <code>ACS_AcrossEmptyLines</code> (in configuration: <code>AcrossEmptyLines</code>) / Same as ACS_Consecutive, but also spans over empty lines, e.g. / </p><div class="fragment"><div class="line"><span class="comment">///      int         aaaa = 12;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      float       b = 23;</span></div>
<div class="line"><span class="comment">///      std::string ccc;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///      int         a = 42;</span></div>
<div class="line"><span class="comment">///      /* A comment. */</span></div>
<div class="line"><span class="comment">///      bool c = false;</span></div>
<div class="line"><span class="comment"></span><span class="comment">///    </span></div>
</div><!-- fragment --><p> / / * <code>ACS_AcrossComments</code> (in configuration: <code>AcrossComments</code>) / Same as ACS_Consecutive, but also spans over lines only containing / comments, e.g. / </p><div class="fragment"><div class="line"><span class="comment">///      int         aaaa = 12;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      float       b = 23;</span></div>
<div class="line"><span class="comment">///      std::string ccc;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///      int  a = 42;</span></div>
<div class="line"><span class="comment">///      /* A comment. */</span></div>
<div class="line"><span class="comment">///      bool c = false;</span></div>
<div class="line"><span class="comment"></span><span class="comment">///    </span></div>
</div><!-- fragment --><p> / / * <code>ACS_AcrossEmptyLinesAndComments</code> / (in configuration: <code>AcrossEmptyLinesAndComments</code>) / / Same as ACS_Consecutive, but also spans over lines only containing / comments and empty lines, e.g. / </p><div class="fragment"><div class="line"><span class="comment">///      int         aaaa = 12;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      float       b = 23;</span></div>
<div class="line"><span class="comment">///      std::string ccc;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///      int         a = 42;</span></div>
<div class="line"><span class="comment">///      /* A comment. */</span></div>
<div class="line"><span class="comment">///      bool        c = false;</span></div>
<div class="line"><span class="comment"></span><span class="comment">///    </span></div>
</div><!-- fragment --><p> AlignConsecutiveStyle AlignConsecutiveDeclarations;</p>
<p>/ Different styles for aligning escaped newlines. enum EscapedNewlineAlignmentStyle : unsigned char { / Don't align escaped newlines. / </p><div class="fragment"><div class="line"><span class="comment">///   #define A \</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     int aaaa; \</span></div>
<div class="line"><span class="comment">///     int b; \</span></div>
<div class="line"><span class="comment">///     int dddddddddd;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> ENAS_DontAlign, / Align escaped newlines as far left as possible. / </p><div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   #define A   \</span></div>
<div class="line"><span class="comment">///     int aaaa; \</span></div>
<div class="line"><span class="comment">///     int b;    \</span></div>
<div class="line"><span class="comment">///     int dddddddddd;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> ENAS_Left, / Align escaped newlines in the right-most column. / </p><div class="fragment"><div class="line"><span class="comment">///   #define A                                                                      \</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     int aaaa;                                                                    \</span></div>
<div class="line"><span class="comment">///     int b;                                                                       \</span></div>
<div class="line"><span class="comment">///     int dddddddddd;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> ENAS_Right, };</p>
<p>/ Options for aligning backslashes in escaped newlines. EscapedNewlineAlignmentStyle AlignEscapedNewlines;</p>
<p>/ Different styles for aligning operands. enum OperandAlignmentStyle : unsigned char { / Do not align operands of binary and ternary expressions. / The wrapped lines are indented <code>ContinuationIndentWidth</code> spaces from / the start of the line. OAS_DontAlign, / Horizontally align operands of binary and ternary expressions. / / Specifically, this aligns operands of a single expression that needs / to be split over multiple lines, e.g.: / </p><div class="fragment"><div class="line"><span class="comment">///   int aaa = bbbbbbbbbbbbbbb +</span><span class="comment"></span></div>
<div class="line"><span class="comment">///             ccccccccccccccc;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / When <code>BreakBeforeBinaryOperators</code> is set, the wrapped operator is / aligned with the operand on the first line. / </p><div class="fragment"><div class="line"><span class="comment">///   int aaa = bbbbbbbbbbbbbbb</span><span class="comment"></span></div>
<div class="line"><span class="comment">///             + ccccccccccccccc;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> OAS_Align, / Horizontally align operands of binary and ternary expressions. / / This is similar to <code>AO_Align</code>, except when / <code>BreakBeforeBinaryOperators</code> is set, the operator is un-indented so / that the wrapped operand is aligned with the operand on the first line. / </p><div class="fragment"><div class="line"><span class="comment">///   int aaa = bbbbbbbbbbbbbbb</span><span class="comment"></span></div>
<div class="line"><span class="comment">///           + ccccccccccccccc;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> OAS_AlignAfterOperator, };</p>
<p>/ If <code>true</code>, horizontally align operands of binary and ternary / expressions. OperandAlignmentStyle AlignOperands;</p>
<p>/ If <code>true</code>, aligns trailing comments. / </p><div class="fragment"><div class="line"><span class="comment">///   true:                                   false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   int a;     // My comment a      vs.     int a; // My comment a</span></div>
<div class="line"><span class="comment">///   int b = 2; // comment  b                int b = 2; // comment about b</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool AlignTrailingComments;</p>
<p>/ If a function call or braced initializer list doesn't fit on a / line, allow putting all arguments onto the next line, even if / <code>BinPackArguments</code> is <code>false</code>. / </p><div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   callFunction(</span></div>
<div class="line"><span class="comment">///       a, b, c, d);</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   callFunction(a,</span></div>
<div class="line"><span class="comment">///                b,</span></div>
<div class="line"><span class="comment">///                c,</span></div>
<div class="line"><span class="comment">///                d);</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool AllowAllArgumentsOnNextLine;</p>
<p>/ If a constructor definition with a member initializer list doesn't / fit on a single line, allow putting all member initializers onto the next / line, if <code>ConstructorInitializerAllOnOneLineOrOnePerLine</code> is true. / Note that this parameter has no effect if / <code>ConstructorInitializerAllOnOneLineOrOnePerLine</code> is false. / </p><div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   MyClass::MyClass() :</span></div>
<div class="line"><span class="comment">///       member0(0), member1(2) {}</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   MyClass::MyClass() :</span></div>
<div class="line"><span class="comment">///       member0(0),</span></div>
<div class="line"><span class="comment">///       member1(2) {}</span></div>
<div class="line"><span class="comment"></span><span class="keywordtype">bool</span> AllowAllConstructorInitializersOnNextLine;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/// If the function declaration doesn&#39;t fit on a line,</span></div>
<div class="line"><span class="comment">/// allow putting all parameters of a function declaration onto</span></div>
<div class="line"><span class="comment">/// the next line even if ``BinPackParameters`` is ``false``.</span></div>
<div class="line"><span class="comment">/// \code</span></div>
<div class="line"><span class="comment">///   true:</span></div>
<div class="line"><span class="comment">///   void myFunction(</span></div>
<div class="line"><span class="comment">///       int a, int b, int c, int d, int e);</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   void myFunction(int a,</span></div>
<div class="line"><span class="comment">///                   int b,</span></div>
<div class="line"><span class="comment">///                   int c,</span></div>
<div class="line"><span class="comment">///                   int d,</span></div>
<div class="line"><span class="comment">///                   int e);</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool AllowAllParametersOfDeclarationOnNextLine;</p>
<p>/ Allow short enums on a single line. / </p><div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   enum { A, B } myEnum;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   enum</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     A,</span></div>
<div class="line"><span class="comment">///     B</span></div>
<div class="line"><span class="comment">///   } myEnum;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool AllowShortEnumsOnASingleLine;</p>
<p>/ Different styles for merging short blocks containing at most one / statement. enum ShortBlockStyle : unsigned char { / Never merge blocks into a single line. / </p><div class="fragment"><div class="line"><span class="comment">///   while (true) {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///   while (true) {</span></div>
<div class="line"><span class="comment">///     continue;</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SBS_Never, / Only merge empty blocks. / </p><div class="fragment"><div class="line"><span class="comment">///   while (true) {}</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   while (true) {</span></div>
<div class="line"><span class="comment">///     continue;</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SBS_Empty, / Always merge short blocks into a single line. / </p><div class="fragment"><div class="line"><span class="comment">///   while (true) {}</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   while (true) { continue; }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SBS_Always, };</p>
<p>/ Dependent on the value, <code>while (true) { continue; }</code> can be put on a / single line. ShortBlockStyle AllowShortBlocksOnASingleLine;</p>
<p>/ If <code>true</code>, short case labels will be contracted to a single line. / </p><div class="fragment"><div class="line"><span class="comment">///   true:                                   false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   switch (a) {                    vs.     switch (a) {</span></div>
<div class="line"><span class="comment">///   case 1: x = 1; break;                   case 1:</span></div>
<div class="line"><span class="comment">///   case 2: return;                           x = 1;</span></div>
<div class="line"><span class="comment">///   }                                         break;</span></div>
<div class="line"><span class="comment">///                                           case 2:</span></div>
<div class="line"><span class="comment">///                                             return;</span></div>
<div class="line"><span class="comment">///                                           }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool AllowShortCaseLabelsOnASingleLine;</p>
<p>/ Different styles for merging short functions containing at most one / statement. enum ShortFunctionStyle : unsigned char { / Never merge functions into a single line. SFS_None, / Only merge functions defined inside a class. Same as "inline", / except it does not implies "empty": i.e. top level empty functions / are not merged either. / </p><div class="fragment"><div class="line"><span class="comment">///   class Foo {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     void f() { foo(); }</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///   void f() {</span></div>
<div class="line"><span class="comment">///     foo();</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///   void f() {</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SFS_InlineOnly, / Only merge empty functions. / </p><div class="fragment"><div class="line"><span class="comment">///   void f() {}</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   void f2() {</span></div>
<div class="line"><span class="comment">///     bar2();</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SFS_Empty, / Only merge functions defined inside a class. Implies "empty". / </p><div class="fragment"><div class="line"><span class="comment">///   class Foo {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     void f() { foo(); }</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///   void f() {</span></div>
<div class="line"><span class="comment">///     foo();</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///   void f() {}</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SFS_Inline, / Merge all functions fitting on a single line. / </p><div class="fragment"><div class="line"><span class="comment">///   class Foo {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     void f() { foo(); }</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///   void f() { bar(); }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SFS_All, };</p>
<p>/ Dependent on the value, <code>int f() { return 0; }</code> can be put on a / single line. ShortFunctionStyle AllowShortFunctionsOnASingleLine;</p>
<p>/ Different styles for handling short if lines enum ShortIfStyle : unsigned char { / Never put short ifs on the same line. / </p><div class="fragment"><div class="line"><span class="comment">///   if (a)</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     return ;</span></div>
<div class="line"><span class="comment">///   else {</span></div>
<div class="line"><span class="comment">///     return;</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SIS_Never, / Without else put short ifs on the same line only if / the else is not a compound statement. / </p><div class="fragment"><div class="line"><span class="comment">///   if (a) return;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   else</span></div>
<div class="line"><span class="comment">///     return;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SIS_WithoutElse, / Always put short ifs on the same line if / the else is not a compound statement or not. / </p><div class="fragment"><div class="line"><span class="comment">///   if (a) return;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   else {</span></div>
<div class="line"><span class="comment">///     return;</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SIS_Always, };</p>
<p>/ If <code>true</code>, <code>if (a) return;</code> can be put on a single line. ShortIfStyle AllowShortIfStatementsOnASingleLine;</p>
<p>/ Different styles for merging short lambdas containing at most one / statement. enum ShortLambdaStyle : unsigned char { / Never merge lambdas into a single line. SLS_None, / Only merge empty lambdas. / </p><div class="fragment"><div class="line"><span class="comment">///   auto lambda = [](int a) {}</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   auto lambda2 = [](int a) {</span></div>
<div class="line"><span class="comment">///       return a;</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SLS_Empty, / Merge lambda into a single line if argument of a function. / </p><div class="fragment"><div class="line"><span class="comment">///   auto lambda = [](int a) {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///       return a;</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///   sort(a.begin(), a.end(), ()[] { return x &lt; y; })</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SLS_Inline, / Merge all lambdas fitting on a single line. / </p><div class="fragment"><div class="line"><span class="comment">///   auto lambda = [](int a) {}</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   auto lambda2 = [](int a) { return a; };</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SLS_All, };</p>
<p>/ Dependent on the value, <code>auto lambda []() { return 0; }</code> can be put on a / single line. ShortLambdaStyle AllowShortLambdasOnASingleLine;</p>
<p>/ If <code>true</code>, <code>while (true) continue;</code> can be put on a single / line. bool AllowShortLoopsOnASingleLine;</p>
<p>/ Different ways to break after the function definition return type. / This option is <b>deprecated</b> and is retained for backwards compatibility. enum DefinitionReturnTypeBreakingStyle : unsigned char { / Break after return type automatically. / <code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account. DRTBS_None, / Always break after the return type. DRTBS_All, / Always break after the return types of top-level functions. DRTBS_TopLevel, };</p>
<p>/ Different ways to break after the function definition or / declaration return type. enum ReturnTypeBreakingStyle : unsigned char { / Break after return type automatically. / <code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account. / </p><div class="fragment"><div class="line"><span class="comment">///   class A {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     int f() { return 0; };</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///   int f();</span></div>
<div class="line"><span class="comment">///   int f() { return 1; }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> RTBS_None, / Always break after the return type. / </p><div class="fragment"><div class="line"><span class="comment">///   class A {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     int</span></div>
<div class="line"><span class="comment">///     f() {</span></div>
<div class="line"><span class="comment">///       return 0;</span></div>
<div class="line"><span class="comment">///     };</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///   int</span></div>
<div class="line"><span class="comment">///   f();</span></div>
<div class="line"><span class="comment">///   int</span></div>
<div class="line"><span class="comment">///   f() {</span></div>
<div class="line"><span class="comment">///     return 1;</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> RTBS_All, / Always break after the return types of top-level functions. / </p><div class="fragment"><div class="line"><span class="comment">///   class A {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     int f() { return 0; };</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///   int</span></div>
<div class="line"><span class="comment">///   f();</span></div>
<div class="line"><span class="comment">///   int</span></div>
<div class="line"><span class="comment">///   f() {</span></div>
<div class="line"><span class="comment">///     return 1;</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> RTBS_TopLevel, / Always break after the return type of function definitions. / </p><div class="fragment"><div class="line"><span class="comment">///   class A {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     int</span></div>
<div class="line"><span class="comment">///     f() {</span></div>
<div class="line"><span class="comment">///       return 0;</span></div>
<div class="line"><span class="comment">///     };</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///   int f();</span></div>
<div class="line"><span class="comment">///   int</span></div>
<div class="line"><span class="comment">///   f() {</span></div>
<div class="line"><span class="comment">///     return 1;</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> RTBS_AllDefinitions, / Always break after the return type of top-level definitions. / </p><div class="fragment"><div class="line"><span class="comment">///   class A {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     int f() { return 0; };</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///   int f();</span></div>
<div class="line"><span class="comment">///   int</span></div>
<div class="line"><span class="comment">///   f() {</span></div>
<div class="line"><span class="comment">///     return 1;</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> RTBS_TopLevelDefinitions, };</p>
<p>/ The function definition return type breaking style to use. This / option is <b>deprecated</b> and is retained for backwards compatibility. DefinitionReturnTypeBreakingStyle AlwaysBreakAfterDefinitionReturnType;</p>
<p>/ The function declaration return type breaking style to use. ReturnTypeBreakingStyle AlwaysBreakAfterReturnType;</p>
<p>/ If <code>true</code>, always break before multiline string literals. / / This flag is mean to make cases where there are multiple multiline strings / in a file look more consistent. Thus, it will only take effect if wrapping / the string at that point leads to it being indented / <code>ContinuationIndentWidth</code> spaces from the start of the line. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    aaaa =                         vs.     aaaa = &quot;bbbb&quot;</span></div>
<div class="line"><span class="comment">///        &quot;bbbb&quot;                                    &quot;cccc&quot;;</span></div>
<div class="line"><span class="comment">///        &quot;cccc&quot;;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool AlwaysBreakBeforeMultilineStrings;</p>
<p>/ Different ways to break after the template declaration. enum BreakTemplateDeclarationsStyle : unsigned char { / Do not force break before declaration. / <code>PenaltyBreakTemplateDeclaration</code> is taken into account. / </p><div class="fragment"><div class="line"><span class="comment">///    template &lt;typename T&gt; T foo() {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment">///    template &lt;typename T&gt; T foo(int aaaaaaaaaaaaaaaaaaaaa,</span></div>
<div class="line"><span class="comment">///                                int bbbbbbbbbbbbbbbbbbbbb) {</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BTDS_No, / Force break after template declaration only when the following / declaration spans multiple lines. / </p><div class="fragment"><div class="line"><span class="comment">///    template &lt;typename T&gt; T foo() {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment">///    template &lt;typename T&gt;</span></div>
<div class="line"><span class="comment">///    T foo(int aaaaaaaaaaaaaaaaaaaaa,</span></div>
<div class="line"><span class="comment">///          int bbbbbbbbbbbbbbbbbbbbb) {</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BTDS_MultiLine, / Always break after template declaration. / </p><div class="fragment"><div class="line"><span class="comment">///    template &lt;typename T&gt;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    T foo() {</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment">///    template &lt;typename T&gt;</span></div>
<div class="line"><span class="comment">///    T foo(int aaaaaaaaaaaaaaaaaaaaa,</span></div>
<div class="line"><span class="comment">///          int bbbbbbbbbbbbbbbbbbbbb) {</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BTDS_Yes };</p>
<p>/ The template declaration breaking style to use. BreakTemplateDeclarationsStyle AlwaysBreakTemplateDeclarations;</p>
<p>/ A vector of strings that should be interpreted as attributes/qualifiers / instead of identifiers. This can be useful for language extensions or / static analyzer annotations. / / For example: / </p><div class="fragment"><div class="line"><span class="comment">///   x = (char *__capability)&amp;y;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   int function(void) __ununsed;</span></div>
<div class="line"><span class="comment">///   void only_writes_to_buffer(char *__output buffer);</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / In the .clang-format configuration file, this can be configured like: / </p><div class="fragment"><div class="line">///   AttributeMacros: [&#39;__capability&#39;, &#39;__output&#39;, &#39;__ununsed&#39;]</div>
<div class="line">/// </div>
</div><!-- fragment --><p> / std::vector&lt;std::string&gt; AttributeMacros;</p>
<p>/ If <code>false</code>, a function call's arguments will either be all on the / same line or will have one line each. / </p><div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   void f() {</span></div>
<div class="line"><span class="comment">///     f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,</span></div>
<div class="line"><span class="comment">///       aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   void f() {</span></div>
<div class="line"><span class="comment">///     f(aaaaaaaaaaaaaaaaaaaa,</span></div>
<div class="line"><span class="comment">///       aaaaaaaaaaaaaaaaaaaa,</span></div>
<div class="line"><span class="comment">///       aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool BinPackArguments;</p>
<p>/ The style of inserting trailing commas into container literals. enum TrailingCommaStyle : unsigned char { / Do not insert trailing commas. TCS_None, / Insert trailing commas in container literals that were wrapped over / multiple lines. Note that this is conceptually incompatible with / bin-packing, because the trailing comma is used as an indicator / that a container should be formatted one-per-line (i.e. not bin-packed). / So inserting a trailing comma counteracts bin-packing. TCS_Wrapped, };</p>
<p>/ If set to <code>TCS_Wrapped</code> will insert trailing commas in container / literals (arrays and objects) that wrap across multiple lines. / It is currently only available for JavaScript / and disabled by default <code>TCS_None</code>. / <code>InsertTrailingCommas</code> cannot be used together with <code>BinPackArguments</code> / as inserting the comma disables bin-packing. / </p><div class="fragment"><div class="line"><span class="comment">///   TSC_Wrapped:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   const someArray = [</span></div>
<div class="line"><span class="comment">///   aaaaaaaaaaaaaaaaaaaaaaaaaa,</span></div>
<div class="line"><span class="comment">///   aaaaaaaaaaaaaaaaaaaaaaaaaa,</span></div>
<div class="line"><span class="comment">///   aaaaaaaaaaaaaaaaaaaaaaaaaa,</span></div>
<div class="line"><span class="comment">///   //                        ^ inserted</span></div>
<div class="line"><span class="comment">///   ]</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> TrailingCommaStyle InsertTrailingCommas;</p>
<p>/ If <code>false</code>, a function declaration's or function definition's / parameters will either all be on the same line or will have one line each. / </p><div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,</span></div>
<div class="line"><span class="comment">///          int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   void f(int aaaaaaaaaaaaaaaaaaaa,</span></div>
<div class="line"><span class="comment">///          int aaaaaaaaaaaaaaaaaaaa,</span></div>
<div class="line"><span class="comment">///          int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool BinPackParameters;</p>
<p>/ The style of wrapping parameters on the same line (bin-packed) or / on one line each. enum BinPackStyle : unsigned char { / Automatically determine parameter bin-packing behavior. BPS_Auto, / Always bin-pack parameters. BPS_Always, / Never bin-pack parameters. BPS_Never, };</p>
<p>/ The style of breaking before or after binary operators. enum BinaryOperatorStyle : unsigned char { / Break after operators. / </p><div class="fragment"><div class="line"><span class="comment">///    LooooooooooongType loooooooooooooooooooooongVariable =</span><span class="comment"></span></div>
<div class="line"><span class="comment">///        someLooooooooooooooooongFunction();</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +</span></div>
<div class="line"><span class="comment">///                         aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==</span></div>
<div class="line"><span class="comment">///                     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &amp;&amp;</span></div>
<div class="line"><span class="comment">///                 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &gt;</span></div>
<div class="line"><span class="comment">///                     ccccccccccccccccccccccccccccccccccccccccc;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BOS_None, / Break before operators that aren't assignments. / </p><div class="fragment"><div class="line"><span class="comment">///    LooooooooooongType loooooooooooooooooooooongVariable =</span><span class="comment"></span></div>
<div class="line"><span class="comment">///        someLooooooooooooooooongFunction();</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span></div>
<div class="line"><span class="comment">///                         + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span></div>
<div class="line"><span class="comment">///                     == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span></div>
<div class="line"><span class="comment">///                 &amp;&amp; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span></div>
<div class="line"><span class="comment">///                        &gt; ccccccccccccccccccccccccccccccccccccccccc;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BOS_NonAssignment, / Break before operators. / </p><div class="fragment"><div class="line"><span class="comment">///    LooooooooooongType loooooooooooooooooooooongVariable</span><span class="comment"></span></div>
<div class="line"><span class="comment">///        = someLooooooooooooooooongFunction();</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span></div>
<div class="line"><span class="comment">///                         + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span></div>
<div class="line"><span class="comment">///                     == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span></div>
<div class="line"><span class="comment">///                 &amp;&amp; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span></div>
<div class="line"><span class="comment">///                        &gt; ccccccccccccccccccccccccccccccccccccccccc;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BOS_All, };</p>
<p>/ The way to wrap binary operators. BinaryOperatorStyle BreakBeforeBinaryOperators;</p>
<p>/ Different ways to attach braces to their surrounding context. enum BraceBreakingStyle : unsigned char { / Always attach braces to surrounding context. / </p><div class="fragment"><div class="line"><span class="comment">///   namespace N {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   enum E {</span></div>
<div class="line"><span class="comment">///     E1,</span></div>
<div class="line"><span class="comment">///     E2,</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   class C {</span></div>
<div class="line"><span class="comment">///   public:</span></div>
<div class="line"><span class="comment">///     C();</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   bool baz(int i) {</span></div>
<div class="line"><span class="comment">///     try {</span></div>
<div class="line"><span class="comment">///       do {</span></div>
<div class="line"><span class="comment">///         switch (i) {</span></div>
<div class="line"><span class="comment">///         case 1: {</span></div>
<div class="line"><span class="comment">///           foobar();</span></div>
<div class="line"><span class="comment">///           break;</span></div>
<div class="line"><span class="comment">///         }</span></div>
<div class="line"><span class="comment">///         default: {</span></div>
<div class="line"><span class="comment">///           break;</span></div>
<div class="line"><span class="comment">///         }</span></div>
<div class="line"><span class="comment">///         }</span></div>
<div class="line"><span class="comment">///       } while (--i);</span></div>
<div class="line"><span class="comment">///       return true;</span></div>
<div class="line"><span class="comment">///     } catch (...) {</span></div>
<div class="line"><span class="comment">///       handleError();</span></div>
<div class="line"><span class="comment">///       return false;</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   void foo(bool b) {</span></div>
<div class="line"><span class="comment">///     if (b) {</span></div>
<div class="line"><span class="comment">///       baz(2);</span></div>
<div class="line"><span class="comment">///     } else {</span></div>
<div class="line"><span class="comment">///       baz(5);</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   void bar() { foo(true); }</span></div>
<div class="line"><span class="comment">///   } // namespace N</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BS_Attach, / Like <code>Attach</code>, but break before braces on function, namespace and / class definitions. / </p><div class="fragment"><div class="line"><span class="comment">///   namespace N</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///   enum E {</span></div>
<div class="line"><span class="comment">///     E1,</span></div>
<div class="line"><span class="comment">///     E2,</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   class C</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///   public:</span></div>
<div class="line"><span class="comment">///     C();</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   bool baz(int i)</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     try {</span></div>
<div class="line"><span class="comment">///       do {</span></div>
<div class="line"><span class="comment">///         switch (i) {</span></div>
<div class="line"><span class="comment">///         case 1: {</span></div>
<div class="line"><span class="comment">///           foobar();</span></div>
<div class="line"><span class="comment">///           break;</span></div>
<div class="line"><span class="comment">///         }</span></div>
<div class="line"><span class="comment">///         default: {</span></div>
<div class="line"><span class="comment">///           break;</span></div>
<div class="line"><span class="comment">///         }</span></div>
<div class="line"><span class="comment">///         }</span></div>
<div class="line"><span class="comment">///       } while (--i);</span></div>
<div class="line"><span class="comment">///       return true;</span></div>
<div class="line"><span class="comment">///     } catch (...) {</span></div>
<div class="line"><span class="comment">///       handleError();</span></div>
<div class="line"><span class="comment">///       return false;</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   void foo(bool b)</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     if (b) {</span></div>
<div class="line"><span class="comment">///       baz(2);</span></div>
<div class="line"><span class="comment">///     } else {</span></div>
<div class="line"><span class="comment">///       baz(5);</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   void bar() { foo(true); }</span></div>
<div class="line"><span class="comment">///   } // namespace N</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BS_Linux, / Like <code>Attach</code>, but break before braces on enum, function, and record / definitions. / </p><div class="fragment"><div class="line"><span class="comment">///   namespace N {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   enum E</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     E1,</span></div>
<div class="line"><span class="comment">///     E2,</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   class C</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///   public:</span></div>
<div class="line"><span class="comment">///     C();</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   bool baz(int i)</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     try {</span></div>
<div class="line"><span class="comment">///       do {</span></div>
<div class="line"><span class="comment">///         switch (i) {</span></div>
<div class="line"><span class="comment">///         case 1: {</span></div>
<div class="line"><span class="comment">///           foobar();</span></div>
<div class="line"><span class="comment">///           break;</span></div>
<div class="line"><span class="comment">///         }</span></div>
<div class="line"><span class="comment">///         default: {</span></div>
<div class="line"><span class="comment">///           break;</span></div>
<div class="line"><span class="comment">///         }</span></div>
<div class="line"><span class="comment">///         }</span></div>
<div class="line"><span class="comment">///       } while (--i);</span></div>
<div class="line"><span class="comment">///       return true;</span></div>
<div class="line"><span class="comment">///     } catch (...) {</span></div>
<div class="line"><span class="comment">///       handleError();</span></div>
<div class="line"><span class="comment">///       return false;</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   void foo(bool b)</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     if (b) {</span></div>
<div class="line"><span class="comment">///       baz(2);</span></div>
<div class="line"><span class="comment">///     } else {</span></div>
<div class="line"><span class="comment">///       baz(5);</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   void bar() { foo(true); }</span></div>
<div class="line"><span class="comment">///   } // namespace N</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BS_Mozilla, / Like <code>Attach</code>, but break before function definitions, <code>catch</code>, and / <code>else</code>. / </p><div class="fragment"><div class="line"><span class="comment">///   namespace N {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   enum E {</span></div>
<div class="line"><span class="comment">///     E1,</span></div>
<div class="line"><span class="comment">///     E2,</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   class C {</span></div>
<div class="line"><span class="comment">///   public:</span></div>
<div class="line"><span class="comment">///     C();</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   bool baz(int i)</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     try {</span></div>
<div class="line"><span class="comment">///       do {</span></div>
<div class="line"><span class="comment">///         switch (i) {</span></div>
<div class="line"><span class="comment">///         case 1: {</span></div>
<div class="line"><span class="comment">///           foobar();</span></div>
<div class="line"><span class="comment">///           break;</span></div>
<div class="line"><span class="comment">///         }</span></div>
<div class="line"><span class="comment">///         default: {</span></div>
<div class="line"><span class="comment">///           break;</span></div>
<div class="line"><span class="comment">///         }</span></div>
<div class="line"><span class="comment">///         }</span></div>
<div class="line"><span class="comment">///       } while (--i);</span></div>
<div class="line"><span class="comment">///       return true;</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///     catch (...) {</span></div>
<div class="line"><span class="comment">///       handleError();</span></div>
<div class="line"><span class="comment">///       return false;</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   void foo(bool b)</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     if (b) {</span></div>
<div class="line"><span class="comment">///       baz(2);</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///     else {</span></div>
<div class="line"><span class="comment">///       baz(5);</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   void bar() { foo(true); }</span></div>
<div class="line"><span class="comment">///   } // namespace N</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BS_Stroustrup, / Always break before braces. / </p><div class="fragment"><div class="line"><span class="comment">///   namespace N</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///   enum E</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     E1,</span></div>
<div class="line"><span class="comment">///     E2,</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   class C</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///   public:</span></div>
<div class="line"><span class="comment">///     C();</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   bool baz(int i)</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     try</span></div>
<div class="line"><span class="comment">///     {</span></div>
<div class="line"><span class="comment">///       do</span></div>
<div class="line"><span class="comment">///       {</span></div>
<div class="line"><span class="comment">///         switch (i)</span></div>
<div class="line"><span class="comment">///         {</span></div>
<div class="line"><span class="comment">///         case 1:</span></div>
<div class="line"><span class="comment">///         {</span></div>
<div class="line"><span class="comment">///           foobar();</span></div>
<div class="line"><span class="comment">///           break;</span></div>
<div class="line"><span class="comment">///         }</span></div>
<div class="line"><span class="comment">///         default:</span></div>
<div class="line"><span class="comment">///         {</span></div>
<div class="line"><span class="comment">///           break;</span></div>
<div class="line"><span class="comment">///         }</span></div>
<div class="line"><span class="comment">///         }</span></div>
<div class="line"><span class="comment">///       } while (--i);</span></div>
<div class="line"><span class="comment">///       return true;</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///     catch (...)</span></div>
<div class="line"><span class="comment">///     {</span></div>
<div class="line"><span class="comment">///       handleError();</span></div>
<div class="line"><span class="comment">///       return false;</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   void foo(bool b)</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     if (b)</span></div>
<div class="line"><span class="comment">///     {</span></div>
<div class="line"><span class="comment">///       baz(2);</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///     else</span></div>
<div class="line"><span class="comment">///     {</span></div>
<div class="line"><span class="comment">///       baz(5);</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   void bar() { foo(true); }</span></div>
<div class="line"><span class="comment">///   } // namespace N</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BS_Allman, / Like <code>Allman</code> but always indent braces and line up code with braces. / </p><div class="fragment"><div class="line"><span class="comment">///   namespace N</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     {</span></div>
<div class="line"><span class="comment">///   enum E</span></div>
<div class="line"><span class="comment">///     {</span></div>
<div class="line"><span class="comment">///     E1,</span></div>
<div class="line"><span class="comment">///     E2,</span></div>
<div class="line"><span class="comment">///     };</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   class C</span></div>
<div class="line"><span class="comment">///     {</span></div>
<div class="line"><span class="comment">///   public:</span></div>
<div class="line"><span class="comment">///     C();</span></div>
<div class="line"><span class="comment">///     };</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   bool baz(int i)</span></div>
<div class="line"><span class="comment">///     {</span></div>
<div class="line"><span class="comment">///     try</span></div>
<div class="line"><span class="comment">///       {</span></div>
<div class="line"><span class="comment">///       do</span></div>
<div class="line"><span class="comment">///         {</span></div>
<div class="line"><span class="comment">///         switch (i)</span></div>
<div class="line"><span class="comment">///           {</span></div>
<div class="line"><span class="comment">///           case 1:</span></div>
<div class="line"><span class="comment">///           {</span></div>
<div class="line"><span class="comment">///           foobar();</span></div>
<div class="line"><span class="comment">///           break;</span></div>
<div class="line"><span class="comment">///           }</span></div>
<div class="line"><span class="comment">///           default:</span></div>
<div class="line"><span class="comment">///           {</span></div>
<div class="line"><span class="comment">///           break;</span></div>
<div class="line"><span class="comment">///           }</span></div>
<div class="line"><span class="comment">///           }</span></div>
<div class="line"><span class="comment">///         } while (--i);</span></div>
<div class="line"><span class="comment">///       return true;</span></div>
<div class="line"><span class="comment">///       }</span></div>
<div class="line"><span class="comment">///     catch (...)</span></div>
<div class="line"><span class="comment">///       {</span></div>
<div class="line"><span class="comment">///       handleError();</span></div>
<div class="line"><span class="comment">///       return false;</span></div>
<div class="line"><span class="comment">///       }</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   void foo(bool b)</span></div>
<div class="line"><span class="comment">///     {</span></div>
<div class="line"><span class="comment">///     if (b)</span></div>
<div class="line"><span class="comment">///       {</span></div>
<div class="line"><span class="comment">///       baz(2);</span></div>
<div class="line"><span class="comment">///       }</span></div>
<div class="line"><span class="comment">///     else</span></div>
<div class="line"><span class="comment">///       {</span></div>
<div class="line"><span class="comment">///       baz(5);</span></div>
<div class="line"><span class="comment">///       }</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   void bar() { foo(true); }</span></div>
<div class="line"><span class="comment">///     } // namespace N</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BS_Whitesmiths, / Always break before braces and add an extra level of indentation to / braces of control statements, not to those of class, function / or other definitions. / </p><div class="fragment"><div class="line"><span class="comment">///   namespace N</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///   enum E</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     E1,</span></div>
<div class="line"><span class="comment">///     E2,</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   class C</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///   public:</span></div>
<div class="line"><span class="comment">///     C();</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   bool baz(int i)</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     try</span></div>
<div class="line"><span class="comment">///       {</span></div>
<div class="line"><span class="comment">///         do</span></div>
<div class="line"><span class="comment">///           {</span></div>
<div class="line"><span class="comment">///             switch (i)</span></div>
<div class="line"><span class="comment">///               {</span></div>
<div class="line"><span class="comment">///               case 1:</span></div>
<div class="line"><span class="comment">///                 {</span></div>
<div class="line"><span class="comment">///                   foobar();</span></div>
<div class="line"><span class="comment">///                   break;</span></div>
<div class="line"><span class="comment">///                 }</span></div>
<div class="line"><span class="comment">///               default:</span></div>
<div class="line"><span class="comment">///                 {</span></div>
<div class="line"><span class="comment">///                   break;</span></div>
<div class="line"><span class="comment">///                 }</span></div>
<div class="line"><span class="comment">///               }</span></div>
<div class="line"><span class="comment">///           }</span></div>
<div class="line"><span class="comment">///         while (--i);</span></div>
<div class="line"><span class="comment">///         return true;</span></div>
<div class="line"><span class="comment">///       }</span></div>
<div class="line"><span class="comment">///     catch (...)</span></div>
<div class="line"><span class="comment">///       {</span></div>
<div class="line"><span class="comment">///         handleError();</span></div>
<div class="line"><span class="comment">///         return false;</span></div>
<div class="line"><span class="comment">///       }</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   void foo(bool b)</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     if (b)</span></div>
<div class="line"><span class="comment">///       {</span></div>
<div class="line"><span class="comment">///         baz(2);</span></div>
<div class="line"><span class="comment">///       }</span></div>
<div class="line"><span class="comment">///     else</span></div>
<div class="line"><span class="comment">///       {</span></div>
<div class="line"><span class="comment">///         baz(5);</span></div>
<div class="line"><span class="comment">///       }</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   void bar() { foo(true); }</span></div>
<div class="line"><span class="comment">///   } // namespace N</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BS_GNU, / Like <code>Attach</code>, but break before functions. / </p><div class="fragment"><div class="line"><span class="comment">///   namespace N {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   enum E {</span></div>
<div class="line"><span class="comment">///     E1,</span></div>
<div class="line"><span class="comment">///     E2,</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   class C {</span></div>
<div class="line"><span class="comment">///   public:</span></div>
<div class="line"><span class="comment">///     C();</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   bool baz(int i)</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     try {</span></div>
<div class="line"><span class="comment">///       do {</span></div>
<div class="line"><span class="comment">///         switch (i) {</span></div>
<div class="line"><span class="comment">///         case 1: {</span></div>
<div class="line"><span class="comment">///           foobar();</span></div>
<div class="line"><span class="comment">///           break;</span></div>
<div class="line"><span class="comment">///         }</span></div>
<div class="line"><span class="comment">///         default: {</span></div>
<div class="line"><span class="comment">///           break;</span></div>
<div class="line"><span class="comment">///         }</span></div>
<div class="line"><span class="comment">///         }</span></div>
<div class="line"><span class="comment">///       } while (--i);</span></div>
<div class="line"><span class="comment">///       return true;</span></div>
<div class="line"><span class="comment">///     } catch (...) {</span></div>
<div class="line"><span class="comment">///       handleError();</span></div>
<div class="line"><span class="comment">///       return false;</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   void foo(bool b)</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     if (b) {</span></div>
<div class="line"><span class="comment">///       baz(2);</span></div>
<div class="line"><span class="comment">///     } else {</span></div>
<div class="line"><span class="comment">///       baz(5);</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   void bar() { foo(true); }</span></div>
<div class="line"><span class="comment">///   } // namespace N</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BS_WebKit, / Configure each individual brace in <code>BraceWrapping</code>. BS_Custom };</p>
<p>/ The brace breaking style to use. BraceBreakingStyle BreakBeforeBraces;</p>
<p>/ Different ways to wrap braces after control statements. enum BraceWrappingAfterControlStatementStyle : unsigned char { / Never wrap braces after a control statement. / </p><div class="fragment"><div class="line"><span class="comment">///   if (foo()) {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   } else {</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///   for (int i = 0; i &lt; 10; ++i) {</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BWACS_Never, / Only wrap braces after a multi-line control statement. / </p><div class="fragment"><div class="line"><span class="comment">///   if (foo &amp;&amp; bar &amp;&amp;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///       baz)</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     quux();</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///   while (foo || bar) {</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BWACS_MultiLine, / Always wrap braces after a control statement. / </p><div class="fragment"><div class="line"><span class="comment">///   if (foo())</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///   } else</span></div>
<div class="line"><span class="comment">///   {}</span></div>
<div class="line"><span class="comment">///   for (int i = 0; i &lt; 10; ++i)</span></div>
<div class="line"><span class="comment">///   {}</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BWACS_Always };</p>
<p>/ Precise control over the wrapping of braces. / </p><div class="fragment"><div class="line"><span class="comment">///   # Should be declared this way:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   BreakBeforeBraces: Custom</span></div>
<div class="line"><span class="comment">///   BraceWrapping:</span></div>
<div class="line"><span class="comment">///       AfterClass: true</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> struct BraceWrappingFlags { / Wrap case labels. / </p><div class="fragment"><div class="line"><span class="comment">///   false:                                true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   switch (foo) {                vs.     switch (foo) {</span></div>
<div class="line"><span class="comment">///     case 1: {                             case 1:</span></div>
<div class="line"><span class="comment">///       bar();                              {</span></div>
<div class="line"><span class="comment">///       break;                                bar();</span></div>
<div class="line"><span class="comment">///     }                                       break;</span></div>
<div class="line"><span class="comment">///     default: {                            }</span></div>
<div class="line"><span class="comment">///       plop();                             default:</span></div>
<div class="line"><span class="comment">///     }                                     {</span></div>
<div class="line"><span class="comment">///   }                                         plop();</span></div>
<div class="line"><span class="comment">///                                           }</span></div>
<div class="line"><span class="comment">///                                         }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool AfterCaseLabel; / Wrap class definitions. / </p><div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   class foo {};</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   class foo</span></div>
<div class="line"><span class="comment">///   {};</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool AfterClass;</p>
<p>/ Wrap control statements (<code>if</code>/<code>for</code>/<code>while</code>/<code>switch</code>/..). BraceWrappingAfterControlStatementStyle AfterControlStatement; / Wrap enum definitions. / </p><div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   enum X : int</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     B</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   enum X : int { B };</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool AfterEnum; / Wrap function definitions. / </p><div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   void foo()</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     bar();</span></div>
<div class="line"><span class="comment">///     bar2();</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   void foo() {</span></div>
<div class="line"><span class="comment">///     bar();</span></div>
<div class="line"><span class="comment">///     bar2();</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool AfterFunction; / Wrap namespace definitions. / </p><div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   namespace</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///   int foo();</span></div>
<div class="line"><span class="comment">///   int bar();</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   namespace {</span></div>
<div class="line"><span class="comment">///   int foo();</span></div>
<div class="line"><span class="comment">///   int bar();</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool AfterNamespace; / Wrap ObjC definitions (interfaces, implementations...). / </p><dl class="section note"><dt>Note</dt><dd>@autoreleasepool and @synchronized blocks are wrapped / according to <code>AfterControlStatement</code> flag. bool AfterObjCDeclaration; / Wrap struct definitions. / <div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   struct foo</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     int x;</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   struct foo {</span></div>
<div class="line"><span class="comment">///     int x;</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --> bool AfterStruct; / Wrap union definitions. / <div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   union foo</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     int x;</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   union foo {</span></div>
<div class="line"><span class="comment">///     int x;</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --> bool AfterUnion; / Wrap extern blocks. / <div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   extern &quot;C&quot;</span></div>
<div class="line"><span class="comment">///   {</span></div>
<div class="line"><span class="comment">///     int foo();</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   extern &quot;C&quot; {</span></div>
<div class="line"><span class="comment">///   int foo();</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --> bool AfterExternBlock; // Partially superseded by IndentExternBlock / Wrap before <code>catch</code>. / <div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   try {</span></div>
<div class="line"><span class="comment">///     foo();</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///   catch () {</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   try {</span></div>
<div class="line"><span class="comment">///     foo();</span></div>
<div class="line"><span class="comment">///   } catch () {</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --> bool BeforeCatch; / Wrap before <code>else</code>. / <div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   if (foo()) {</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///   else {</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   if (foo()) {</span></div>
<div class="line"><span class="comment">///   } else {</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --> bool BeforeElse; / Wrap lambda block. / <div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   connect(</span></div>
<div class="line"><span class="comment">///     []()</span></div>
<div class="line"><span class="comment">///     {</span></div>
<div class="line"><span class="comment">///       foo();</span></div>
<div class="line"><span class="comment">///       bar();</span></div>
<div class="line"><span class="comment">///     });</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   connect([]() {</span></div>
<div class="line"><span class="comment">///     foo();</span></div>
<div class="line"><span class="comment">///     bar();</span></div>
<div class="line"><span class="comment">///   });</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --> bool BeforeLambdaBody; / Wrap before <code>while</code>. / <div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   do {</span></div>
<div class="line"><span class="comment">///     foo();</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///   while (1);</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   do {</span></div>
<div class="line"><span class="comment">///     foo();</span></div>
<div class="line"><span class="comment">///   } while (1);</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --> bool BeforeWhile; / Indent the wrapped braces themselves. bool IndentBraces; / If <code>false</code>, empty function body can be put on a single line. / This option is used only if the opening brace of the function has / already been wrapped, i.e. the <code>AfterFunction</code> brace wrapping mode is / set, and the function could/should not be put on a single line (as per / <code>AllowShortFunctionsOnASingleLine</code> and constructor formatting options). / <div class="fragment"><div class="line"><span class="comment">///   int f()   vs.   int f()</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   {}              {</span></div>
<div class="line"><span class="comment">///                   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --> / bool SplitEmptyFunction; / If <code>false</code>, empty record (e.g. class, struct or union) body / can be put on a single line. This option is used only if the opening / brace of the record has already been wrapped, i.e. the <code>AfterClass</code> / (for classes) brace wrapping mode is set. / <div class="fragment"><div class="line"><span class="comment">///   class Foo   vs.  class Foo</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   {}               {</span></div>
<div class="line"><span class="comment">///                    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --> / bool SplitEmptyRecord; / If <code>false</code>, empty namespace body can be put on a single line. / This option is used only if the opening brace of the namespace has / already been wrapped, i.e. the <code>AfterNamespace</code> brace wrapping mode is / set. / <div class="fragment"><div class="line"><span class="comment">///   namespace Foo   vs.  namespace Foo</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   {}                   {</span></div>
<div class="line"><span class="comment">///                        }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --> / bool SplitEmptyNamespace; };</dd></dl>
<p>/ Control of individual brace wrapping cases. / / If <code>BreakBeforeBraces</code> is set to <code>BS_Custom</code>, use this to specify how / each individual brace case should be handled. Otherwise, this is ignored. / </p><div class="fragment"><div class="line">///   # Example of usage:</div>
<div class="line">///   BreakBeforeBraces: Custom</div>
<div class="line">///   BraceWrapping:</div>
<div class="line">///     AfterEnum: true</div>
<div class="line">///     AfterStruct: false</div>
<div class="line">///     SplitEmptyFunction: false</div>
<div class="line">/// </div>
</div><!-- fragment --><p> BraceWrappingFlags BraceWrapping;</p>
<p>/ If <code>true</code>, concept will be placed on a new line. / </p><div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    template&lt;typename T&gt;</span></div>
<div class="line"><span class="comment">///    concept ...</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///    template&lt;typename T&gt; concept ...</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool BreakBeforeConceptDeclarations;</p>
<p>/ If <code>true</code>, ternary operators will be placed after line breaks. / </p><div class="fragment"><div class="line"><span class="comment">///    true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription</span></div>
<div class="line"><span class="comment">///        ? firstValue</span></div>
<div class="line"><span class="comment">///        : SecondValueVeryVeryVeryVeryLong;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    false:</span></div>
<div class="line"><span class="comment">///    veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?</span></div>
<div class="line"><span class="comment">///        firstValue :</span></div>
<div class="line"><span class="comment">///        SecondValueVeryVeryVeryVeryLong;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool BreakBeforeTernaryOperators;</p>
<p>/ Different ways to break initializers. enum BreakConstructorInitializersStyle : unsigned char { / Break constructor initializers before the colon and after the commas. / </p><div class="fragment"><div class="line"><span class="comment">///    Constructor()</span><span class="comment"></span></div>
<div class="line"><span class="comment">///        : initializer1(),</span></div>
<div class="line"><span class="comment">///          initializer2()</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BCIS_BeforeColon, / Break constructor initializers before the colon and commas, and align / the commas with the colon. / </p><div class="fragment"><div class="line"><span class="comment">///    Constructor()</span><span class="comment"></span></div>
<div class="line"><span class="comment">///        : initializer1()</span></div>
<div class="line"><span class="comment">///        , initializer2()</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BCIS_BeforeComma, / Break constructor initializers after the colon and commas. / </p><div class="fragment"><div class="line"><span class="comment">///    Constructor() :</span><span class="comment"></span></div>
<div class="line"><span class="comment">///        initializer1(),</span></div>
<div class="line"><span class="comment">///        initializer2()</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BCIS_AfterColon };</p>
<p>/ The constructor initializers style to use. BreakConstructorInitializersStyle BreakConstructorInitializers;</p>
<p>/ Break after each annotation on a field in Java files. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    @Partial                       vs.     @Partial @Mock DataLoad loader;</span></div>
<div class="line"><span class="comment">///    @Mock</span></div>
<div class="line"><span class="comment">///    DataLoad loader;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool BreakAfterJavaFieldAnnotations;</p>
<p>/ Allow breaking string literals when formatting. / </p><div class="fragment"><div class="line"><span class="comment">///    true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    const char* x = &quot;veryVeryVeryVeryVeryVe&quot;</span></div>
<div class="line"><span class="comment">///                    &quot;ryVeryVeryVeryVeryVery&quot;</span></div>
<div class="line"><span class="comment">///                    &quot;VeryLongString&quot;;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    false:</span></div>
<div class="line"><span class="comment">///    const char* x =</span></div>
<div class="line"><span class="comment">///      &quot;veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString&quot;;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool BreakStringLiterals;</p>
<p>/ The column limit. / / A column limit of <code>0</code> means that there is no column limit. In this case, / clang-format will respect the input's line breaking decisions within / statements unless they contradict other rules. unsigned ColumnLimit;</p>
<p>/ A regular expression that describes comments with special meaning, / which should not be split into lines or otherwise changed. / </p><div class="fragment"><div class="line"><span class="comment">///    // CommentPragmas: &#39;^ FOOBAR pragma:&#39;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    // Will leave the following line unaffected</span></div>
<div class="line"><span class="comment">///    #include &lt;vector&gt; // FOOBAR pragma: keep</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> std::string CommentPragmas;</p>
<p>/ Different ways to break inheritance list. enum BreakInheritanceListStyle : unsigned char { / Break inheritance list before the colon and after the commas. / </p><div class="fragment"><div class="line"><span class="comment">///    class Foo</span><span class="comment"></span></div>
<div class="line"><span class="comment">///        : Base1,</span></div>
<div class="line"><span class="comment">///          Base2</span></div>
<div class="line"><span class="comment">///    {};</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BILS_BeforeColon, / Break inheritance list before the colon and commas, and align / the commas with the colon. / </p><div class="fragment"><div class="line"><span class="comment">///    class Foo</span><span class="comment"></span></div>
<div class="line"><span class="comment">///        : Base1</span></div>
<div class="line"><span class="comment">///        , Base2</span></div>
<div class="line"><span class="comment">///    {};</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BILS_BeforeComma, / Break inheritance list after the colon and commas. / </p><div class="fragment"><div class="line"><span class="comment">///    class Foo :</span><span class="comment"></span></div>
<div class="line"><span class="comment">///        Base1,</span></div>
<div class="line"><span class="comment">///        Base2</span></div>
<div class="line"><span class="comment">///    {};</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> BILS_AfterColon };</p>
<p>/ The inheritance list style to use. BreakInheritanceListStyle BreakInheritanceList;</p>
<p>/ If <code>true</code>, consecutive namespace declarations will be on the same / line. If <code>false</code>, each namespace is declared on a new line. / </p><div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   namespace Foo { namespace Bar {</span></div>
<div class="line"><span class="comment">///   }}</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   namespace Foo {</span></div>
<div class="line"><span class="comment">///   namespace Bar {</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / If it does not fit on a single line, the overflowing namespaces get / wrapped: / </p><div class="fragment"><div class="line"><span class="comment">///   namespace Foo { namespace Bar {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   namespace Extra {</span></div>
<div class="line"><span class="comment">///   }}}</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool CompactNamespaces;</p>
<p>clang-format off / If the constructor initializers don't fit on a line, put each / initializer on its own line. / </p><div class="fragment"><div class="line"><span class="comment">///   true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   SomeClass::Constructor()</span></div>
<div class="line"><span class="comment">///       : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {</span></div>
<div class="line"><span class="comment">///     return 0;</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   false:</span></div>
<div class="line"><span class="comment">///   SomeClass::Constructor()</span></div>
<div class="line"><span class="comment">///       : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa),</span></div>
<div class="line"><span class="comment">///         aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {</span></div>
<div class="line"><span class="comment">///     return 0;</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool ConstructorInitializerAllOnOneLineOrOnePerLine; clang-format on</p>
<p>/ The number of characters to use for indentation of constructor / initializer lists as well as inheritance lists. unsigned ConstructorInitializerIndentWidth;</p>
<p>/ Indent width for line continuations. / </p><div class="fragment"><div class="line"><span class="comment">///    ContinuationIndentWidth: 2</span><span class="comment"></span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    int i =         //  VeryVeryVeryVeryVeryLongComment</span></div>
<div class="line"><span class="comment">///      longFunction( // Again a long comment</span></div>
<div class="line"><span class="comment">///        arg);</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> unsigned ContinuationIndentWidth;</p>
<p>/ If <code>true</code>, format braced lists as best suited for C++11 braced / lists. / / Important differences: / - No spaces inside the braced list. / - No line break before the closing brace. / - Indentation with the continuation indent, not with the block indent. / / Fundamentally, C++11 braced lists are formatted exactly like function / calls would be formatted in their place. If the braced list follows a name / (e.g. a type or variable name), clang-format formats as if the <code>{}</code> were / the parentheses of a function call with that name. If there is no name, / a zero-length name is assumed. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    vector&lt;int&gt; x{1, 2, 3, 4};     vs.     vector&lt;int&gt; x{ 1, 2, 3, 4 };</span></div>
<div class="line"><span class="comment">///    vector&lt;T&gt; x{{}, {}, {}, {}};           vector&lt;T&gt; x{ {}, {}, {}, {} };</span></div>
<div class="line"><span class="comment">///    f(MyMap[{composite, key}]);            f(MyMap[{ composite, key }]);</span></div>
<div class="line"><span class="comment">///    new int[3]{1, 2, 3};                   new int[3]{ 1, 2, 3 };</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool Cpp11BracedListStyle;</p>
<p>/ Analyze the formatted file for the most used line ending (<code>\r\n</code> / or <code>\n</code>). <code>UseCRLF</code> is only used as a fallback if none can be derived. bool DeriveLineEnding;</p>
<p>/ If <code>true</code>, analyze the formatted file for the most common / alignment of <code>&amp;</code> and <code>*</code>. / Pointer and reference alignment styles are going to be updated according / to the preferences found in the file. / <code>PointerAlignment</code> is then used only as fallback. bool DerivePointerAlignment;</p>
<p>/ Disables formatting completely. bool DisableFormat;</p>
<p>/ Different styles for empty line before access modifiers. enum EmptyLineBeforeAccessModifierStyle : unsigned char { / Remove all empty lines before access modifiers. / </p><div class="fragment"><div class="line"><span class="comment">///   struct foo {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   private:</span></div>
<div class="line"><span class="comment">///     int i;</span></div>
<div class="line"><span class="comment">///   protected:</span></div>
<div class="line"><span class="comment">///     int j;</span></div>
<div class="line"><span class="comment">///     /* comment */</span></div>
<div class="line"><span class="comment">///   public:</span></div>
<div class="line"><span class="comment">///     foo() {}</span></div>
<div class="line"><span class="comment">///   private:</span></div>
<div class="line"><span class="comment">///   protected:</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> ELBAMS_Never, / Keep existing empty lines before access modifiers. ELBAMS_Leave, / Add empty line only when access modifier starts a new logical block. / Logical block is a group of one or more member fields or functions. / </p><div class="fragment"><div class="line"><span class="comment">///   struct foo {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   private:</span></div>
<div class="line"><span class="comment">///     int i;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   protected:</span></div>
<div class="line"><span class="comment">///     int j;</span></div>
<div class="line"><span class="comment">///     /* comment */</span></div>
<div class="line"><span class="comment">///   public:</span></div>
<div class="line"><span class="comment">///     foo() {}</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   private:</span></div>
<div class="line"><span class="comment">///   protected:</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> ELBAMS_LogicalBlock, / Always add empty line before access modifiers unless access modifier / is at the start of struct or class definition. / </p><div class="fragment"><div class="line"><span class="comment">///   struct foo {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   private:</span></div>
<div class="line"><span class="comment">///     int i;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   protected:</span></div>
<div class="line"><span class="comment">///     int j;</span></div>
<div class="line"><span class="comment">///     /* comment */</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   public:</span></div>
<div class="line"><span class="comment">///     foo() {}</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   private:</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   protected:</span></div>
<div class="line"><span class="comment">///   };</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> ELBAMS_Always, };</p>
<p>/ Defines in which cases to put empty line before access modifiers. EmptyLineBeforeAccessModifierStyle EmptyLineBeforeAccessModifier;</p>
<p>/ If <code>true</code>, clang-format detects whether function calls and / definitions are formatted with one parameter per line. / / Each call can be bin-packed, one-per-line or inconclusive. If it is / inconclusive, e.g. completely on one line, but a decision needs to be / made, clang-format analyzes whether there are other bin-packed cases in / the input file and act accordingly. / / NOTE: This is an experimental flag, that might go away or be renamed. Do / not use this in config files, etc. Use at your own risk. bool ExperimentalAutoDetectBinPacking;</p>
<p>/ If <code>true</code>, clang-format adds missing namespace end comments and / fixes invalid existing ones. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    namespace a {                  vs.     namespace a {</span></div>
<div class="line"><span class="comment">///    foo();                                 foo();</span></div>
<div class="line"><span class="comment">///    } // namespace a                       }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool FixNamespaceComments;</p>
<p>/ A vector of macros that should be interpreted as foreach loops / instead of as function calls. / / These are expected to be macros of the form: / </p><div class="fragment"><div class="line"><span class="comment">///   FOREACH(&lt;variable-declaration&gt;, ...)</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     &lt;loop-body&gt;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / In the .clang-format configuration file, this can be configured like: / </p><div class="fragment"><div class="line">///   ForEachMacros: [&#39;RANGES_FOR&#39;, &#39;FOREACH&#39;]</div>
<div class="line">/// </div>
</div><!-- fragment --><p> / / For example: BOOST_FOREACH. std::vector&lt;std::string&gt; ForEachMacros;</p>
<p>/ A vector of macros that should be interpreted as type declarations / instead of as function calls. / / These are expected to be macros of the form: / </p><div class="fragment"><div class="line"><span class="comment">///   STACK_OF(...)</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / In the .clang-format configuration file, this can be configured like: / </p><div class="fragment"><div class="line">///   TypenameMacros: [&#39;STACK_OF&#39;, &#39;LIST&#39;]</div>
<div class="line">/// </div>
</div><!-- fragment --><p> / / For example: OpenSSL STACK_OF, BSD LIST_ENTRY. std::vector&lt;std::string&gt; TypenameMacros;</p>
<p>/ A vector of macros that should be interpreted as complete / statements. / / Typical macros are expressions, and require a semi-colon to be / added; sometimes this is not the case, and this allows to make / clang-format aware of such cases. / / For example: Q_UNUSED std::vector&lt;std::string&gt; StatementMacros;</p>
<p>/ A vector of macros which are used to open namespace blocks. / / These are expected to be macros of the form: / </p><div class="fragment"><div class="line"><span class="comment">///   NAMESPACE(&lt;namespace-name&gt;, ...) {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     &lt;namespace-content&gt;</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / For example: TESTSUITE std::vector&lt;std::string&gt; NamespaceMacros;</p>
<p>/ A vector of macros which are whitespace-sensitive and should not / be touched. / / These are expected to be macros of the form: / </p><div class="fragment"><div class="line"><span class="comment">///   STRINGIZE(...)</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / In the .clang-format configuration file, this can be configured like: / </p><div class="fragment"><div class="line">///   WhitespaceSensitiveMacros: [&#39;STRINGIZE&#39;, &#39;PP_STRINGIZE&#39;]</div>
<div class="line">/// </div>
</div><!-- fragment --><p> / / For example: BOOST_PP_STRINGIZE std::vector&lt;std::string&gt; WhitespaceSensitiveMacros;</p>
<p><a class="el" href="structclang_1_1tooling_1_1IncludeStyle.html" title="Style for sorting and grouping C++ #include directives.">tooling::IncludeStyle</a> IncludeStyle;</p>
<p>/ Indent case labels one level from the switch statement. / / When <code>false</code>, use the same indentation level as for the switch / statement. Switch statement body is always indented one level more than / case labels (except the first block following the case label, which / itself indents the code - unless IndentCaseBlocks is enabled). / </p><div class="fragment"><div class="line"><span class="comment">///    false:                                 true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    switch (fool) {                vs.     switch (fool) {</span></div>
<div class="line"><span class="comment">///    case 1:                                  case 1:</span></div>
<div class="line"><span class="comment">///      bar();                                   bar();</span></div>
<div class="line"><span class="comment">///      break;                                   break;</span></div>
<div class="line"><span class="comment">///    default:                                 default:</span></div>
<div class="line"><span class="comment">///      plop();                                  plop();</span></div>
<div class="line"><span class="comment">///    }                                      }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool IndentCaseLabels;</p>
<p>/ Indent case label blocks one level from the case label. / / When <code>false</code>, the block following the case label uses the same / indentation level as for the case label, treating the case label the same / as an if-statement. / When <code>true</code>, the block gets indented as a scope block. / </p><div class="fragment"><div class="line"><span class="comment">///    false:                                 true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    switch (fool) {                vs.     switch (fool) {</span></div>
<div class="line"><span class="comment">///    case 1: {                              case 1:</span></div>
<div class="line"><span class="comment">///      bar();                                 {</span></div>
<div class="line"><span class="comment">///    } break;                                   bar();</span></div>
<div class="line"><span class="comment">///    default: {                               }</span></div>
<div class="line"><span class="comment">///      plop();                                break;</span></div>
<div class="line"><span class="comment">///    }                                      default:</span></div>
<div class="line"><span class="comment">///    }                                        {</span></div>
<div class="line"><span class="comment">///                                               plop();</span></div>
<div class="line"><span class="comment">///                                             }</span></div>
<div class="line"><span class="comment">///                                           }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool IndentCaseBlocks;</p>
<p>/ Indent goto labels. / / When <code>false</code>, goto labels are flushed left. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    int f() {                      vs.     int f() {</span></div>
<div class="line"><span class="comment">///      if (foo()) {                           if (foo()) {</span></div>
<div class="line"><span class="comment">///      label1:                              label1:</span></div>
<div class="line"><span class="comment">///        bar();                                 bar();</span></div>
<div class="line"><span class="comment">///      }                                      }</span></div>
<div class="line"><span class="comment">///    label2:                                label2:</span></div>
<div class="line"><span class="comment">///      return 1;                              return 1;</span></div>
<div class="line"><span class="comment">///    }                                      }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool IndentGotoLabels;</p>
<p>/ Options for indenting preprocessor directives. enum PPDirectiveIndentStyle : unsigned char { / Does not indent any directives. / </p><div class="fragment"><div class="line"><span class="comment">///    #if FOO</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    #if BAR</span></div>
<div class="line"><span class="comment">///    #include &lt;foo&gt;</span></div>
<div class="line"><span class="comment">///    #endif</span></div>
<div class="line"><span class="comment">///    #endif</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> PPDIS_None, / Indents directives after the hash. / </p><div class="fragment"><div class="line"><span class="comment">///    #if FOO</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    #  if BAR</span></div>
<div class="line"><span class="comment">///    #    include &lt;foo&gt;</span></div>
<div class="line"><span class="comment">///    #  endif</span></div>
<div class="line"><span class="comment">///    #endif</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> PPDIS_AfterHash, / Indents directives before the hash. / </p><div class="fragment"><div class="line"><span class="comment">///    #if FOO</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      #if BAR</span></div>
<div class="line"><span class="comment">///        #include &lt;foo&gt;</span></div>
<div class="line"><span class="comment">///      #endif</span></div>
<div class="line"><span class="comment">///    #endif</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> PPDIS_BeforeHash };</p>
<p>/ The preprocessor directive indenting style to use. PPDirectiveIndentStyle IndentPPDirectives;</p>
<p>/ Indents extern blocks enum IndentExternBlockStyle : unsigned char { / Backwards compatible with AfterExternBlock's indenting. / </p><div class="fragment"><div class="line"><span class="comment">///    IndentExternBlock: AfterExternBlock</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    BraceWrapping.AfterExternBlock: true</span></div>
<div class="line"><span class="comment">///    extern &quot;C&quot;</span></div>
<div class="line"><span class="comment">///    {</span></div>
<div class="line"><span class="comment">///        void foo();</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / </p><div class="fragment"><div class="line"><span class="comment">///    IndentExternBlock: AfterExternBlock</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    BraceWrapping.AfterExternBlock: false</span></div>
<div class="line"><span class="comment">///    extern &quot;C&quot; {</span></div>
<div class="line"><span class="comment">///    void foo();</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> IEBS_AfterExternBlock, / Does not indent extern blocks. / </p><div class="fragment"><div class="line"><span class="comment">///     extern &quot;C&quot; {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     void foo();</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> IEBS_NoIndent, / Indents extern blocks. / </p><div class="fragment"><div class="line"><span class="comment">///     extern &quot;C&quot; {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///       void foo();</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> IEBS_Indent, };</p>
<p>/ IndentExternBlockStyle is the type of indenting of extern blocks. IndentExternBlockStyle IndentExternBlock;</p>
<p>/ Indent the requires clause in a template / </p><div class="fragment"><div class="line"><span class="comment">///    true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    template &lt;typename It&gt;</span></div>
<div class="line"><span class="comment">///      requires Iterator&lt;It&gt;</span></div>
<div class="line"><span class="comment">///    void sort(It begin, It end) {</span></div>
<div class="line"><span class="comment">///      //....</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    false:</span></div>
<div class="line"><span class="comment">///    template &lt;typename It&gt;</span></div>
<div class="line"><span class="comment">///    requires Iterator&lt;It&gt;</span></div>
<div class="line"><span class="comment">///    void sort(It begin, It end) {</span></div>
<div class="line"><span class="comment">///      //....</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool IndentRequires;</p>
<p>/ The number of columns to use for indentation. / </p><div class="fragment"><div class="line"><span class="comment">///    IndentWidth: 3</span><span class="comment"></span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    void f() {</span></div>
<div class="line"><span class="comment">///       someFunction();</span></div>
<div class="line"><span class="comment">///       if (true, false) {</span></div>
<div class="line"><span class="comment">///          f();</span></div>
<div class="line"><span class="comment">///       }</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> unsigned IndentWidth;</p>
<p>/ Indent if a function definition or declaration is wrapped after the / type. / </p><div class="fragment"><div class="line"><span class="comment">///    true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    LoooooooooooooooooooooooooooooooooooooooongReturnType</span></div>
<div class="line"><span class="comment">///        LoooooooooooooooooooooooooooooooongFunctionDeclaration();</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    false:</span></div>
<div class="line"><span class="comment">///    LoooooooooooooooooooooooooooooooooooooooongReturnType</span></div>
<div class="line"><span class="comment">///    LoooooooooooooooooooooooooooooooongFunctionDeclaration();</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool IndentWrappedFunctionNames;</p>
<p>/ A vector of prefixes ordered by the desired groups for Java imports. / / One group's prefix can be a subset of another - the longest prefix is / always matched. Within a group, the imports are ordered lexicographically. / Static imports are grouped separately and follow the same group rules. / By default, static imports are placed before non-static imports, / but this behavior is changed by another option, / <code>SortJavaStaticImport</code>. / / In the .clang-format configuration file, this can be configured like / in the following yaml example. This will result in imports being / formatted as in the Java example below. / </p><div class="fragment"><div class="line">///   JavaImportGroups: [&#39;com.example&#39;, &#39;com&#39;, &#39;org&#39;]</div>
<div class="line">/// </div>
</div><!-- fragment --><p> / / </p><div class="fragment"><div class="line"><span class="comment">///    import static com.example.function1;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    import static com.test.function2;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    import static org.example.function3;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    import com.example.ClassA;</span></div>
<div class="line"><span class="comment">///    import com.example.Test;</span></div>
<div class="line"><span class="comment">///    import com.example.a.ClassB;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    import com.test.ClassC;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    import org.example.ClassD;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> std::vector&lt;std::string&gt; JavaImportGroups;</p>
<p>/ Quotation styles for JavaScript strings. Does not affect template / strings. enum JavaScriptQuoteStyle : unsigned char { / Leave string quotes as they are. / </p><div class="fragment"><div class="line">///    string1 = &quot;foo&quot;;</div>
<div class="line">///    string2 = &#39;bar&#39;;</div>
<div class="line">/// </div>
</div><!-- fragment --><p> JSQS_Leave, / Always use single quotes. / </p><div class="fragment"><div class="line">///    string1 = &#39;foo&#39;;</div>
<div class="line">///    string2 = &#39;bar&#39;;</div>
<div class="line">/// </div>
</div><!-- fragment --><p> JSQS_Single, / Always use double quotes. / </p><div class="fragment"><div class="line">///    string1 = &quot;foo&quot;;</div>
<div class="line">///    string2 = &quot;bar&quot;;</div>
<div class="line">/// </div>
</div><!-- fragment --><p> JSQS_Double };</p>
<p>/ The JavaScriptQuoteStyle to use for JavaScript strings. JavaScriptQuoteStyle JavaScriptQuotes;</p>
<p>clang-format off / Whether to wrap JavaScript import/export statements. / </p><div class="fragment"><div class="line">///    true:</div>
<div class="line">///    import {</div>
<div class="line">///        VeryLongImportsAreAnnoying,</div>
<div class="line">///        VeryLongImportsAreAnnoying,</div>
<div class="line">///        VeryLongImportsAreAnnoying,</div>
<div class="line">///    } from &#39;some/module.js&#39;</div>
<div class="line">///</div>
<div class="line">///    false:</div>
<div class="line">///    import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from &quot;some/module.js&quot;</div>
<div class="line">/// </div>
</div><!-- fragment --><p> bool JavaScriptWrapImports; clang-format on</p>
<p>/ If true, the empty line at the start of blocks is kept. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    if (foo) {                     vs.     if (foo) {</span></div>
<div class="line"><span class="comment">///                                             bar();</span></div>
<div class="line"><span class="comment">///      bar();                               }</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool KeepEmptyLinesAtTheStartOfBlocks;</p>
<p>/ Supported languages. / / When stored in a configuration file, specifies the language, that the / configuration targets. When passed to the <code><a class="el" href="#a277c8b4d6e86b42cfc60b2fdd51652de">reformat()</a></code> function, enables / syntax features specific to the language. enum LanguageKind : unsigned char { / Do not use. LK_None, / Should be used for C, C++. LK_Cpp, / Should be used for C#. LK_CSharp, / Should be used for Java. LK_Java, / Should be used for JavaScript. LK_JavaScript, / Should be used for Objective-C, Objective-C++. LK_ObjC, / Should be used for Protocol Buffers / (<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>). LK_Proto, / Should be used for TableGen code. LK_TableGen, / Should be used for Protocol Buffer messages in text format / (<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>). LK_TextProto }; bool isCpp() const { return Language == LK_Cpp || Language == LK_ObjC; } bool isCSharp() const { return Language == LK_CSharp; }</p>
<p>/ Language, this format style is targeted at. LanguageKind Language;</p>
<p>/ A regular expression matching macros that start a block. / </p><div class="fragment"><div class="line"><span class="comment">///    # With:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    MacroBlockBegin: &quot;^NS_MAP_BEGIN|\</span></div>
<div class="line"><span class="comment">///    NS_TABLE_HEAD$&quot;</span></div>
<div class="line"><span class="comment">///    MacroBlockEnd: &quot;^\</span></div>
<div class="line"><span class="comment">///    NS_MAP_END|\</span></div>
<div class="line"><span class="comment">///    NS_TABLE_.*_END$&quot;</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    NS_MAP_BEGIN</span></div>
<div class="line"><span class="comment">///      foo();</span></div>
<div class="line"><span class="comment">///    NS_MAP_END</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    NS_TABLE_HEAD</span></div>
<div class="line"><span class="comment">///      bar();</span></div>
<div class="line"><span class="comment">///    NS_TABLE_FOO_END</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    # Without:</span></div>
<div class="line"><span class="comment">///    NS_MAP_BEGIN</span></div>
<div class="line"><span class="comment">///    foo();</span></div>
<div class="line"><span class="comment">///    NS_MAP_END</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    NS_TABLE_HEAD</span></div>
<div class="line"><span class="comment">///    bar();</span></div>
<div class="line"><span class="comment">///    NS_TABLE_FOO_END</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> std::string MacroBlockBegin;</p>
<p>/ A regular expression matching macros that end a block. std::string MacroBlockEnd;</p>
<p>/ The maximum number of consecutive empty lines to keep. / </p><div class="fragment"><div class="line"><span class="comment">///    MaxEmptyLinesToKeep: 1         vs.     MaxEmptyLinesToKeep: 0</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    int f() {                              int f() {</span></div>
<div class="line"><span class="comment">///      int = 1;                                 int i = 1;</span></div>
<div class="line"><span class="comment">///                                               i = foo();</span></div>
<div class="line"><span class="comment">///      i = foo();                               return i;</span></div>
<div class="line"><span class="comment">///                                           }</span></div>
<div class="line"><span class="comment">///      return i;</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> unsigned MaxEmptyLinesToKeep;</p>
<p>/ Different ways to indent namespace contents. enum NamespaceIndentationKind : unsigned char { / Don't indent in namespaces. / </p><div class="fragment"><div class="line"><span class="comment">///    namespace out {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    int i;</span></div>
<div class="line"><span class="comment">///    namespace in {</span></div>
<div class="line"><span class="comment">///    int i;</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> NI_None, / Indent only in inner namespaces (nested in other namespaces). / </p><div class="fragment"><div class="line"><span class="comment">///    namespace out {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    int i;</span></div>
<div class="line"><span class="comment">///    namespace in {</span></div>
<div class="line"><span class="comment">///      int i;</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> NI_Inner, / Indent in all namespaces. / </p><div class="fragment"><div class="line"><span class="comment">///    namespace out {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      int i;</span></div>
<div class="line"><span class="comment">///      namespace in {</span></div>
<div class="line"><span class="comment">///        int i;</span></div>
<div class="line"><span class="comment">///      }</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> NI_All };</p>
<p>/ The indentation used for namespaces. NamespaceIndentationKind NamespaceIndentation;</p>
<p>/ Controls bin-packing Objective-C protocol conformance list / items into as few lines as possible when they go over <code>ColumnLimit</code>. / / If <code>Auto</code> (the default), delegates to the value in / <code>BinPackParameters</code>. If that is <code>true</code>, bin-packs Objective-C / protocol conformance list items into as few lines as possible / whenever they go over <code>ColumnLimit</code>. / / If <code>Always</code>, always bin-packs Objective-C protocol conformance / list items into as few lines as possible whenever they go over / <code>ColumnLimit</code>. / / If <code>Never</code>, lays out Objective-C protocol conformance list items / onto individual lines whenever they go over <code>ColumnLimit</code>. / / </p><div class="fragment"><div class="line">///    Always (or Auto, if BinPackParameters=true):</div>
<div class="line">///    @interface ccccccccccccc () &lt;</div>
<div class="line">///        ccccccccccccc, ccccccccccccc,</div>
<div class="line">///        ccccccccccccc, ccccccccccccc&gt; {</div>
<div class="line">///    }</div>
<div class="line">///</div>
<div class="line">///    Never (or Auto, if BinPackParameters=false):</div>
<div class="line">///    @interface ddddddddddddd () &lt;</div>
<div class="line">///        ddddddddddddd,</div>
<div class="line">///        ddddddddddddd,</div>
<div class="line">///        ddddddddddddd,</div>
<div class="line">///        ddddddddddddd&gt; {</div>
<div class="line">///    }</div>
<div class="line">/// </div>
</div><!-- fragment --><p> BinPackStyle ObjCBinPackProtocolList;</p>
<p>/ The number of characters to use for indentation of ObjC blocks. / </p><div class="fragment"><div class="line">///    ObjCBlockIndentWidth: 4</div>
<div class="line">///</div>
<div class="line">///    [operation setCompletionBlock:^{</div>
<div class="line">///        [self onOperationDone];</div>
<div class="line">///    }];</div>
<div class="line">/// </div>
</div><!-- fragment --><p> unsigned ObjCBlockIndentWidth;</p>
<p>/ Add a space after <code>@property</code> in Objective-C, i.e. use / <code>@property (readonly)</code> instead of <code>@property(readonly)</code>. bool ObjCSpaceAfterProperty;</p>
<p>/ Break parameters list into lines when there is nested block / parameters in a function call. / </p><div class="fragment"><div class="line"><span class="comment">///   false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    - (void)_aMethod</span></div>
<div class="line"><span class="comment">///    {</span></div>
<div class="line"><span class="comment">///        [self.test1 t:self w:self callback:^(typeof(self) self, NSNumber</span></div>
<div class="line"><span class="comment">///        *u, NSNumber *v) {</span></div>
<div class="line"><span class="comment">///            u = c;</span></div>
<div class="line"><span class="comment">///        }]</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment">///    true:</span></div>
<div class="line"><span class="comment">///    - (void)_aMethod</span></div>
<div class="line"><span class="comment">///    {</span></div>
<div class="line"><span class="comment">///       [self.test1 t:self</span></div>
<div class="line"><span class="comment">///                    w:self</span></div>
<div class="line"><span class="comment">///           callback:^(typeof(self) self, NSNumber *u, NSNumber *v) {</span></div>
<div class="line"><span class="comment">///                u = c;</span></div>
<div class="line"><span class="comment">///            }]</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool ObjCBreakBeforeNestedBlockParam;</p>
<p>/ Add a space in front of an Objective-C protocol list, i.e. use / <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>. bool ObjCSpaceBeforeProtocolList;</p>
<p>/ The penalty for breaking around an assignment operator. unsigned PenaltyBreakAssignment;</p>
<p>/ The penalty for breaking a function call after <code>call(</code>. unsigned PenaltyBreakBeforeFirstCallParameter;</p>
<p>/ The penalty for each line break introduced inside a comment. unsigned PenaltyBreakComment;</p>
<p>/ The penalty for breaking before the first <code>&lt;&lt;</code>. unsigned PenaltyBreakFirstLessLess;</p>
<p>/ The penalty for each line break introduced inside a string literal. unsigned PenaltyBreakString;</p>
<p>/ The penalty for breaking after template declaration. unsigned PenaltyBreakTemplateDeclaration;</p>
<p>/ The penalty for each character outside of the column limit. unsigned PenaltyExcessCharacter;</p>
<p>/ Penalty for putting the return type of a function onto its own / line. unsigned PenaltyReturnTypeOnItsOwnLine;</p>
<p>/ Penalty for each character of whitespace indentation / (counted relative to leading non-whitespace column). unsigned PenaltyIndentedWhitespace;</p>
<p>/ The <code>&amp;</code> and <code>*</code> alignment style. enum PointerAlignmentStyle : unsigned char { / Align pointer to the left. / </p><div class="fragment"><div class="line"><span class="comment">///   int* a;</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> PAS_Left, / Align pointer to the right. / </p><div class="fragment"><div class="line"><span class="comment">///   int *a;</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> PAS_Right, / Align pointer in the middle. / </p><div class="fragment"><div class="line"><span class="comment">///   int * a;</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> PAS_Middle };</p>
<p>/ Pointer and reference alignment style. PointerAlignmentStyle PointerAlignment;</p>
<p>/ See documentation of <code>RawStringFormats</code>. struct RawStringFormat { / The language of this raw string. LanguageKind Language; / A list of raw string delimiters that match this language. std::vector&lt;std::string&gt; Delimiters; / A list of enclosing function names that match this language. std::vector&lt;std::string&gt; EnclosingFunctions; / The canonical delimiter for this language. std::string CanonicalDelimiter; / The style name on which this raw string format is based on. / If not specified, the raw string format is based on the style that this / format is based on. std::string BasedOnStyle; bool operator==(const RawStringFormat &amp;Other) const { return Language == Other.Language &amp;&amp; Delimiters == Other.Delimiters &amp;&amp; EnclosingFunctions == Other.EnclosingFunctions &amp;&amp; CanonicalDelimiter == Other.CanonicalDelimiter &amp;&amp; BasedOnStyle == Other.BasedOnStyle; } };</p>
<p>/ Defines hints for detecting supported languages code blocks in raw / strings. / / A raw string with a matching delimiter or a matching enclosing function / name will be reformatted assuming the specified language based on the / style for that language defined in the .clang-format file. If no style has / been defined in the .clang-format file for the specific language, a / predefined style given by 'BasedOnStyle' is used. If 'BasedOnStyle' is not / found, the formatting is based on llvm style. A matching delimiter takes / precedence over a matching enclosing function name for determining the / language of the raw string contents. / / If a canonical delimiter is specified, occurrences of other delimiters for / the same language will be updated to the canonical if possible. / / There should be at most one specification per language and each delimiter / and enclosing function should not occur in multiple specifications. / / To configure this in the .clang-format file, use: / </p><div class="fragment"><div class="line">///   RawStringFormats:</div>
<div class="line">///     - Language: TextProto</div>
<div class="line">///         Delimiters:</div>
<div class="line">///           - &#39;pb&#39;</div>
<div class="line">///           - &#39;proto&#39;</div>
<div class="line">///         EnclosingFunctions:</div>
<div class="line">///           - &#39;PARSE_TEXT_PROTO&#39;</div>
<div class="line">///         BasedOnStyle: google</div>
<div class="line">///     - Language: Cpp</div>
<div class="line">///         Delimiters:</div>
<div class="line">///           - &#39;cc&#39;</div>
<div class="line">///           - &#39;cpp&#39;</div>
<div class="line">///         BasedOnStyle: llvm</div>
<div class="line">///         CanonicalDelimiter: &#39;cc&#39;</div>
<div class="line">/// </div>
</div><!-- fragment --><p> std::vector&lt;RawStringFormat&gt; RawStringFormats;</p>
<p>clang-format off / If <code>true</code>, clang-format will attempt to re-flow comments. / </p><div class="fragment"><div class="line"><span class="comment">///    false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information</span></div>
<div class="line"><span class="comment">///    /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///    true:</span></div>
<div class="line"><span class="comment">///    // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of</span></div>
<div class="line"><span class="comment">///    // information</span></div>
<div class="line"><span class="comment">///    /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of</span></div>
<div class="line"><span class="comment">///     * information */</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool ReflowComments; clang-format on</p>
<p>/ If <code>true</code>, clang-format will sort <code>#includes</code>. / </p><div class="fragment"><div class="line"><span class="comment">///    false:                                 true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    #include &quot;b.h&quot;                 vs.     #include &quot;a.h&quot;</span></div>
<div class="line"><span class="comment">///    #include &quot;a.h&quot;                         #include &quot;b.h&quot;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SortIncludes;</p>
<p>/ Position for Java Static imports. enum SortJavaStaticImportOptions : unsigned char { / Static imports are placed before non-static imports. / </p><div class="fragment"><div class="line"><span class="comment">///   import static org.example.function1;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   import org.example.ClassA;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SJSIO_Before, / Static imports are placed after non-static imports. / </p><div class="fragment"><div class="line"><span class="comment">///   import org.example.ClassA;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   import static org.example.function1;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SJSIO_After, };</p>
<p>/ When sorting Java imports, by default static imports are placed before / non-static imports. If <code>JavaStaticImportAfterImport</code> is <code>After</code>, / static imports are placed after non-static imports. SortJavaStaticImportOptions SortJavaStaticImport;</p>
<p>/ If <code>true</code>, clang-format will sort using declarations. / / The order of using declarations is defined as follows: / Split the strings by "::" and discard any initial empty strings. The last / element of each list is a non-namespace name; all others are namespace / names. Sort the lists of names lexicographically, where the sort order of / individual names is that all non-namespace names come before all namespace / names, and within those groups, names are in case-insensitive / lexicographic order. / </p><div class="fragment"><div class="line"><span class="comment">///    false:                                 true:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    using std::cout;               vs.     using std::cin;</span></div>
<div class="line"><span class="comment">///    using std::cin;                        using std::cout;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SortUsingDeclarations;</p>
<p>/ If <code>true</code>, a space is inserted after C style casts. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    (int) i;                       vs.     (int)i;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SpaceAfterCStyleCast;</p>
<p>/ If <code>true</code>, a space is inserted after the logical not operator (<code>!</code>). / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    ! someExpression();            vs.     !someExpression();</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SpaceAfterLogicalNot;</p>
<p>/ If <code>true</code>, a space will be inserted after the 'template' keyword. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    template &lt;int&gt; void foo();     vs.     template&lt;int&gt; void foo();</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SpaceAfterTemplateKeyword;</p>
<p>/ Different ways to put a space before opening parentheses. enum SpaceAroundPointerQualifiersStyle : unsigned char { / Don't ensure spaces around pointer qualifiers and use PointerAlignment / instead. / </p><div class="fragment"><div class="line"><span class="comment">///    PointerAlignment: Left                 PointerAlignment: Right</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    void* const* x = NULL;         vs.     void *const *x = NULL;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SAPQ_Default, / Ensure that there is a space before pointer qualifiers. / </p><div class="fragment"><div class="line"><span class="comment">///    PointerAlignment: Left                 PointerAlignment: Right</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    void* const* x = NULL;         vs.     void * const *x = NULL;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SAPQ_Before, / Ensure that there is a space after pointer qualifiers. / </p><div class="fragment"><div class="line"><span class="comment">///    PointerAlignment: Left                 PointerAlignment: Right</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    void* const * x = NULL;         vs.     void *const *x = NULL;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SAPQ_After, / Ensure that there is a space both before and after pointer qualifiers. / </p><div class="fragment"><div class="line"><span class="comment">///    PointerAlignment: Left                 PointerAlignment: Right</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    void* const * x = NULL;         vs.     void * const *x = NULL;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SAPQ_Both, };</p>
<p>/ Defines in which cases to put a space before or after pointer qualifiers SpaceAroundPointerQualifiersStyle SpaceAroundPointerQualifiers;</p>
<p>/ If <code>false</code>, spaces will be removed before assignment operators. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    int a = 5;                     vs.     int a= 5;</span></div>
<div class="line"><span class="comment">///    a += 42;                               a+= 42;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SpaceBeforeAssignmentOperators;</p>
<p>/ If <code>false</code>, spaces will be removed before case colon. / </p><div class="fragment"><div class="line"><span class="comment">///   true:                                   false</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   switch (x) {                    vs.     switch (x) {</span></div>
<div class="line"><span class="comment">///     case 1 : break;                         case 1: break;</span></div>
<div class="line"><span class="comment">///   }                                       }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SpaceBeforeCaseColon;</p>
<p>/ If <code>true</code>, a space will be inserted before a C++11 braced list / used to initialize an object (after the preceding identifier or type). / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    Foo foo { bar };               vs.     Foo foo{ bar };</span></div>
<div class="line"><span class="comment">///    Foo {};                                Foo{};</span></div>
<div class="line"><span class="comment">///    vector&lt;int&gt; { 1, 2, 3 };               vector&lt;int&gt;{ 1, 2, 3 };</span></div>
<div class="line"><span class="comment">///    new int[3] { 1, 2, 3 };                new int[3]{ 1, 2, 3 };</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SpaceBeforeCpp11BracedList;</p>
<p>/ If <code>false</code>, spaces will be removed before constructor initializer / colon. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    Foo::Foo() : a(a) {}                   Foo::Foo(): a(a) {}</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SpaceBeforeCtorInitializerColon;</p>
<p>/ If <code>false</code>, spaces will be removed before inheritance colon. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    class Foo : Bar {}             vs.     class Foo: Bar {}</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SpaceBeforeInheritanceColon;</p>
<p>/ Different ways to put a space before opening parentheses. enum SpaceBeforeParensOptions : unsigned char { / Never put a space before opening parentheses. / </p><div class="fragment"><div class="line"><span class="comment">///    void f() {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      if(true) {</span></div>
<div class="line"><span class="comment">///        f();</span></div>
<div class="line"><span class="comment">///      }</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SBPO_Never, / Put a space before opening parentheses only after control statement / keywords (<code>for/if/while...</code>). / </p><div class="fragment"><div class="line"><span class="comment">///    void f() {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      if (true) {</span></div>
<div class="line"><span class="comment">///        f();</span></div>
<div class="line"><span class="comment">///      }</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SBPO_ControlStatements, / Same as <code>SBPO_ControlStatements</code> except this option doesn't apply to / ForEach macros. This is useful in projects where ForEach macros are / treated as function calls instead of control statements. / </p><div class="fragment"><div class="line"><span class="comment">///    void f() {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      Q_FOREACH(...) {</span></div>
<div class="line"><span class="comment">///        f();</span></div>
<div class="line"><span class="comment">///      }</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SBPO_ControlStatementsExceptForEachMacros, / Put a space before opening parentheses only if the parentheses are not / empty i.e. '()' / </p><div class="fragment"><div class="line"><span class="comment">///   void() {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///     if (true) {</span></div>
<div class="line"><span class="comment">///       f();</span></div>
<div class="line"><span class="comment">///       g (x, y, z);</span></div>
<div class="line"><span class="comment">///     }</span></div>
<div class="line"><span class="comment">///   }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SBPO_NonEmptyParentheses, / Always put a space before opening parentheses, except when it's / prohibited by the syntax rules (in function-like macro definitions) or / when determined by other style rules (after unary operators, opening / parentheses, etc.) / </p><div class="fragment"><div class="line"><span class="comment">///    void f () {</span><span class="comment"></span></div>
<div class="line"><span class="comment">///      if (true) {</span></div>
<div class="line"><span class="comment">///        f ();</span></div>
<div class="line"><span class="comment">///      }</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> SBPO_Always };</p>
<p>/ Defines in which cases to put a space before opening parentheses. SpaceBeforeParensOptions SpaceBeforeParens;</p>
<p>/ If <code>false</code>, spaces will be removed before range-based for loop / colon. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    for (auto v : values) {}       vs.     for(auto v: values) {}</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SpaceBeforeRangeBasedForLoopColon;</p>
<p>/ If <code>true</code>, spaces will be inserted into <code>{}</code>. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    void f() { }                   vs.   void f() {}</span></div>
<div class="line"><span class="comment">///    while (true) { }                     while (true) {}</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SpaceInEmptyBlock;</p>
<p>/ If <code>true</code>, spaces may be inserted into <code>()</code>. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    void f( ) {                    vs.   void f() {</span></div>
<div class="line"><span class="comment">///      int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};</span></div>
<div class="line"><span class="comment">///      if (true) {                          if (true) {</span></div>
<div class="line"><span class="comment">///        f( );                                f();</span></div>
<div class="line"><span class="comment">///      }                                    }</span></div>
<div class="line"><span class="comment">///    }                                    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SpaceInEmptyParentheses;</p>
<p>/ The number of spaces before trailing line comments / (<code>//</code> - comments). / / This does not affect trailing block comments (<code>/*</code> - comments) as / those commonly have different usage patterns and a number of special / cases. / </p><div class="fragment"><div class="line"><span class="comment">///    SpacesBeforeTrailingComments: 3</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    void f() {</span></div>
<div class="line"><span class="comment">///      if (true) {   // foo1</span></div>
<div class="line"><span class="comment">///        f();        // bar</span></div>
<div class="line"><span class="comment">///      }             // foo</span></div>
<div class="line"><span class="comment">///    }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> unsigned SpacesBeforeTrailingComments;</p>
<p>/ If <code>true</code>, spaces will be inserted after <code>&lt;</code> and before <code>&gt;</code> / in template argument lists. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    static_cast&lt; int &gt;(arg);       vs.     static_cast&lt;int&gt;(arg);</span></div>
<div class="line"><span class="comment">///    std::function&lt; void(int) &gt; fct;        std::function&lt;void(int)&gt; fct;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SpacesInAngles;</p>
<p>/ If <code>true</code>, spaces will be inserted around if/for/switch/while / conditions. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    if ( a )  { ... }              vs.     if (a) { ... }</span></div>
<div class="line"><span class="comment">///    while ( i &lt; 5 )  { ... }               while (i &lt; 5) { ... }</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SpacesInConditionalStatement;</p>
<p>/ If <code>true</code>, spaces are inserted inside container literals (e.g. / ObjC and Javascript array and dict literals). / </p><div class="fragment"><div class="line">///    true:                                  false:</div>
<div class="line">///    var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];</div>
<div class="line">///    f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});</div>
<div class="line">/// </div>
</div><!-- fragment --><p> bool SpacesInContainerLiterals;</p>
<p>/ If <code>true</code>, spaces may be inserted into C style casts. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    x = ( int32 )y                 vs.     x = (int32)y</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SpacesInCStyleCastParentheses;</p>
<p>/ If <code>true</code>, spaces will be inserted after <code>(</code> and before <code>)</code>. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    t f( Deleted &amp; ) &amp; = delete;   vs.     t f(Deleted &amp;) &amp; = delete;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SpacesInParentheses;</p>
<p>/ If <code>true</code>, spaces will be inserted after <code>[</code> and before <code>]</code>. / Lambdas without arguments or unspecified size array declarations will not / be affected. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    int a[ 5 ];                    vs.     int a[5];</span></div>
<div class="line"><span class="comment">///    std::unique_ptr&lt;int[]&gt; foo() {} // Won&#39;t be affected</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SpacesInSquareBrackets;</p>
<p>/ If <code>true</code>, spaces will be before <code>[</code>. / Lambdas will not be affected. Only the first <code>[</code> will get a space added. / </p><div class="fragment"><div class="line"><span class="comment">///    true:                                  false:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    int a [5];                    vs.      int a[5];</span></div>
<div class="line"><span class="comment">///    int a [5][5];                 vs.      int a[5][5];</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> bool SpaceBeforeSquareBrackets;</p>
<p>/ Styles for adding spacing around <code>:</code> in bitfield definitions. enum BitFieldColonSpacingStyle : unsigned char { / Add one space on each side of the <code>:</code> / </p><div class="fragment"><div class="line"><span class="comment">///   unsigned bf : 2;</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> BFCS_Both, / Add no space around the <code>:</code> (except when needed for / <code>AlignConsecutiveBitFields</code>). / </p><div class="fragment"><div class="line"><span class="comment">///   unsigned bf:2;</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> BFCS_None, / Add space before the <code>:</code> only / </p><div class="fragment"><div class="line"><span class="comment">///   unsigned bf :2;</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> BFCS_Before, / Add space after the <code>:</code> only (space may be added before if / needed for <code>AlignConsecutiveBitFields</code>). / </p><div class="fragment"><div class="line"><span class="comment">///   unsigned bf: 2;</span></div>
<div class="line"><span class="comment">/// </span></div>
</div><!-- fragment --><p> BFCS_After }; / The BitFieldColonSpacingStyle to use for bitfields. BitFieldColonSpacingStyle BitFieldColonSpacing;</p>
<p>/ Supported language standards for parsing and formatting C++ constructs. / </p><div class="fragment"><div class="line"><span class="comment">///    Latest:                                vector&lt;set&lt;int&gt;&gt;</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    c++03                          vs.     vector&lt;set&lt;int&gt; &gt;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> / / The correct way to spell a specific language version is e.g. <code>c++11</code>. / The historical aliases <code>Cpp03</code> and <code>Cpp11</code> are deprecated. enum LanguageStandard : unsigned char { / Parse and format as C++03. / <code>Cpp03</code> is a deprecated alias for <code>c++03</code> LS_Cpp03, // c++03 / Parse and format as C++11. LS_Cpp11, // c++11 / Parse and format as C++14. LS_Cpp14, // c++14 / Parse and format as C++17. LS_Cpp17, // c++17 / Parse and format as C++20. LS_Cpp20, // c++20 / Parse and format using the latest supported language version. / <code>Cpp11</code> is a deprecated alias for <code>Latest</code> LS_Latest, / Automatic detection based on the input. LS_Auto, };</p>
<p>/ Parse and format C++ constructs compatible with this standard. / </p><div class="fragment"><div class="line"><span class="comment">///    c++03:                                 latest:</span><span class="comment"></span></div>
<div class="line"><span class="comment">///    vector&lt;set&lt;int&gt; &gt; x;           vs.     vector&lt;set&lt;int&gt;&gt; x;</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> LanguageStandard Standard;</p>
<p>/ Macros which are ignored in front of a statement, as if they were an / attribute. So that they are not parsed as identifier, for example for Qts / emit. / </p><div class="fragment"><div class="line"><span class="comment">///   AlignConsecutiveDeclarations: true</span><span class="comment"></span></div>
<div class="line"><span class="comment">///   StatementAttributeLikeMacros: []</span></div>
<div class="line"><span class="comment">///   unsigned char data = &#39;x&#39;;</span></div>
<div class="line"><span class="comment">///   emit          signal(data); // This is parsed as variable declaration.</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">///   AlignConsecutiveDeclarations: true</span></div>
<div class="line"><span class="comment">///   StatementAttributeLikeMacros: [emit]</span></div>
<div class="line"><span class="comment">///   unsigned char data = &#39;x&#39;;</span></div>
<div class="line"><span class="comment">///   emit signal(data); // Now it&#39;s fine again.</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// </span></div>
</div><!-- fragment --><p> std::vector&lt;std::string&gt; StatementAttributeLikeMacros;</p>
<p>/ The number of columns used for tab stops. unsigned TabWidth;</p>
<p>/ Different ways to use tab in formatting. enum UseTabStyle : unsigned char { / Never use tab. UT_Never, / Use tabs only for indentation. UT_ForIndentation, / Fill all leading whitespace with tabs, and use spaces for alignment that / appears within a line (e.g. consecutive assignments and declarations). UT_ForContinuationAndIndentation, / Use tabs for line continuation and indentation, and spaces for / alignment. UT_AlignWithSpaces, / Use tabs whenever we need to fill whitespace that spans at least from / one tab stop to the next one. UT_Always };</p>
<p>/ Use <code>\r\n</code> instead of <code>\n</code> for line breaks. / Also used as fallback if <code>DeriveLineEnding</code> is true. bool UseCRLF;</p>
<p>/ The way to use tab characters in the resulting file. UseTabStyle UseTab;</p>
<p>bool operator==(const FormatStyle &amp;R) const { return AccessModifierOffset == R.AccessModifierOffset &amp;&amp; AlignAfterOpenBracket == R.AlignAfterOpenBracket &amp;&amp; AlignConsecutiveAssignments == R.AlignConsecutiveAssignments &amp;&amp; AlignConsecutiveBitFields == R.AlignConsecutiveBitFields &amp;&amp; AlignConsecutiveDeclarations == R.AlignConsecutiveDeclarations &amp;&amp; AlignConsecutiveMacros == R.AlignConsecutiveMacros &amp;&amp; AlignEscapedNewlines == R.AlignEscapedNewlines &amp;&amp; AlignOperands == R.AlignOperands &amp;&amp; AlignTrailingComments == R.AlignTrailingComments &amp;&amp; AllowAllArgumentsOnNextLine == R.AllowAllArgumentsOnNextLine &amp;&amp; AllowAllConstructorInitializersOnNextLine == R.AllowAllConstructorInitializersOnNextLine &amp;&amp; AllowAllParametersOfDeclarationOnNextLine == R.AllowAllParametersOfDeclarationOnNextLine &amp;&amp; AllowShortEnumsOnASingleLine == R.AllowShortEnumsOnASingleLine &amp;&amp; AllowShortBlocksOnASingleLine == R.AllowShortBlocksOnASingleLine &amp;&amp; AllowShortCaseLabelsOnASingleLine == R.AllowShortCaseLabelsOnASingleLine &amp;&amp; AllowShortFunctionsOnASingleLine == R.AllowShortFunctionsOnASingleLine &amp;&amp; AllowShortIfStatementsOnASingleLine == R.AllowShortIfStatementsOnASingleLine &amp;&amp; AllowShortLambdasOnASingleLine == R.AllowShortLambdasOnASingleLine &amp;&amp; AllowShortLoopsOnASingleLine == R.AllowShortLoopsOnASingleLine &amp;&amp; AlwaysBreakAfterReturnType == R.AlwaysBreakAfterReturnType &amp;&amp; AlwaysBreakBeforeMultilineStrings == R.AlwaysBreakBeforeMultilineStrings &amp;&amp; AlwaysBreakTemplateDeclarations == R.AlwaysBreakTemplateDeclarations &amp;&amp; AttributeMacros == R.AttributeMacros &amp;&amp; BinPackArguments == R.BinPackArguments &amp;&amp; BinPackParameters == R.BinPackParameters &amp;&amp; BreakBeforeBinaryOperators == R.BreakBeforeBinaryOperators &amp;&amp; BreakBeforeBraces == R.BreakBeforeBraces &amp;&amp; BreakBeforeConceptDeclarations == R.BreakBeforeConceptDeclarations &amp;&amp; BreakBeforeTernaryOperators == R.BreakBeforeTernaryOperators &amp;&amp; BreakConstructorInitializers == R.BreakConstructorInitializers &amp;&amp; CompactNamespaces == R.CompactNamespaces &amp;&amp; BreakAfterJavaFieldAnnotations == R.BreakAfterJavaFieldAnnotations &amp;&amp; BreakStringLiterals == R.BreakStringLiterals &amp;&amp; ColumnLimit == R.ColumnLimit &amp;&amp; CommentPragmas == R.CommentPragmas &amp;&amp; BreakInheritanceList == R.BreakInheritanceList &amp;&amp; ConstructorInitializerAllOnOneLineOrOnePerLine == R.ConstructorInitializerAllOnOneLineOrOnePerLine &amp;&amp; ConstructorInitializerIndentWidth == R.ConstructorInitializerIndentWidth &amp;&amp; ContinuationIndentWidth == R.ContinuationIndentWidth &amp;&amp; Cpp11BracedListStyle == R.Cpp11BracedListStyle &amp;&amp; DeriveLineEnding == R.DeriveLineEnding &amp;&amp; DerivePointerAlignment == R.DerivePointerAlignment &amp;&amp; DisableFormat == R.DisableFormat &amp;&amp; EmptyLineBeforeAccessModifier == R.EmptyLineBeforeAccessModifier &amp;&amp; ExperimentalAutoDetectBinPacking == R.ExperimentalAutoDetectBinPacking &amp;&amp; FixNamespaceComments == R.FixNamespaceComments &amp;&amp; ForEachMacros == R.ForEachMacros &amp;&amp; IncludeStyle.IncludeBlocks == R.IncludeStyle.IncludeBlocks &amp;&amp; IncludeStyle.IncludeCategories == R.IncludeStyle.IncludeCategories &amp;&amp; IncludeStyle.IncludeIsMainRegex == R.IncludeStyle.IncludeIsMainRegex &amp;&amp; IncludeStyle.IncludeIsMainSourceRegex == R.IncludeStyle.IncludeIsMainSourceRegex &amp;&amp; IndentCaseLabels == R.IndentCaseLabels &amp;&amp; IndentCaseBlocks == R.IndentCaseBlocks &amp;&amp; IndentGotoLabels == R.IndentGotoLabels &amp;&amp; IndentPPDirectives == R.IndentPPDirectives &amp;&amp; IndentExternBlock == R.IndentExternBlock &amp;&amp; IndentRequires == R.IndentRequires &amp;&amp; IndentWidth == R.IndentWidth &amp;&amp; Language == R.Language &amp;&amp; IndentWrappedFunctionNames == R.IndentWrappedFunctionNames &amp;&amp; JavaImportGroups == R.JavaImportGroups &amp;&amp; JavaScriptQuotes == R.JavaScriptQuotes &amp;&amp; JavaScriptWrapImports == R.JavaScriptWrapImports &amp;&amp; KeepEmptyLinesAtTheStartOfBlocks == R.KeepEmptyLinesAtTheStartOfBlocks &amp;&amp; MacroBlockBegin == R.MacroBlockBegin &amp;&amp; MacroBlockEnd == R.MacroBlockEnd &amp;&amp; MaxEmptyLinesToKeep == R.MaxEmptyLinesToKeep &amp;&amp; NamespaceIndentation == R.NamespaceIndentation &amp;&amp; NamespaceMacros == R.NamespaceMacros &amp;&amp; ObjCBinPackProtocolList == R.ObjCBinPackProtocolList &amp;&amp; ObjCBlockIndentWidth == R.ObjCBlockIndentWidth &amp;&amp; ObjCBreakBeforeNestedBlockParam == R.ObjCBreakBeforeNestedBlockParam &amp;&amp; ObjCSpaceAfterProperty == R.ObjCSpaceAfterProperty &amp;&amp; ObjCSpaceBeforeProtocolList == R.ObjCSpaceBeforeProtocolList &amp;&amp; PenaltyBreakAssignment == R.PenaltyBreakAssignment &amp;&amp; PenaltyBreakBeforeFirstCallParameter == R.PenaltyBreakBeforeFirstCallParameter &amp;&amp; PenaltyBreakComment == R.PenaltyBreakComment &amp;&amp; PenaltyBreakFirstLessLess == R.PenaltyBreakFirstLessLess &amp;&amp; PenaltyBreakString == R.PenaltyBreakString &amp;&amp; PenaltyExcessCharacter == R.PenaltyExcessCharacter &amp;&amp; PenaltyReturnTypeOnItsOwnLine == R.PenaltyReturnTypeOnItsOwnLine &amp;&amp; PenaltyBreakTemplateDeclaration == R.PenaltyBreakTemplateDeclaration &amp;&amp; PointerAlignment == R.PointerAlignment &amp;&amp; RawStringFormats == R.RawStringFormats &amp;&amp; SortJavaStaticImport == R.SortJavaStaticImport &amp;&amp; SpaceAfterCStyleCast == R.SpaceAfterCStyleCast &amp;&amp; SpaceAfterLogicalNot == R.SpaceAfterLogicalNot &amp;&amp; SpaceAfterTemplateKeyword == R.SpaceAfterTemplateKeyword &amp;&amp; SpaceBeforeAssignmentOperators == R.SpaceBeforeAssignmentOperators &amp;&amp; SpaceBeforeCaseColon == R.SpaceBeforeCaseColon &amp;&amp; SpaceBeforeCpp11BracedList == R.SpaceBeforeCpp11BracedList &amp;&amp; SpaceBeforeCtorInitializerColon == R.SpaceBeforeCtorInitializerColon &amp;&amp; SpaceBeforeInheritanceColon == R.SpaceBeforeInheritanceColon &amp;&amp; SpaceBeforeParens == R.SpaceBeforeParens &amp;&amp; SpaceAroundPointerQualifiers == R.SpaceAroundPointerQualifiers &amp;&amp; SpaceBeforeRangeBasedForLoopColon == R.SpaceBeforeRangeBasedForLoopColon &amp;&amp; SpaceInEmptyBlock == R.SpaceInEmptyBlock &amp;&amp; SpaceInEmptyParentheses == R.SpaceInEmptyParentheses &amp;&amp; SpacesBeforeTrailingComments == R.SpacesBeforeTrailingComments &amp;&amp; SpacesInAngles == R.SpacesInAngles &amp;&amp; SpacesInConditionalStatement == R.SpacesInConditionalStatement &amp;&amp; SpacesInContainerLiterals == R.SpacesInContainerLiterals &amp;&amp; SpacesInCStyleCastParentheses == R.SpacesInCStyleCastParentheses &amp;&amp; SpacesInParentheses == R.SpacesInParentheses &amp;&amp; SpacesInSquareBrackets == R.SpacesInSquareBrackets &amp;&amp; SpaceBeforeSquareBrackets == R.SpaceBeforeSquareBrackets &amp;&amp; BitFieldColonSpacing == R.BitFieldColonSpacing &amp;&amp; Standard == R.Standard &amp;&amp; StatementAttributeLikeMacros == R.StatementAttributeLikeMacros &amp;&amp; StatementMacros == R.StatementMacros &amp;&amp; TabWidth == R.TabWidth &amp;&amp; UseTab == R.UseTab &amp;&amp; UseCRLF == R.UseCRLF &amp;&amp; TypenameMacros == R.TypenameMacros; }</p>
<p>llvm::Optional&lt;FormatStyle&gt; GetLanguageStyle(LanguageKind Language) const;</p>
<p>Stores per-language styles. A FormatStyle instance inside has an empty StyleSet. A FormatStyle instance returned by the Get method has its StyleSet set to a copy of the originating StyleSet, effectively keeping the internal representation of that StyleSet alive.</p>
<p>The memory management and ownership reminds of a birds nest: chicks leaving the nest take photos of the nest with them. struct FormatStyleSet { typedef std::map&lt;FormatStyle::LanguageKind, FormatStyle&gt; MapType;</p>
<p>llvm::Optional&lt;FormatStyle&gt; Get(FormatStyle::LanguageKind Language) const;</p>
<p>Adds <code>Style</code> to this FormatStyleSet. Style must not have an associated FormatStyleSet. Style.Language should be different than LK_None. If this FormatStyleSet already contains an entry for Style.Language, that gets replaced with the passed Style. void Add(FormatStyle Style);</p>
<p>Clears this FormatStyleSet. void Clear();</p>
<p>private: std::shared_ptr&lt;MapType&gt; Styles; };</p>
<p>static FormatStyleSet BuildStyleSetFromConfiguration(
      const FormatStyle &amp;MainStyle,
      const std::vector&lt;FormatStyle&gt; &amp;ConfigurationStyles);</p>
<p>private: FormatStyleSet StyleSet;</p>
<p>friend std::error_code <a class="el" href="#a7cf0f004f086333441812832af92aadc">parseConfiguration(llvm::MemoryBufferRef Config,
                                            FormatStyle *Style,
                                            bool AllowUnknownOptions)</a>; };</p>
<p>/ Returns a format style complying with the LLVM coding standards: / <a href="http://llvm.org/docs/CodingStandards.html">http://llvm.org/docs/CodingStandards.html</a>. FormatStyle getLLVMStyle( FormatStyle::LanguageKind Language = FormatStyle::LanguageKind::LK_Cpp);</p>
<p>/ Returns a format style complying with one of Google's style guides: / <a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml">http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml</a>. / <a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml">http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml</a>. / <a href="https://developers.google.com/protocol-buffers/docs/style">https://developers.google.com/protocol-buffers/docs/style</a>. FormatStyle <a class="el" href="#a4dec822e6f8985e433a49d9a2e322c7c">getGoogleStyle(FormatStyle::LanguageKind Language)</a>;</p>
<p>/ Returns a format style complying with Chromium's style guide: / <a href="http://www.chromium.org/developers/coding-style">http://www.chromium.org/developers/coding-style</a>. FormatStyle <a class="el" href="#ad9cb4770ecc9217cc26baf529e0e72a4">getChromiumStyle(FormatStyle::LanguageKind Language)</a>;</p>
<p>/ Returns a format style complying with Mozilla's style guide: / <a href="https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style">https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style</a>. FormatStyle <a class="el" href="#aa342c0dc9c7831f9b8571c3ef81637d6">getMozillaStyle()</a>;</p>
<p>/ Returns a format style complying with Webkit's style guide: / <a href="http://www.webkit.org/coding/coding-style.html">http://www.webkit.org/coding/coding-style.html</a> FormatStyle <a class="el" href="#a1614d4d536703b03a0b101ec206b4ea8">getWebKitStyle()</a>;</p>
<p>/ Returns a format style complying with GNU Coding Standards: / <a href="http://www.gnu.org/prep/standards/standards.html">http://www.gnu.org/prep/standards/standards.html</a> FormatStyle <a class="el" href="#a962486c55900a9550fc495817bc4bd23">getGNUStyle()</a>;</p>
<p>/ Returns a format style complying with Microsoft style guide: / <a href="https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference?view=vs-2017">https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference?view=vs-2017</a> FormatStyle <a class="el" href="#a5b0434ecbb4bf08a1adb94ac6b9d5c13">getMicrosoftStyle(FormatStyle::LanguageKind Language)</a>;</p>
<p>/ Returns style indicating formatting should be not applied at all. FormatStyle <a class="el" href="#ae7bbd5b0ec7bc869e80febca4a395c85">getNoStyle()</a>;</p>
<p>/ Gets a predefined style for the specified language by name. / / Currently supported names: LLVM, Google, Chromium, Mozilla. Names are / compared case-insensitively. / / Returns <code>true</code> if the Style has been set. bool <a class="el" href="#aa4d51fc3e0f96d7e36a07a99c12636d0">getPredefinedStyle(StringRef Name, FormatStyle::LanguageKind Language,
                        FormatStyle *Style)</a>;</p>
<p>/ Parse configuration from YAML-formatted text. / / Style-&gt;Language is used to get the base style, if the <code>BasedOnStyle</code> / option is present. / / The FormatStyleSet of Style is reset. / / When <code>BasedOnStyle</code> is not present, options not present in the YAML / document, are retained in <code>Style</code>. / / If AllowUnknownOptions is true, no errors are emitted if unknown / format options are occured. std::error_code parseConfiguration(llvm::MemoryBufferRef Config, FormatStyle *Style, bool AllowUnknownOptions = false);</p>
<p>/ Like above but accepts an unnamed buffer. inline std::error_code parseConfiguration(StringRef Config, FormatStyle *Style, bool AllowUnknownOptions = false) { return parseConfiguration(llvm::MemoryBufferRef(Config, "YAML"), Style, AllowUnknownOptions); }</p>
<p>/ Gets configuration in a YAML string. std::string <a class="el" href="#a55b4c945b9f6b5e81279ad3c83c981f1">configurationAsText(const FormatStyle &amp;Style)</a>;</p>
<p>/ Returns the replacements necessary to sort all <code>#include</code> blocks / that are affected by <code>Ranges</code>. <a class="el" href="classclang_1_1tooling_1_1Replacements.html" title="Maintains a set of replacements that are conflict-free.">tooling::Replacements</a> sortIncludes(const FormatStyle &amp;Style, StringRef Code, ArrayRef&lt;tooling::Range&gt; Ranges, StringRef FileName, unsigned *Cursor = nullptr);</p>
<p>/ Returns the replacements corresponding to applying and formatting / <code>Replaces</code> on success; otheriwse, return an llvm::Error carrying / llvm::StringError. llvm::Expected&lt;tooling::Replacements&gt; <a class="el" href="#afb183420a2ad22d30e195f394cee34a0">formatReplacements(StringRef Code, const tooling::Replacements &amp;Replaces,
                   const FormatStyle &amp;Style)</a>;</p>
<p>/ Returns the replacements corresponding to applying <code>Replaces</code> and / cleaning up the code after that on success; otherwise, return an llvm::Error / carrying llvm::StringError. / This also supports inserting/deleting C++ #include directives: / - If a replacement has offset UINT_MAX, length 0, and a replacement text / that is an #include directive, this will insert the #include into the / correct block in the <code>Code</code>. / - If a replacement has offset UINT_MAX, length 1, and a replacement text / that is the name of the header to be removed, the header will be removed / from <code>Code</code> if it exists. / The include manipulation is done via <code>tooling::HeaderInclude</code>, see its / documentation for more details on how include insertion points are found and / what edits are produced. llvm::Expected&lt;tooling::Replacements&gt; <a class="el" href="#a2c7b58332eaeaf555434a72be83f7891">cleanupAroundReplacements(StringRef Code, const tooling::Replacements &amp;Replaces,
                          const FormatStyle &amp;Style)</a>;</p>
<p>/ Represents the status of a formatting attempt. struct FormattingAttemptStatus { / A value of <code>false</code> means that any of the affected ranges were not / formatted due to a non-recoverable syntax error. bool FormatComplete = true;</p>
<p>/ If <code>FormatComplete</code> is false, <code>Line</code> records a one-based / original line number at which a syntax error might have occurred. This is / based on a best-effort analysis and could be imprecise. unsigned Line = 0; };</p>
<p>/ Reformats the given <code>Ranges</code> in <code>Code</code>. / / Each range is extended on either end to its next bigger logic unit, i.e. / everything that might influence its formatting or might be influenced by its / formatting. / / Returns the <code>Replacements</code> necessary to make all <code>Ranges</code> comply with / <code>Style</code>. / / If <code>Status</code> is non-null, its value will be populated with the status of / this formatting attempt. See <code>FormattingAttemptStatus</code>. <a class="el" href="classclang_1_1tooling_1_1Replacements.html" title="Maintains a set of replacements that are conflict-free.">tooling::Replacements</a> reformat(const FormatStyle &amp;Style, StringRef Code, ArrayRef&lt;tooling::Range&gt; Ranges, StringRef FileName = "&lt;stdin&gt;", FormattingAttemptStatus *Status = nullptr);</p>
<p>/ Same as above, except if <code>IncompleteFormat</code> is non-null, its value / will be set to true if any of the affected ranges were not formatted due to / a non-recoverable syntax error. <a class="el" href="classclang_1_1tooling_1_1Replacements.html" title="Maintains a set of replacements that are conflict-free.">tooling::Replacements</a> <a class="el" href="#a89e601c265faac6784717f9cfb0aad6d">reformat(const FormatStyle &amp;Style, StringRef Code,
                               ArrayRef&lt;tooling::Range&gt; Ranges,
                               StringRef FileName, bool *IncompleteFormat)</a>;</p>
<p>/ Clean up any erroneous/redundant code in the given <code>Ranges</code> in <code>/</code> Code. / / Returns the <code>Replacements</code> that clean up all <code>Ranges</code> in <code>Code</code>. <a class="el" href="classclang_1_1tooling_1_1Replacements.html" title="Maintains a set of replacements that are conflict-free.">tooling::Replacements</a> cleanup(const FormatStyle &amp;Style, StringRef Code, ArrayRef&lt;tooling::Range&gt; Ranges, StringRef FileName = "&lt;stdin&gt;");</p>
<p>/ Fix namespace end comments in the given <code>Ranges</code> in <code>Code</code>. / / Returns the <code>Replacements</code> that fix the namespace comments in all / <code>Ranges</code> in <code>Code</code>. <a class="el" href="classclang_1_1tooling_1_1Replacements.html" title="Maintains a set of replacements that are conflict-free.">tooling::Replacements</a> fixNamespaceEndComments(const FormatStyle &amp;Style, StringRef Code, ArrayRef&lt;tooling::Range&gt; Ranges, StringRef FileName = "&lt;stdin&gt;");</p>
<p>/ Sort consecutive using declarations in the given <code>Ranges</code> in / <code>Code</code>. / / Returns the <code>Replacements</code> that sort the using declarations in all / <code>Ranges</code> in <code>Code</code>. <a class="el" href="classclang_1_1tooling_1_1Replacements.html" title="Maintains a set of replacements that are conflict-free.">tooling::Replacements</a> sortUsingDeclarations(const FormatStyle &amp;Style, StringRef Code, ArrayRef&lt;tooling::Range&gt; Ranges, StringRef FileName = "&lt;stdin&gt;");</p>
<p>/ Returns the <code>LangOpts</code> that the formatter expects you to set. / /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Style</td><td>determines specific settings for lexing mode. <a class="el" href="classclang_1_1LangOptions.html" title="Keeps track of the various options that can be enabled, which controls the dialect of C or C++ that i...">LangOptions</a> getFormattingLangOpts(const FormatStyle &amp;Style = <a class="el" href="#ac3979a01708870992df724a9845e731f">getLLVMStyle()</a>);</td></tr>
  </table>
  </dd>
</dl>
<p>/ Description to be used for help text for a <code><a class="el" href="namespacellvm_1_1cl.html">llvm::cl</a></code> option for / specifying format style. The description is closely related to the operation / of <code><a class="el" href="#afc311b0133dd54184578648d406528f6">getStyle()</a></code>. extern const char *StyleOptionHelpDescription;</p>
<p>/ The suggested format style to use by default. This allows tools using / <code>getStyle</code> to have a consistent default style. / Different builds can modify the value to the preferred styles. extern const char *DefaultFormatStyle;</p>
<p>/ The suggested predefined style to use as the fallback style in <code>getStyle</code>. / Different builds can modify the value to the preferred styles. extern const char *DefaultFallbackStyle;</p>
<p>/ Construct a FormatStyle based on <code>StyleName</code>. / / <code>StyleName</code> can take several forms: / * "{&lt;key&gt;: &lt;value&gt;, ...}" - Set specic style parameters. / * "&lt;style name&gt;" - One of the style names supported by / <a class="el" href="#aa4d51fc3e0f96d7e36a07a99c12636d0">getPredefinedStyle()</a>. / * "file" - Load style configuration from a file called <code>.clang-format</code> / located in one of the parent directories of <code>FileName</code> or the current / directory if <code>FileName</code> is empty. / /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">StyleName</td><td>Style name to interpret according to the description / above. /</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FileName</td><td>Path to start search for .clang-format if <code>StyleName</code> / == "file". /</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FallbackStyle</td><td>The name of a predefined style used to fallback to / in case <code>StyleName</code> is "file" and no file can be found. /</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Code</td><td>The actual code to be formatted. Used to determine the / language if the filename isn't sufficient. /</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FS</td><td>The underlying file system, in which the file resides. By / default, the file system is the real file system. /</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AllowUnknownOptions</td><td>If true, unknown format options only / emit a warning. If false, errors are emitted on unknown format / options. / / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FormatStyle as specified by <code>StyleName</code>. If <code>StyleName</code> is / "file" and no file is found, returns <code>FallbackStyle</code>. If no style could be / determined, returns an Error. llvm::Expected&lt;FormatStyle&gt; getStyle(StringRef StyleName, StringRef FileName, StringRef FallbackStyle, StringRef Code = "", llvm::vfs::FileSystem *FS = nullptr, bool AllowUnknownOptions = false);</dd></dl>
<p>Guesses the language from the <code>FileName</code> and <code>Code</code> to be formatted. Defaults to FormatStyle::LK_Cpp. FormatStyle::LanguageKind <a class="el" href="#a673110731b1bee34155d96c81e4e1129">guessLanguage(StringRef FileName, StringRef Code)</a>;</p>
<p>Returns a string representation of <code>Language</code>. </p>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03414">3414</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l02895">getStyle()</a>, and <a class="el" href="TokenAnalyzer_8cpp_source.html#l00051">clang::format::TokenAnalyzer::TokenAnalyzer()</a>.</p>

</div>
</div>
<a id="a1b6645664f6b3d404af5f479ecbe1b2b" name="a1b6645664f6b3d404af5f479ecbe1b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6645664f6b3d404af5f479ecbe1b2b">&#9670;&#160;</a></span>getLastLineEndColumn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classunsigned.html">unsigned</a> clang::format::getLastLineEndColumn </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>StartColumn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>TabWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1format_1_1encoding.html#a7e8496e9d93edf497ca8100b48b12492">encoding::Encoding</a></td>          <td class="paramname"><span class="paramname"><em>Encoding</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ContinuationIndenter_8cpp_source.html#l01634">1634</a> of file <a class="el" href="ContinuationIndenter_8cpp_source.html">ContinuationIndenter.cpp</a>.</p>

<p class="reference">References <a class="el" href="Encoding_8h_source.html#l00061">clang::format::encoding::columnWidthWithTabs()</a>, and <a class="el" href="Format_8cpp_source.html#l02112">Text</a>.</p>

</div>
</div>
<a id="a6c208d8905d23732c90471fe6520e232" name="a6c208d8905d23732c90471fe6520e232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c208d8905d23732c90471fe6520e232">&#9670;&#160;</a></span>getLengthToMatchingParen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classunsigned.html">unsigned</a> clang::format::getLengthToMatchingParen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Tok</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structclang_1_1format_1_1ParenState.html">ParenState</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Stack</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ContinuationIndenter_8cpp_source.html#l00037">37</a> of file <a class="el" href="ContinuationIndenter_8cpp_source.html">ContinuationIndenter.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00643">Tok</a>.</p>

<p class="reference">Referenced by <a class="el" href="ContinuationIndenter_8cpp_source.html#l00329">clang::format::ContinuationIndenter::mustBreak()</a>.</p>

</div>
</div>
<a id="a8628c2728c82f335dfb3f1ce5af1e3f7" name="a8628c2728c82f335dfb3f1ce5af1e3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8628c2728c82f335dfb3f1ce5af1e3f7">&#9670;&#160;</a></span>getLengthToNextOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classunsigned.html">unsigned</a> clang::format::getLengthToNextOperator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Tok</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ContinuationIndenter_8cpp_source.html#l00107">107</a> of file <a class="el" href="ContinuationIndenter_8cpp_source.html">ContinuationIndenter.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00643">Tok</a>.</p>

<p class="reference">Referenced by <a class="el" href="ContinuationIndenter_8cpp_source.html#l00329">clang::format::ContinuationIndenter::mustBreak()</a>.</p>

</div>
</div>
<a id="aa5ac2b085f545d66e5426ea4b9be2b39" name="aa5ac2b085f545d66e5426ea4b9be2b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ac2b085f545d66e5426ea4b9be2b39">&#9670;&#160;</a></span>getLineCommentIndentPrefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static StringRef clang::format::getLineCommentIndentPrefix </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Comment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BreakableToken_8cpp_source.html#l00042">42</a> of file <a class="el" href="BreakableToken_8cpp_source.html">BreakableToken.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BreakableToken_8cpp_source.html#l00753">clang::format::BreakableLineCommentSection::BreakableLineCommentSection()</a>.</p>

</div>
</div>
<a id="ac3979a01708870992df724a9845e731f" name="ac3979a01708870992df724a9845e731f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3979a01708870992df724a9845e731f">&#9670;&#160;</a></span>getLLVMStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FormatStyle clang::format::getLLVMStyle </td>
          <td>(</td>
          <td class="paramtype">FormatStyle::LanguageKind</td>          <td class="paramname"><span class="paramname"><em>Language</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l00881">881</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperatorPrecedence_8h_source.html#l00029">clang::prec::Assignment</a>, <a class="el" href="IncludeStyle_8h_source.html#l00030">clang::tooling::IncludeStyle::IBS_Preserve</a>, and <a class="el" href="OperatorPrecedence_8h_source.html#l00037">clang::prec::Relational</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01285">getGNUStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01036">getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01300">getMicrosoftStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01236">getMozillaStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01330">getNoStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01338">getPredefinedStyle()</a>, <a class="el" href="Format_8cpp_source.html#l02895">getStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01262">getWebKitStyle()</a>, <a class="el" href="Format_8cpp_source.html#l02873">guessLanguage()</a>, and <a class="el" href="ContinuationIndenter_8cpp_source.html#l00183">clang::format::RawStringFormatStyleManager::RawStringFormatStyleManager()</a>.</p>

</div>
</div>
<a id="a5b0434ecbb4bf08a1adb94ac6b9d5c13" name="a5b0434ecbb4bf08a1adb94ac6b9d5c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0434ecbb4bf08a1adb94ac6b9d5c13">&#9670;&#160;</a></span>getMicrosoftStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FormatStyle clang::format::getMicrosoftStyle </td>
          <td>(</td>
          <td class="paramtype">FormatStyle::LanguageKind</td>          <td class="paramname"><span class="paramname"><em>Language</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l01300">1300</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l00881">getLLVMStyle()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01338">getPredefinedStyle()</a>.</p>

</div>
</div>
<a id="aa342c0dc9c7831f9b8571c3ef81637d6" name="aa342c0dc9c7831f9b8571c3ef81637d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa342c0dc9c7831f9b8571c3ef81637d6">&#9670;&#160;</a></span>getMozillaStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FormatStyle clang::format::getMozillaStyle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l01236">1236</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l00881">getLLVMStyle()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01338">getPredefinedStyle()</a>.</p>

</div>
</div>
<a id="a10b13b0f837586ebe2744424f447dcf2" name="a10b13b0f837586ebe2744424f447dcf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b13b0f837586ebe2744424f447dcf2">&#9670;&#160;</a></span>getNamespaceToken() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> * clang::format::getNamespaceToken </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the actual namespace token, if this token starts a namespace block. </p>

<p class="definition">Definition at line <a class="el" href="FormatToken_8h_source.html#l00685">685</a> of file <a class="el" href="FormatToken_8h_source.html">FormatToken.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="NamespaceEndCommentsFixer_8cpp_source.html#l00202">clang::format::NamespaceEndCommentsFixer::analyze()</a>, and <a class="el" href="NamespaceEndCommentsFixer_8cpp_source.html#l00192">getNamespaceTokenText()</a>.</p>

</div>
</div>
<a id="a1dda1cac8cf4e3121ef1c0716ddc8ca0" name="a1dda1cac8cf4e3121ef1c0716ddc8ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dda1cac8cf4e3121ef1c0716ddc8ca0">&#9670;&#160;</a></span>getNamespaceToken() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> * clang::format::getNamespaceToken </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1format_1_1AnnotatedLine.html">AnnotatedLine</a> *</td>          <td class="paramname"><span class="paramname"><em>Line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classclang_1_1format_1_1AnnotatedLine.html">AnnotatedLine</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>AnnotatedLines</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NamespaceEndCommentsFixer_8cpp_source.html#l00173">173</a> of file <a class="el" href="NamespaceEndCommentsFixer_8cpp_source.html">NamespaceEndCommentsFixer.cpp</a>.</p>

<p class="reference">References <a class="el" href="TokenAnnotator_8h_source.html#l00138">clang::format::AnnotatedLine::Affected</a>, <a class="el" href="TokenAnnotator_8h_source.html#l00131">clang::format::AnnotatedLine::InPPDirective</a>, <a class="el" href="FormatToken_8h_source.html#l00444">clang::format::FormatToken::is()</a>, <a class="el" href="UnwrappedLineParser_8h_source.html#l00061">clang::format::UnwrappedLine::kInvalidIndex</a>, <a class="el" href="TokenAnnotator_8h_source.html#l00129">clang::format::AnnotatedLine::MatchingOpeningBlockLineIndex</a>, and <a class="el" href="TokenAnnotator_8h_source.html#l00086">clang::format::AnnotatedLine::startsWith()</a>.</p>

</div>
</div>
<a id="ae5ad169fedb393886bc74c65a6a809c7" name="ae5ad169fedb393886bc74c65a6a809c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ad169fedb393886bc74c65a6a809c7">&#9670;&#160;</a></span>getNamespaceTokenText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef clang::format::getNamespaceTokenText </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1format_1_1AnnotatedLine.html">AnnotatedLine</a> *</td>          <td class="paramname"><span class="paramname"><em>Line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classclang_1_1format_1_1AnnotatedLine.html">AnnotatedLine</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>AnnotatedLines</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NamespaceEndCommentsFixer_8cpp_source.html#l00192">192</a> of file <a class="el" href="NamespaceEndCommentsFixer_8cpp_source.html">NamespaceEndCommentsFixer.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00685">getNamespaceToken()</a>, and <a class="el" href="FormatToken_8h_source.html#l00228">clang::format::FormatToken::TokenText</a>.</p>

<p class="reference">Referenced by <a class="el" href="NamespaceEndCommentsFixer_8cpp_source.html#l00202">clang::format::NamespaceEndCommentsFixer::analyze()</a>.</p>

</div>
</div>
<a id="a150e750831c1fe938ffa8676b27ba8ab" name="a150e750831c1fe938ffa8676b27ba8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150e750831c1fe938ffa8676b27ba8ab">&#9670;&#160;</a></span>getNextNonComment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> * clang::format::getNextNonComment </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next token ignoring comments. </p>

<p class="definition">Definition at line <a class="el" href="FormatToken_8h_source.html#l00640">640</a> of file <a class="el" href="FormatToken_8h_source.html">FormatToken.h</a>.</p>

<p class="reference">References <a class="el" href="Token_8h_source.html#l00097">clang::Token::is()</a>, <a class="el" href="FormatToken_8h_source.html#l00434">clang::format::FormatToken::Next</a>, and <a class="el" href="FormatToken_8h_source.html#l00222">clang::format::FormatToken::Tok</a>.</p>

</div>
</div>
<a id="ae7bbd5b0ec7bc869e80febca4a395c85" name="ae7bbd5b0ec7bc869e80febca4a395c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bbd5b0ec7bc869e80febca4a395c85">&#9670;&#160;</a></span>getNoStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FormatStyle clang::format::getNoStyle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l01330">1330</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l00881">getLLVMStyle()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01338">getPredefinedStyle()</a>, and <a class="el" href="Format_8cpp_source.html#l02895">getStyle()</a>.</p>

</div>
</div>
<a id="a5d73a9a775aba4993b85370531b2c24a" name="a5d73a9a775aba4993b85370531b2c24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d73a9a775aba4993b85370531b2c24a">&#9670;&#160;</a></span>getParseCategory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::error_category &amp; clang::format::getParseCategory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l00744">744</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">clang::C</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l00748">make_error_code()</a>.</p>

</div>
</div>
<a id="aa4d51fc3e0f96d7e36a07a99c12636d0" name="aa4d51fc3e0f96d7e36a07a99c12636d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d51fc3e0f96d7e36a07a99c12636d0">&#9670;&#160;</a></span>getPredefinedStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::getPredefinedStyle </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FormatStyle::LanguageKind</td>          <td class="paramname"><span class="paramname"><em>Language</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FormatStyle *</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l01338">1338</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l01176">getChromiumStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01285">getGNUStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01036">getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l00881">getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01300">getMicrosoftStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01236">getMozillaStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01330">getNoStyle()</a>, and <a class="el" href="Format_8cpp_source.html#l01262">getWebKitStyle()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l02895">getStyle()</a>, and <a class="el" href="ContinuationIndenter_8cpp_source.html#l00183">clang::format::RawStringFormatStyleManager::RawStringFormatStyleManager()</a>.</p>

</div>
</div>
<a id="a73cf486e8836b20a423db5d02331b745" name="a73cf486e8836b20a423db5d02331b745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cf486e8836b20a423db5d02331b745">&#9670;&#160;</a></span>getPreviousNonComment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structclang_1_1format_1_1FormatToken.html">clang::format::FormatToken</a> clang::format::getPreviousNonComment </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the previous token ignoring comments. </p>

<p class="definition">Definition at line <a class="el" href="FormatToken_8h_source.html#l00134">134</a> of file <a class="el" href="FormatToken_8h_source.html">FormatToken.h</a>.</p>

</div>
</div>
<a id="af5395fabc4580c3e956307f9ddac9d6b" name="af5395fabc4580c3e956307f9ddac9d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5395fabc4580c3e956307f9ddac9d6b">&#9670;&#160;</a></span>getRawStringDelimiter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; StringRef &gt; clang::format::getRawStringDelimiter </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>TokenText</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ContinuationIndenter_8cpp_source.html#l00149">149</a> of file <a class="el" href="ContinuationIndenter_8cpp_source.html">ContinuationIndenter.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#acdf88ec6c845aa781824469fcb0af66ca6adf97f83acf6453d4a6a4b1070f3754">clang::None</a>, and <a class="el" href="FormatToken_8h_source.html#l00649">TokenText</a>.</p>

</div>
</div>
<a id="a9788e485bda7513ea5602e1ea2fca23f" name="a9788e485bda7513ea5602e1ea2fca23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9788e485bda7513ea5602e1ea2fca23f">&#9670;&#160;</a></span>getStringSplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1format_1_1BreakableToken.html#a0fce9f5e13cf25199ff58a96c5eb7882">BreakableToken::Split</a> clang::format::getStringSplit </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>UsedColumns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ColumnLimit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>TabWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1format_1_1encoding.html#a7e8496e9d93edf497ca8100b48b12492">encoding::Encoding</a></td>          <td class="paramname"><span class="paramname"><em>Encoding</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BreakableToken_8cpp_source.html#l00171">171</a> of file <a class="el" href="BreakableToken_8cpp_source.html">BreakableToken.cpp</a>.</p>

<p class="reference">References <a class="el" href="Encoding_8h_source.html#l00061">clang::format::encoding::columnWidthWithTabs()</a>, <a class="el" href="Encoding_8h_source.html#l00078">clang::format::encoding::getCodePointNumBytes()</a>, <a class="el" href="Encoding_8h_source.html#l00097">clang::format::encoding::getEscapeSequenceLength()</a>, <a class="el" href="CharInfo_8h_source.html#l00117">clang::isAlphanumeric()</a>, <a class="el" href="BreakableToken_8cpp_source.html#l00029">IsBlank()</a>, and <a class="el" href="Format_8cpp_source.html#l02112">Text</a>.</p>

<p class="reference">Referenced by <a class="el" href="BreakableToken_8cpp_source.html#l00279">clang::format::BreakableStringLiteral::getSplit()</a>.</p>

</div>
</div>
<a id="afc311b0133dd54184578648d406528f6" name="afc311b0133dd54184578648d406528f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc311b0133dd54184578648d406528f6">&#9670;&#160;</a></span>getStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Expected.html">llvm::Expected</a>&lt; FormatStyle &gt; clang::format::getStyle </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>StyleName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>FileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>FallbackStyleName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::vfs::FileSystem *</td>          <td class="paramname"><span class="paramname"><em>FS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>AllowUnknownOptions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02895">2895</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8h_source.html#l03414">getLanguageName()</a>, <a class="el" href="Format_8cpp_source.html#l00881">getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01330">getNoStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01338">getPredefinedStyle()</a>, <a class="el" href="Format_8cpp_source.html#l02873">guessLanguage()</a>, <a class="el" href="Format_8cpp_source.html#l00752">make_string_error()</a>, <a class="el" href="Format_8cpp_source.html#l01364">parseConfiguration()</a>, <a class="el" href="Format_8cpp_source.html#l02112">Text</a>, and <a class="el" href="#a8361fae3448126045290df1a4506c954a91957bd1005afd35f28861fe81992ee0">Unsuitable</a>.</p>

<p class="reference">Referenced by <a class="el" href="Refactoring_8cpp_source.html#l00069">clang::tooling::formatAndApplyAllReplacements()</a>.</p>

</div>
</div>
<a id="a11e0d3865faed44e2cc12fb794f30fa8" name="a11e0d3865faed44e2cc12fb794f30fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e0d3865faed44e2cc12fb794f30fa8">&#9670;&#160;</a></span>getTokenTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * clang::format::getTokenTypeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad4b610ca9f97cde157e9b4a864f588d7">TokenType</a></td>          <td class="paramname"><span class="paramname"><em>Type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the name of a token type. </p>

<p class="definition">Definition at line <a class="el" href="FormatToken_8cpp_source.html#l00024">24</a> of file <a class="el" href="FormatToken_8cpp_source.html">FormatToken.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00028">LIST_TOKEN_TYPES</a>, <a class="el" href="FormatToken_8h_source.html#l00130">NUM_TOKEN_TYPES</a>, <a class="el" href="TokenKinds_8cpp_source.html#l00017">TokNames</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00070">Type</a>.</p>

</div>
</div>
<a id="a1614d4d536703b03a0b101ec206b4ea8" name="a1614d4d536703b03a0b101ec206b4ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1614d4d536703b03a0b101ec206b4ea8">&#9670;&#160;</a></span>getWebKitStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FormatStyle clang::format::getWebKitStyle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l01262">1262</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l00881">getLLVMStyle()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01338">getPredefinedStyle()</a>.</p>

</div>
</div>
<a id="a673110731b1bee34155d96c81e4e1129" name="a673110731b1bee34155d96c81e4e1129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673110731b1bee34155d96c81e4e1129">&#9670;&#160;</a></span>guessLanguage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FormatStyle::LanguageKind clang::format::guessLanguage </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>FileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Code</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02873">2873</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l02850">getLanguageByFileName()</a>, and <a class="el" href="Format_8cpp_source.html#l00881">getLLVMStyle()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l02895">getStyle()</a>.</p>

</div>
</div>
<a id="a0f3a04b1e5e97440ce32f4dad85899c0" name="a0f3a04b1e5e97440ce32f4dad85899c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3a04b1e5e97440ce32f4dad85899c0">&#9670;&#160;</a></span>hash_combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void clang::format::hash_combine </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UnwrappedLineParser_8cpp_source.html#l00568">568</a> of file <a class="el" href="UnwrappedLineParser_8cpp_source.html">UnwrappedLineParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="arm__acle_8h_source.html#l00076">v</a>.</p>

</div>
</div>
<a id="a76ec9ad8d6fa166cd74ced3ad3a73cad" name="a76ec9ad8d6fa166cd74ced3ad3a73cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ec9ad8d6fa166cd74ced3ad3a73cad">&#9670;&#160;</a></span>hasNestedBlockInlined()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::hasNestedBlockInlined </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> *</td>          <td class="paramname"><span class="paramname"><em>Previous</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Current</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ContinuationIndenter_8cpp_source.html#l01162">1162</a> of file <a class="el" href="ContinuationIndenter_8cpp_source.html">ContinuationIndenter.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00444">clang::format::FormatToken::is()</a>, <a class="el" href="FormatToken_8h_source.html#l00463">clang::format::FormatToken::isNot()</a>, <a class="el" href="FormatToken_8h_source.html#l00356">clang::format::FormatToken::ParameterCount</a>, and <a class="el" href="FormatToken_8h_source.html#l00852">Previous</a>.</p>

</div>
</div>
<a id="ab97c3cb18694cf466a4953bef844d985" name="ab97c3cb18694cf466a4953bef844d985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97c3cb18694cf466a4953bef844d985">&#9670;&#160;</a></span>isAllmanBrace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::isAllmanBrace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Tok</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TokenAnnotator_8cpp_source.html#l03459">3459</a> of file <a class="el" href="TokenAnnotator_8cpp_source.html">TokenAnnotator.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00137">BK_Block</a>, and <a class="el" href="FormatToken_8h_source.html#l00643">Tok</a>.</p>

</div>
</div>
<a id="a7e1b939670689969ce90f608897a7e07" name="a7e1b939670689969ce90f608897a7e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1b939670689969ce90f608897a7e07">&#9670;&#160;</a></span>isAllmanBraceIncludedBreakableLambda()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::isAllmanBraceIncludedBreakableLambda </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Tok</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FormatStyle::ShortLambdaStyle</td>          <td class="paramname"><span class="paramname"><em>ShortLambdaOption</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TokenAnnotator_8cpp_source.html#l03500">3500</a> of file <a class="el" href="TokenAnnotator_8cpp_source.html">TokenAnnotator.cpp</a>.</p>

<p class="reference">References <a class="el" href="TokenAnnotator_8cpp_source.html#l03495">isAllmanLambdaBrace()</a>, <a class="el" href="TokenAnnotator_8cpp_source.html#l03477">isItAInlineLambdaAllowed()</a>, <a class="el" href="TokenAnnotator_8cpp_source.html#l03471">isItAnEmptyLambdaAllowed()</a>, <a class="el" href="TokenAnnotator_8cpp_source.html#l03484">isOneChildWithoutMustBreakBefore()</a>, and <a class="el" href="FormatToken_8h_source.html#l00643">Tok</a>.</p>

</div>
</div>
<a id="a1759d7f24425968404daf6c41e6cc1e0" name="a1759d7f24425968404daf6c41e6cc1e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1759d7f24425968404daf6c41e6cc1e0">&#9670;&#160;</a></span>isAllmanLambdaBrace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::isAllmanLambdaBrace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Tok</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TokenAnnotator_8cpp_source.html#l03495">3495</a> of file <a class="el" href="TokenAnnotator_8cpp_source.html">TokenAnnotator.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00137">BK_Block</a>, and <a class="el" href="FormatToken_8h_source.html#l00643">Tok</a>.</p>

<p class="reference">Referenced by <a class="el" href="TokenAnnotator_8cpp_source.html#l03500">isAllmanBraceIncludedBreakableLambda()</a>.</p>

</div>
</div>
<a id="a73a774e5ca1bcf315304bfc2af80b066" name="a73a774e5ca1bcf315304bfc2af80b066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a774e5ca1bcf315304bfc2af80b066">&#9670;&#160;</a></span>IsBlank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::IsBlank </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>C</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BreakableToken_8cpp_source.html#l00029">29</a> of file <a class="el" href="BreakableToken_8cpp_source.html">BreakableToken.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#af8c0867861ea3fbfd8957e1e6325c559a0d61f8370cad1d412f80b84d143e1257">clang::C</a>.</p>

<p class="reference">Referenced by <a class="el" href="BreakableToken_8cpp_source.html#l00171">getStringSplit()</a>.</p>

</div>
</div>
<a id="abacb102c3f35a5682f4fd19018b72400" name="abacb102c3f35a5682f4fd19018b72400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abacb102c3f35a5682f4fd19018b72400">&#9670;&#160;</a></span>isCppStructuredBinding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::isCppStructuredBinding </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the token is the left square bracket of a C++ structured binding declaration. </p>

<p class="definition">Definition at line <a class="el" href="FormatToken_8h_source.html#l00665">665</a> of file <a class="el" href="FormatToken_8h_source.html">FormatToken.h</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00463">clang::format::FormatToken::isNot()</a>.</p>

</div>
</div>
<a id="a498b137cf49b30963e804194bfdc0f2d" name="a498b137cf49b30963e804194bfdc0f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498b137cf49b30963e804194bfdc0f2d">&#9670;&#160;</a></span>IsFunctionArgument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::IsFunctionArgument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Tok</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TokenAnnotator_8cpp_source.html#l03465">3465</a> of file <a class="el" href="TokenAnnotator_8cpp_source.html">TokenAnnotator.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00643">Tok</a>.</p>

<p class="reference">Referenced by <a class="el" href="TokenAnnotator_8cpp_source.html#l03477">isItAInlineLambdaAllowed()</a>.</p>

</div>
</div>
<a id="ad12134c25628ef1ab55ec3df3810cfc8" name="ad12134c25628ef1ab55ec3df3810cfc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12134c25628ef1ab55ec3df3810cfc8">&#9670;&#160;</a></span>isFunctionDeclarationName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::isFunctionDeclarationName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Current</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1format_1_1AnnotatedLine.html">AnnotatedLine</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Line</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TokenAnnotator_8cpp_source.html#l02355">2355</a> of file <a class="el" href="TokenAnnotator_8cpp_source.html">TokenAnnotator.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00444">clang::format::FormatToken::is()</a>, <a class="el" href="FormatToken_8h_source.html#l00456">clang::format::FormatToken::isOneOf()</a>, <a class="el" href="TokenAnnotator_8h_source.html#l00123">clang::format::AnnotatedLine::Last</a>, <a class="el" href="FormatToken_8h_source.html#l00428">clang::format::FormatToken::MatchingParen</a>, <a class="el" href="FormatToken_8h_source.html#l00385">clang::format::FormatToken::NestingLevel</a>, <a class="el" href="FormatToken_8h_source.html#l00434">clang::format::FormatToken::Next</a>, <a class="el" href="FormatToken_8h_source.html#l00855">Next</a>, <a class="el" href="FormatToken_8h_source.html#l00431">clang::format::FormatToken::Previous</a>, and <a class="el" href="FormatToken_8h_source.html#l00643">Tok</a>.</p>

<p class="reference">Referenced by <a class="el" href="TokenAnnotator_8cpp_source.html#l02474">clang::format::TokenAnnotator::calculateFormattingInformation()</a>.</p>

</div>
</div>
<a id="ace8b6875cc50576cc30019f782e8d422" name="ace8b6875cc50576cc30019f782e8d422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8b6875cc50576cc30019f782e8d422">&#9670;&#160;</a></span>isGoogScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::isGoogScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1UnwrappedLine.html">UnwrappedLine</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Line</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UnwrappedLineParser_8cpp_source.html#l00664">664</a> of file <a class="el" href="UnwrappedLineParser_8cpp_source.html">UnwrappedLineParser.cpp</a>.</p>

</div>
</div>
<a id="ab1331e1d97b5082959f33946d788eeda" name="ab1331e1d97b5082959f33946d788eeda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1331e1d97b5082959f33946d788eeda">&#9670;&#160;</a></span>isIIFE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::isIIFE </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1UnwrappedLine.html">UnwrappedLine</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structclang_1_1AdditionalKeywords.html">AdditionalKeywords</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Keywords</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UnwrappedLineParser_8cpp_source.html#l00682">682</a> of file <a class="el" href="UnwrappedLineParser_8cpp_source.html">UnwrappedLineParser.cpp</a>.</p>

</div>
</div>
<a id="a4e091a48e0380b420039080323011210" name="a4e091a48e0380b420039080323011210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e091a48e0380b420039080323011210">&#9670;&#160;</a></span>isItAInlineLambdaAllowed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::isItAInlineLambdaAllowed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Tok</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FormatStyle::ShortLambdaStyle</td>          <td class="paramname"><span class="paramname"><em>ShortLambdaOption</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TokenAnnotator_8cpp_source.html#l03477">3477</a> of file <a class="el" href="TokenAnnotator_8cpp_source.html">TokenAnnotator.cpp</a>.</p>

<p class="reference">References <a class="el" href="TokenAnnotator_8cpp_source.html#l03465">IsFunctionArgument()</a>, and <a class="el" href="FormatToken_8h_source.html#l00643">Tok</a>.</p>

<p class="reference">Referenced by <a class="el" href="TokenAnnotator_8cpp_source.html#l03500">isAllmanBraceIncludedBreakableLambda()</a>.</p>

</div>
</div>
<a id="aa200af6deb5a9b431c5307385d1231a2" name="aa200af6deb5a9b431c5307385d1231a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa200af6deb5a9b431c5307385d1231a2">&#9670;&#160;</a></span>isItAnEmptyLambdaAllowed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::isItAnEmptyLambdaAllowed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Tok</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FormatStyle::ShortLambdaStyle</td>          <td class="paramname"><span class="paramname"><em>ShortLambdaOption</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TokenAnnotator_8cpp_source.html#l03471">3471</a> of file <a class="el" href="TokenAnnotator_8cpp_source.html">TokenAnnotator.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00643">Tok</a>.</p>

<p class="reference">Referenced by <a class="el" href="TokenAnnotator_8cpp_source.html#l03500">isAllmanBraceIncludedBreakableLambda()</a>.</p>

</div>
</div>
<a id="a950e7a8451edd9827e1b944757d93f31" name="a950e7a8451edd9827e1b944757d93f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950e7a8451edd9827e1b944757d93f31">&#9670;&#160;</a></span>isJSDeclOrStmt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::isJSDeclOrStmt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1AdditionalKeywords.html">AdditionalKeywords</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Keywords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> *</td>          <td class="paramname"><span class="paramname"><em>FormatTok</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UnwrappedLineParser_8cpp_source.html#l00977">977</a> of file <a class="el" href="UnwrappedLineParser_8cpp_source.html">UnwrappedLineParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00456">clang::format::FormatToken::isOneOf()</a>.</p>

</div>
</div>
<a id="a2051628b228736f5032642207d89b208" name="a2051628b228736f5032642207d89b208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2051628b228736f5032642207d89b208">&#9670;&#160;</a></span>isLikelyXml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::isLikelyXml </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02524">2524</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l02693">clang::format::internal::reformat()</a>, and <a class="el" href="Format_8cpp_source.html#l02526">sortIncludes()</a>.</p>

</div>
</div>
<a id="a6c8d4347555541a74523c231b5d8cdb1" name="a6c8d4347555541a74523c231b5d8cdb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8d4347555541a74523c231b5d8cdb1">&#9670;&#160;</a></span>isMpegTS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::isMpegTS </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02517">2517</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l02693">clang::format::internal::reformat()</a>, and <a class="el" href="Format_8cpp_source.html#l02526">sortIncludes()</a>.</p>

</div>
</div>
<a id="aed9e36e82249b31bbc11ca7bc5f41667" name="aed9e36e82249b31bbc11ca7bc5f41667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9e36e82249b31bbc11ca7bc5f41667">&#9670;&#160;</a></span>isOneChildWithoutMustBreakBefore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::isOneChildWithoutMustBreakBefore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Tok</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TokenAnnotator_8cpp_source.html#l03484">3484</a> of file <a class="el" href="TokenAnnotator_8cpp_source.html">TokenAnnotator.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00438">clang::format::FormatToken::Children</a>, <a class="el" href="FormatToken_8h_source.html#l00253">clang::format::FormatToken::MustBreakBefore</a>, <a class="el" href="FormatToken_8h_source.html#l00434">clang::format::FormatToken::Next</a>, and <a class="el" href="FormatToken_8h_source.html#l00643">Tok</a>.</p>

<p class="reference">Referenced by <a class="el" href="TokenAnnotator_8cpp_source.html#l03500">isAllmanBraceIncludedBreakableLambda()</a>.</p>

</div>
</div>
<a id="a3204de8fb2e07d16a22f24fb7ad9395c" name="a3204de8fb2e07d16a22f24fb7ad9395c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3204de8fb2e07d16a22f24fb7ad9395c">&#9670;&#160;</a></span>make_error_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code clang::format::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a8361fae3448126045290df1a4506c954">ParseError</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l00748">748</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l00744">getParseCategory()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01364">parseConfiguration()</a>.</p>

</div>
</div>
<a id="a253f0600906434207ea8e9a704ca53cf" name="a253f0600906434207ea8e9a704ca53cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253f0600906434207ea8e9a704ca53cf">&#9670;&#160;</a></span>make_string_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Error clang::format::make_string_error </td>
          <td>(</td>
          <td class="paramtype">const llvm::Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>Message</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l00752">752</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l02895">getStyle()</a>.</p>

</div>
</div>
<a id="a5deb7cdaa47a8e54572bc893220e2ea1" name="a5deb7cdaa47a8e54572bc893220e2ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5deb7cdaa47a8e54572bc893220e2ea1">&#9670;&#160;</a></span>maxNestingDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classunsigned.html">unsigned</a> clang::format::maxNestingDepth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1format_1_1AnnotatedLine.html">AnnotatedLine</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Line</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TokenAnnotator_8cpp_source.html#l02313">2313</a> of file <a class="el" href="TokenAnnotator_8cpp_source.html">TokenAnnotator.cpp</a>.</p>

<p class="reference">References <a class="el" href="TokenAnnotator_8h_source.html#l00122">clang::format::AnnotatedLine::First</a>, <a class="el" href="FormatToken_8h_source.html#l00434">clang::format::FormatToken::Next</a>, <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>, and <a class="el" href="FormatToken_8h_source.html#l00643">Tok</a>.</p>

<p class="reference">Referenced by <a class="el" href="TokenAnnotator_8cpp_source.html#l02320">clang::format::TokenAnnotator::annotate()</a>.</p>

</div>
</div>
<a id="abc23931ee38e4d74c645786b0ff5b476" name="abc23931ee38e4d74c645786b0ff5b476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc23931ee38e4d74c645786b0ff5b476">&#9670;&#160;</a></span>mayReflowContent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::mayReflowContent </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Content</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BreakableToken_8cpp_source.html#l00336">336</a> of file <a class="el" href="BreakableToken_8cpp_source.html">BreakableToken.cpp</a>.</p>

<p class="reference">References <a class="el" href="BreakableToken_8cpp_source.html#l00028">Blanks</a>, and <a class="el" href="CharInfo_8h_source.html#l00131">clang::isPunctuation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BreakableToken_8cpp_source.html#l00740">clang::format::BreakableBlockComment::mayReflow()</a>, and <a class="el" href="BreakableToken_8cpp_source.html#l00991">clang::format::BreakableLineCommentSection::mayReflow()</a>.</p>

</div>
</div>
<a id="aae8eae2e84b1c07b32ceabe61a991e76" name="aae8eae2e84b1c07b32ceabe61a991e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8eae2e84b1c07b32ceabe61a991e76">&#9670;&#160;</a></span>mustBeJSIdent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::mustBeJSIdent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1AdditionalKeywords.html">AdditionalKeywords</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Keywords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> *</td>          <td class="paramname"><span class="paramname"><em>FormatTok</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UnwrappedLineParser_8cpp_source.html#l00953">953</a> of file <a class="el" href="UnwrappedLineParser_8cpp_source.html">UnwrappedLineParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="Token_8h_source.html#l00179">clang::Token::getIdentifierInfo()</a>, <a class="el" href="FormatToken_8h_source.html#l00444">clang::format::FormatToken::is()</a>, <a class="el" href="FormatToken_8h_source.html#l00456">clang::format::FormatToken::isOneOf()</a>, and <a class="el" href="FormatToken_8h_source.html#l00222">clang::format::FormatToken::Tok</a>.</p>

<p class="reference">Referenced by <a class="el" href="UnwrappedLineParser_8cpp_source.html#l00968">mustBeJSIdentOrValue()</a>.</p>

</div>
</div>
<a id="a11d6f2b231494481c6c272127678bcda" name="a11d6f2b231494481c6c272127678bcda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d6f2b231494481c6c272127678bcda">&#9670;&#160;</a></span>mustBeJSIdentOrValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::mustBeJSIdentOrValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1AdditionalKeywords.html">AdditionalKeywords</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Keywords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> *</td>          <td class="paramname"><span class="paramname"><em>FormatTok</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UnwrappedLineParser_8cpp_source.html#l00968">968</a> of file <a class="el" href="UnwrappedLineParser_8cpp_source.html">UnwrappedLineParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="Token_8h_source.html#l00115">clang::Token::isLiteral()</a>, <a class="el" href="FormatToken_8h_source.html#l00456">clang::format::FormatToken::isOneOf()</a>, <a class="el" href="UnwrappedLineParser_8cpp_source.html#l00953">mustBeJSIdent()</a>, and <a class="el" href="FormatToken_8h_source.html#l00222">clang::format::FormatToken::Tok</a>.</p>

</div>
</div>
<a id="ac5d340642f13213a59fae88b75ba90a4" name="ac5d340642f13213a59fae88b75ba90a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d340642f13213a59fae88b75ba90a4">&#9670;&#160;</a></span>opensBlockOrBlockTypeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::opensBlockOrBlockTypeList </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this tokens starts a block-type list, i.e. a list that should be indented with a block indent. </p>

<p class="definition">Definition at line <a class="el" href="FormatToken_8h_source.html#l00649">649</a> of file <a class="el" href="FormatToken_8h_source.html">FormatToken.h</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00137">BK_BracedInit</a>, <a class="el" href="FormatToken_8h_source.html#l00290">clang::format::FormatToken::getBlockKind()</a>, and <a class="el" href="FormatToken_8h_source.html#l00444">clang::format::FormatToken::is()</a>.</p>

</div>
</div>
<a id="ad1b2615bf03f2292639e2905a27f0929" name="ad1b2615bf03f2292639e2905a27f0929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b2615bf03f2292639e2905a27f0929">&#9670;&#160;</a></span>opensProtoMessageField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::opensProtoMessageField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>LessTok</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ContinuationIndenter_8cpp_source.html#l00136">136</a> of file <a class="el" href="ContinuationIndenter_8cpp_source.html">ContinuationIndenter.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00444">clang::format::FormatToken::is()</a>, <a class="el" href="FormatToken_8h_source.html#l00463">clang::format::FormatToken::isNot()</a>, <a class="el" href="FormatToken_8h_source.html#l00385">clang::format::FormatToken::NestingLevel</a>, and <a class="el" href="FormatToken_8h_source.html#l00431">clang::format::FormatToken::Previous</a>.</p>

<p class="reference">Referenced by <a class="el" href="ContinuationIndenter_8cpp_source.html#l00329">clang::format::ContinuationIndenter::mustBreak()</a>.</p>

</div>
</div>
<a id="a95d089be8c5aab299d138d9df155fcef" name="a95d089be8c5aab299d138d9df155fcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d089be8c5aab299d138d9df155fcef">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1JsModuleReference.html">JsModuleReference</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>LHS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1JsModuleReference.html">JsModuleReference</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>RHS</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SortJavaScriptImports_8cpp_source.html#l00093">93</a> of file <a class="el" href="SortJavaScriptImports_8cpp_source.html">SortJavaScriptImports.cpp</a>.</p>

<p class="reference">References <a class="el" href="SortJavaScriptImports_8cpp_source.html#l00080">clang::format::JsModuleReference::Category</a>, <a class="el" href="SortJavaScriptImports_8cpp_source.html#l00072">clang::format::JsModuleReference::IsExport</a>, <a class="el" href="SortJavaScriptImports_8cpp_source.html#l00085">clang::format::JsModuleReference::Prefix</a>, <a class="el" href="SortJavaScriptImports_8cpp_source.html#l00075">clang::format::JsModuleReference::SIDE_EFFECT</a>, and <a class="el" href="SortJavaScriptImports_8cpp_source.html#l00082">clang::format::JsModuleReference::URL</a>.</p>

</div>
</div>
<a id="a7cf0f004f086333441812832af92aadc" name="a7cf0f004f086333441812832af92aadc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf0f004f086333441812832af92aadc">&#9670;&#160;</a></span>parseConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code clang::format::parseConfiguration </td>
          <td>(</td>
          <td class="paramtype">llvm::MemoryBufferRef</td>          <td class="paramname"><span class="paramname"><em>Config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FormatStyle *</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>AllowUnknownOptions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l01364">1364</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a8361fae3448126045290df1a4506c954aa9b40ec5afeefed5b4c02dddfef2a294">BinPackTrailingCommaConflict</a>, <a class="el" href="#a8361fae3448126045290df1a4506c954a902b0d55fddef6f8d651fe1035b7d4bd">Error</a>, <a class="el" href="Format_8cpp_source.html#l00748">make_error_code()</a>, <a class="el" href="#a8361fae3448126045290df1a4506c954a505a83f220c02df2f85c3810cd9ceb38">Success</a>, and <a class="el" href="#a8361fae3448126045290df1a4506c954a91957bd1005afd35f28861fe81992ee0">Unsuitable</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l02895">getStyle()</a>.</p>

</div>
</div>
<a id="a5f2036244f1c590e57ecacc143ba9a79" name="a5f2036244f1c590e57ecacc143ba9a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2036244f1c590e57ecacc143ba9a79">&#9670;&#160;</a></span>printDebugInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LLVM_ATTRIBUTE_UNUSED void clang::format::printDebugInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1UnwrappedLine.html">UnwrappedLine</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UnwrappedLineParser_8cpp_source.html#l02928">2928</a> of file <a class="el" href="UnwrappedLineParser_8cpp_source.html">UnwrappedLineParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="TokenAnnotator_8h_source.html#l00147">clang::format::AnnotatedLine::FirstStartColumn</a>, <a class="el" href="TokenAnnotator_8h_source.html#l00131">clang::format::AnnotatedLine::InPPDirective</a>, <a class="el" href="TokenAnnotator_8h_source.html#l00128">clang::format::AnnotatedLine::Level</a>, <a class="el" href="ASTMatchFinder_8cpp_source.html#l00067">Node</a>, and <a class="el" href="UnwrappedLineParser_8cpp_source.html#l02928">printDebugInfo()</a>.</p>

<p class="reference">Referenced by <a class="el" href="UnwrappedLineParser_8cpp_source.html#l02928">printDebugInfo()</a>.</p>

</div>
</div>
<a id="a4b1aa262e52e1123db1dc04d007423e5" name="a4b1aa262e52e1123db1dc04d007423e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1aa262e52e1123db1dc04d007423e5">&#9670;&#160;</a></span>processReplacements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Expected.html">llvm::Expected</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &gt; clang::format::processReplacements </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>ProcessFunc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Replaces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02547">2547</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Replacement_8h_source.html#l00278">clang::tooling::Replacements::begin()</a>, <a class="el" href="Replacement_8h_source.html#l00276">clang::tooling::Replacements::empty()</a>, <a class="el" href="Replacement_8cpp_source.html#l00534">clang::tooling::Replacements::getAffectedRanges()</a>, and <a class="el" href="Replacement_8cpp_source.html#l00443">clang::tooling::Replacements::merge()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l02676">cleanupAroundReplacements()</a>, and <a class="el" href="Format_8cpp_source.html#l02566">formatReplacements()</a>.</p>

</div>
</div>
<a id="a89e601c265faac6784717f9cfb0aad6d" name="a89e601c265faac6784717f9cfb0aad6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e601c265faac6784717f9cfb0aad6d">&#9670;&#160;</a></span>reformat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> clang::format::reformat </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Ranges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>FileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> *</td>          <td class="paramname"><span class="paramname"><em>IncompleteFormat</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02785">2785</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l02765">reformat()</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="a277c8b4d6e86b42cfc60b2fdd51652de" name="a277c8b4d6e86b42cfc60b2fdd51652de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277c8b4d6e86b42cfc60b2fdd51652de">&#9670;&#160;</a></span>reformat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> clang::format::reformat </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Ranges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>FileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FormattingAttemptStatus *</td>          <td class="paramname"><span class="paramname"><em>Status</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02765">2765</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l02693">clang::format::internal::reformat()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AtomicChange_8cpp_source.html#l00301">clang::tooling::applyAtomicChanges()</a>, <a class="el" href="Format_8cpp_source.html#l02566">formatReplacements()</a>, and <a class="el" href="Format_8cpp_source.html#l02785">reformat()</a>.</p>

</div>
</div>
<a id="a2e43d46c0fc19789278de9a6e926dcab" name="a2e43d46c0fc19789278de9a6e926dcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e43d46c0fc19789278de9a6e926dcab">&#9670;&#160;</a></span>replaceCRLF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string clang::format::replaceCRLF </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>Code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02168">2168</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l02196">sortCppIncludes()</a>, and <a class="el" href="Format_8cpp_source.html#l02385">sortJavaImports()</a>.</p>

</div>
</div>
<a id="a9af388270e2a22fe9447e697ead1a941" name="a9af388270e2a22fe9447e697ead1a941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af388270e2a22fe9447e697ead1a941">&#9670;&#160;</a></span>ShouldBreakBeforeBrace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::ShouldBreakBeforeBrace </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>InitialToken</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UnwrappedLineParser_8cpp_source.html#l00700">700</a> of file <a class="el" href="UnwrappedLineParser_8cpp_source.html">UnwrappedLineParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00444">clang::format::FormatToken::is()</a>, and <a class="el" href="FormatToken_8h_source.html#l00456">clang::format::FormatToken::isOneOf()</a>.</p>

</div>
</div>
<a id="a8b8445c626e0e6239a9c10931ae56700" name="a8b8445c626e0e6239a9c10931ae56700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8445c626e0e6239a9c10931ae56700">&#9670;&#160;</a></span>shouldIndentWrappedSelectorName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::shouldIndentWrappedSelectorName </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af1aa248193ce0aa256a43af928d62171">LineType</a></td>          <td class="paramname"><span class="paramname"><em>LineType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ContinuationIndenter_8cpp_source.html#l00030">30</a> of file <a class="el" href="ContinuationIndenter_8cpp_source.html">ContinuationIndenter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TokenAnnotator_8h_source.html#l00030">LT_ObjCMethodDecl</a>.</p>

</div>
</div>
<a id="af102889ff4692be283f2164fe7106c11" name="af102889ff4692be283f2164fe7106c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af102889ff4692be283f2164fe7106c11">&#9670;&#160;</a></span>sortCppIncludes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void clang::format::sortCppIncludes </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; IncludeDirective &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Includes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Ranges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>FileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Replaces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *</td>          <td class="paramname"><span class="paramname"><em>Cursor</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02196">2196</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Replacement_8cpp_source.html#l00245">clang::tooling::Replacements::add()</a>, <a class="el" href="Format_8cpp_source.html#l02129">affectsRange()</a>, <a class="el" href="Format_8cpp_source.html#l02111">Filename</a>, <a class="el" href="Format_8cpp_source.html#l02147">FindCursorIndex()</a>, <a class="el" href="IncludeStyle_8h_source.html#l00030">clang::tooling::IncludeStyle::IBS_Preserve</a>, <a class="el" href="IncludeStyle_8h_source.html#l00048">clang::tooling::IncludeStyle::IBS_Regroup</a>, and <a class="el" href="Format_8cpp_source.html#l02168">replaceCRLF()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l02283">sortCppIncludes()</a>, and <a class="el" href="Format_8cpp_source.html#l02526">sortIncludes()</a>.</p>

</div>
</div>
<a id="a666e2d158cd26ea76bc7583887a65a0e" name="a666e2d158cd26ea76bc7583887a65a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666e2d158cd26ea76bc7583887a65a0e">&#9670;&#160;</a></span>sortCppIncludes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> clang::format::sortCppIncludes </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Ranges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>FileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Replaces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *</td>          <td class="paramname"><span class="paramname"><em>Cursor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02283">2283</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l02114">Category</a>, <a class="el" href="HeaderIncludes_8cpp_source.html#l00208">clang::tooling::IncludeCategoryManager::getIncludePriority()</a>, <a class="el" href="HeaderIncludes_8cpp_source.html#l00221">clang::tooling::IncludeCategoryManager::getSortIncludePriority()</a>, <a class="el" href="IncludeStyle_8h_source.html#l00038">clang::tooling::IncludeStyle::IBS_Merge</a>, <a class="el" href="IncludeStyle_8h_source.html#l00048">clang::tooling::IncludeStyle::IBS_Regroup</a>, and <a class="el" href="Format_8cpp_source.html#l02196">sortCppIncludes()</a>.</p>

</div>
</div>
<a id="ab10c25d07fe088e876a859f227e7eb86" name="ab10c25d07fe088e876a859f227e7eb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10c25d07fe088e876a859f227e7eb86">&#9670;&#160;</a></span>sortIncludes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> clang::format::sortIncludes </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Ranges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>FileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *</td>          <td class="paramname"><span class="paramname"><em>Cursor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02526">2526</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l02524">isLikelyXml()</a>, <a class="el" href="Format_8cpp_source.html#l02517">isMpegTS()</a>, <a class="el" href="Format_8cpp_source.html#l02196">sortCppIncludes()</a>, <a class="el" href="Format_8cpp_source.html#l02385">sortJavaImports()</a>, and <a class="el" href="SortJavaScriptImports_8cpp_source.html#l00440">sortJavaScriptImports()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AtomicChange_8cpp_source.html#l00301">clang::tooling::applyAtomicChanges()</a>, and <a class="el" href="Format_8cpp_source.html#l02566">formatReplacements()</a>.</p>

</div>
</div>
<a id="ab51fc90a80b779f1af6ac93704d3b275" name="ab51fc90a80b779f1af6ac93704d3b275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51fc90a80b779f1af6ac93704d3b275">&#9670;&#160;</a></span>sortJavaImports() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void clang::format::sortJavaImports </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; JavaImportDirective &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Imports</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Ranges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>FileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Replaces</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02385">2385</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Replacement_8cpp_source.html#l00245">clang::tooling::Replacements::add()</a>, <a class="el" href="Format_8cpp_source.html#l02129">affectsRange()</a>, <a class="el" href="Format_8cpp_source.html#l02122">AssociatedCommentLines</a>, <a class="el" href="Format_8cpp_source.html#l02365">findJavaImportGroup()</a>, <a class="el" href="Format_8cpp_source.html#l02119">Identifier</a>, <a class="el" href="Format_8cpp_source.html#l02123">IsStatic</a>, and <a class="el" href="Format_8cpp_source.html#l02168">replaceCRLF()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l02526">sortIncludes()</a>, and <a class="el" href="Format_8cpp_source.html#l02464">sortJavaImports()</a>.</p>

</div>
</div>
<a id="aab55f9f5072a8256c6e413fea200c66c" name="aab55f9f5072a8256c6e413fea200c66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab55f9f5072a8256c6e413fea200c66c">&#9670;&#160;</a></span>sortJavaImports() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> clang::format::sortJavaImports </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Ranges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>FileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Replaces</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02464">2464</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l02122">AssociatedCommentLines</a>, <a class="el" href="Format_8cpp_source.html#l02119">Identifier</a>, <a class="el" href="Format_8cpp_source.html#l02123">IsStatic</a>, and <a class="el" href="Format_8cpp_source.html#l02385">sortJavaImports()</a>.</p>

</div>
</div>
<a id="aa2651f32d54bc0e73608c207815ef665" name="aa2651f32d54bc0e73608c207815ef665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2651f32d54bc0e73608c207815ef665">&#9670;&#160;</a></span>sortJavaScriptImports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> clang::format::sortJavaScriptImports </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Ranges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>FileName</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SortJavaScriptImports_8cpp_source.html#l00440">440</a> of file <a class="el" href="SortJavaScriptImports_8cpp_source.html">SortJavaScriptImports.cpp</a>.</p>

<p class="reference">References <a class="el" href="TokenAnalyzer_8cpp_source.html#l00065">clang::format::TokenAnalyzer::process()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l02526">sortIncludes()</a>.</p>

</div>
</div>
<a id="a2b8b00f65922e74228424df219c28489" name="a2b8b00f65922e74228424df219c28489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8b00f65922e74228424df219c28489">&#9670;&#160;</a></span>sortUsingDeclarations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> clang::format::sortUsingDeclarations </td>
          <td>(</td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1tooling_1_1Range.html">tooling::Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Ranges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>FileName</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02804">2804</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="TokenAnalyzer_8cpp_source.html#l00065">clang::format::TokenAnalyzer::process()</a>.</p>

</div>
</div>
<a id="a863a7a3fcf1022607339341a698df78d" name="a863a7a3fcf1022607339341a698df78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863a7a3fcf1022607339341a698df78d">&#9670;&#160;</a></span>startsNextParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::startsNextParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Current</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FormatStyle &amp;</td>          <td class="paramname"><span class="paramname"><em>Style</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ContinuationIndenter_8cpp_source.html#l00120">120</a> of file <a class="el" href="ContinuationIndenter_8cpp_source.html">ContinuationIndenter.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00444">clang::format::FormatToken::is()</a>, <a class="el" href="FormatToken_8h_source.html#l00463">clang::format::FormatToken::isNot()</a>, <a class="el" href="FormatToken_8h_source.html#l00431">clang::format::FormatToken::Previous</a>, and <a class="el" href="FormatToken_8h_source.html#l00852">Previous</a>.</p>

<p class="reference">Referenced by <a class="el" href="ContinuationIndenter_8cpp_source.html#l00329">clang::format::ContinuationIndenter::mustBreak()</a>.</p>

</div>
</div>
<a id="a77277e89c12de4c668b790cd02b9ae14" name="a77277e89c12de4c668b790cd02b9ae14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77277e89c12de4c668b790cd02b9ae14">&#9670;&#160;</a></span>startsSegmentOfBuilderTypeCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::startsSegmentOfBuilderTypeCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Tok</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ContinuationIndenter_8cpp_source.html#l00115">115</a> of file <a class="el" href="ContinuationIndenter_8cpp_source.html">ContinuationIndenter.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00643">Tok</a>.</p>

<p class="reference">Referenced by <a class="el" href="ContinuationIndenter_8cpp_source.html#l00329">clang::format::ContinuationIndenter::mustBreak()</a>.</p>

</div>
</div>
<a id="a5fc087ad9babe720e69f71329042d17d" name="a5fc087ad9babe720e69f71329042d17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc087ad9babe720e69f71329042d17d">&#9670;&#160;</a></span>switchesFormatting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::switchesFormatting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Token</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code><a class="el" href="classclang_1_1Token.html" title="Token - This structure provides full information about a lexed token.">Token</a></code> switches formatting, like /* clang-format off *&zwj;/. </p>
<p><code><a class="el" href="classclang_1_1Token.html" title="Token - This structure provides full information about a lexed token.">Token</a></code> must be a comment. </p>

<p class="definition">Definition at line <a class="el" href="BreakableToken_8cpp_source.html#l00219">219</a> of file <a class="el" href="BreakableToken_8cpp_source.html">BreakableToken.cpp</a>.</p>

<p class="reference">References <a class="el" href="Token_8h_source.html#l00097">clang::Token::is()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BreakableToken_8cpp_source.html#l00740">clang::format::BreakableBlockComment::mayReflow()</a>, and <a class="el" href="BreakableToken_8cpp_source.html#l00991">clang::format::BreakableLineCommentSection::mayReflow()</a>.</p>

</div>
</div>
<a id="a4170e2033d41c34c0b47ab551b8110d1" name="a4170e2033d41c34c0b47ab551b8110d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4170e2033d41c34c0b47ab551b8110d1">&#9670;&#160;</a></span>tokenCanStartNewLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::tokenCanStartNewLine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatToken.html">FormatToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Tok</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UnwrappedLineParser_8cpp_source.html#l00927">927</a> of file <a class="el" href="UnwrappedLineParser_8cpp_source.html">UnwrappedLineParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00643">Tok</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0139f59128492a6bf38328cf67a8cc82" name="a0139f59128492a6bf38328cf67a8cc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0139f59128492a6bf38328cf67a8cc82">&#9670;&#160;</a></span>Blanks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringRef clang::format::Blanks = &quot; \t\v\f\r&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BreakableToken_8cpp_source.html#l00028">28</a> of file <a class="el" href="BreakableToken_8cpp_source.html">BreakableToken.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BreakableToken_8cpp_source.html#l00677">clang::format::BreakableBlockComment::adaptStartOfLine()</a>, <a class="el" href="BreakableToken_8cpp_source.html#l00753">clang::format::BreakableLineCommentSection::BreakableLineCommentSection()</a>, <a class="el" href="BreakableToken_8cpp_source.html#l00068">getCommentSplit()</a>, <a class="el" href="BreakableToken_8cpp_source.html#l00582">clang::format::BreakableBlockComment::getContentIndent()</a>, <a class="el" href="BreakableToken_8cpp_source.html#l00632">clang::format::BreakableBlockComment::getReflowSplit()</a>, <a class="el" href="BreakableToken_8cpp_source.html#l00879">clang::format::BreakableLineCommentSection::getReflowSplit()</a>, <a class="el" href="BreakableToken_8cpp_source.html#l00727">clang::format::BreakableBlockComment::getSplitAfterLastLine()</a>, <a class="el" href="BreakableToken_8cpp_source.html#l00650">clang::format::BreakableBlockComment::introducesBreakBeforeToken()</a>, <a class="el" href="BreakableToken_8cpp_source.html#l00740">clang::format::BreakableBlockComment::mayReflow()</a>, <a class="el" href="BreakableToken_8cpp_source.html#l00336">mayReflowContent()</a>, and <a class="el" href="BreakableToken_8cpp_source.html#l00656">clang::format::BreakableBlockComment::reflow()</a>.</p>

</div>
</div>
<a id="a335725622d34fd0f5d0caec296010195" name="a335725622d34fd0f5d0caec296010195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335725622d34fd0f5d0caec296010195">&#9670;&#160;</a></span>DefaultFallbackStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* clang::format::DefaultFallbackStyle = &quot;LLVM&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02893">2893</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

</div>
</div>
<a id="a47454fe750136909d455c39ac6c3fa59" name="a47454fe750136909d455c39ac6c3fa59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47454fe750136909d455c39ac6c3fa59">&#9670;&#160;</a></span>DefaultFormatStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* clang::format::DefaultFormatStyle = &quot;file&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02891">2891</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

</div>
</div>
<a id="a2ad333f1c207f36ba93dedefbec3bd81" name="a2ad333f1c207f36ba93dedefbec3bd81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad333f1c207f36ba93dedefbec3bd81">&#9670;&#160;</a></span>StyleOptionHelpDescription</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* clang::format::StyleOptionHelpDescription</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <span class="stringliteral">&quot;Coding style, currently supports:\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  LLVM, GNU, Google, Chromium, Microsoft, Mozilla, WebKit.\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;Use -style=file to load style configuration from\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;.clang-format file located in one of the parent\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;directories of the source file (or current\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;directory for stdin).\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;Use -style=\&quot;{key: value, ...}\&quot; to set specific\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;parameters, e.g.:\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  -style=\&quot;{BasedOnStyle: llvm, IndentWidth: 8}\&quot;&quot;</span></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02839">2839</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 8 2024 10:08:25 for clang by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
