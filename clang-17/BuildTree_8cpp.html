<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: lib/Tooling/Syntax/BuildTree.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">clang<span id="projectnumber">&#160;17.0.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_c4270fa7a06cd7372c7af2452fb3367e.html">Tooling</a></li><li class="navelem"><a class="el" href="dir_b207e0eda86654f1f9e47751ddd3b478.html">Syntax</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">BuildTree.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="BuildTree_8h_source.html">clang/Tooling/Syntax/BuildTree.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ASTFwd_8h_source.html">clang/AST/ASTFwd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Decl_8h_source.html">clang/AST/Decl.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DeclBase_8h_source.html">clang/AST/DeclBase.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DeclCXX_8h_source.html">clang/AST/DeclCXX.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DeclarationName_8h_source.html">clang/AST/DeclarationName.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Expr_8h_source.html">clang/AST/Expr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ExprCXX_8h_source.html">clang/AST/ExprCXX.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IgnoreExpr_8h_source.html">clang/AST/IgnoreExpr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="OperationKinds_8h_source.html">clang/AST/OperationKinds.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="RecursiveASTVisitor_8h_source.html">clang/AST/RecursiveASTVisitor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Stmt_8h_source.html">clang/AST/Stmt.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TypeLoc_8h_source.html">clang/AST/TypeLoc.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TypeLocVisitor_8h_source.html">clang/AST/TypeLocVisitor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LLVM_8h_source.html">clang/Basic/LLVM.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SourceLocation_8h_source.html">clang/Basic/SourceLocation.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SourceManager_8h_source.html">clang/Basic/SourceManager.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Specifiers_8h_source.html">clang/Basic/Specifiers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TokenKinds_8h_source.html">clang/Basic/TokenKinds.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Lexer_8h_source.html">clang/Lex/Lexer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LiteralSupport_8h_source.html">clang/Lex/LiteralSupport.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Nodes_8h_source.html">clang/Tooling/Syntax/Nodes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TokenBufferTokenManager_8h_source.html">clang/Tooling/Syntax/TokenBufferTokenManager.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Tokens_8h_source.html">clang/Tooling/Syntax/Tokens.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Tree_8h_source.html">clang/Tooling/Syntax/Tree.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/ArrayRef.h&quot;</code><br />
<code>#include &quot;llvm/ADT/DenseMap.h&quot;</code><br />
<code>#include &quot;llvm/ADT/PointerUnion.h&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/ScopeExit.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallVector.h&quot;</code><br />
<code>#include &quot;llvm/Support/Allocator.h&quot;</code><br />
<code>#include &quot;llvm/Support/Casting.h&quot;</code><br />
<code>#include &quot;llvm/Support/Compiler.h&quot;</code><br />
<code>#include &quot;llvm/Support/FormatVariadic.h&quot;</code><br />
<code>#include &quot;llvm/Support/MemoryBuffer.h&quot;</code><br />
<code>#include &quot;llvm/Support/raw_ostream.h&quot;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
</div>
<p><a href="BuildTree_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af72714cd1bb2d0d6627db5a14dc52f97" id="r_af72714cd1bb2d0d6627db5a14dc52f97"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1Expr.html">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af72714cd1bb2d0d6627db5a14dc52f97">IgnoreImplicitConstructorSingleStep</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a> *E)</td></tr>
<tr class="separator:af72714cd1bb2d0d6627db5a14dc52f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49e6638d8b070ccf2a29578a5055d7a" id="r_ab49e6638d8b070ccf2a29578a5055d7a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1Expr.html">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab49e6638d8b070ccf2a29578a5055d7a">IgnoreCXXFunctionalCastExprWrappingConstructor</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a> *E)</td></tr>
<tr class="separator:ab49e6638d8b070ccf2a29578a5055d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7973a80f08272178071162f509a04caf" id="r_a7973a80f08272178071162f509a04caf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1Expr.html">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7973a80f08272178071162f509a04caf">IgnoreImplicit</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a> *E)</td></tr>
<tr class="separator:a7973a80f08272178071162f509a04caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa618e237633bf63db8b922315aaa6d37" id="r_aa618e237633bf63db8b922315aaa6d37"><td class="memItemLeft" align="right" valign="top">static LLVM_ATTRIBUTE_UNUSED <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa618e237633bf63db8b922315aaa6d37">isImplicitExpr</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a> *E)</td></tr>
<tr class="separator:aa618e237633bf63db8b922315aaa6d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd4838c55f172277e52e0ad6572779c" id="r_a9cd4838c55f172277e52e0ad6572779c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1CallExpr.html#ab15c738b5609b17c71c171b1600120e9">CallExpr::arg_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cd4838c55f172277e52e0ad6572779c">dropDefaultArgs</a> (<a class="el" href="classclang_1_1CallExpr.html#ab15c738b5609b17c71c171b1600120e9">CallExpr::arg_range</a> Args)</td></tr>
<tr class="separator:a9cd4838c55f172277e52e0ad6572779c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac17857e32f3f7db7bacfd1c5493f01" id="r_abac17857e32f3f7db7bacfd1c5493f01"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceclang_1_1syntax.html#a81b5b8b797bac504f7538749a7bb0a2a">syntax::NodeKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abac17857e32f3f7db7bacfd1c5493f01">getOperatorNodeKind</a> (const <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a> &amp;E)</td></tr>
<tr class="separator:abac17857e32f3f7db7bacfd1c5493f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdf5828a4279d1000dcbdfd72e2c558" id="r_accdf5828a4279d1000dcbdfd72e2c558"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accdf5828a4279d1000dcbdfd72e2c558">getQualifiedNameStart</a> (<a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> *D)</td></tr>
<tr class="memdesc:accdf5828a4279d1000dcbdfd72e2c558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the start of the qualified name.  <br /></td></tr>
<tr class="separator:accdf5828a4279d1000dcbdfd72e2c558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf06269ea7a064d93921be359ff6ee73" id="r_abf06269ea7a064d93921be359ff6ee73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf06269ea7a064d93921be359ff6ee73">if</a> (!Range.getBegin().isValid())</td></tr>
<tr class="memdesc:abf06269ea7a064d93921be359ff6ee73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the range of the initializer inside an init-declarator C++ [dcl.decl].  <br /></td></tr>
<tr class="separator:abf06269ea7a064d93921be359ff6ee73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae9f975f03a7f0af0d1440f8511bdba" id="r_a7ae9f975f03a7f0af0d1440f8511bdba"><td class="memItemLeft" align="right" valign="top">Builder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ae9f975f03a7f0af0d1440f8511bdba">foldNode</a> (<a class="el" href="SourceCode_8cpp.html#ac784043095c8193a7562afebf09bdc23">Builder.getRange</a>(Range), <a class="el" href="#ab409187cd8023f701425d74753612d6b">N</a>, nullptr)</td></tr>
<tr class="separator:a7ae9f975f03a7f0af0d1440f8511bdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0107a1154a69cd7c01e3d686a3fdc0" id="r_afc0107a1154a69cd7c01e3d686a3fdc0"><td class="memItemLeft" align="right" valign="top">Builder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc0107a1154a69cd7c01e3d686a3fdc0">markChild</a> (<a class="el" href="#ab409187cd8023f701425d74753612d6b">N</a>, syntax::NodeRole::ListElement)</td></tr>
<tr class="separator:afc0107a1154a69cd7c01e3d686a3fdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93378d2c3c4cf7aa9c7e436efc5b5708" id="r_a93378d2c3c4cf7aa9c7e436efc5b5708"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93378d2c3c4cf7aa9c7e436efc5b5708">if</a> (!Builder.isResponsibleForCreatingDeclaration(D))</td></tr>
<tr class="separator:a93378d2c3c4cf7aa9c7e436efc5b5708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80704734b581154bcaba48045d7a1527" id="r_a80704734b581154bcaba48045d7a1527"><td class="memItemLeft" align="right" valign="top">Builder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80704734b581154bcaba48045d7a1527">foldList</a> (<a class="el" href="#aed67ee690ac5ba179fccb86950a6afd9">DeclarationRange</a>, DL, nullptr)</td></tr>
<tr class="separator:a80704734b581154bcaba48045d7a1527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c2afcea856b997b355479c3bc49410" id="r_aa6c2afcea856b997b355479c3bc49410"><td class="memItemLeft" align="right" valign="top">Builder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6c2afcea856b997b355479c3bc49410">markChild</a> (DL, syntax::NodeRole::Declarators)</td></tr>
<tr class="separator:aa6c2afcea856b997b355479c3bc49410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6bd65a985784f1f100fdfb844dcb5d" id="r_a9a6bd65a985784f1f100fdfb844dcb5d"><td class="memItemLeft" align="right" valign="top">Builder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a6bd65a985784f1f100fdfb844dcb5d">foldNode</a> (<a class="el" href="#aed67ee690ac5ba179fccb86950a6afd9">DeclarationRange</a>, new(<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2">allocator</a>()) <a class="el" href="classclang_1_1syntax_1_1SimpleDeclaration.html">syntax::SimpleDeclaration</a>, D)</td></tr>
<tr class="separator:a9a6bd65a985784f1f100fdfb844dcb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4088f0b8f02f25bcfbdcd31a94643d5" id="r_ac4088f0b8f02f25bcfbdcd31a94643d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1syntax_1_1TrailingReturnType.html">syntax::TrailingReturnType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4088f0b8f02f25bcfbdcd31a94643d5">buildTrailingReturn</a> (<a class="el" href="classclang_1_1FunctionProtoTypeLoc.html">FunctionProtoTypeLoc</a> L)</td></tr>
<tr class="memdesc:ac4088f0b8f02f25bcfbdcd31a94643d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the range of the built node.  <br /></td></tr>
<tr class="separator:ac4088f0b8f02f25bcfbdcd31a94643d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbbe5d25bd50a4428043a606a1749d1" id="r_a6cbbe5d25bd50a4428043a606a1749d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cbbe5d25bd50a4428043a606a1749d1">foldExplicitTemplateInstantiation</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt; Range, const <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> *ExternKW, const <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> *TemplateKW, <a class="el" href="classclang_1_1syntax_1_1SimpleDeclaration.html">syntax::SimpleDeclaration</a> *InnerDeclaration, <a class="el" href="classclang_1_1Decl.html">Decl</a> *From)</td></tr>
<tr class="separator:a6cbbe5d25bd50a4428043a606a1749d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7937d74c1508b3719dad9dbb65e69ec" id="r_af7937d74c1508b3719dad9dbb65e69ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1syntax_1_1TemplateDeclaration.html">syntax::TemplateDeclaration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7937d74c1508b3719dad9dbb65e69ec">foldTemplateDeclaration</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt; Range, const <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> *TemplateKW, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt; TemplatedDeclaration, <a class="el" href="classclang_1_1Decl.html">Decl</a> *From)</td></tr>
<tr class="separator:af7937d74c1508b3719dad9dbb65e69ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94093fefa46a9c9540e2f49b161aac2" id="r_ab94093fefa46a9c9540e2f49b161aac2"><td class="memItemLeft" align="right" valign="top">llvm::BumpPtrAllocator &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2">allocator</a> ()</td></tr>
<tr class="memdesc:ab94093fefa46a9c9540e2f49b161aac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small helper to save some typing.  <br /></td></tr>
<tr class="separator:ab94093fefa46a9c9540e2f49b161aac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab409187cd8023f701425d74753612d6b" id="r_ab409187cd8023f701425d74753612d6b"><td class="memItemLeft" align="right" valign="top">auto *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab409187cd8023f701425d74753612d6b">N</a> = new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2">allocator</a>()) <a class="el" href="classclang_1_1syntax_1_1SimpleDeclarator.html">syntax::SimpleDeclarator</a></td></tr>
<tr class="separator:ab409187cd8023f701425d74753612d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0544c3fe466e421738dae463968b70ba" id="r_a0544c3fe466e421738dae463968b70ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0544c3fe466e421738dae463968b70ba">else</a></td></tr>
<tr class="separator:a0544c3fe466e421738dae463968b70ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed67ee690ac5ba179fccb86950a6afd9" id="r_aed67ee690ac5ba179fccb86950a6afd9"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed67ee690ac5ba179fccb86950a6afd9">DeclarationRange</a> = Builder.getDeclarationRange(D)</td></tr>
<tr class="separator:aed67ee690ac5ba179fccb86950a6afd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930920b2bc42824a5c03be681830f4b2" id="r_a930920b2bc42824a5c03be681830f4b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm__acle_8h.html#a82c9b0d3112c0f958c62a5f94d329d7b">return</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a930920b2bc42824a5c03be681830f4b2">true</a></td></tr>
<tr class="separator:a930920b2bc42824a5c03be681830f4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87dc9caf4e431513d7b0ca4bb389a25" id="r_aa87dc9caf4e431513d7b0ca4bb389a25"><td class="memItemLeft" align="right" valign="top">syntax::TreeBuilder &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa87dc9caf4e431513d7b0ca4bb389a25">Builder</a></td></tr>
<tr class="separator:aa87dc9caf4e431513d7b0ca4bb389a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aeaeb39eb301ad5f1a31cad0934e732" id="r_a3aeaeb39eb301ad5f1a31cad0934e732"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aeaeb39eb301ad5f1a31cad0934e732">Context</a></td></tr>
<tr class="separator:a3aeaeb39eb301ad5f1a31cad0934e732"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab94093fefa46a9c9540e2f49b161aac2" name="ab94093fefa46a9c9540e2f49b161aac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94093fefa46a9c9540e2f49b161aac2">&#9670;&#160;</a></span>allocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::BumpPtrAllocator &amp; allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A small helper to save some typing. </p>

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l01677">1677</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BuildTree_8cpp_source.html#l01624">buildTrailingReturn()</a>, <a class="el" href="BuildTree_8cpp_source.html#l01651">foldExplicitTemplateInstantiation()</a>, <a class="el" href="BuildTree_8cpp_source.html#l01664">foldTemplateDeclaration()</a>, and <a class="el" href="BuildTree_8cpp_source.html#l01593">if()</a>.</p>

</div>
</div>
<a id="ac4088f0b8f02f25bcfbdcd31a94643d5" name="ac4088f0b8f02f25bcfbdcd31a94643d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4088f0b8f02f25bcfbdcd31a94643d5">&#9670;&#160;</a></span>buildTrailingReturn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1syntax_1_1TrailingReturnType.html">syntax::TrailingReturnType</a> * buildTrailingReturn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FunctionProtoTypeLoc.html">FunctionProtoTypeLoc</a></td>          <td class="paramname"><span class="paramname"><em>L</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the range of the built node. </p>

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l01624">1624</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuildTree_8cpp_source.html#l01677">allocator()</a>, <a class="el" href="TypeLoc_8h_source.html#l01472">clang::FunctionTypeLoc::getReturnLoc()</a>, <a class="el" href="TypeLoc_8h_source.html#l00507">clang::InheritingConcreteTypeLoc&lt; Base, Derived, TypeClass &gt;::getTypePtr()</a>, and <a class="el" href="Type_8h_source.html#l04419">clang::FunctionProtoType::hasTrailingReturn()</a>.</p>

</div>
</div>
<a id="a9cd4838c55f172277e52e0ad6572779c" name="a9cd4838c55f172277e52e0ad6572779c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd4838c55f172277e52e0ad6572779c">&#9670;&#160;</a></span>dropDefaultArgs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1CallExpr.html#ab15c738b5609b17c71c171b1600120e9">CallExpr::arg_range</a> dropDefaultArgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CallExpr.html#ab15c738b5609b17c71c171b1600120e9">CallExpr::arg_range</a></td>          <td class="paramname"><span class="paramname"><em>Args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l00158">158</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

<p class="reference">References <a class="el" href="Address_8h_source.html#l00155">clang::isa()</a>.</p>

</div>
</div>
<a id="a6cbbe5d25bd50a4428043a606a1749d1" name="a6cbbe5d25bd50a4428043a606a1749d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cbbe5d25bd50a4428043a606a1749d1">&#9670;&#160;</a></span>foldExplicitTemplateInstantiation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void foldExplicitTemplateInstantiation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> *</td>          <td class="paramname"><span class="paramname"><em>ExternKW</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> *</td>          <td class="paramname"><span class="paramname"><em>TemplateKW</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1syntax_1_1SimpleDeclaration.html">syntax::SimpleDeclaration</a> *</td>          <td class="paramname"><span class="paramname"><em>InnerDeclaration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Decl.html">Decl</a> *</td>          <td class="paramname"><span class="paramname"><em>From</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l01651">1651</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuildTree_8cpp_source.html#l01677">allocator()</a>, and <a class="el" href="Tokens_8h_source.html#l00109">clang::syntax::Token::kind()</a>.</p>

</div>
</div>
<a id="a80704734b581154bcaba48045d7a1527" name="a80704734b581154bcaba48045d7a1527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80704734b581154bcaba48045d7a1527">&#9670;&#160;</a></span>foldList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Builder foldList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aed67ee690ac5ba179fccb86950a6afd9">DeclarationRange</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DL</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ae9f975f03a7f0af0d1440f8511bdba" name="a7ae9f975f03a7f0af0d1440f8511bdba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae9f975f03a7f0af0d1440f8511bdba">&#9670;&#160;</a></span>foldNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Builder foldNode </td>
          <td>(</td>
          <td class="paramtype">Builder.</td>          <td class="paramname"><span class="paramname"><em>getRange</em></span>Range, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab409187cd8023f701425d74753612d6b">N</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a6bd65a985784f1f100fdfb844dcb5d" name="a9a6bd65a985784f1f100fdfb844dcb5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6bd65a985784f1f100fdfb844dcb5d">&#9670;&#160;</a></span>foldNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Builder foldNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aed67ee690ac5ba179fccb86950a6afd9">DeclarationRange</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">new(<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2">allocator</a>()) <a class="el" href="classclang_1_1syntax_1_1SimpleDeclaration.html">syntax::SimpleDeclaration</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7937d74c1508b3719dad9dbb65e69ec" name="af7937d74c1508b3719dad9dbb65e69ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7937d74c1508b3719dad9dbb65e69ec">&#9670;&#160;</a></span>foldTemplateDeclaration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1syntax_1_1TemplateDeclaration.html">syntax::TemplateDeclaration</a> * foldTemplateDeclaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> *</td>          <td class="paramname"><span class="paramname"><em>TemplateKW</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>TemplatedDeclaration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Decl.html">Decl</a> *</td>          <td class="paramname"><span class="paramname"><em>From</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l01664">1664</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuildTree_8cpp_source.html#l01677">allocator()</a>, <a class="el" href="Tokens_8h_source.html#l00109">clang::syntax::Token::kind()</a>, and <a class="el" href="BuildTree_8cpp_source.html#l01601">N</a>.</p>

</div>
</div>
<a id="abac17857e32f3f7db7bacfd1c5493f01" name="abac17857e32f3f7db7bacfd1c5493f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac17857e32f3f7db7bacfd1c5493f01">&#9670;&#160;</a></span>getOperatorNodeKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceclang_1_1syntax.html#a81b5b8b797bac504f7538749a7bb0a2a">syntax::NodeKind</a> getOperatorNodeKind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>E</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l00164">164</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

<p class="reference">References <a class="el" href="Expr_8h_source.html#l03009">clang::CallExpr::getNumArgs()</a>, <a class="el" href="ExprCXX_8h_source.html#l00111">clang::CXXOperatorCallExpr::getOperator()</a>, <a class="el" href="OperatorKinds_8h_source.html#l00026">clang::NUM_OVERLOADED_OPERATORS</a>, and <a class="el" href="OperatorKinds_8h_source.html#l00022">clang::OO_None</a>.</p>

</div>
</div>
<a id="accdf5828a4279d1000dcbdfd72e2c558" name="accdf5828a4279d1000dcbdfd72e2c558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accdf5828a4279d1000dcbdfd72e2c558">&#9670;&#160;</a></span>getQualifiedNameStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> getQualifiedNameStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> *</td>          <td class="paramname"><span class="paramname"><em>D</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the start of the qualified name. </p>
<p>In the examples below it gives the location of the <code>^</code>: <code>int ^a;</code> <code>int *^a;</code> <code>int ^a::S::f(){}</code> </p>

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l00250">250</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

<p class="reference">References <a class="el" href="Decl_8h_source.html#l00313">clang::NamedDecl::getDeclName()</a>, <a class="el" href="DeclBase_8h_source.html#l00432">clang::Decl::getLocation()</a>, and <a class="el" href="DeclarationName_8h_source.html#l00384">clang::DeclarationName::isIdentifier()</a>.</p>

</div>
</div>
<a id="a93378d2c3c4cf7aa9c7e436efc5b5708" name="a93378d2c3c4cf7aa9c7e436efc5b5708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93378d2c3c4cf7aa9c7e436efc5b5708">&#9670;&#160;</a></span>if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">if </td>
          <td>(</td>
          <td class="paramtype">!Builder.</td>          <td class="paramname"><span class="paramname"><em>isResponsibleForCreatingDeclaration</em></span>D</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l01605">1605</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

</div>
</div>
<a id="abf06269ea7a064d93921be359ff6ee73" name="abf06269ea7a064d93921be359ff6ee73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf06269ea7a064d93921be359ff6ee73">&#9670;&#160;</a></span>if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">if </td>
          <td>(</td>
          <td class="paramtype">!Range.</td>          <td class="paramname"><span class="paramname"><em>getBegin</em></span>).isValid(</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the range of the initializer inside an init-declarator C++ [dcl.decl]. </p>
<p><code>int a;</code> -&gt; range of `<code>, /</code>int *a = nullptr<code>-&gt; range of</code>= nullptr<code>. /</code>int a{}<code>-&gt; range of</code>{}<code>. /</code>int a()<code>-&gt; range of</code>()`. static SourceRange getInitializerRange(Decl *D) { if (auto *V = dyn_cast&lt;VarDecl&gt;(D)) { auto *I = V-&gt;getInit(); Initializers in range-based-for are not part of the declarator if (I &amp;&amp; !V-&gt;isCXXForRangeDecl()) return I-&gt;getSourceRange(); }</p>
<p>return SourceRange(); }</p>
<p>/ Gets the range of declarator as defined by the C++ grammar. E.g. / <code>int a;</code> -&gt; range of <code>a</code>, / <code>int *a;</code> -&gt; range of <code>*a</code>, / <code>int a[10];</code> -&gt; range of <code>a[10]</code>, / <code>int a[1][2][3];</code> -&gt; range of <code>a[1][2][3]</code>, / <code>int *a = nullptr</code> -&gt; range of <code>*a = nullptr</code>. / <code>int S::f(){}</code> -&gt; range of <code>S::f()</code>. / FIXME: <code>Name</code> must be a source range. static SourceRange getDeclaratorRange(const SourceManager &amp;SM, TypeLoc T,
                                      SourceLocation Name,
                                      SourceRange Initializer) { SourceLocation Start = GetStartLoc().Visit(T); SourceLocation End = T.getEndLoc(); if (Name.isValid()) { if (Start.isInvalid()) Start = Name; End of TypeLoc could be invalid if the type is invalid, fallback to the NameLoc. if (End.isInvalid() || SM.isBeforeInTranslationUnit(End, Name)) End = Name; } if (Initializer.isValid()) { auto InitializerEnd = Initializer.getEnd(); assert(SM.isBeforeInTranslationUnit(End, InitializerEnd) || End == InitializerEnd); End = InitializerEnd; } return SourceRange(Start, End); }</p>
<p>namespace { / All AST hierarchy roots that can be represented as pointers. using ASTPtr = llvm::PointerUnion&lt;Stmt *, Decl *&gt;; / Maintains a mapping from AST to syntax tree nodes. This class will get more / complicated as we support more kinds of AST nodes, e.g. TypeLocs. / FIXME: expose this as public API. class ASTToSyntaxMapping { public: void add(ASTPtr From, syntax::Tree *To) { assert(To != nullptr); assert(!From.isNull());</p>
<p>bool Added = Nodes.insert({From, To}).second; (void)Added; assert(Added &amp;&amp; "mapping added twice"); }</p>
<p>void add(NestedNameSpecifierLoc From, syntax::Tree *To) { assert(To != nullptr); assert(From.hasQualifier());</p>
<p>bool Added = NNSNodes.insert({From, To}).second; (void)Added; assert(Added &amp;&amp; "mapping added twice"); }</p>
<p>syntax::Tree *find(ASTPtr P) const { return Nodes.lookup(P); }</p>
<p>syntax::Tree *find(NestedNameSpecifierLoc P) const { return NNSNodes.lookup(P); }</p>
<p>private: llvm::DenseMap&lt;ASTPtr, syntax::Tree *&gt; Nodes; llvm::DenseMap&lt;NestedNameSpecifierLoc, syntax::Tree *&gt; NNSNodes; }; } // namespace</p>
<p>/ A helper class for constructing the syntax tree while traversing a clang / AST. / / At each point of the traversal we maintain a list of pending nodes. / Initially all tokens are added as pending nodes. When processing a clang AST / node, the clients need to: / - create a corresponding syntax node, / - assign roles to all pending child nodes with 'markChild' and / 'markChildToken', / - replace the child nodes with the new syntax node in the pending list / with 'foldNode'. / / Note that all children are expected to be processed when building a node. / / Call <a class="el" href="namespaceclang.html#addb9e36a0528443df269a65ef2ed0634">finalize()</a> to finish building the tree and consume the root node. class syntax::TreeBuilder { public: TreeBuilder(syntax::Arena &amp;Arena, TokenBufferTokenManager&amp; TBTM) : Arena(Arena), TBTM(TBTM), Pending(Arena, TBTM.tokenBuffer()) { for (const auto &amp;T : TBTM.tokenBuffer().expandedTokens()) LocationToToken.insert({T.location(), &amp;T}); }</p>
<p>llvm::BumpPtrAllocator &amp;<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a> { return Arena.getAllocator(); } const SourceManager &amp;sourceManager() const { return TBTM.sourceManager(); }</p>
<p>/ Populate children for <code>New</code> node, assuming it covers tokens from <code>/</code> Range. void foldNode(ArrayRef&lt;syntax::Token&gt; Range, syntax::Tree *New, ASTPtr From) { assert(New); Pending.foldChildren(TBTM.tokenBuffer(), Range, New); if (From) Mapping.add(From, New); }</p>
<p>void foldNode(ArrayRef&lt;syntax::Token&gt; Range, syntax::Tree *New, TypeLoc L) { FIXME: add mapping for TypeLocs foldNode(Range, New, nullptr); }</p>
<p>void foldNode(llvm::ArrayRef&lt;syntax::Token&gt; Range, syntax::Tree *New,
                NestedNameSpecifierLoc From) { assert(New); Pending.foldChildren(TBTM.tokenBuffer(), Range, New); if (From) Mapping.add(From, New); }</p>
<p>/ Populate children for <code>New</code> list, assuming it covers tokens from a / subrange of <code>SuperRange</code>. void foldList(ArrayRef&lt;syntax::Token&gt; SuperRange, syntax::List *New,
                ASTPtr From) { assert(New); auto ListRange = Pending.shrinkToFitList(SuperRange); Pending.foldChildren(TBTM.tokenBuffer(), ListRange, New); if (From) Mapping.add(From, New); }</p>
<p>/ Notifies that we should not consume trailing semicolon when computing / token range of <code>D</code>. void noticeDeclWithoutSemicolon(Decl *D);</p>
<p>/ Mark the <code>Child</code> node with a corresponding <code>Role</code>. All marked children / should be consumed by foldNode. / When called on expressions (<a class="el" href="classclang_1_1Expr.html" title="This represents one expression.">clang::Expr</a> is derived from <a class="el" href="classclang_1_1Stmt.html" title="Stmt - This represents one statement.">clang::Stmt</a>), / wraps expressions into expression statement. void markStmtChild(Stmt *Child, NodeRole Role); / Should be called for expressions in non-statement position to avoid / wrapping into expression statement. void markExprChild(Expr *Child, NodeRole Role); / Set role for a token starting at <code>Loc</code>. void markChildToken(SourceLocation Loc, NodeRole R); / Set role for <code>T</code>. void markChildToken(const syntax::Token *T, NodeRole R);</p>
<p>/ Set role for <code>N</code>. void markChild(syntax::Node *N, NodeRole R); / Set role for the syntax node matching <code>N</code>. void markChild(ASTPtr N, NodeRole R); / Set role for the syntax node matching <code>N</code>. void markChild(NestedNameSpecifierLoc N, NodeRole R);</p>
<p>/ Finish building the tree and consume the root node. syntax::TranslationUnit *finalize() &amp;&amp; { auto Tokens = TBTM.tokenBuffer().expandedTokens(); assert(!Tokens.empty()); assert(Tokens.back().kind() == tok::eof);</p>
<p>Build the root of the tree, consuming all the children. Pending.foldChildren(TBTM.tokenBuffer(), Tokens.drop_back(), new (Arena.getAllocator()) syntax::TranslationUnit);</p>
<p>auto *TU = cast&lt;syntax::TranslationUnit&gt;(std::move(Pending).<a class="el" href="namespaceclang.html#addb9e36a0528443df269a65ef2ed0634">finalize()</a>); TU-&gt;assertInvariantsRecursive(); return TU; }</p>
<p>/ Finds a token starting at <code>L</code>. The token must exist if <code>L</code> is valid. const syntax::Token *findToken(SourceLocation L) const;</p>
<p>/ Finds the syntax tokens corresponding to the <code>SourceRange</code>. ArrayRef&lt;syntax::Token&gt; getRange(SourceRange Range) const { assert(Range.isValid()); return getRange(Range.getBegin(), Range.getEnd()); }</p>
<p>/ Finds the syntax tokens corresponding to the passed source locations. / <code>First</code> is the start position of the first token and <code>Last</code> is the start / position of the last token. ArrayRef&lt;syntax::Token&gt; getRange(SourceLocation First,
                                   SourceLocation Last) const { assert(First.isValid()); assert(Last.isValid()); assert(First == Last || TBTM.sourceManager().isBeforeInTranslationUnit(First, Last)); return <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>(findToken(First), std::next(findToken(Last))); }</p>
<p>ArrayRef&lt;syntax::Token&gt; getTemplateRange(const ClassTemplateSpecializationDecl *D) const { auto Tokens = getRange(D-&gt;getSourceRange()); return maybeAppendSemicolon(Tokens, D); }</p>
<p>/ Returns true if <code>D</code> is the last declarator in a chain and is thus / reponsible for creating SimpleDeclaration for the whole chain. bool isResponsibleForCreatingDeclaration(const Decl *D) const { assert((isa&lt;DeclaratorDecl, TypedefNameDecl&gt;(D)) &amp;&amp; "only DeclaratorDecl and TypedefNameDecl are supported.");</p>
<p>const Decl *Next = D-&gt;getNextDeclInContext();</p>
<p>There's no next sibling, this one is responsible. if (Next == nullptr) { return true; }</p>
<p>Next sibling is not the same type, this one is responsible. if (D-&gt;<a class="el" href="DeclBase_8cpp.html#a37d13911f1772d0ed90b6b2e89cf3c60">getKind()</a> != Next-&gt;<a class="el" href="DeclBase_8cpp.html#a37d13911f1772d0ed90b6b2e89cf3c60">getKind()</a>) { return true; } Next sibling doesn't begin at the same loc, it must be a different declaration, so this declarator is responsible. if (Next-&gt;getBeginLoc() != D-&gt;getBeginLoc()) { return true; }</p>
<p>NextT is a member of the same declaration, and we need the last member to create declaration. This one is not responsible. return false; }</p>
<p>ArrayRef&lt;syntax::Token&gt; getDeclarationRange(Decl *D) { ArrayRef&lt;syntax::Token&gt; Tokens; We want to drop the template parameters for specializations. if (const auto *S = dyn_cast&lt;TagDecl&gt;(D)) Tokens = getRange(S-&gt;<a class="el" href="classclang_1_1TypeDecl.html#af6a71dbd81d4269f0099ff94e1364bc9">TypeDecl::getBeginLoc()</a>, S-&gt;getEndLoc()); else Tokens = getRange(D-&gt;getSourceRange()); return maybeAppendSemicolon(Tokens, D); }</p>
<p>ArrayRef&lt;syntax::Token&gt; getExprRange(const Expr *E) const { return getRange(E-&gt;getSourceRange()); }</p>
<p>/ Find the adjusted range for the statement, consuming the trailing / semicolon when needed. ArrayRef&lt;syntax::Token&gt; getStmtRange(const Stmt *S) const { auto Tokens = getRange(S-&gt;getSourceRange()); if (isa&lt;CompoundStmt&gt;(S)) return Tokens;</p>
<p>Some statements miss a trailing semicolon, e.g. 'return', 'continue' and all statements that end with those. Consume this semicolon here. if (Tokens.back().kind() == tok::semi) return Tokens; return withTrailingSemicolon(Tokens); }</p>
<p>private: ArrayRef&lt;syntax::Token&gt; maybeAppendSemicolon(ArrayRef&lt;syntax::Token&gt; Tokens,
                                               const Decl *D) const { if (isa&lt;NamespaceDecl&gt;(D)) return Tokens; if (DeclsWithoutSemicolons.count(D)) return Tokens; FIXME: do not consume trailing semicolon on function definitions. Most declarations own a semicolon in syntax trees, but not in clang AST. return withTrailingSemicolon(Tokens); }</p>
<p>ArrayRef&lt;syntax::Token&gt; withTrailingSemicolon(ArrayRef&lt;syntax::Token&gt; Tokens) const { assert(!Tokens.empty()); assert(Tokens.back().kind() != tok::eof); We never consume 'eof', so looking at the next token is ok. if (Tokens.back().kind() != tok::semi &amp;&amp; Tokens.end()-&gt;kind() == tok::semi) return <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>(Tokens.begin(), Tokens.end() + 1); return Tokens; }</p>
<p>void setRole(syntax::Node *N, NodeRole R) { assert(N-&gt;getRole() == NodeRole::Detached); N-&gt;setRole(R); }</p>
<p>/ A collection of trees covering the input tokens. / When created, each tree corresponds to a single token in the file. / Clients call 'foldChildren' to attach one or more subtrees to a parent / node and update the list of trees accordingly. / / Ensures that added nodes properly nest and cover the whole token stream. struct Forest { Forest(syntax::Arena &amp;A, const syntax::TokenBuffer &amp;TB) { assert(!TB.expandedTokens().empty()); assert(TB.expandedTokens().back().kind() == tok::eof); Create all leaf nodes. Note that we do not have 'eof' in the tree. for (const auto &amp;T : TB.expandedTokens().drop_back()) { auto *L = new (A.getAllocator()) syntax::Leaf(reinterpret_cast&lt;TokenManager::Key&gt;(&amp;T)); L-&gt;Original = true; L-&gt;CanModify = TB.spelledForExpanded(T).has_value(); Trees.insert(Trees.end(), {&amp;T, L}); } }</p>
<p>void assignRole(ArrayRef&lt;syntax::Token&gt; Range, syntax::NodeRole Role) { assert(!Range.empty()); auto It = Trees.lower_bound(Range.begin()); assert(It != Trees.end() &amp;&amp; "no node found"); assert(It-&gt;first == Range.begin() &amp;&amp; "no child with the specified range"); assert((std::next(It) == Trees.end() || std::next(It)-&gt;first == Range.end()) &amp;&amp; "no child with the specified range"); assert(It-&gt;second-&gt;getRole() == NodeRole::Detached &amp;&amp; "re-assigning role for a child"); It-&gt;second-&gt;setRole(Role); }</p>
<p>/ Shrink <code>Range</code> to a subrange that only contains tokens of a list. / List elements and delimiters should already have correct roles. ArrayRef&lt;syntax::Token&gt; shrinkToFitList(ArrayRef&lt;syntax::Token&gt; Range) { auto BeginChildren = Trees.lower_bound(Range.begin()); assert((BeginChildren == Trees.end() || BeginChildren-&gt;first == Range.begin()) &amp;&amp; "Range crosses boundaries of existing subtrees");</p>
<p>auto EndChildren = Trees.lower_bound(Range.end()); assert( (EndChildren == Trees.end() || EndChildren-&gt;first == Range.end()) &amp;&amp; "Range crosses boundaries of existing subtrees");</p>
<p>auto BelongsToList = [](decltype(Trees)::value_type KV) { auto Role = KV.second-&gt;getRole(); return Role == syntax::NodeRole::ListElement || Role == syntax::NodeRole::ListDelimiter; };</p>
<p>auto BeginListChildren = std::find_if(BeginChildren, EndChildren, BelongsToList);</p>
<p>auto EndListChildren = std::find_if_not(BeginListChildren, EndChildren, BelongsToList);</p>
<p>return ArrayRef&lt;syntax::Token&gt;(BeginListChildren-&gt;first, EndListChildren-&gt;first); }</p>
<p>/ Add <code>Node</code> to the forest and attach child nodes based on <code>Tokens</code>. void foldChildren(const syntax::TokenBuffer &amp;TB,
                      ArrayRef&lt;syntax::Token&gt; Tokens, syntax::Tree *Node) { Attach children to <code>Node</code>. assert(Node-&gt;getFirstChild() == nullptr &amp;&amp; "node already has children");</p>
<p>auto *FirstToken = Tokens.begin(); auto BeginChildren = Trees.lower_bound(FirstToken);</p>
<p>assert((BeginChildren == Trees.end() || BeginChildren-&gt;first == FirstToken) &amp;&amp; "fold crosses boundaries of existing subtrees"); auto EndChildren = Trees.lower_bound(Tokens.end()); assert( (EndChildren == Trees.end() || EndChildren-&gt;first == Tokens.end()) &amp;&amp; "fold crosses boundaries of existing subtrees");</p>
<p>for (auto It = BeginChildren; It != EndChildren; ++It) { auto *C = It-&gt;second; if (C-&gt;getRole() == NodeRole::Detached) C-&gt;setRole(NodeRole::Unknown); Node-&gt;appendChildLowLevel(C); }</p>
<p>Mark that this node came from the AST and is backed by the source code. Node-&gt;Original = true; Node-&gt;CanModify = TB.spelledForExpanded(Tokens).has_value();</p>
<p>Trees.erase(BeginChildren, EndChildren); Trees.insert({FirstToken, Node}); }</p>
<p>EXPECTS: all tokens were consumed and are owned by a single root node. syntax::Node *finalize() &amp;&amp; { assert(Trees.size() == 1); auto *Root = Trees.begin()-&gt;second; Trees = {}; return Root; }</p>
<p>std::string str(const syntax::TokenBufferTokenManager &amp;STM) const { std::string R; for (auto It = Trees.begin(); It != Trees.end(); ++It) { unsigned CoveredTokens = It != Trees.end() ? (std::next(It)-&gt;first - It-&gt;first) : STM.tokenBuffer().expandedTokens().end() - It-&gt;first;</p>
<p>R += std::string( formatv("- '{0}' covers '{1}'+{2} tokens\n", It-&gt;second-&gt;<a class="el" href="DeclBase_8cpp.html#a37d13911f1772d0ed90b6b2e89cf3c60">getKind()</a>, It-&gt;first-&gt;text(STM.sourceManager()), CoveredTokens)); R += It-&gt;second-&gt;dump(STM); } return R; }</p>
<p>private: / Maps from the start token to a subtree starting at that token. / Keys in the map are pointers into the array of expanded tokens, so / pointer order corresponds to the order of preprocessor tokens. std::map&lt;const syntax::Token *, syntax::Node *&gt; Trees; };</p>
<p>/ For debugging purposes. std::string str() { return Pending.str(TBTM); }</p>
<p>syntax::Arena &amp;Arena; TokenBufferTokenManager&amp; TBTM; / To quickly find tokens by their start location. llvm::DenseMap&lt;SourceLocation, const syntax::Token *&gt; LocationToToken; Forest Pending; llvm::DenseSet&lt;Decl *&gt; DeclsWithoutSemicolons; ASTToSyntaxMapping Mapping; };</p>
<p>namespace { class BuildTreeVisitor : public RecursiveASTVisitor&lt;BuildTreeVisitor&gt; { public: explicit BuildTreeVisitor(ASTContext &amp;Context, syntax::TreeBuilder &amp;Builder) : <a class="el" href="#aa87dc9caf4e431513d7b0ca4bb389a25">Builder(Builder)</a>, <a class="el" href="#a3aeaeb39eb301ad5f1a31cad0934e732">Context(Context)</a> {}</p>
<p>bool shouldTraversePostOrder() const { return true; }</p>
<p>bool WalkUpFromDeclaratorDecl(DeclaratorDecl *DD) { return processDeclaratorAndDeclaration(DD); }</p>
<p>bool WalkUpFromTypedefNameDecl(TypedefNameDecl *TD) { return processDeclaratorAndDeclaration(TD); }</p>
<p>bool VisitDecl(Decl *D) { assert(!D-&gt;isImplicit()); Builder.foldNode(Builder.getDeclarationRange(D), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::UnknownDeclaration(), D); return true; }</p>
<p>RAV does not call WalkUpFrom* on explicit instantiations, so we have to override Traverse. FIXME: make RAV call WalkUpFrom* instead. bool TraverseClassTemplateSpecializationDecl(ClassTemplateSpecializationDecl *C) { if (!RecursiveASTVisitor::TraverseClassTemplateSpecializationDecl(C)) return false; if (C-&gt;isExplicitSpecialization()) return true; // we are only interested in explicit instantiations. auto *Declaration = cast&lt;syntax::SimpleDeclaration&gt;(handleFreeStandingTagDecl(C)); foldExplicitTemplateInstantiation( Builder.getTemplateRange(C), Builder.findToken(C-&gt;getExternLoc()), Builder.findToken(C-&gt;getTemplateKeywordLoc()), Declaration, C); return true; }</p>
<p>bool WalkUpFromTemplateDecl(TemplateDecl *S) { foldTemplateDeclaration( Builder.getDeclarationRange(S), Builder.findToken(S-&gt;getTemplateParameters()-&gt;getTemplateLoc()), Builder.getDeclarationRange(S-&gt;getTemplatedDecl()), S); return true; }</p>
<p>bool WalkUpFromTagDecl(TagDecl *C) { FIXME: build the ClassSpecifier node. if (!C-&gt;isFreeStanding()) { assert(C-&gt;getNumTemplateParameterLists() == 0); return true; } handleFreeStandingTagDecl(C); return true; }</p>
<p>syntax::Declaration *handleFreeStandingTagDecl(TagDecl *C) { assert(C-&gt;isFreeStanding()); Class is a declaration specifier and needs a spanning declaration node. auto DeclarationRange = Builder.getDeclarationRange(C); syntax::Declaration *Result = new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::SimpleDeclaration; Builder.foldNode(DeclarationRange, Result, nullptr);</p>
<p>Build TemplateDeclaration nodes if we had template parameters. auto ConsumeTemplateParameters = [&amp;](const TemplateParameterList &amp;L) { const auto *TemplateKW = Builder.findToken(L.getTemplateLoc()); auto R = <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>(TemplateKW, DeclarationRange.end()); Result = foldTemplateDeclaration(R, TemplateKW, DeclarationRange, nullptr); DeclarationRange = R; }; if (auto *S = dyn_cast&lt;ClassTemplatePartialSpecializationDecl&gt;(C)) ConsumeTemplateParameters(*S-&gt;getTemplateParameters()); for (unsigned I = C-&gt;getNumTemplateParameterLists(); 0 &lt; I; &ndash;I) ConsumeTemplateParameters(*C-&gt;getTemplateParameterList(I - 1)); return Result; }</p>
<p>bool WalkUpFromTranslationUnitDecl(TranslationUnitDecl *TU) { We do not want to call VisitDecl(), the declaration for translation unit is built by <a class="el" href="namespaceclang.html#addb9e36a0528443df269a65ef2ed0634">finalize()</a>. return true; }</p>
<p>bool WalkUpFromCompoundStmt(CompoundStmt *S) { using NodeRole = <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5" title="A relation between a parent and child node, e.g.">syntax::NodeRole</a>;</p>
<p>Builder.markChildToken(S-&gt;getLBracLoc(), NodeRole::OpenParen); for (auto *Child : S-&gt;body()) Builder.markStmtChild(Child, NodeRole::Statement); Builder.markChildToken(S-&gt;getRBracLoc(), NodeRole::CloseParen);</p>
<p>Builder.foldNode(Builder.getStmtRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::CompoundStatement, S); return true; }</p>
<p>Some statements are not yet handled by syntax trees. bool WalkUpFromStmt(Stmt *S) { Builder.foldNode(Builder.getStmtRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::UnknownStatement, S); return true; }</p>
<p>bool TraverseIfStmt(IfStmt *S) { bool Result = [&amp;, this]() { if (S-&gt;getInit() &amp;&amp; !TraverseStmt(S-&gt;getInit())) { return false; } In cases where the condition is an initialized declaration in a statement, we want to preserve the declaration and ignore the implicit condition expression in the syntax tree. if (S-&gt;hasVarStorage()) { if (!TraverseStmt(S-&gt;getConditionVariableDeclStmt())) return false; } else if (S-&gt;getCond() &amp;&amp; !TraverseStmt(S-&gt;getCond())) return false;</p>
<p>if (S-&gt;getThen() &amp;&amp; !TraverseStmt(S-&gt;getThen())) return false; if (S-&gt;getElse() &amp;&amp; !TraverseStmt(S-&gt;getElse())) return false; return true; }(); WalkUpFromIfStmt(S); return Result; }</p>
<p>bool TraverseCXXForRangeStmt(CXXForRangeStmt *S) { We override to traverse range initializer as VarDecl. RAV traverses it as a statement, we produce invalid node kinds in that case. FIXME: should do this in RAV instead? bool Result = [&amp;, this]() { if (S-&gt;getInit() &amp;&amp; !TraverseStmt(S-&gt;getInit())) return false; if (S-&gt;getLoopVariable() &amp;&amp; !TraverseDecl(S-&gt;getLoopVariable())) return false; if (S-&gt;getRangeInit() &amp;&amp; !TraverseStmt(S-&gt;getRangeInit())) return false; if (S-&gt;getBody() &amp;&amp; !TraverseStmt(S-&gt;getBody())) return false; return true; }(); WalkUpFromCXXForRangeStmt(S); return Result; }</p>
<p>bool TraverseStmt(Stmt *S) { if (auto *DS = dyn_cast_or_null&lt;DeclStmt&gt;(S)) { We want to consume the semicolon, make sure SimpleDeclaration does not. for (auto *D : DS-&gt;decls()) Builder.noticeDeclWithoutSemicolon(D); } else if (auto *E = dyn_cast_or_null&lt;Expr&gt;(S)) { return RecursiveASTVisitor::TraverseStmt(IgnoreImplicit(E)); } return RecursiveASTVisitor::TraverseStmt(S); }</p>
<p>bool TraverseOpaqueValueExpr(OpaqueValueExpr *VE) { OpaqueValue doesn't correspond to concrete syntax, ignore it. return true; }</p>
<p>Some expressions are not yet handled by syntax trees. bool WalkUpFromExpr(Expr *E) { assert(!isImplicitExpr(E) &amp;&amp; "should be handled by TraverseStmt"); Builder.foldNode(Builder.getExprRange(E), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::UnknownExpression, E); return true; }</p>
<p>bool TraverseUserDefinedLiteral(UserDefinedLiteral *S) { The semantic AST node <code>UserDefinedLiteral</code> (UDL) may have one child node referencing the location of the UDL suffix (<code>_w</code> in <code>1.2_w</code>). The UDL suffix location does not point to the beginning of a token, so we can't represent the UDL suffix as a separate syntax tree node. </p><pre class="fragment">return WalkUpFromUserDefinedLiteral(S);
</pre><p> }</p>
<p>syntax::UserDefinedLiteralExpression * buildUserDefinedLiteral(UserDefinedLiteral *S) { switch (S-&gt;getLiteralOperatorKind()) { case <a class="el" href="classclang_1_1UserDefinedLiteral.html#ad15ae87e47c18b5b3c4efeec7e694650a8d54ca95325cd68c897b495a69d405b7" title="operator &quot;&quot; X (unsigned long long)">UserDefinedLiteral::LOK_Integer</a>: return new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::IntegerUserDefinedLiteralExpression; case <a class="el" href="classclang_1_1UserDefinedLiteral.html#ad15ae87e47c18b5b3c4efeec7e694650a89b2415ae635790a038542ea893ba540" title="operator &quot;&quot; X (long double)">UserDefinedLiteral::LOK_Floating</a>: return new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::FloatUserDefinedLiteralExpression; case <a class="el" href="classclang_1_1UserDefinedLiteral.html#ad15ae87e47c18b5b3c4efeec7e694650aea920bdbd1602f1e8fd50cb4ca56217e" title="operator &quot;&quot; X (CharT)">UserDefinedLiteral::LOK_Character</a>: return new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::CharUserDefinedLiteralExpression; case <a class="el" href="classclang_1_1UserDefinedLiteral.html#ad15ae87e47c18b5b3c4efeec7e694650a54677ae30ddc5a5cdb1ec96191c511f3" title="operator &quot;&quot; X (const CharT *, size_t)">UserDefinedLiteral::LOK_String</a>: return new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::StringUserDefinedLiteralExpression; case <a class="el" href="classclang_1_1UserDefinedLiteral.html#ad15ae87e47c18b5b3c4efeec7e694650a7b9288f6bb5a635a065508aaaa4c9661" title="Raw form: operator &quot;&quot; X (const char *)">UserDefinedLiteral::LOK_Raw</a>: case <a class="el" href="classclang_1_1UserDefinedLiteral.html#ad15ae87e47c18b5b3c4efeec7e694650ab1bc57fb3eb699f002147067fef0b3d7" title="Raw form: operator &quot;&quot; X&lt;cs...&gt; ()">UserDefinedLiteral::LOK_Template</a>: For raw literal operator and numeric literal operator template we cannot get the type of the operand in the semantic AST. We get this information from the token. As integer and floating point have the same token kind, we run <code>NumericLiteralParser</code> again to distinguish them. auto TokLoc = S-&gt;getBeginLoc(); auto TokSpelling = Builder.findToken(TokLoc)-&gt;text(Context.getSourceManager()); auto Literal = NumericLiteralParser(TokSpelling, TokLoc, Context.getSourceManager(), Context.getLangOpts(), Context.getTargetInfo(), Context.getDiagnostics()); if (Literal.isIntegerLiteral()) return new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::IntegerUserDefinedLiteralExpression; else { assert(Literal.isFloatingLiteral()); return new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::FloatUserDefinedLiteralExpression; } } llvm_unreachable("Unknown literal operator kind."); }</p>
<p>bool WalkUpFromUserDefinedLiteral(UserDefinedLiteral *S) { Builder.markChildToken(S-&gt;getBeginLoc(), syntax::NodeRole::LiteralToken); Builder.foldNode(Builder.getExprRange(S), buildUserDefinedLiteral(S), S); return true; }</p>
<p>FIXME: Fix <code><a class="el" href="classclang_1_1NestedNameSpecifierLoc.html#a81212298b2de6eb931e15a220b66dc7f" title="Retrieve the source range covering just the last part of this nested-name-specifier,...">NestedNameSpecifierLoc::getLocalSourceRange</a></code> for the <code>DependentTemplateSpecializationType</code> case. / Given a nested-name-specifier return the range for the last name / specifier. / / e.g. <code>std::T::template X&lt;<a class="el" href="classU.html">U</a>&gt;::</code> =&gt; <code>template X&lt;<a class="el" href="classU.html">U</a>&gt;::</code> SourceRange getLocalSourceRange(const NestedNameSpecifierLoc &amp;NNSLoc) { auto SR = NNSLoc.getLocalSourceRange();</p>
<p>The method <code><a class="el" href="classclang_1_1NestedNameSpecifierLoc.html#a81212298b2de6eb931e15a220b66dc7f" title="Retrieve the source range covering just the last part of this nested-name-specifier,...">NestedNameSpecifierLoc::getLocalSourceRange</a></code> <em>should</em> return the desired <code>SourceRange</code>, but there is a corner case. For a <code>DependentTemplateSpecializationType</code> this method returns its qualifiers as well, in other words in the example above this method returns <code>T::template X&lt;<a class="el" href="classU.html">U</a>&gt;::</code> instead of only <code>template X&lt;<a class="el" href="classU.html">U</a>&gt;::</code> if (auto TL = NNSLoc.getTypeLoc()) { if (auto DependentTL = TL.getAs&lt;DependentTemplateSpecializationTypeLoc&gt;()) { The 'template' keyword is always present in dependent template specializations. Except in the case of incorrect code TODO: Treat the case of incorrect code. SR.setBegin(DependentTL.getTemplateKeywordLoc()); } }</p>
<p>return SR; }</p>
<p><a class="el" href="namespaceclang_1_1syntax.html#a81b5b8b797bac504f7538749a7bb0a2a" title="A kind of a syntax node, used for implementing casts.">syntax::NodeKind</a> getNameSpecifierKind(const NestedNameSpecifier &amp;NNS) { switch (NNS.getKind()) { case <a class="el" href="classclang_1_1NestedNameSpecifier.html#ac707a113605ed4283684b8c05664eb6faae6e1e63c803f3852ba7b44c670fa292" title="The global specifier &#39;::&#39;. There is no stored value.">NestedNameSpecifier::Global</a>: return syntax::NodeKind::GlobalNameSpecifier; case <a class="el" href="classclang_1_1NestedNameSpecifier.html#ac707a113605ed4283684b8c05664eb6faf37ff4b711e0a555e2ae7f89ddecc8db" title="A namespace, stored as a NamespaceDecl*.">NestedNameSpecifier::Namespace</a>: case <a class="el" href="classclang_1_1NestedNameSpecifier.html#ac707a113605ed4283684b8c05664eb6fa052c4102c633839bbabf6f043419bb6d" title="A namespace alias, stored as a NamespaceAliasDecl*.">NestedNameSpecifier::NamespaceAlias</a>: case <a class="el" href="classclang_1_1NestedNameSpecifier.html#ac707a113605ed4283684b8c05664eb6faa92d18857428e63813afa4e0a88def5a" title="An identifier, stored as an IdentifierInfo*.">NestedNameSpecifier::Identifier</a>: return syntax::NodeKind::IdentifierNameSpecifier; case <a class="el" href="classclang_1_1NestedNameSpecifier.html#ac707a113605ed4283684b8c05664eb6fa4216f217193417af58feacb7f446ce35" title="A type that was preceded by the &#39;template&#39; keyword, stored as a Type*.">NestedNameSpecifier::TypeSpecWithTemplate</a>: return syntax::NodeKind::SimpleTemplateNameSpecifier; case <a class="el" href="classclang_1_1NestedNameSpecifier.html#ac707a113605ed4283684b8c05664eb6fa1b66ddf448ef55a1d35777ca0324db3d" title="A type, stored as a Type*.">NestedNameSpecifier::TypeSpec</a>: { const auto *NNSType = NNS.getAsType(); assert(NNSType); if (isa&lt;DecltypeType&gt;(NNSType)) return syntax::NodeKind::DecltypeNameSpecifier; if (isa&lt;TemplateSpecializationType, DependentTemplateSpecializationType&gt;(
              NNSType)) return syntax::NodeKind::SimpleTemplateNameSpecifier; return syntax::NodeKind::IdentifierNameSpecifier; } default: FIXME: Support Microsoft's __super llvm::report_fatal_error("We don't yet support the __super specifier", true); } }</p>
<p>syntax::NameSpecifier * buildNameSpecifier(const NestedNameSpecifierLoc &amp;NNSLoc) { assert(NNSLoc.hasQualifier()); auto NameSpecifierTokens = Builder.getRange(getLocalSourceRange(NNSLoc)).drop_back(); switch (getNameSpecifierKind(<em>NNSLoc.getNestedNameSpecifier())) { case syntax::NodeKind::GlobalNameSpecifier: return new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::GlobalNameSpecifier; case syntax::NodeKind::IdentifierNameSpecifier: { assert(NameSpecifierTokens.size() == 1); Builder.markChildToken(NameSpecifierTokens.begin(), syntax::NodeRole::Unknown); auto *NS = new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::IdentifierNameSpecifier; Builder.foldNode(NameSpecifierTokens, NS, nullptr); return NS; } case syntax::NodeKind::SimpleTemplateNameSpecifier: { TODO: Build <code>SimpleTemplateNameSpecifier</code> children and implement accessors to them. Be aware, we cannot do that simply by calling <code>TraverseTypeLoc</code>, some <code>TypeLoc</code>s have inside them the previous name specifier and we want to treat them independently. auto *NS = new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::SimpleTemplateNameSpecifier; Builder.foldNode(NameSpecifierTokens, NS, nullptr); return NS; } case syntax::NodeKind::DecltypeNameSpecifier: { const auto TL = NNSLoc.getTypeLoc().castAs&lt;DecltypeTypeLoc&gt;(); if (!RecursiveASTVisitor::TraverseDecltypeTypeLoc(TL)) return nullptr; auto *NS = new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::DecltypeNameSpecifier; TODO: Implement accessor to <code>DecltypeNameSpecifier</code> inner <code>DecltypeTypeLoc</code>. For that add mapping from <code>TypeLoc</code> to `syntax<a class="el" href="ASTMatchFinder_8cpp.html#a32ca2adfad3611927e87efc253e7b7b1">Node</a></em>` then: Builder.markChild(TypeLoc, syntax::NodeRole); Builder.foldNode(NameSpecifierTokens, NS, nullptr); return NS; } default: llvm_unreachable("getChildKind() does not return this value"); } }</p>
<p>To build syntax tree nodes for NestedNameSpecifierLoc we override Traverse instead of WalkUpFrom because we want to traverse the children ourselves and build a list instead of a nested tree of name specifier prefixes. bool TraverseNestedNameSpecifierLoc(NestedNameSpecifierLoc QualifierLoc) { if (!QualifierLoc) return true; for (auto It = QualifierLoc; It; It = It.getPrefix()) { auto *NS = buildNameSpecifier(It); if (!NS) return false; Builder.markChild(NS, syntax::NodeRole::ListElement); Builder.markChildToken(It.getEndLoc(), syntax::NodeRole::ListDelimiter); } Builder.foldNode(Builder.getRange(QualifierLoc.getSourceRange()), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::NestedNameSpecifier, QualifierLoc); return true; }</p>
<p>syntax::IdExpression *buildIdExpression(NestedNameSpecifierLoc QualifierLoc, SourceLocation TemplateKeywordLoc, SourceRange UnqualifiedIdLoc, ASTPtr From) { if (QualifierLoc) { Builder.markChild(QualifierLoc, syntax::NodeRole::Qualifier); if (TemplateKeywordLoc.isValid()) Builder.markChildToken(TemplateKeywordLoc,
                               syntax::NodeRole::TemplateKeyword); }</p>
<p>auto *TheUnqualifiedId = new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::UnqualifiedId; Builder.foldNode(Builder.getRange(UnqualifiedIdLoc), TheUnqualifiedId, nullptr); Builder.markChild(TheUnqualifiedId, syntax::NodeRole::UnqualifiedId);</p>
<p>auto IdExpressionBeginLoc = QualifierLoc ? QualifierLoc.getBeginLoc() : UnqualifiedIdLoc.getBegin();</p>
<p>auto *TheIdExpression = new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::IdExpression; Builder.foldNode( Builder.getRange(IdExpressionBeginLoc, UnqualifiedIdLoc.getEnd()), TheIdExpression, From);</p>
<p>return TheIdExpression; }</p>
<p>bool WalkUpFromMemberExpr(MemberExpr *S) { For <code>MemberExpr</code> with implicit <code>this-&gt;</code> we generate a simple <code>id-expression</code> syntax node, beacuse an implicit <code>member-expression</code> is syntactically undistinguishable from an <code>id-expression</code> if (S-&gt;isImplicitAccess()) { buildIdExpression(S-&gt;getQualifierLoc(), S-&gt;getTemplateKeywordLoc(), SourceRange(S-&gt;getMemberLoc(), S-&gt;getEndLoc()), S); return true; }</p>
<p>auto *TheIdExpression = buildIdExpression( S-&gt;getQualifierLoc(), S-&gt;getTemplateKeywordLoc(), SourceRange(S-&gt;getMemberLoc(), S-&gt;getEndLoc()), nullptr);</p>
<p>Builder.markChild(TheIdExpression, syntax::NodeRole::Member);</p>
<p>Builder.markExprChild(S-&gt;getBase(), syntax::NodeRole::Object); Builder.markChildToken(S-&gt;getOperatorLoc(), syntax::NodeRole::AccessToken);</p>
<p>Builder.foldNode(Builder.getExprRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::MemberExpression, S); return true; }</p>
<p>bool WalkUpFromDeclRefExpr(DeclRefExpr *S) { buildIdExpression(S-&gt;getQualifierLoc(), S-&gt;getTemplateKeywordLoc(), SourceRange(S-&gt;getLocation(), S-&gt;getEndLoc()), S);</p>
<p>return true; }</p>
<p>Same logic as DeclRefExpr. bool WalkUpFromDependentScopeDeclRefExpr(DependentScopeDeclRefExpr *S) { buildIdExpression(S-&gt;getQualifierLoc(), S-&gt;getTemplateKeywordLoc(), SourceRange(S-&gt;getLocation(), S-&gt;getEndLoc()), S);</p>
<p>return true; }</p>
<p>bool WalkUpFromCXXThisExpr(CXXThisExpr *S) { if (!S-&gt;isImplicit()) { Builder.markChildToken(S-&gt;getLocation(), syntax::NodeRole::IntroducerKeyword); Builder.foldNode(Builder.getExprRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::ThisExpression, S); } return true; }</p>
<p>bool WalkUpFromParenExpr(ParenExpr *S) { Builder.markChildToken(S-&gt;getLParen(), syntax::NodeRole::OpenParen); Builder.markExprChild(S-&gt;getSubExpr(), syntax::NodeRole::SubExpression); Builder.markChildToken(S-&gt;getRParen(), syntax::NodeRole::CloseParen); Builder.foldNode(Builder.getExprRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::ParenExpression, S); return true; }</p>
<p>bool WalkUpFromIntegerLiteral(IntegerLiteral *S) { Builder.markChildToken(S-&gt;getLocation(), syntax::NodeRole::LiteralToken); Builder.foldNode(Builder.getExprRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::IntegerLiteralExpression, S); return true; }</p>
<p>bool WalkUpFromCharacterLiteral(CharacterLiteral *S) { Builder.markChildToken(S-&gt;getLocation(), syntax::NodeRole::LiteralToken); Builder.foldNode(Builder.getExprRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::CharacterLiteralExpression, S); return true; }</p>
<p>bool WalkUpFromFloatingLiteral(FloatingLiteral *S) { Builder.markChildToken(S-&gt;getLocation(), syntax::NodeRole::LiteralToken); Builder.foldNode(Builder.getExprRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::FloatingLiteralExpression, S); return true; }</p>
<p>bool WalkUpFromStringLiteral(StringLiteral *S) { Builder.markChildToken(S-&gt;getBeginLoc(), syntax::NodeRole::LiteralToken); Builder.foldNode(Builder.getExprRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::StringLiteralExpression, S); return true; }</p>
<p>bool WalkUpFromCXXBoolLiteralExpr(CXXBoolLiteralExpr *S) { Builder.markChildToken(S-&gt;getLocation(), syntax::NodeRole::LiteralToken); Builder.foldNode(Builder.getExprRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::BoolLiteralExpression, S); return true; }</p>
<p>bool WalkUpFromCXXNullPtrLiteralExpr(CXXNullPtrLiteralExpr *S) { Builder.markChildToken(S-&gt;getLocation(), syntax::NodeRole::LiteralToken); Builder.foldNode(Builder.getExprRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::CxxNullPtrExpression, S); return true; }</p>
<p>bool WalkUpFromUnaryOperator(UnaryOperator *S) { Builder.markChildToken(S-&gt;getOperatorLoc(), syntax::NodeRole::OperatorToken); Builder.markExprChild(S-&gt;getSubExpr(), syntax::NodeRole::Operand);</p>
<p>if (S-&gt;isPostfix()) Builder.foldNode(Builder.getExprRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::PostfixUnaryOperatorExpression, S); else Builder.foldNode(Builder.getExprRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::PrefixUnaryOperatorExpression, S);</p>
<p>return true; }</p>
<p>bool WalkUpFromBinaryOperator(BinaryOperator *S) { Builder.markExprChild(S-&gt;getLHS(), syntax::NodeRole::LeftHandSide); Builder.markChildToken(S-&gt;getOperatorLoc(), syntax::NodeRole::OperatorToken); Builder.markExprChild(S-&gt;getRHS(), syntax::NodeRole::RightHandSide); Builder.foldNode(Builder.getExprRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::BinaryOperatorExpression, S); return true; }</p>
<p>/ Builds <code>CallArguments</code> syntax node from arguments that appear in source / code, i.e. not default arguments. syntax::CallArguments * buildCallArguments(CallExpr::arg_range ArgsAndDefaultArgs) { auto Args = dropDefaultArgs(ArgsAndDefaultArgs); for (auto *Arg : Args) { Builder.markExprChild(Arg, syntax::NodeRole::ListElement); const auto *DelimiterToken = std::next(Builder.findToken(Arg-&gt;getEndLoc())); if (DelimiterToken-&gt;kind() == clang::tok::TokenKind::comma) Builder.markChildToken(DelimiterToken, syntax::NodeRole::ListDelimiter); }</p>
<p>auto *Arguments = new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::CallArguments; if (!Args.empty()) Builder.foldNode(Builder.getRange((*Args.begin())-&gt;getBeginLoc(), (*(Args.end() - 1))-&gt;getEndLoc()), Arguments, nullptr);</p>
<p>return Arguments; }</p>
<p>bool WalkUpFromCallExpr(CallExpr *S) { Builder.markExprChild(S-&gt;getCallee(), syntax::NodeRole::Callee);</p>
<p>const auto *LParenToken = std::next(Builder.findToken(S-&gt;getCallee()-&gt;getEndLoc())); FIXME: Assert that <code>LParenToken</code> is indeed a <code>l_paren</code> once we have fixed the test on decltype desctructors. if (LParenToken-&gt;kind() == clang::tok::l_paren) Builder.markChildToken(LParenToken, syntax::NodeRole::OpenParen);</p>
<p>Builder.markChild(buildCallArguments(S-&gt;arguments()), syntax::NodeRole::Arguments);</p>
<p>Builder.markChildToken(S-&gt;getRParenLoc(), syntax::NodeRole::CloseParen);</p>
<p>Builder.foldNode(Builder.getRange(S-&gt;getSourceRange()), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::CallExpression, S); return true; }</p>
<p>bool WalkUpFromCXXConstructExpr(CXXConstructExpr *S) { Ignore the implicit calls to default constructors. if ((S-&gt;getNumArgs() == 0 || isa&lt;CXXDefaultArgExpr&gt;(S-&gt;getArg(0))) &amp;&amp; S-&gt;getParenOrBraceRange().<a class="el" href="SourceManager_8cpp.html#a77014e847c0061fb1cf6ae20ae2a7a36">isInvalid()</a>) return true; return RecursiveASTVisitor::WalkUpFromCXXConstructExpr(S); }</p>
<p>bool TraverseCXXOperatorCallExpr(CXXOperatorCallExpr *S) { To construct a syntax tree of the same shape for calls to built-in and user-defined operators, ignore the <code>DeclRefExpr</code> that refers to the operator and treat it as a simple token. Do that by traversing arguments instead of children. for (auto *child : S-&gt;arguments()) { A postfix unary operator is declared as taking two operands. The second operand is used to distinguish from its prefix counterpart. In the semantic AST this "phantom" operand is represented as a <code>IntegerLiteral</code> with invalid <code>SourceLocation</code>. We skip visiting this operand because it does not correspond to anything written in source code. if (child-&gt;getSourceRange().<a class="el" href="SourceManager_8cpp.html#a77014e847c0061fb1cf6ae20ae2a7a36">isInvalid()</a>) { assert(getOperatorNodeKind(*S) == syntax::NodeKind::PostfixUnaryOperatorExpression); continue; } if (!TraverseStmt(child)) return false; } return WalkUpFromCXXOperatorCallExpr(S); }</p>
<p>bool WalkUpFromCXXOperatorCallExpr(CXXOperatorCallExpr *S) { switch (getOperatorNodeKind(*S)) { case syntax::NodeKind::BinaryOperatorExpression: Builder.markExprChild(S-&gt;getArg(0), syntax::NodeRole::LeftHandSide); Builder.markChildToken(S-&gt;getOperatorLoc(), syntax::NodeRole::OperatorToken); Builder.markExprChild(S-&gt;getArg(1), syntax::NodeRole::RightHandSide); Builder.foldNode(Builder.getExprRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::BinaryOperatorExpression, S); return true; case syntax::NodeKind::PrefixUnaryOperatorExpression: Builder.markChildToken(S-&gt;getOperatorLoc(), syntax::NodeRole::OperatorToken); Builder.markExprChild(S-&gt;getArg(0), syntax::NodeRole::Operand); Builder.foldNode(Builder.getExprRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::PrefixUnaryOperatorExpression, S); return true; case syntax::NodeKind::PostfixUnaryOperatorExpression: Builder.markChildToken(S-&gt;getOperatorLoc(), syntax::NodeRole::OperatorToken); Builder.markExprChild(S-&gt;getArg(0), syntax::NodeRole::Operand); Builder.foldNode(Builder.getExprRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::PostfixUnaryOperatorExpression, S); return true; case syntax::NodeKind::CallExpression: { Builder.markExprChild(S-&gt;getArg(0), syntax::NodeRole::Callee);</p>
<p>const auto *LParenToken = std::next(Builder.findToken(S-&gt;getArg(0)-&gt;getEndLoc())); FIXME: Assert that <code>LParenToken</code> is indeed a <code>l_paren</code> once we have fixed the test on decltype desctructors. if (LParenToken-&gt;kind() == clang::tok::l_paren) Builder.markChildToken(LParenToken, syntax::NodeRole::OpenParen);</p>
<p>Builder.markChild(buildCallArguments(<a class="el" href="classclang_1_1CallExpr.html#ab15c738b5609b17c71c171b1600120e9">CallExpr::arg_range</a>( S-&gt;arg_begin() + 1, S-&gt;arg_end())), syntax::NodeRole::Arguments);</p>
<p>Builder.markChildToken(S-&gt;getRParenLoc(), syntax::NodeRole::CloseParen);</p>
<p>Builder.foldNode(Builder.getRange(S-&gt;getSourceRange()), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::CallExpression, S); return true; } case syntax::NodeKind::UnknownExpression: return WalkUpFromExpr(S); default: llvm_unreachable("getOperatorNodeKind() does not return this value"); } }</p>
<p>bool WalkUpFromCXXDefaultArgExpr(CXXDefaultArgExpr *S) { return true; }</p>
<p>bool WalkUpFromNamespaceDecl(NamespaceDecl *S) { auto Tokens = Builder.getDeclarationRange(S); if (Tokens.front().kind() == tok::coloncolon) { Handle nested namespace definitions. Those start at '::' token, e.g. namespace a^<a class="el" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> {} FIXME: build corresponding nodes for the name of this namespace. return true; } Builder.foldNode(Tokens, new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::NamespaceDefinition, S); return true; }</p>
<p>FIXME: Deleting the <code>TraverseParenTypeLoc</code> override doesn't change test results. Find test coverage or remove it. bool TraverseParenTypeLoc(ParenTypeLoc L) { We reverse order of traversal to get the proper syntax structure. if (!WalkUpFromParenTypeLoc(L)) return false; return TraverseTypeLoc(L.getInnerLoc()); }</p>
<p>bool WalkUpFromParenTypeLoc(ParenTypeLoc L) { Builder.markChildToken(L.getLParenLoc(), syntax::NodeRole::OpenParen); Builder.markChildToken(L.getRParenLoc(), syntax::NodeRole::CloseParen); Builder.foldNode(Builder.getRange(L.getLParenLoc(), L.getRParenLoc()), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::ParenDeclarator, L); return true; }</p>
<p>Declarator chunks, they are produced by type locs and some clang::Decls. bool WalkUpFromArrayTypeLoc(ArrayTypeLoc L) { Builder.markChildToken(L.getLBracketLoc(), syntax::NodeRole::OpenParen); Builder.markExprChild(L.getSizeExpr(), syntax::NodeRole::Size); Builder.markChildToken(L.getRBracketLoc(), syntax::NodeRole::CloseParen); Builder.foldNode(Builder.getRange(L.getLBracketLoc(), L.getRBracketLoc()), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::ArraySubscript, L); return true; }</p>
<p>syntax::ParameterDeclarationList * buildParameterDeclarationList(ArrayRef&lt;ParmVarDecl *&gt; Params) { for (auto *P : Params) { Builder.markChild(P, syntax::NodeRole::ListElement); const auto *DelimiterToken = std::next(Builder.findToken(P-&gt;getEndLoc())); if (DelimiterToken-&gt;kind() == clang::tok::TokenKind::comma) Builder.markChildToken(DelimiterToken, syntax::NodeRole::ListDelimiter); } auto *Parameters = new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::ParameterDeclarationList; if (!Params.empty()) Builder.foldNode(Builder.getRange(Params.front()-&gt;getBeginLoc(), Params.back()-&gt;getEndLoc()), Parameters, nullptr); return Parameters; }</p>
<p>bool WalkUpFromFunctionTypeLoc(FunctionTypeLoc L) { Builder.markChildToken(L.getLParenLoc(), syntax::NodeRole::OpenParen);</p>
<p>Builder.markChild(buildParameterDeclarationList(L.getParams()), syntax::NodeRole::Parameters);</p>
<p>Builder.markChildToken(L.getRParenLoc(), syntax::NodeRole::CloseParen); Builder.foldNode(Builder.getRange(L.getLParenLoc(), L.getEndLoc()), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::ParametersAndQualifiers, L); return true; }</p>
<p>bool WalkUpFromFunctionProtoTypeLoc(FunctionProtoTypeLoc L) { if (!L.getTypePtr()-&gt;hasTrailingReturn()) return WalkUpFromFunctionTypeLoc(L);</p>
<p>auto *TrailingReturnTokens = buildTrailingReturn(L); Finish building the node for parameters. Builder.markChild(TrailingReturnTokens, syntax::NodeRole::TrailingReturn); return WalkUpFromFunctionTypeLoc(L); }</p>
<p>bool TraverseMemberPointerTypeLoc(MemberPointerTypeLoc L) { In the source code "void (Y::*mp)()" <code>MemberPointerTypeLoc</code> corresponds to "Y::*" but it points to a <code>ParenTypeLoc</code> that corresponds to "(Y::*mp)" We thus reverse the order of traversal to get the proper syntax structure. if (!WalkUpFromMemberPointerTypeLoc(L)) return false; return TraverseTypeLoc(L.getPointeeLoc()); }</p>
<p>bool WalkUpFromMemberPointerTypeLoc(MemberPointerTypeLoc L) { auto SR = L.getLocalSourceRange(); Builder.foldNode(Builder.getRange(SR), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::MemberPointer, L); return true; }</p>
<p>The code below is very regular, it could even be generated with some preprocessor magic. We merely assign roles to the corresponding children and fold resulting nodes. bool WalkUpFromDeclStmt(DeclStmt *S) { Builder.foldNode(Builder.getStmtRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::DeclarationStatement, S); return true; }</p>
<p>bool WalkUpFromNullStmt(NullStmt *S) { Builder.foldNode(Builder.getStmtRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::EmptyStatement, S); return true; }</p>
<p>bool WalkUpFromSwitchStmt(SwitchStmt *S) { Builder.markChildToken(S-&gt;getSwitchLoc(), syntax::NodeRole::IntroducerKeyword); Builder.markStmtChild(S-&gt;getBody(), syntax::NodeRole::BodyStatement); Builder.foldNode(Builder.getStmtRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::SwitchStatement, S); return true; }</p>
<p>bool WalkUpFromCaseStmt(CaseStmt *S) { Builder.markChildToken(S-&gt;getKeywordLoc(), syntax::NodeRole::IntroducerKeyword); Builder.markExprChild(S-&gt;getLHS(), syntax::NodeRole::CaseValue); Builder.markStmtChild(S-&gt;getSubStmt(), syntax::NodeRole::BodyStatement); Builder.foldNode(Builder.getStmtRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::CaseStatement, S); return true; }</p>
<p>bool WalkUpFromDefaultStmt(DefaultStmt *S) { Builder.markChildToken(S-&gt;getKeywordLoc(), syntax::NodeRole::IntroducerKeyword); Builder.markStmtChild(S-&gt;getSubStmt(), syntax::NodeRole::BodyStatement); Builder.foldNode(Builder.getStmtRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::DefaultStatement, S); return true; }</p>
<p>bool WalkUpFromIfStmt(IfStmt *S) { Builder.markChildToken(S-&gt;getIfLoc(), syntax::NodeRole::IntroducerKeyword); Stmt *ConditionStatement = S-&gt;getCond(); if (S-&gt;hasVarStorage()) ConditionStatement = S-&gt;getConditionVariableDeclStmt(); Builder.markStmtChild(ConditionStatement, syntax::NodeRole::Condition); Builder.markStmtChild(S-&gt;getThen(), syntax::NodeRole::ThenStatement); Builder.markChildToken(S-&gt;getElseLoc(), syntax::NodeRole::ElseKeyword); Builder.markStmtChild(S-&gt;getElse(), syntax::NodeRole::ElseStatement); Builder.foldNode(Builder.getStmtRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::IfStatement, S); return true; }</p>
<p>bool WalkUpFromForStmt(ForStmt *S) { Builder.markChildToken(S-&gt;getForLoc(), syntax::NodeRole::IntroducerKeyword); Builder.markStmtChild(S-&gt;getBody(), syntax::NodeRole::BodyStatement); Builder.foldNode(Builder.getStmtRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::ForStatement, S); return true; }</p>
<p>bool WalkUpFromWhileStmt(WhileStmt *S) { Builder.markChildToken(S-&gt;getWhileLoc(), syntax::NodeRole::IntroducerKeyword); Builder.markStmtChild(S-&gt;getBody(), syntax::NodeRole::BodyStatement); Builder.foldNode(Builder.getStmtRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::WhileStatement, S); return true; }</p>
<p>bool WalkUpFromContinueStmt(ContinueStmt *S) { Builder.markChildToken(S-&gt;getContinueLoc(), syntax::NodeRole::IntroducerKeyword); Builder.foldNode(Builder.getStmtRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::ContinueStatement, S); return true; }</p>
<p>bool WalkUpFromBreakStmt(BreakStmt *S) { Builder.markChildToken(S-&gt;getBreakLoc(), syntax::NodeRole::IntroducerKeyword); Builder.foldNode(Builder.getStmtRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::BreakStatement, S); return true; }</p>
<p>bool WalkUpFromReturnStmt(ReturnStmt *S) { Builder.markChildToken(S-&gt;getReturnLoc(), syntax::NodeRole::IntroducerKeyword); Builder.markExprChild(S-&gt;getRetValue(), syntax::NodeRole::ReturnValue); Builder.foldNode(Builder.getStmtRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::ReturnStatement, S); return true; }</p>
<p>bool WalkUpFromCXXForRangeStmt(CXXForRangeStmt *S) { Builder.markChildToken(S-&gt;getForLoc(), syntax::NodeRole::IntroducerKeyword); Builder.markStmtChild(S-&gt;getBody(), syntax::NodeRole::BodyStatement); Builder.foldNode(Builder.getStmtRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::RangeBasedForStatement, S); return true; }</p>
<p>bool WalkUpFromEmptyDecl(EmptyDecl *S) { Builder.foldNode(Builder.getDeclarationRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::EmptyDeclaration, S); return true; }</p>
<p>bool WalkUpFromStaticAssertDecl(StaticAssertDecl *S) { Builder.markExprChild(S-&gt;getAssertExpr(), syntax::NodeRole::Condition); Builder.markExprChild(S-&gt;getMessage(), syntax::NodeRole::Message); Builder.foldNode(Builder.getDeclarationRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::StaticAssertDeclaration, S); return true; }</p>
<p>bool WalkUpFromLinkageSpecDecl(LinkageSpecDecl *S) { Builder.foldNode(Builder.getDeclarationRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::LinkageSpecificationDeclaration, S); return true; }</p>
<p>bool WalkUpFromNamespaceAliasDecl(NamespaceAliasDecl *S) { Builder.foldNode(Builder.getDeclarationRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::NamespaceAliasDefinition, S); return true; }</p>
<p>bool WalkUpFromUsingDirectiveDecl(UsingDirectiveDecl *S) { Builder.foldNode(Builder.getDeclarationRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::UsingNamespaceDirective, S); return true; }</p>
<p>bool WalkUpFromUsingDecl(UsingDecl *S) { Builder.foldNode(Builder.getDeclarationRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::UsingDeclaration, S); return true; }</p>
<p>bool WalkUpFromUnresolvedUsingValueDecl(UnresolvedUsingValueDecl *S) { Builder.foldNode(Builder.getDeclarationRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::UsingDeclaration, S); return true; }</p>
<p>bool WalkUpFromUnresolvedUsingTypenameDecl(UnresolvedUsingTypenameDecl *S) { Builder.foldNode(Builder.getDeclarationRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::UsingDeclaration, S); return true; }</p>
<p>bool WalkUpFromTypeAliasDecl(TypeAliasDecl *S) { Builder.foldNode(Builder.getDeclarationRange(S), new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2" title="A small helper to save some typing.">allocator()</a>) syntax::TypeAliasDeclaration, S); return true; }</p>
<p>private: / Folds SimpleDeclarator node (if present) and in case this is the last / declarator in the chain it also folds SimpleDeclaration node. template &lt;class T&gt; bool processDeclaratorAndDeclaration(T *D) { auto Range = getDeclaratorRange( Builder.sourceManager(), D-&gt;getTypeSourceInfo()-&gt;getTypeLoc(), getQualifiedNameStart(D), getInitializerRange(D));</p>
<p>There doesn't have to be a declarator (e.g. <code>void foo(int)</code> only has </p>

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l01593">1593</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuildTree_8cpp_source.html#l01677">allocator()</a>.</p>

</div>
</div>
<a id="ab49e6638d8b070ccf2a29578a5055d7a" name="ab49e6638d8b070ccf2a29578a5055d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49e6638d8b070ccf2a29578a5055d7a">&#9670;&#160;</a></span>IgnoreCXXFunctionalCastExprWrappingConstructor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1Expr.html">Expr</a> * IgnoreCXXFunctionalCastExprWrappingConstructor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a> *</td>          <td class="paramname"><span class="paramname"><em>E</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l00072">72</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BuildTree_8cpp_source.html#l00080">IgnoreImplicit()</a>.</p>

</div>
</div>
<a id="a7973a80f08272178071162f509a04caf" name="a7973a80f08272178071162f509a04caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7973a80f08272178071162f509a04caf">&#9670;&#160;</a></span>IgnoreImplicit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1Expr.html">Expr</a> * IgnoreImplicit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a> *</td>          <td class="paramname"><span class="paramname"><em>E</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l00080">80</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuildTree_8cpp_source.html#l00072">IgnoreCXXFunctionalCastExprWrappingConstructor()</a>, <a class="el" href="IgnoreExpr_8h_source.html#l00034">clang::IgnoreExprNodes()</a>, <a class="el" href="BuildTree_8cpp_source.html#l00053">IgnoreImplicitConstructorSingleStep()</a>, and <a class="el" href="IgnoreExpr_8h_source.html#l00111">clang::IgnoreImplicitSingleStep()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BuildTree_8cpp_source.html#l00087">isImplicitExpr()</a>.</p>

</div>
</div>
<a id="af72714cd1bb2d0d6627db5a14dc52f97" name="af72714cd1bb2d0d6627db5a14dc52f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72714cd1bb2d0d6627db5a14dc52f97">&#9670;&#160;</a></span>IgnoreImplicitConstructorSingleStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1Expr.html">Expr</a> * IgnoreImplicitConstructorSingleStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a> *</td>          <td class="paramname"><span class="paramname"><em>E</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l00053">53</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a6f904bf7056cbce941d51eeebe3bfd5ca0d61f8370cad1d412f80b84d143e1257">clang::C</a>.</p>

<p class="reference">Referenced by <a class="el" href="BuildTree_8cpp_source.html#l00080">IgnoreImplicit()</a>, and <a class="el" href="Expr_8cpp_source.html#l03125">clang::Expr::IgnoreUnlessSpelledInSource()</a>.</p>

</div>
</div>
<a id="aa618e237633bf63db8b922315aaa6d37" name="aa618e237633bf63db8b922315aaa6d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa618e237633bf63db8b922315aaa6d37">&#9670;&#160;</a></span>isImplicitExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LLVM_ATTRIBUTE_UNUSED <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> isImplicitExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a> *</td>          <td class="paramname"><span class="paramname"><em>E</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l00087">87</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuildTree_8cpp_source.html#l00080">IgnoreImplicit()</a>.</p>

</div>
</div>
<a id="aa6c2afcea856b997b355479c3bc49410" name="aa6c2afcea856b997b355479c3bc49410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c2afcea856b997b355479c3bc49410">&#9670;&#160;</a></span>markChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Builder markChild </td>
          <td>(</td>
          <td class="paramtype">DL</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">syntax::NodeRole::Declarators</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc0107a1154a69cd7c01e3d686a3fdc0" name="afc0107a1154a69cd7c01e3d686a3fdc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0107a1154a69cd7c01e3d686a3fdc0">&#9670;&#160;</a></span>markChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Builder markChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab409187cd8023f701425d74753612d6b">N</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">syntax::NodeRole::ListElement</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aa87dc9caf4e431513d7b0ca4bb389a25" name="aa87dc9caf4e431513d7b0ca4bb389a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87dc9caf4e431513d7b0ca4bb389a25">&#9670;&#160;</a></span>Builder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">syntax::TreeBuilder&amp; Builder</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l01679">1679</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BuildTree_8cpp_source.html#l01753">clang::syntax::buildSyntaxTree()</a>.</p>

</div>
</div>
<a id="a3aeaeb39eb301ad5f1a31cad0934e732" name="a3aeaeb39eb301ad5f1a31cad0934e732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aeaeb39eb301ad5f1a31cad0934e732">&#9670;&#160;</a></span>Context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a>&amp; Context</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l01680">1680</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BuildTree_8cpp_source.html#l01753">clang::syntax::buildSyntaxTree()</a>.</p>

</div>
</div>
<a id="aed67ee690ac5ba179fccb86950a6afd9" name="aed67ee690ac5ba179fccb86950a6afd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed67ee690ac5ba179fccb86950a6afd9">&#9670;&#160;</a></span>DeclarationRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto DeclarationRange = Builder.getDeclarationRange(D)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l01613">1613</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

</div>
</div>
<a id="a0544c3fe466e421738dae463968b70ba" name="a0544c3fe466e421738dae463968b70ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0544c3fe466e421738dae463968b70ba">&#9670;&#160;</a></span>else</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">else</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">      <span class="keyword">auto</span> *DL = <span class="keyword">new</span> (<a class="code hl_function" href="#ab94093fefa46a9c9540e2f49b161aac2">allocator</a>()) <a class="code hl_class" href="classclang_1_1syntax_1_1DeclaratorList.html">syntax::DeclaratorList</a></div>
<div class="ttc" id="aBuildTree_8cpp_html_ab94093fefa46a9c9540e2f49b161aac2"><div class="ttname"><a href="#ab94093fefa46a9c9540e2f49b161aac2">allocator</a></div><div class="ttdeci">llvm::BumpPtrAllocator &amp; allocator()</div><div class="ttdoc">A small helper to save some typing.</div><div class="ttdef"><b>Definition</b> <a href="BuildTree_8cpp_source.html#l01677">BuildTree.cpp:1677</a></div></div>
<div class="ttc" id="aclassclang_1_1syntax_1_1DeclaratorList_html"><div class="ttname"><a href="classclang_1_1syntax_1_1DeclaratorList.html">clang::syntax::DeclaratorList</a></div><div class="ttdef"><b>Definition</b> <a href="Nodes_8h_source.html#l00393">Nodes.h:393</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l01611">1611</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

</div>
</div>
<a id="ab409187cd8023f701425d74753612d6b" name="ab409187cd8023f701425d74753612d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab409187cd8023f701425d74753612d6b">&#9670;&#160;</a></span>N</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto* N = new (<a class="el" href="#ab94093fefa46a9c9540e2f49b161aac2">allocator</a>()) <a class="el" href="classclang_1_1syntax_1_1SimpleDeclarator.html">syntax::SimpleDeclarator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l01601">1601</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaTemplate_8cpp_source.html#l08610">clang::Sema::ActOnClassTemplateSpecialization()</a>, <a class="el" href="SemaCXXScopeSpec_8cpp_source.html#l00886">clang::Sema::ActOnCXXNestedNameSpecifier()</a>, <a class="el" href="SemaExprCXX_8cpp_source.html#l01852">clang::Sema::ActOnCXXNew()</a>, <a class="el" href="SemaExprCXX_8cpp_source.html#l07410">clang::Sema::ActOnDecltypeExpression()</a>, <a class="el" href="SemaDecl_8cpp_source.html#l18705">clang::Sema::ActOnFields()</a>, <a class="el" href="SemaModule_8cpp_source.html#l00545">clang::Sema::ActOnModuleImport()</a>, <a class="el" href="SemaExpr_8cpp_source.html#l03845">clang::Sema::ActOnNumericConstant()</a>, <a class="el" href="SemaExpr_8cpp_source.html#l01956">clang::Sema::ActOnStringLiteral()</a>, <a class="el" href="SemaTemplate_8cpp_source.html#l04232">clang::Sema::ActOnTagTemplateIdType()</a>, <a class="el" href="SemaTemplate_8cpp_source.html#l04123">clang::Sema::ActOnTemplateIdType()</a>, <a class="el" href="SemaTemplate_8cpp_source.html#l10828">clang::Sema::ActOnTypenameType()</a>, <a class="el" href="SemaExprCXX_8cpp_source.html#l05616">clang::Sema::ActOnTypeTrait()</a>, <a class="el" href="SemaTemplate_8cpp_source.html#l04514">clang::Sema::ActOnVarTemplateSpecialization()</a>, <a class="el" href="ExplodedGraph_8h_source.html#l00470">clang::ento::ExplodedNodeSet::Add()</a>, <a class="el" href="SemaLookup_8cpp_source.html#l02977">addAssociatedClassesAndNamespaces()</a>, <a class="el" href="SemaOverload_8cpp_source.html#l08010">clang::Sema::AddBuiltinCandidate()</a>, <a class="el" href="SemaOverload_8cpp_source.html#l09447">clang::Sema::AddBuiltinOperatorCandidates()</a>, <a class="el" href="SemaCodeComplete_8cpp_source.html#l08022">AddClassMessageCompletions()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l03455">clang::ento::FalsePositiveRefutationBRVisitor::addConstraints()</a>, <a class="el" href="ASTWriter_8cpp_source.html#l05923">clang::ASTRecordWriter::AddCXXDefinitionData()</a>, <a class="el" href="SemaCodeComplete_8cpp_source.html#l03041">AddFunctionParameterChunks()</a>, <a class="el" href="SemaLambda_8cpp_source.html#l01532">addFunctionPointerConversion()</a>, <a class="el" href="ASTDiff_8cpp_source.html#l00146">clang::diff::SyntaxTree::Impl::addNode()</a>, <a class="el" href="CoreEngine_8h_source.html#l00340">clang::ento::NodeBuilder::addNodes()</a>, <a class="el" href="SemaCodeComplete_8cpp_source.html#l04864">AddObjCBlockCall()</a>, <a class="el" href="DeclContextInternals_8h_source.html#l00215">clang::StoredDeclsList::addOrReplaceDecl()</a>, <a class="el" href="SemaCodeComplete_8cpp_source.html#l07789">AddSuperSendCompletion()</a>, <a class="el" href="SemaOverload_8cpp_source.html#l07787">clang::Sema::AddSurrogateCandidate()</a>, <a class="el" href="SemaTemplateInstantiateDecl_8cpp_source.html#l04038">clang::TemplateDeclInstantiator::adjustForRewrite()</a>, <a class="el" href="CGOpenMPRuntime_8cpp_source.html#l00982">clang::CodeGen::ReductionCodeGen::adjustPrivateAddress()</a>, <a class="el" href="Parsing_8cpp_source.html#l00144">advance()</a>, <a class="el" href="Descriptor_8cpp_source.html#l00324">clang::interp::InitMap::allocate()</a>, <a class="el" href="BasicObjCFoundationChecks_8cpp_source.html#l00966">alreadyExecutedAtLeastOneLoopIteration()</a>, <a class="el" href="Stmt_8cpp_source.html#l00601">clang::GCCAsmStmt::AnalyzeAsmString()</a>, <a class="el" href="RetainCountDiagnostics_8cpp_source.html#l00373">annotateConsumedSummaryMismatch()</a>, <a class="el" href="RetainCountDiagnostics_8cpp_source.html#l00423">annotateStartParameter()</a>, <a class="el" href="APValue_8cpp_source.html#l00311">clang::APValue::APValue()</a>, <a class="el" href="APValue_8h_source.html#l00319">clang::APValue::APValue()</a>, <a class="el" href="APValue_8h_source.html#l00330">clang::APValue::APValue()</a>, <a class="el" href="Tree_8cpp_source.html#l00277">clang::syntax::Node::assertInvariantsRecursive()</a>, <a class="el" href="ExprEngine_8cpp_source.html#l02686">assumeCondition()</a>, <a class="el" href="ASTMatchers_8h_source.html#l03168">clang::ast_matchers::AST_MATCHER_P()</a>, <a class="el" href="ASTMatchers_8h_source.html#l04555">clang::ast_matchers::AST_MATCHER_P()</a>, <a class="el" href="ASTMatchers_8h_source.html#l02769">clang::ast_matchers::AST_MATCHER_P()</a>, <a class="el" href="ASTMatchers_8h_source.html#l03876">clang::ast_matchers::AST_MATCHER_P()</a>, <a class="el" href="ASTMatchers_8h_source.html#l04578">clang::ast_matchers::AST_MATCHER_P2()</a>, <a class="el" href="ASTMatchers_8h_source.html#l04538">clang::ast_matchers::AST_MATCHER_P2()</a>, <a class="el" href="ASTMatchers_8h_source.html#l04494">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P()</a>, <a class="el" href="ASTMatchers_8h_source.html#l04467">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P()</a>, <a class="el" href="ASTMatchers_8h_source.html#l01090">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P()</a>, <a class="el" href="ASTMatchers_8h_source.html#l04518">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P2()</a>, <a class="el" href="ASTMatchers_8h_source.html#l04877">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P2()</a>, <a class="el" href="ASTMatchers_8h_source.html#l01068">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P2()</a>, <a class="el" href="ASTVector_8h_source.html#l00060">clang::ASTVector&lt; T &gt;::ASTVector()</a>, <a class="el" href="SemaLambda_8cpp_source.html#l02157">clang::Sema::BuildBlockForLambdaConversion()</a>, <a class="el" href="SemaLambda_8cpp_source.html#l01938">clang::Sema::BuildLambdaExpr()</a>, <a class="el" href="SemaOverload_8cpp_source.html#l15338">clang::Sema::BuildLiteralOperatorCall()</a>, <a class="el" href="RewriteRule_8cpp_source.html#l00410">clang::transformer::detail::buildMatchers()</a>, <a class="el" href="SemaExprObjC_8cpp_source.html#l00794">clang::Sema::BuildObjCArrayLiteral()</a>, <a class="el" href="SemaExprCXX_8cpp_source.html#l05585">clang::Sema::BuildTypeTrait()</a>, <a class="el" href="BumpVector_8h_source.html#l00075">clang::BumpVector&lt; T &gt;::BumpVector()</a>, <a class="el" href="CGNonTrivialStruct_8cpp_source.html#l00823">callSpecialFunction()</a>, <a class="el" href="ExprConstant_8cpp_source.html#l03079">CastToDerivedClass()</a>, <a class="el" href="Dominators_8h_source.html#l00160">clang::CFGDominatorTreeImpl&lt; IsPostDom &gt;::changeImmediateDominator()</a>, <a class="el" href="Interp_8cpp_source.html#l00056">CheckActive()</a>, <a class="el" href="SemaTemplate_8cpp_source.html#l03643">checkBuiltinTemplateIdType()</a>, <a class="el" href="SemaDecl_8cpp_source.html#l14020">clang::Sema::CheckCompleteVariableDeclaration()</a>, <a class="el" href="SemaDeclCXX_8cpp_source.html#l02230">CheckConstexprFunctionBody()</a>, <a class="el" href="SemaDeclCXX_8cpp_source.html#l06307">checkCUDADeviceBuiltinSurfaceClassTemplate()</a>, <a class="el" href="SemaDeclCXX_8cpp_source.html#l06361">checkCUDADeviceBuiltinTextureClassTemplate()</a>, <a class="el" href="ExprConstant_8cpp_source.html#l02375">CheckEvaluationResult()</a>, <a class="el" href="SemaDeclCXX_8cpp_source.html#l10296">clang::Sema::checkIllFormedTrivialABIStruct()</a>, <a class="el" href="NullabilityChecker_8cpp_source.html#l00452">checkInvariantViolation()</a>, <a class="el" href="SemaOverload_8cpp_source.html#l07423">clang::Sema::CheckNonDependentConversions()</a>, <a class="el" href="SemaChecking_8cpp_source.html#l14521">checkObjCArrayLiteral()</a>, <a class="el" href="SemaChecking_8cpp_source.html#l14550">checkObjCDictionaryLiteral()</a>, <a class="el" href="SemaOpenMP_8cpp_source.html#l09573">checkOpenMPLoop()</a>, <a class="el" href="ASTReader_8cpp_source.html#l00649">checkPreprocessorOptions()</a>, <a class="el" href="RetainCountChecker_8cpp_source.html#l01066">clang::ento::retaincountchecker::RetainCountChecker::checkReturnWithRetEffect()</a>, <a class="el" href="SemaTemplate_8cpp_source.html#l08585">clang::Sema::CheckTemplatePartialSpecializationArgs()</a>, <a class="el" href="SemaDeclCXX_8cpp_source.html#l18673">clang::Sema::checkThisInStaticMemberFunctionAttributes()</a>, <a class="el" href="SemaExprCXX_8cpp_source.html#l05562">clang::Sema::CheckTypeTraitArity()</a>, <a class="el" href="SemaTemplate_8cpp_source.html#l04720">clang::Sema::CheckVarTemplateId()</a>, <a class="el" href="CFG_8h_source.html#l01448">llvm::GraphTraits&lt; ::clang::CFGBlock * &gt;::child_begin()</a>, <a class="el" href="CallGraph_8h_source.html#l00249">llvm::GraphTraits&lt; clang::CallGraphNode * &gt;::child_begin()</a>, <a class="el" href="Dominators_8h_source.html#l00285">llvm::GraphTraits&lt; clang::DomTreeNode * &gt;::child_begin()</a>, <a class="el" href="ExplodedGraph_8h_source.html#l00519">llvm::GraphTraits&lt; clang::ento::ExplodedGraph * &gt;::child_begin()</a>, <a class="el" href="StmtGraphTraits_8h_source.html#l00030">llvm::GraphTraits&lt; clang::Stmt * &gt;::child_begin()</a>, <a class="el" href="CFG_8h_source.html#l01457">llvm::GraphTraits&lt; const ::clang::CFGBlock * &gt;::child_begin()</a>, <a class="el" href="CallGraph_8h_source.html#l00259">llvm::GraphTraits&lt; const clang::CallGraphNode * &gt;::child_begin()</a>, <a class="el" href="StmtGraphTraits_8h_source.html#l00056">llvm::GraphTraits&lt; const clang::Stmt * &gt;::child_begin()</a>, <a class="el" href="CFG_8h_source.html#l01469">llvm::GraphTraits&lt; Inverse&lt; ::clang::CFGBlock * &gt; &gt;::child_begin()</a>, <a class="el" href="CFG_8h_source.html#l01481">llvm::GraphTraits&lt; Inverse&lt; const ::clang::CFGBlock * &gt; &gt;::child_begin()</a>, <a class="el" href="CFG_8h_source.html#l01449">llvm::GraphTraits&lt; ::clang::CFGBlock * &gt;::child_end()</a>, <a class="el" href="CallGraph_8h_source.html#l00250">llvm::GraphTraits&lt; clang::CallGraphNode * &gt;::child_end()</a>, <a class="el" href="Dominators_8h_source.html#l00286">llvm::GraphTraits&lt; clang::DomTreeNode * &gt;::child_end()</a>, <a class="el" href="ExplodedGraph_8h_source.html#l00525">llvm::GraphTraits&lt; clang::ento::ExplodedGraph * &gt;::child_end()</a>, <a class="el" href="StmtGraphTraits_8h_source.html#l00035">llvm::GraphTraits&lt; clang::Stmt * &gt;::child_end()</a>, <a class="el" href="CFG_8h_source.html#l01458">llvm::GraphTraits&lt; const ::clang::CFGBlock * &gt;::child_end()</a>, <a class="el" href="CallGraph_8h_source.html#l00260">llvm::GraphTraits&lt; const clang::CallGraphNode * &gt;::child_end()</a>, <a class="el" href="StmtGraphTraits_8h_source.html#l00061">llvm::GraphTraits&lt; const clang::Stmt * &gt;::child_end()</a>, <a class="el" href="CFG_8h_source.html#l01470">llvm::GraphTraits&lt; Inverse&lt; ::clang::CFGBlock * &gt; &gt;::child_end()</a>, <a class="el" href="CFG_8h_source.html#l01482">llvm::GraphTraits&lt; Inverse&lt; const ::clang::CFGBlock * &gt; &gt;::child_end()</a>, <a class="el" href="TokenBufferTokenManager_8h_source.html#l00026">clang::syntax::TokenBufferTokenManager::classof()</a>, <a class="el" href="CGCleanup_8h_source.html#l00216">clang::CodeGen::EHCatchScope::clearHandlerBlocks()</a>, <a class="el" href="SemaCodeComplete_8cpp_source.html#l04755">clang::Sema::CodeCompleteExpression()</a>, <a class="el" href="SemaCodeComplete_8cpp_source.html#l04282">clang::Sema::CodeCompleteModuleImport()</a>, <a class="el" href="SemaCodeComplete_8cpp_source.html#l08132">clang::Sema::CodeCompleteObjCInstanceMessage()</a>, <a class="el" href="SemaCodeComplete_8cpp_source.html#l09465">clang::Sema::CodeCompleteObjCMethodDecl()</a>, <a class="el" href="SemaCodeComplete_8cpp_source.html#l09642">clang::Sema::CodeCompleteObjCMethodDeclSelector()</a>, <a class="el" href="SemaCodeComplete_8cpp_source.html#l08305">clang::Sema::CodeCompleteObjCSelector()</a>, <a class="el" href="ASTReader_8cpp_source.html#l00598">collectMacroDefinitions()</a>, <a class="el" href="SemaOverload_8cpp_source.html#l06219">collectViableConversionCandidates()</a>, <a class="el" href="DeclarationName_8cpp_source.html#l00046">clang::DeclarationName::compare()</a>, <a class="el" href="ComputeDependence_8cpp_source.html#l00880">clang::computeDependence()</a>, <a class="el" href="ComputeDependence_8cpp_source.html#l00888">clang::computeDependence()</a>, <a class="el" href="ComputeDependence_8cpp_source.html#l00606">clang::computeDependence()</a>, <a class="el" href="ASTCommon_8cpp_source.html#l00281">clang::serialization::ComputeHash()</a>, <a class="el" href="ThreadSafetyTIL_8cpp_source.html#l00277">computeNodeID()</a>, <a class="el" href="ThreadSafetyTIL_8cpp_source.html#l00266">computeNodeSize()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l01992">constructDebugPieceForTrackedCondition()</a>, <a class="el" href="SemaTemplateVariadic_8cpp_source.html#l00858">clang::Sema::containsUnexpandedParameterPacks()</a>, <a class="el" href="SemaTemplateDeduction_8cpp_source.html#l02726">ConvertDeducedTemplateArguments()</a>, <a class="el" href="SemaInit_8cpp_source.html#l06747">CopyObject()</a>, <a class="el" href="Decl_8h_source.html#l02093">clang::FunctionDecl::Create()</a>, <a class="el" href="DeclCXX_8cpp_source.html#l03330">clang::MSPropertyDecl::Create()</a>, <a class="el" href="DeclOpenMP_8cpp_source.html#l00150">clang::OMPDeclareMapperDecl::CreateDeserialized()</a>, <a class="el" href="DeclOpenMP_8cpp_source.html#l00092">clang::OMPRequiresDecl::CreateDeserialized()</a>, <a class="el" href="DeclOpenMP_8cpp_source.html#l00038">clang::OMPThreadPrivateDecl::CreateDeserialized()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l01634">clang::OMPAffinityClause::CreateEmpty()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l01012">clang::OMPAllocateClause::CreateEmpty()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l00688">clang::OMPCopyinClause::CreateEmpty()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l00729">clang::OMPCopyprivateClause::CreateEmpty()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l01070">clang::OMPDependClause::CreateEmpty()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l01692">clang::OMPDoacrossClause::CreateEmpty()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l01551">clang::OMPExclusiveClause::CreateEmpty()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l00476">clang::OMPFirstprivateClause::CreateEmpty()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l01030">clang::OMPFlushClause::CreateEmpty()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l01533">clang::OMPInclusiveClause::CreateEmpty()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l01657">clang::OMPInitClause::CreateEmpty()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l00944">clang::OMPInReductionClause::CreateEmpty()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l00528">clang::OMPLastprivateClause::CreateEmpty()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l01509">clang::OMPNontemporalClause::CreateEmpty()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l00443">clang::OMPPrivateClause::CreateEmpty()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l00825">clang::OMPReductionClause::CreateEmpty()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l00546">clang::OMPSharedClause::CreateEmpty()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l00881">clang::OMPTaskReductionClause::CreateEmpty()</a>, <a class="el" href="OpenMPClause_8cpp_source.html#l01614">clang::OMPUsesAllocatorsClause::CreateEmpty()</a>, <a class="el" href="StmtOpenMP_8cpp_source.html#l01011">OMPTargetDataDirective::CreateEmpty()</a>, <a class="el" href="StmtOpenMP_8cpp_source.html#l01026">OMPTargetEnterDataDirective::CreateEmpty()</a>, <a class="el" href="StmtOpenMP_8cpp_source.html#l01040">OMPTargetExitDataDirective::CreateEmpty()</a>, <a class="el" href="Program_8cpp_source.html#l00037">clang::interp::Program::createGlobalString()</a>, <a class="el" href="DeclTemplate_8cpp_source.html#l01466">createMakeIntegerSeqParameterList()</a>, <a class="el" href="ExprCXX_8cpp_source.html#l01133">clang::CXXConstructExpr::CXXConstructExpr()</a>, <a class="el" href="ASTContext_8h_source.html#l00725">clang::ASTContext::DeallocateDeclListNode()</a>, <a class="el" href="Synthesis_8cpp_source.html#l00217">clang::syntax::deepCopyExpandingMacros()</a>, <a class="el" href="namespaceclang.html#a2f3da2d195116649c153ac4f13c231e2">clang::DEF_TRAVERSE_TYPELOC()</a>, <a class="el" href="InterpFrame_8cpp_source.html#l00147">clang::interp::InterpFrame::describe()</a>, <a class="el" href="SemaOverload_8cpp_source.html#l06120">diagnoseAmbiguousConversion()</a>, <a class="el" href="PPDirectives_8cpp_source.html#l01824">diagnoseAutoModuleImport()</a>, <a class="el" href="ODRDiagsEmitter_8cpp_source.html#l00704">clang::ODRDiagsEmitter::diagnoseMismatch()</a>, <a class="el" href="ODRDiagsEmitter_8cpp_source.html#l01787">clang::ODRDiagsEmitter::diagnoseMismatch()</a>, <a class="el" href="SemaLookup_8cpp_source.html#l05687">clang::Sema::diagnoseMissingImport()</a>, <a class="el" href="SemaDeclObjC_8cpp_source.html#l03596">clang::Sema::DiagnoseMultipleMethodInGlobalPool()</a>, <a class="el" href="SemaTemplateVariadic_8cpp_source.html#l00291">clang::Sema::DiagnoseUnexpandedParameterPacks()</a>, <a class="el" href="SemaTemplate_8cpp_source.html#l02755">DiagnoseUnexpandedParameterPacks()</a>, <a class="el" href="SemaDeclObjC_8cpp_source.html#l05254">clang::Sema::DiagnoseUseOfUnimplementedSelectors()</a>, <a class="el" href="Disasm_8cpp_source.html#l00036">clang::interp::Function::dump()</a>, <a class="el" href="LayoutOverrideSource_8cpp_source.html#l00248">clang::LayoutOverrideSource::dump()</a>, <a class="el" href="ModuleFile_8cpp_source.html#l00047">clang::serialization::ModuleFile::dump()</a>, <a class="el" href="ExprEngine_8cpp_source.html#l03902">clang::ento::ExprEngine::DumpGraph()</a>, <a class="el" href="Tree_8cpp_source.html#l00227">clang::syntax::Node::dumpTokens()</a>, <a class="el" href="ParentMapContext_8h_source.html#l00100">clang::DynTypedNodeList::DynTypedNodeList()</a>, <a class="el" href="CGOpenMPRuntime_8cpp_source.html#l00821">clang::CodeGen::ReductionCodeGen::emitAggregateType()</a>, <a class="el" href="CGOpenMPRuntime_8cpp_source.html#l00855">clang::CodeGen::ReductionCodeGen::emitAggregateType()</a>, <a class="el" href="ReturnUndefChecker_8cpp_source.html#l00080">emitBug()</a>, <a class="el" href="CGOpenMPRuntime_8cpp_source.html#l00903">clang::CodeGen::ReductionCodeGen::emitCleanups()</a>, <a class="el" href="CGExprScalar_8cpp_source.html#l05209">EmitGEPOffsetInBytes()</a>, <a class="el" href="CGOpenMPRuntime_8cpp_source.html#l00872">clang::CodeGen::ReductionCodeGen::emitInitialization()</a>, <a class="el" href="CGOpenMPRuntime_8cpp_source.html#l05514">emitReduceCombFunction()</a>, <a class="el" href="CGOpenMPRuntime_8cpp_source.html#l05589">emitReduceFiniFunction()</a>, <a class="el" href="CGOpenMPRuntime_8cpp_source.html#l05446">emitReduceInitFunction()</a>, <a class="el" href="CGOpenMPRuntime_8cpp_source.html#l00806">clang::CodeGen::ReductionCodeGen::emitSharedOrigLValue()</a>, <a class="el" href="CGOpenMPRuntime_8cpp_source.html#l05772">clang::CodeGen::CGOpenMPRuntime::emitTaskReductionFixups()</a>, <a class="el" href="WorkList_8h_source.html#l00072">clang::ento::WorkList::enqueue()</a>, <a class="el" href="WorkList_8h_source.html#l00068">clang::ento::WorkList::enqueue()</a>, <a class="el" href="CoreEngine_8cpp_source.html#l00542">clang::ento::CoreEngine::enqueueStmtNode()</a>, <a class="el" href="CGExprCXX_8cpp_source.html#l01486">EnterNewDeleteCleanup()</a>, <a class="el" href="Parse_2Parser_8cpp_source.html#l00406">clang::Parser::EnterScope()</a>, <a class="el" href="ExplodedGraph_8h_source.html#l00479">clang::ento::ExplodedNodeSet::erase()</a>, <a class="el" href="SemaExprCXX_8cpp_source.html#l05402">EvaluateBooleanTypeTrait()</a>, <a class="el" href="ASTMerge_8cpp_source.html#l00033">clang::ASTMergeAction::ExecuteAction()</a>, <a class="el" href="Frontend_2FrontendActions_8cpp_source.html#l00786">clang::DumpModuleInfoAction::ExecuteAction()</a>, <a class="el" href="Template_8h_source.html#l00443">clang::LocalInstantiationScope::Exit()</a>, <a class="el" href="ExprConstant_8cpp_source.html#l03450">expandStringLiteral()</a>, <a class="el" href="ExplodedGraph_8h_source.html#l00463">clang::ento::ExplodedNodeSet::ExplodedNodeSet()</a>, <a class="el" href="SemaDeclCXX_8cpp_source.html#l15841">clang::Sema::FinalizeVarWithDestructor()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l03274">clang::ento::LikelyFalsePositiveSuppressionBRVisitor::finalizeVisitor()</a>, <a class="el" href="SemaExprCXX_8cpp_source.html#l02636">clang::Sema::FindAllocationFunctions()</a>, <a class="el" href="ExprConstant_8cpp_source.html#l03942">FindDesignatorMismatch()</a>, <a class="el" href="BugReporter_8cpp_source.html#l03161">findExecutedLines()</a>, <a class="el" href="ASTReader_8cpp_source.html#l07683">clang::ASTReader::FindExternalLexicalDecls()</a>, <a class="el" href="SemaDeclCXX_8cpp_source.html#l13805">clang::Sema::findInheritingConstructor()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l02179">findNodeForExpression()</a>, <a class="el" href="RewriteRule_8cpp_source.html#l00465">clang::transformer::detail::findSelectedCase()</a>, <a class="el" href="ExprConstant_8cpp_source.html#l03650">findSubobject()</a>, <a class="el" href="SemaTemplateDeduction_8cpp_source.html#l03555">clang::Sema::FinishTemplateArgumentDeduction()</a>, <a class="el" href="BuildTree_8cpp_source.html#l01664">foldTemplateDeclaration()</a>, <a class="el" href="MacroCallReconstructor_8cpp_source.html#l00032">clang::format::forEachToken()</a>, <a class="el" href="SemaCodeComplete_8cpp_source.html#l02955">formatBlockPlaceholder()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l02756">formatModuleId()</a>, <a class="el" href="CoreEngine_8cpp_source.html#l00634">clang::ento::NodeBuilder::generateNodeImpl()</a>, <a class="el" href="CoreEngine_8h_source.html#l00364">clang::ento::NodeBuilderWithSinks::generateSink()</a>, <a class="el" href="SourceManager_8cpp_source.html#l01273">clang::SrcMgr::LineOffsetMapping::get()</a>, <a class="el" href="Dominators_8h_source.html#l00199">llvm::IDFCalculatorDetail::ChildrenGetterTy&lt; clang::CFGBlock, IsPostDom &gt;::get()</a>, <a class="el" href="CodeGenTBAA_8cpp_source.html#l00431">clang::CodeGen::CodeGenTBAA::getAccessTagInfo()</a>, <a class="el" href="FuchsiaHandleChecker_8cpp_source.html#l00233">getAcquireSite()</a>, <a class="el" href="RetainCountDiagnostics_8cpp_source.html#l00667">GetAllocationSite()</a>, <a class="el" href="ExprInspectionChecker_8cpp_source.html#l00133">getArgumentValueString()</a>, <a class="el" href="CGOpenMPRuntime_8h_source.html#l00216">clang::CodeGen::ReductionCodeGen::getBaseDecl()</a>, <a class="el" href="CodeGenTBAA_8cpp_source.html#l00416">clang::CodeGen::CodeGenTBAA::getBaseTypeInfo()</a>, <a class="el" href="RetainCountDiagnostics_8cpp_source.html#l00353">getCalleeNode()</a>, <a class="el" href="BugReporter_8h_source.html#l00531">clang::ento::PathSensitiveBugReport::getCallStackMessage()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l00233">getConcreteIntegerValue()</a>, <a class="el" href="Basic_2Diagnostic_8h_source.html#l00868">clang::DiagnosticsEngine::getCustomDiagID()</a>, <a class="el" href="ASTDiff_8cpp_source.html#l00423">clang::diff::SyntaxTree::Impl::getDeclValue()</a>, <a class="el" href="BugReporter_8cpp_source.html#l02175">clang::ento::PathSensitiveBugReport::getDeclWithIssue()</a>, <a class="el" href="DivZeroChecker_8cpp_source.html#l00041">getDenomExpr()</a>, <a class="el" href="HIPAMD_8cpp_source.html#l00357">clang::driver::toolchains::HIPAMDToolChain::getDeviceLibs()</a>, <a class="el" href="CommonArgs_8cpp_source.html#l01725">clang::driver::tools::getDwarfVersion()</a>, <a class="el" href="Dominators_8h_source.html#l00284">llvm::GraphTraits&lt; clang::DomTreeNode * &gt;::getEntryNode()</a>, <a class="el" href="Module_8cpp_source.html#l00372">clang::Module::getExportedModules()</a>, <a class="el" href="DeclFriend_8h_source.html#l00129">clang::FriendDecl::getFriendTypeTemplateParameterList()</a>, <a class="el" href="DeclarationName_8h_source.html#l00440">clang::DeclarationName::getFromOpaqueInteger()</a>, <a class="el" href="DeclarationName_8h_source.html#l00432">clang::DeclarationName::getFromOpaquePtr()</a>, <a class="el" href="SemaType_8cpp_source.html#l04633">GetFullTypeForDeclarator()</a>, <a class="el" href="LiteralSupport_8cpp_source.html#l01414">clang::NumericLiteralParser::GetIntegerValue()</a>, <a class="el" href="CheckerContext_8h_source.html#l00141">clang::ento::CheckerContext::getLocationRegionIfPostStore()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l00161">getLocationRegionIfReference()</a>, <a class="el" href="SemaLookup_8cpp_source.html#l01558">clang::Sema::getLookupModules()</a>, <a class="el" href="ProgramState_8h_source.html#l00799">clang::ento::ProgramState::getLValue()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l00373">getMatchingCallExitEnd()</a>, <a class="el" href="ASTContext_8cpp_source.html#l02586">clang::ASTContext::getMemberPointerPathAdjustment()</a>, <a class="el" href="BugReporter_8cpp_source.html#l00285">clang::ento::StackHintGeneratorForSymbol::getMessage()</a>, <a class="el" href="GlobalModuleIndex_8cpp_source.html#l00284">clang::GlobalModuleIndex::getModuleDependencies()</a>, <a class="el" href="ExplodedGraph_8cpp_source.html#l00350">clang::ento::ExplodedNode::getNextStmtForDiagnostics()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l02681">clang::ento::NilReceiverBRVisitor::getNilReceiver()</a>, <a class="el" href="ExprEngine_8cpp_source.html#l03848">llvm::DOTGraphTraits&lt; ExplodedGraph * &gt;::getNodeLabel()</a>, <a class="el" href="ASTDiff_8cpp_source.html#l01012">clang::diff::SyntaxTree::getNodeValue()</a>, <a class="el" href="ASTDiff_8cpp_source.html#l00412">clang::diff::SyntaxTree::Impl::getNodeValue()</a>, <a class="el" href="SemaTemplateVariadic_8cpp_source.html#l00805">clang::Sema::getNumArgumentsInExpansion()</a>, <a class="el" href="TextDiagnostic_8cpp_source.html#l01057">getNumDisplayWidth()</a>, <a class="el" href="CGOpenMPRuntime_8h_source.html#l00209">clang::CodeGen::ReductionCodeGen::getOrigLValue()</a>, <a class="el" href="CodeCompleteConsumer_8cpp_source.html#l00587">clang::CodeCompleteConsumer::OverloadCandidate::getParamDecl()</a>, <a class="el" href="CodeCompleteConsumer_8cpp_source.html#l00558">clang::CodeCompleteConsumer::OverloadCandidate::getParamType()</a>, <a class="el" href="SemaCodeComplete_8cpp_source.html#l06013">getParamType()</a>, <a class="el" href="SemaTemplateInstantiate_8cpp_source.html#l03596">getPatternForClassTemplateSpecialization()</a>, <a class="el" href="SemaCodeComplete_8cpp_source.html#l07990">getPreferredArgumentTypeForMessageSend()</a>, <a class="el" href="ExplodedGraph_8cpp_source.html#l00377">clang::ento::ExplodedNode::getPreviousStmtForDiagnostics()</a>, <a class="el" href="Sema_8h_source.html#l02219">clang::Sema::getPrintable()</a>, <a class="el" href="CGOpenMPRuntime_8h_source.html#l00223">clang::CodeGen::ReductionCodeGen::getPrivateType()</a>, <a class="el" href="CGOpenMPRuntime_8h_source.html#l00218">clang::CodeGen::ReductionCodeGen::getRefExpr()</a>, <a class="el" href="CodeGenModule_8cpp_source.html#l04493">GetRuntimeFunctionDecl()</a>, <a class="el" href="CGOpenMPRuntime_8h_source.html#l00207">clang::CodeGen::ReductionCodeGen::getSharedLValue()</a>, <a class="el" href="Expr_8h_source.html#l04475">clang::ShuffleVectorExpr::getShuffleMaskIdx()</a>, <a class="el" href="CGBuilder_8h_source.html#l00062">clang::CodeGen::CGBuilderTy::getSize()</a>, <a class="el" href="CGBuilder_8h_source.html#l00065">clang::CodeGen::CGBuilderTy::getSize()</a>, <a class="el" href="CGCleanup_8h_source.html#l00176">clang::CodeGen::EHCatchScope::getSizeForNumHandlers()</a>, <a class="el" href="CGOpenMPRuntime_8h_source.html#l00212">clang::CodeGen::ReductionCodeGen::getSizes()</a>, <a class="el" href="ASTDiff_8cpp_source.html#l00993">clang::diff::SyntaxTree::getSourceRangeOffsets()</a>, <a class="el" href="BugReporter_8cpp_source.html#l01030">getStmtBeforeCond()</a>, <a class="el" href="ASTDiff_8cpp_source.html#l00280">clang::diff::getSubtreePostorder()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l00208">getSValForVar()</a>, <a class="el" href="CodeGenTBAA_8cpp_source.html#l00320">clang::CodeGen::CodeGenTBAA::getTBAAStructInfo()</a>, <a class="el" href="SemaTemplate_8cpp_source.html#l11336">clang::Sema::getTemplateArgumentBindingsText()</a>, <a class="el" href="SemaTemplate_8cpp_source.html#l00049">clang::getTemplateParamsRange()</a>, <a class="el" href="CodeGenTBAA_8cpp_source.html#l00225">clang::CodeGen::CodeGenTBAA::getTypeInfo()</a>, <a class="el" href="RetainCountChecker_8cpp_source.html#l01207">clang::ento::retaincountchecker::RetainCountChecker::handleAutoreleaseCounts()</a>, <a class="el" href="SemaDeclAttr_8cpp_source.html#l08095">handleCapabilityAttr()</a>, <a class="el" href="ExprConstant_8cpp_source.html#l04685">HandleMemberPointerAccess()</a>, <a class="el" href="ExprConstant_8cpp_source.html#l06834">HandleOperatorDeleteCall()</a>, <a class="el" href="ExprConstant_8cpp_source.html#l06704">HandleOperatorNewCall()</a>, <a class="el" href="ExprEngineC_8cpp_source.html#l00905">clang::ento::ExprEngine::handleUOExtension()</a>, <a class="el" href="HeaderSearch_8cpp_source.html#l01515">clang::HeaderSearch::hasModuleMap()</a>, <a class="el" href="UncheckedOptionalAccessModel_8cpp_source.html#l00048">clang::dataflow::hasOptionalClassName()</a>, <a class="el" href="ASTDiff_8cpp_source.html#l00266">clang::diff::SyntaxTree::Impl::Impl()</a>, <a class="el" href="ASTDiff_8cpp_source.html#l00273">clang::diff::SyntaxTree::Impl::Impl()</a>, <a class="el" href="ASTImporter_8cpp_source.html#l09892">clang::ASTImporter::Import()</a>, <a class="el" href="ASTReaderDecl_8cpp_source.html#l03639">inheritDefaultTemplateArguments()</a>, <a class="el" href="SourceManager_8cpp_source.html#l00361">clang::SourceManager::initializeForReplay()</a>, <a class="el" href="SemaTemplateInstantiateDecl_8cpp_source.html#l04833">clang::Sema::InstantiateFunctionDefinition()</a>, <a class="el" href="SemaTemplateDeduction_8cpp_source.html#l05094">isAtLeastAsSpecializedAs()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00169">clang::ento::isCapturedByReference()</a>, <a class="el" href="ChromiumCheckModel_8cpp_source.html#l00019">clang::dataflow::isCheckLikeMethod()</a>, <a class="el" href="ASTStructuralEquivalence_8cpp_source.html#l00679">IsEquivalentExceptionSpec()</a>, <a class="el" href="DeclSpec_8h_source.html#l02517">clang::Declarator::isFunctionDeclaratorAFunctionDeclaration()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l01242">isInitializationOfVar()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l00258">isInterestingExpr()</a>, <a class="el" href="CharUnits_8h_source.html#l00143">clang::CharUnits::isMultipleOf()</a>, <a class="el" href="ASTDiff_8cpp_source.html#l00172">clang::diff::isNodeExcluded()</a>, <a class="el" href="ExprEngine_8cpp_source.html#l03844">llvm::DOTGraphTraits&lt; ExplodedGraph * &gt;::isNodeHidden()</a>, <a class="el" href="SemaTemplate_8cpp_source.html#l06537">isNullPointerValueTemplateArgument()</a>, <a class="el" href="ParsedAttr_8cpp_source.html#l00257">clang::ParsedAttr::isParamExpr()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00198">clang::ento::isPossiblyEscaped()</a>, <a class="el" href="SemaLookup_8cpp_source.html#l00369">isPreferredLookupResult()</a>, <a class="el" href="MallocChecker_8cpp_source.html#l03348">isReferenceCountingPointerDestructor()</a>, <a class="el" href="SemaTemplate_8cpp_source.html#l04372">isSameAsPrimaryTemplate()</a>, <a class="el" href="ASTContext_8cpp_source.html#l06404">clang::ASTContext::isSameTemplateParameterList()</a>, <a class="el" href="ASTStructuralEquivalence_8cpp_source.html#l00616">IsStructurallyEquivalent()</a>, <a class="el" href="ASTStructuralEquivalence_8cpp_source.html#l00709">IsStructurallyEquivalent()</a>, <a class="el" href="ASTStructuralEquivalence_8cpp_source.html#l01468">IsStructurallyEquivalent()</a>, <a class="el" href="ASTStructuralEquivalence_8cpp_source.html#l01796">IsStructurallyEquivalent()</a>, <a class="el" href="TypePrinter_8cpp_source.html#l02003">isSubstitutedType()</a>, <a class="el" href="SemaTemplateDeduction_8cpp_source.html#l05819">clang::Sema::isTemplateTemplateParameterAtLeastAsSpecializedAs()</a>, <a class="el" href="Module_8cpp_source.html#l00130">clang::Module::isUnimportable()</a>, <a class="el" href="MultilibBuilder_8cpp_source.html#l00073">clang::driver::MultilibBuilder::isValid()</a>, <a class="el" href="DeclCXX_8cpp_source.html#l03375">isValidStructGUID()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l00241">isVarAnInterestingCondition()</a>, <a class="el" href="ItaniumMangle_8cpp_source.html#l05668">isZeroInitialized()</a>, <a class="el" href="SemaDeclCXX_8cpp_source.html#l18227">clang::Sema::LoadExternalVTableUses()</a>, <a class="el" href="DeclTemplate_8cpp_source.html#l00334">clang::RedeclarableTemplateDecl::loadLazySpecializationsImpl()</a>, <a class="el" href="CompilerInstance_8cpp_source.html#l01966">clang::CompilerInstance::loadModule()</a>, <a class="el" href="Preprocessor_8h_source.html#l01801">clang::Preprocessor::LookAhead()</a>, <a class="el" href="GlobalModuleIndex_8cpp_source.html#l00302">clang::GlobalModuleIndex::lookupIdentifier()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00283">clang::ento::madeNewBranch()</a>, <a class="el" href="SemaTemplateDeduction_8cpp_source.html#l06374">clang::Sema::MarkDeducedTemplateParameters()</a>, <a class="el" href="SemaTemplateDeduction_8cpp_source.html#l06356">clang::Sema::MarkUsedTemplateParameters()</a>, <a class="el" href="SemaTemplateDeduction_8cpp_source.html#l05996">MarkUsedTemplateParameters()</a>, <a class="el" href="RangeSelector_8cpp_source.html#l00200">clang::transformer::name()</a>, <a class="el" href="CGOpenMPRuntime_8cpp_source.html#l00897">clang::CodeGen::ReductionCodeGen::needCleanups()</a>, <a class="el" href="SemaInit_8cpp_source.html#l08022">nextPathEntryRange()</a>, <a class="el" href="ExprEngine_8cpp_source.html#l03803">llvm::DOTGraphTraits&lt; ExplodedGraph * &gt;::nodeHasBugReport()</a>, <a class="el" href="Dominators_8h_source.html#l00306">llvm::GraphTraits&lt; clang::CFGDomTree * &gt;::nodes_begin()</a>, <a class="el" href="Dominators_8h_source.html#l00291">llvm::GraphTraits&lt; clang::DomTreeNode * &gt;::nodes_begin()</a>, <a class="el" href="Dominators_8h_source.html#l00310">llvm::GraphTraits&lt; clang::CFGDomTree * &gt;::nodes_end()</a>, <a class="el" href="Dominators_8h_source.html#l00295">llvm::GraphTraits&lt; clang::DomTreeNode * &gt;::nodes_end()</a>, <a class="el" href="SemaOverload_8cpp_source.html#l11499">NoteFunctionCandidate()</a>, <a class="el" href="SemaTemplate_8cpp_source.html#l04434">noteNonDeducibleParameters()</a>, <a class="el" href="CharUnits_8h_source.html#l00165">clang::CharUnits::operator%()</a>, <a class="el" href="StandardLibrary_8cpp_source.html#l00248">clang::tooling::stdlib::Recognizer::operator()()</a>, <a class="el" href="CharUnits_8h_source.html#l00148">clang::CharUnits::operator*()</a>, <a class="el" href="CharUnits_8h_source.html#l00151">clang::CharUnits::operator*=()</a>, <a class="el" href="DeclFriend_8h_source.html#l00230">clang::CXXRecordDecl::friend_iterator::operator+()</a>, <a class="el" href="DependentDiagnostic_8h_source.html#l00165">clang::DeclContext::ddiag_iterator::operator+()</a>, <a class="el" href="DeclFriend_8h_source.html#l00223">clang::CXXRecordDecl::friend_iterator::operator+=()</a>, <a class="el" href="DependentDiagnostic_8h_source.html#l00158">clang::DeclContext::ddiag_iterator::operator+=()</a>, <a class="el" href="CharUnits_8h_source.html#l00155">clang::CharUnits::operator/()</a>, <a class="el" href="CharUnits_8h_source.html#l00158">clang::CharUnits::operator/=()</a>, <a class="el" href="TemplateName_8cpp_source.html#l00357">clang::operator&lt;&lt;()</a>, <a class="el" href="DeclarationName_8h_source.html#l00887">clang::operator&lt;&lt;()</a>, <a class="el" href="DeclarationName_8cpp_source.html#l00208">clang::operator&lt;&lt;()</a>, <a class="el" href="ASTRecordReader_8h_source.html#l00067">clang::ASTRecordReader::operator[]()</a>, <a class="el" href="ASTRecordWriter_8h_source.html#l00086">clang::ASTRecordWriter::operator[]()</a>, <a class="el" href="ParentMapContext_8h_source.html#l00119">clang::DynTypedNodeList::operator[]()</a>, <a class="el" href="DependencyFile_8cpp_source.html#l00336">clang::DependencyFileGenerator::outputDependencyFile()</a>, <a class="el" href="Expr_8cpp_source.html#l01236">clang::StringLiteral::outputString()</a>, <a class="el" href="Basic_2Diagnostic_8h_source.html#l00741">clang::DiagnosticsEngine::overloadCandidatesShown()</a>, <a class="el" href="PartialDiagnostic_8h_source.html#l00090">clang::PartialDiagnostic::PartialDiagnostic()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l02918">clang::ento::ConditionBRVisitor::patternMatch()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l02113">peelOffOuterExpr()</a>, <a class="el" href="ExplodedGraph_8h_source.html#l00515">llvm::GraphTraits&lt; clang::ento::ExplodedGraph * &gt;::predecessorOfTrivial()</a>, <a class="el" href="CGCXXABI_8h_source.html#l00360">clang::CodeGen::CGCXXABI::AddedStructorArgCounts::prefix()</a>, <a class="el" href="CallGraph_8cpp_source.html#l00218">clang::CallGraph::print()</a>, <a class="el" href="Module_8cpp_source.html#l00452">clang::Module::print()</a>, <a class="el" href="TypePrinter_8cpp_source.html#l00842">clang::FunctionProtoType::printExceptionSpecification()</a>, <a class="el" href="APValue_8cpp_source.html#l00696">clang::APValue::printPretty()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l03224">clang::ento::ConditionBRVisitor::printValue()</a>, <a class="el" href="ExprEngineCallAndReturn_8cpp_source.html#l00254">clang::ento::ExprEngine::processCallExit()</a>, <a class="el" href="RetainCountChecker_8cpp_source.html#l01313">clang::ento::retaincountchecker::RetainCountChecker::processLeaks()</a>, <a class="el" href="RetainCountChecker_8cpp_source.html#l00858">clang::ento::retaincountchecker::RetainCountChecker::processNonLeakError()</a>, <a class="el" href="APValue_8cpp_source.html#l00477">clang::APValue::Profile()</a>, <a class="el" href="APValue_8cpp_source.html#l00472">profileIntValue()</a>, <a class="el" href="ASTRecordWriter_8h_source.html#l00079">clang::ASTRecordWriter::push_back()</a>, <a class="el" href="EHScopeStack_8h_source.html#l00317">clang::CodeGen::EHScopeStack::pushCleanupWithExtra()</a>, <a class="el" href="ASTReader_8cpp_source.html#l04286">clang::ASTReader::ReadAST()</a>, <a class="el" href="ASTReader_8cpp_source.html#l05266">clang::ASTReader::readASTFileControlBlock()</a>, <a class="el" href="ASTReader_8cpp_source.html#l10059">clang::OMPClauseReader::readClause()</a>, <a class="el" href="ASTReader_8cpp_source.html#l08484">clang::ASTReader::ReadDelegatingConstructors()</a>, <a class="el" href="ASTReader_8cpp_source.html#l08495">clang::ASTReader::ReadExtVectorDecls()</a>, <a class="el" href="ASTReader_8cpp_source.html#l00899">clang::serialization::reader::ASTSelectorLookupTrait::ReadKey()</a>, <a class="el" href="ASTReader_8cpp_source.html#l08427">clang::ASTReader::ReadKnownNamespaces()</a>, <a class="el" href="ASTReader_8cpp_source.html#l08587">clang::ASTReader::ReadLateParsedTemplates()</a>, <a class="el" href="ASTReader_8cpp_source.html#l08448">clang::ASTReader::ReadMismatchingDeleteExpressions()</a>, <a class="el" href="ASTReader_8cpp_source.html#l09091">clang::ASTRecordReader::readNestedNameSpecifierLoc()</a>, <a class="el" href="ASTReader_8cpp_source.html#l08575">clang::ASTReader::ReadPendingInstantiations()</a>, <a class="el" href="ASTReader_8cpp_source.html#l08463">clang::ASTReader::ReadTentativeDefinitions()</a>, <a class="el" href="ASTReader_8cpp_source.html#l08438">clang::ASTReader::ReadUndefinedButUsed()</a>, <a class="el" href="ASTReader_8cpp_source.html#l08473">clang::ASTReader::ReadUnusedFileScopedDecls()</a>, <a class="el" href="ASTReader_8cpp_source.html#l08505">clang::ASTReader::ReadUnusedLocalTypedefNameCandidates()</a>, <a class="el" href="ASTReader_8cpp_source.html#l08563">clang::ASTReader::ReadUsedVTables()</a>, <a class="el" href="ASTReader_8cpp_source.html#l08545">clang::ASTReader::ReadWeakUndeclaredIdentifiers()</a>, <a class="el" href="SemaTemplate_8cpp_source.html#l11281">clang::Sema::RebuildTemplateParamsInCurrentInstantiation()</a>, <a class="el" href="RetainCountDiagnostics_8cpp_source.html#l00990">clang::ento::retaincountchecker::RefLeakReport::RefLeakReport()</a>, <a class="el" href="DynamicTypePropagation_8cpp_source.html#l00048">REGISTER_MAP_WITH_PROGRAMSTATE()</a>, <a class="el" href="Mutations_8cpp_source.html#l00065">clang::syntax::MutationsImpl::remove()</a>, <a class="el" href="BugReporter_8cpp_source.html#l00371">removeRedundantMsgs()</a>, <a class="el" href="BugReporter_8cpp_source.html#l00421">removeUnneededCalls()</a>, <a class="el" href="ASTUnresolvedSet_8h_source.html#l00084">clang::ASTUnresolvedSet::reserve()</a>, <a class="el" href="ASTVector_8h_source.html#l00173">clang::ASTVector&lt; T &gt;::reserve()</a>, <a class="el" href="BumpVector_8h_source.html#l00197">clang::BumpVector&lt; T &gt;::reserve()</a>, <a class="el" href="ASTUnresolvedSet_8h_source.html#l00110">clang::LazyASTUnresolvedSet::reserve()</a>, <a class="el" href="ThreadSafetyUtil_8h_source.html#l00123">clang::threadSafety::til::SimpleArray&lt; T &gt;::reserveCheck()</a>, <a class="el" href="ASTVector_8h_source.html#l00341">clang::ASTVector&lt; T &gt;::resize()</a>, <a class="el" href="SemaLookup_8cpp_source.html#l00483">clang::LookupResult::resolveKind()</a>, <a class="el" href="ASTReader_8cpp_source.html#l02158">clang::ASTReader::resolvePendingMacro()</a>, <a class="el" href="Preprocessor_8h_source.html#l01814">clang::Preprocessor::RevertCachedTokens()</a>, <a class="el" href="RewriteRope_8cpp_source.html#l00672">clang::RopePieceBTreeIterator::RopePieceBTreeIterator()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00340">sanitizeFilenameAsIdentifier()</a>, <a class="el" href="ASTMatchFinder_8h_source.html#l00278">clang::ast_matchers::selectFirst()</a>, <a class="el" href="Synthesis_8cpp_source.html#l00020">clang::syntax::FactoryImpl::setCanModify()</a>, <a class="el" href="DeclCXX_8cpp_source.html#l01473">clang::CXXRecordDecl::setCaptures()</a>, <a class="el" href="Basic_2Targets_2M68k_8cpp_source.html#l00063">clang::targets::M68kTargetInfo::setCPU()</a>, <a class="el" href="Decl_8h_source.html#l00316">clang::NamedDecl::setDeclName()</a>, <a class="el" href="ASTReader_8cpp_source.html#l08658">clang::ASTReader::SetGloballyVisibleDecls()</a>, <a class="el" href="DeclarationName_8h_source.html#l00793">clang::DeclarationNameInfo::setName()</a>, <a class="el" href="SemaDeclCXX_8cpp_source.html#l00302">clang::Sema::SetParamDefaultArgument()</a>, <a class="el" href="include_2clang_2Basic_2TargetInfo_8h_source.html#l01124">clang::TargetInfo::ConstraintInfo::setTiedOperand()</a>, <a class="el" href="CGCall_8cpp_source.html#l03597">setUsedBits()</a>, <a class="el" href="APValue_8h_source.html#l00592">clang::APValue::setVector()</a>, <a class="el" href="ASTRecordReader_8h_source.html#l00086">clang::ASTRecordReader::skipInts()</a>, <a class="el" href="SemaTemplateDeduction_8cpp_source.html#l03205">clang::Sema::SubstituteExplicitTemplateArguments()</a>, <a class="el" href="SemaConcept_8cpp_source.html#l01190">substituteParameterMappings()</a>, <a class="el" href="SemaConcept_8cpp_source.html#l01244">substituteParameterMappings()</a>, <a class="el" href="SemaTemplateInstantiateDecl_8cpp_source.html#l04114">clang::TemplateDeclInstantiator::SubstTemplateParams()</a>, <a class="el" href="CGCXXABI_8h_source.html#l00361">clang::CodeGen::CGCXXABI::AddedStructorArgCounts::suffix()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l01862">clang::ento::SuppressInlineDefensiveChecksVisitor::SuppressInlineDefensiveChecksVisitor()</a>, <a class="el" href="CoreEngine_8h_source.html#l00338">clang::ento::NodeBuilder::takeNodes()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l02614">clang::ento::bugreporter::Tracker::track()</a>, <a class="el" href="SourceManager_8cpp_source.html#l01660">clang::SourceManager::translateFile()</a>, <a class="el" href="ExprEngine_8cpp_source.html#l03825">llvm::DOTGraphTraits&lt; ExplodedGraph * &gt;::traverseHiddenNodes()</a>, <a class="el" href="ParentMapContext_8cpp_source.html#l00045">clang::ParentMapContext::traverseIgnored()</a>, <a class="el" href="RecursiveASTVisitor_8h_source.html#l00657">clang::RecursiveASTVisitor&lt; Derived &gt;::TraverseStmt()</a>, <a class="el" href="ExplodedGraph_8cpp_source.html#l00440">clang::ento::ExplodedGraph::trim()</a>, <a class="el" href="UnresolvedSet_8h_source.html#l00132">clang::UnresolvedSetImpl::truncate()</a>, <a class="el" href="SemaExpr_8cpp_source.html#l19539">clang::Sema::tryCaptureVariable()</a>, <a class="el" href="Interpreter_8cpp_source.html#l00440">clang::Interpreter::Undo()</a>, <a class="el" href="SemaTemplateInstantiate_8cpp_source.html#l03573">clang::Sema::usesPartialOrExplicitSpecialization()</a>, <a class="el" href="CGOpenMPRuntime_8cpp_source.html#l01009">clang::CodeGen::ReductionCodeGen::usesReductionInitializer()</a>, <a class="el" href="Basic_2Targets_2AMDGPU_8h_source.html#l00144">clang::targets::AMDGPUTargetInfo::validateAsmConstraint()</a>, <a class="el" href="ASTNodeTraverser_8h_source.html#l00276">clang::ASTNodeTraverser&lt; Derived, NodeDelegateType &gt;::Visit()</a>, <a class="el" href="ExprEngine_8cpp_source.html#l01703">clang::ento::ExprEngine::Visit()</a>, <a class="el" href="ModuleManager_8cpp_source.html#l00340">clang::serialization::ModuleManager::visit()</a>, <a class="el" href="ByteCodeExprGen_8cpp_source.html#l01314">clang::interp::ByteCodeExprGen&lt; Emitter &gt;::visitArrayInitializer()</a>, <a class="el" href="ExprEngineC_8cpp_source.html#l00040">clang::ento::ExprEngine::VisitBinaryOperator()</a>, <a class="el" href="ExprEngineCallAndReturn_8cpp_source.html#l00602">clang::ento::ExprEngine::VisitCallExpr()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l03123">clang::ento::ConditionBRVisitor::VisitConditionVariable()</a>, <a class="el" href="ExprEngineCXX_8cpp_source.html#l00856">clang::ento::ExprEngine::VisitCXXDestructor()</a>, <a class="el" href="ExprEngineC_8cpp_source.html#l00562">clang::ento::ExprEngine::VisitDeclStmt()</a>, <a class="el" href="ASTImporter_8cpp_source.html#l07165">clang::ASTNodeImporter::VisitDesignatedInitExpr()</a>, <a class="el" href="ASTImporter_8cpp_source.html#l03472">clang::ASTNodeImporter::VisitFunctionDecl()</a>, <a class="el" href="ExprEngineC_8cpp_source.html#l00780">clang::ento::ExprEngine::VisitGuardedExpr()</a>, <a class="el" href="ASTReaderDecl_8cpp_source.html#l02289">clang::ASTDeclReader::VisitImportDecl()</a>, <a class="el" href="ASTWriterDecl_8cpp_source.html#l01529">clang::ASTDeclWriter::VisitImportDecl()</a>, <a class="el" href="ExprEngineC_8cpp_source.html#l01056">clang::ento::ExprEngine::VisitIncrementDecrementOperator()</a>, <a class="el" href="ASTImporter_8cpp_source.html#l03960">clang::ASTNodeImporter::VisitIndirectFieldDecl()</a>, <a class="el" href="ASTReader_8cpp_source.html#l09310">clang::ASTReader::visitInputFiles()</a>, <a class="el" href="ASTNodeTraverser_8h_source.html#l00754">clang::ASTNodeTraverser&lt; Derived, NodeDelegateType &gt;::VisitLambdaExpr()</a>, <a class="el" href="SemaInit_8cpp_source.html#l07545">visitLifetimeBoundArguments()</a>, <a class="el" href="SemaInit_8cpp_source.html#l07722">visitLocalsRetainedByInitializer()</a>, <a class="el" href="ExprEngineC_8cpp_source.html#l00638">clang::ento::ExprEngine::VisitLogicalExpr()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l02741">clang::ento::ConditionBRVisitor::VisitNode()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l03475">clang::ento::FalsePositiveRefutationBRVisitor::VisitNode()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l02696">clang::ento::NilReceiverBRVisitor::VisitNode()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l00440">clang::ento::NoStateChangeFuncVisitor::VisitNode()</a>, <a class="el" href="RetainCountDiagnostics_8cpp_source.html#l00453">clang::ento::retaincountchecker::RefCountReportVisitor::VisitNode()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l03498">clang::ento::TagVisitor::VisitNode()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l01810">clang::ento::TrackConstraintBRVisitor::VisitNode()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l03362">clang::ento::UndefOrNullArgVisitor::VisitNode()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l02753">clang::ento::ConditionBRVisitor::VisitNodeImpl()</a>, <a class="el" href="ASTReaderDecl_8cpp_source.html#l02653">clang::ASTDeclReader::VisitNonTypeTemplateParmDecl()</a>, <a class="el" href="ASTWriterDecl_8cpp_source.html#l01798">clang::ASTDeclWriter::VisitNonTypeTemplateParmDecl()</a>, <a class="el" href="ASTImporter_8cpp_source.html#l07660">clang::ASTNodeImporter::VisitOffsetOfExpr()</a>, <a class="el" href="JSONNodeDumper_8cpp_source.html#l00744">clang::JSONNodeDumper::VisitPackExpansionType()</a>, <a class="el" href="TextNodeDumper_8cpp_source.html#l01637">clang::TextNodeDumper::VisitPackExpansionType()</a>, <a class="el" href="ASTReaderDecl_8cpp_source.html#l02733">clang::ASTDeclReader::VisitRedeclarable()</a>, <a class="el" href="ASTReaderDecl_8cpp_source.html#l02675">clang::ASTDeclReader::VisitTemplateTemplateParmDecl()</a>, <a class="el" href="ASTWriterDecl_8cpp_source.html#l01833">clang::ASTDeclWriter::VisitTemplateTemplateParmDecl()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l02791">clang::ento::ConditionBRVisitor::VisitTerminator()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l02850">clang::ento::ConditionBRVisitor::VisitTrueTest()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l03003">clang::ento::ConditionBRVisitor::VisitTrueTest()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l03150">clang::ento::ConditionBRVisitor::VisitTrueTest()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l03186">clang::ento::ConditionBRVisitor::VisitTrueTest()</a>, <a class="el" href="ExprEngineC_8cpp_source.html#l00864">clang::ento::ExprEngine::VisitUnaryExprOrTypeTraitExpr()</a>, <a class="el" href="ExprEngineC_8cpp_source.html#l00920">clang::ento::ExprEngine::VisitUnaryOperator()</a>, and <a class="el" href="BugReporterVisitors_8cpp_source.html#l00291">wasRegionOfInterestModifiedAt()</a>.</p>

</div>
</div>
<a id="a930920b2bc42824a5c03be681830f4b2" name="a930920b2bc42824a5c03be681830f4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930920b2bc42824a5c03be681830f4b2">&#9670;&#160;</a></span>true</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm__acle_8h.html#a82c9b0d3112c0f958c62a5f94d329d7b">return</a> true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l01620">1620</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 8 2024 17:02:12 for clang by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
