<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: clang::syntax Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">clang<span id="projectnumber">&#160;12.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceclang.html">clang</a></li><li class="navelem"><a class="el" href="namespaceclang_1_1syntax.html">syntax</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">clang::syntax Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1Arena.html">Arena</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory arena for syntax trees.  <a href="classclang_1_1syntax_1_1Arena.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ArraySubscript.html">ArraySubscript</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array size specified inside a declarator.  <a href="classclang_1_1syntax_1_1ArraySubscript.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1BinaryOperatorExpression.html">BinaryOperatorExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;lhs&gt; &lt;operator&gt; &lt;rhs&gt;  <a href="classclang_1_1syntax_1_1BinaryOperatorExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1BoolLiteralExpression.html">BoolLiteralExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1syntax_1_1Expression.html" title="A base class for all expressions.">Expression</a> for boolean literals. C++ [lex.bool].  <a href="classclang_1_1syntax_1_1BoolLiteralExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1BreakStatement.html">BreakStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">break;  <a href="classclang_1_1syntax_1_1BreakStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1CallArguments.html">CallArguments</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models arguments of a function call.  <a href="classclang_1_1syntax_1_1CallArguments.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1CallExpression.html">CallExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function call.  <a href="classclang_1_1syntax_1_1CallExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1CaseStatement.html">CaseStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">case : &lt;body&gt;  <a href="classclang_1_1syntax_1_1CaseStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1CharacterLiteralExpression.html">CharacterLiteralExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1syntax_1_1Expression.html" title="A base class for all expressions.">Expression</a> for character literals. C++ [lex.ccon].  <a href="classclang_1_1syntax_1_1CharacterLiteralExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1CharUserDefinedLiteralExpression.html">CharUserDefinedLiteralExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1syntax_1_1Expression.html" title="A base class for all expressions.">Expression</a> for user-defined-character-literal. C++ [lex.ext].  <a href="classclang_1_1syntax_1_1CharUserDefinedLiteralExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1CompoundStatement.html">CompoundStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">{ statement1; statement2; â€¦ }  <a href="classclang_1_1syntax_1_1CompoundStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ContinueStatement.html">ContinueStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">continue;  <a href="classclang_1_1syntax_1_1ContinueStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1CxxNullPtrExpression.html">CxxNullPtrExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1syntax_1_1Expression.html" title="A base class for all expressions.">Expression</a> for the <code>nullptr</code> literal. C++ [lex.nullptr].  <a href="classclang_1_1syntax_1_1CxxNullPtrExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1Declaration.html">Declaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A declaration that can appear at the top-level.  <a href="classclang_1_1syntax_1_1Declaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1DeclarationStatement.html">DeclarationStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">E.g. 'int a, b = 10;'.  <a href="classclang_1_1syntax_1_1DeclarationStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1Declarator.html">Declarator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Covers a name, an initializer and a part of the type outside declaration specifiers.  <a href="classclang_1_1syntax_1_1Declarator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1DeclaratorList.html">DeclaratorList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1DecltypeNameSpecifier.html">DecltypeNameSpecifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A name specifier holding a decltype, of the form: <code>decltype ( expression )</code> e.g.  <a href="classclang_1_1syntax_1_1DecltypeNameSpecifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1DefaultStatement.html">DefaultStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">default: &lt;body&gt;  <a href="classclang_1_1syntax_1_1DefaultStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1EmptyDeclaration.html">EmptyDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A semicolon in the top-level context. Does not declare anything.  <a href="classclang_1_1syntax_1_1EmptyDeclaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1EmptyStatement.html">EmptyStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The no-op statement, i.e. ';'.  <a href="classclang_1_1syntax_1_1EmptyStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ExplicitTemplateInstantiation.html">ExplicitTemplateInstantiation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;declaration&gt; Examples: template struct X&lt;int&gt; template void foo&lt;int&gt;() template int var&lt;double&gt;  <a href="classclang_1_1syntax_1_1ExplicitTemplateInstantiation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1Expression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for all expressions.  <a href="classclang_1_1syntax_1_1Expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ExpressionStatement.html">ExpressionStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1syntax_1_1Expression.html" title="A base class for all expressions.">Expression</a> in a statement position, e.g.  <a href="classclang_1_1syntax_1_1ExpressionStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1FactoryImpl.html">FactoryImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes private syntax tree APIs required to implement node synthesis.  <a href="classclang_1_1syntax_1_1FactoryImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1syntax_1_1FileRange.html">FileRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A half-open character range inside a particular file, the start offset is included and the end offset is excluded from the range.  <a href="structclang_1_1syntax_1_1FileRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1FloatingLiteralExpression.html">FloatingLiteralExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1syntax_1_1Expression.html" title="A base class for all expressions.">Expression</a> for floating-point literals. C++ [lex.fcon].  <a href="classclang_1_1syntax_1_1FloatingLiteralExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1FloatUserDefinedLiteralExpression.html">FloatUserDefinedLiteralExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1syntax_1_1Expression.html" title="A base class for all expressions.">Expression</a> for user-defined-floating-point-literal. C++ [lex.ext].  <a href="classclang_1_1syntax_1_1FloatUserDefinedLiteralExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ForStatement.html">ForStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">for (&lt;init&gt;; &lt;cond&gt;; &lt;increment&gt;) &lt;body&gt;  <a href="classclang_1_1syntax_1_1ForStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1GlobalNameSpecifier.html">GlobalNameSpecifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The global namespace name specifier, this specifier doesn't correspond to a token instead an absence of tokens before a <code>::</code> characterizes it, in <code>::std::vector&lt;int&gt;</code> it would be characterized by the absence of a token before the first <code>::</code>  <a href="classclang_1_1syntax_1_1GlobalNameSpecifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1IdentifierNameSpecifier.html">IdentifierNameSpecifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A identifier name specifier, of the form <code>identifier</code> e.g.  <a href="classclang_1_1syntax_1_1IdentifierNameSpecifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1IdExpression.html">IdExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models an <code>id-expression</code>, e.g.  <a href="classclang_1_1syntax_1_1IdExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1IfStatement.html">IfStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">if (cond) &lt;then-statement&gt; else &lt;else-statement&gt; FIXME: add condition that models 'expression or variable declaration'  <a href="classclang_1_1syntax_1_1IfStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1IntegerLiteralExpression.html">IntegerLiteralExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1syntax_1_1Expression.html" title="A base class for all expressions.">Expression</a> for integer literals. C++ [lex.icon].  <a href="classclang_1_1syntax_1_1IntegerLiteralExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1IntegerUserDefinedLiteralExpression.html">IntegerUserDefinedLiteralExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1syntax_1_1Expression.html" title="A base class for all expressions.">Expression</a> for user-defined-integer-literal. C++ [lex.ext].  <a href="classclang_1_1syntax_1_1IntegerUserDefinedLiteralExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1Leaf.html">Leaf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A leaf node points to a single token inside the expanded token stream.  <a href="classclang_1_1syntax_1_1Leaf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1LinkageSpecificationDeclaration.html">LinkageSpecificationDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">extern &lt;string-literal&gt; declaration extern &lt;string-literal&gt; { &lt;decls&gt; }  <a href="classclang_1_1syntax_1_1LinkageSpecificationDeclaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1List.html">List</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of Elements separated or terminated by a fixed token.  <a href="classclang_1_1syntax_1_1List.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1LiteralExpression.html">LiteralExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1syntax_1_1Expression.html" title="A base class for all expressions.">Expression</a> for literals. C++ [lex.literal].  <a href="classclang_1_1syntax_1_1LiteralExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1MemberExpression.html">MemberExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a class member access.  <a href="classclang_1_1syntax_1_1MemberExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1MemberPointer.html">MemberPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member pointer inside a declarator E.g.  <a href="classclang_1_1syntax_1_1MemberPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyntax_1_1MutationsImpl.html">MutationsImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1NamespaceAliasDefinition.html">NamespaceAliasDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace &lt;name&gt; = &lt;namespace-reference&gt;  <a href="classclang_1_1syntax_1_1NamespaceAliasDefinition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1NamespaceDefinition.html">NamespaceDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace &lt;name&gt; { &lt;decls&gt; }  <a href="classclang_1_1syntax_1_1NamespaceDefinition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1NameSpecifier.html">NameSpecifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of these specifiers make a <code>nested-name-specifier</code>.  <a href="classclang_1_1syntax_1_1NameSpecifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1NestedNameSpecifier.html">NestedNameSpecifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a <code>nested-name-specifier</code>.  <a href="classclang_1_1syntax_1_1NestedNameSpecifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node in a syntax tree.  <a href="classclang_1_1syntax_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ParameterDeclarationList.html">ParameterDeclarationList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a <code>parameter-declaration-list</code> which appears within <code>parameters-and-qualifiers</code>.  <a href="classclang_1_1syntax_1_1ParameterDeclarationList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ParametersAndQualifiers.html">ParametersAndQualifiers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter list for a function type and a trailing return type, if the function has one.  <a href="classclang_1_1syntax_1_1ParametersAndQualifiers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ParenDeclarator.html">ParenDeclarator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1syntax_1_1Declarator.html" title="Covers a name, an initializer and a part of the type outside declaration specifiers.">Declarator</a> inside parentheses.  <a href="classclang_1_1syntax_1_1ParenDeclarator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ParenExpression.html">ParenExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a parenthesized expression <code>(E)</code>.  <a href="classclang_1_1syntax_1_1ParenExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1PostfixUnaryOperatorExpression.html">PostfixUnaryOperatorExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;operand&gt; &lt;operator&gt;  <a href="classclang_1_1syntax_1_1PostfixUnaryOperatorExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1PrefixUnaryOperatorExpression.html">PrefixUnaryOperatorExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;operator&gt; &lt;operand&gt;  <a href="classclang_1_1syntax_1_1PrefixUnaryOperatorExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1RangeBasedForStatement.html">RangeBasedForStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">for (&lt;decl&gt; : &lt;init&gt;) &lt;body&gt;  <a href="classclang_1_1syntax_1_1RangeBasedForStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ReturnStatement.html">ReturnStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">return &lt;expr&gt;; return;  <a href="classclang_1_1syntax_1_1ReturnStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1SimpleDeclaration.html">SimpleDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups multiple declarators (e.g.  <a href="classclang_1_1syntax_1_1SimpleDeclaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1SimpleDeclarator.html">SimpleDeclarator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A top-level declarator without parentheses.  <a href="classclang_1_1syntax_1_1SimpleDeclarator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1SimpleTemplateNameSpecifier.html">SimpleTemplateNameSpecifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A name specifier with a simple-template-id, of the form <code>template_opt / identifier &lt; template-args &gt;</code> e.g.  <a href="classclang_1_1syntax_1_1SimpleTemplateNameSpecifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1Statement.html">Statement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract node for C++ statements, e.g.  <a href="classclang_1_1syntax_1_1Statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1StaticAssertDeclaration.html">StaticAssertDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">static_assert(&lt;condition&gt;, &lt;message&gt;) static_assert(&lt;condition&gt;)  <a href="classclang_1_1syntax_1_1StaticAssertDeclaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1StringLiteralExpression.html">StringLiteralExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1syntax_1_1Expression.html" title="A base class for all expressions.">Expression</a> for string-literals. C++ [lex.string].  <a href="classclang_1_1syntax_1_1StringLiteralExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1StringUserDefinedLiteralExpression.html">StringUserDefinedLiteralExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1syntax_1_1Expression.html" title="A base class for all expressions.">Expression</a> for user-defined-string-literal. C++ [lex.ext].  <a href="classclang_1_1syntax_1_1StringUserDefinedLiteralExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1SwitchStatement.html">SwitchStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">switch (&lt;cond&gt;) &lt;body&gt;  <a href="classclang_1_1syntax_1_1SwitchStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1TemplateDeclaration.html">TemplateDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;template-parameters&gt; &lt;declaration&gt;  <a href="classclang_1_1syntax_1_1TemplateDeclaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ThisExpression.html">ThisExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a this expression <code>this</code>. C++ [expr.prim.this].  <a href="classclang_1_1syntax_1_1ThisExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1Token.html">Token</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A token coming directly from a file or from a macro invocation.  <a href="classclang_1_1syntax_1_1Token.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1TokenBuffer.html">TokenBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of tokens obtained by preprocessing a text buffer and operations to map between the expanded and spelled tokens, i.e.  <a href="classclang_1_1syntax_1_1TokenBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1TokenCollector.html">TokenCollector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects tokens for the main file while running the frontend action.  <a href="classclang_1_1syntax_1_1TokenCollector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1TrailingReturnType.html">TrailingReturnType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trailing return type after the parameter list, including the arrow token.  <a href="classclang_1_1syntax_1_1TrailingReturnType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1TranslationUnit.html">TranslationUnit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A root node for a translation unit. Parent is always null.  <a href="classclang_1_1syntax_1_1TranslationUnit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1Tree.html">Tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node that has children and represents a syntactic language construct.  <a href="classclang_1_1syntax_1_1Tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1TypeAliasDeclaration.html">TypeAliasDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">using &lt;name&gt; = &lt;type&gt;  <a href="classclang_1_1syntax_1_1TypeAliasDeclaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1UnaryOperatorExpression.html">UnaryOperatorExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class for prefix and postfix unary operators.  <a href="classclang_1_1syntax_1_1UnaryOperatorExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1UnknownDeclaration.html">UnknownDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1syntax_1_1Declaration.html" title="A declaration that can appear at the top-level.">Declaration</a> of an unknown kind, e.g. not yet supported in syntax trees.  <a href="classclang_1_1syntax_1_1UnknownDeclaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1UnknownExpression.html">UnknownExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An expression of an unknown kind, i.e.  <a href="classclang_1_1syntax_1_1UnknownExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1UnknownStatement.html">UnknownStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A statement of an unknown kind, i.e.  <a href="classclang_1_1syntax_1_1UnknownStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1UnqualifiedId.html">UnqualifiedId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models an <code>unqualified-id</code>.  <a href="classclang_1_1syntax_1_1UnqualifiedId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1UserDefinedLiteralExpression.html">UserDefinedLiteralExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1syntax_1_1Expression.html" title="A base class for all expressions.">Expression</a> for user-defined literal.  <a href="classclang_1_1syntax_1_1UserDefinedLiteralExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1UsingDeclaration.html">UsingDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">using &lt;scope&gt;::&lt;name&gt; using typename &lt;scope&gt;::&lt;name&gt;  <a href="classclang_1_1syntax_1_1UsingDeclaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1UsingNamespaceDirective.html">UsingNamespaceDirective</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">using namespace &lt;name&gt;  <a href="classclang_1_1syntax_1_1UsingNamespaceDirective.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1WhileStatement.html">WhileStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">while (&lt;cond&gt;) &lt;body&gt;  <a href="classclang_1_1syntax_1_1WhileStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a81b5b8b797bac504f7538749a7bb0a2a" id="r_a81b5b8b797bac504f7538749a7bb0a2a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81b5b8b797bac504f7538749a7bb0a2a">NodeKind</a> : uint16_t { <a class="el" href="#a81b5b8b797bac504f7538749a7bb0a2aa26c550fe2b08ea192795846db6b692cb">CONCRETE_NODE</a>
, <a class="el" href="#a81b5b8b797bac504f7538749a7bb0a2aa556f203d5391bd45296ba9cafab6939c">NODE</a>
, <a class="el" href="#a81b5b8b797bac504f7538749a7bb0a2aa321196a7b020a3cdf4d1dbbc1bbaba52">ABSTRACT_NODE</a>
 }</td></tr>
<tr class="memdesc:a81b5b8b797bac504f7538749a7bb0a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A kind of a syntax node, used for implementing casts.  <a href="#a81b5b8b797bac504f7538749a7bb0a2a">More...</a><br /></td></tr>
<tr class="separator:a81b5b8b797bac504f7538749a7bb0a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d10149d69e32e3c86140b4d325925e5" id="r_a0d10149d69e32e3c86140b4d325925e5"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d10149d69e32e3c86140b4d325925e5">NodeRole</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a41cc07ca5bb4a5988322245a665a16f8">Detached</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5ad5b985fa59b8b23c9f237e8c9df0349f">OpenParen</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a56f5ae57e2b58737187d503944cab6cd">CloseParen</a>
, <br />
&#160;&#160;<a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a7547a0ac0bd2577afe9388dfc89805ea">IntroducerKeyword</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a28f0b8951a3d115abc20f68762316ca5">LiteralToken</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5ae4ed9e8e60aa25c2496ee227f54f9377">ArrowToken</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5ab40269cdb76e2169dc4c0e35d8486787">ExternKeyword</a>
, <br />
&#160;&#160;<a class="el" href="#a0d10149d69e32e3c86140b4d325925e5ac254d57618c58574efba31bb528124fb">TemplateKeyword</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5aa8ef626e9c0eafe3e8c568c0c7ef310d">BodyStatement</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a22b39e80e2066739f3396c06a3f009e7">ListElement</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5ad2b105a9154e8e15b3153249cf3a8aa8">ListDelimiter</a>
, <br />
&#160;&#160;<a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a83c0b4306ec14cf15baa9d1cd377af23">OperatorToken</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a1b488933c47964ca059d24f978f094e4">Operand</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a9519654199c7499bb8864adb16bd8078">LeftHandSide</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a2e07cec0197c7aea8c2354d4d06c6623">RightHandSide</a>
, <br />
&#160;&#160;<a class="el" href="#a0d10149d69e32e3c86140b4d325925e5aef075575efe2059289041f1118338f18">ReturnValue</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a0290b73cde0025b5a093756176463f34">CaseValue</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a7cad0f174fa8345d623d0a7f8f70e62b">ThenStatement</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a693581a349737568c6eed825bc9e8183">ElseKeyword</a>
, <br />
&#160;&#160;<a class="el" href="#a0d10149d69e32e3c86140b4d325925e5affe69b660ba55a5f2d68e56ac13f31c6">ElseStatement</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5aa1a6657be79cc0fc1e9b23b9e108f043">Expression</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a2af6fd9ec72aee193ee7ffe09638e08f">Statement</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a9e2941b3c81256fac10392aaca4ccfde">Condition</a>
, <br />
&#160;&#160;<a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a4c2a8fe7eaf24721cc7a9f0175115bd4">Message</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5aae1289ec5221a0ecb07a1440f3cc97c2">Declarator</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a6246655a4c0a99b49f104cd87a0a7a7a">Declaration</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a6f6cb72d544962fa333e2e34ce64f719">Size</a>
, <br />
&#160;&#160;<a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a3225a10b07f1580f10dee4abc3779e6c">Parameters</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a095a2910571dda799078657b7d11a941">TrailingReturn</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5aa43d0e23c5b5a3c83e986a71d0203536">UnqualifiedId</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a75a47e1c183d2fea32df2a5e573ed35f">Qualifier</a>
, <br />
&#160;&#160;<a class="el" href="#a0d10149d69e32e3c86140b4d325925e5ac37f67826c216dfcf8ef24375fa263ac">SubExpression</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a497031794414a552435f90151ac3b54b">Object</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a61e00b7ad470c7b8638b10803d4d67c9">AccessToken</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5a858ba4765e53c712ef672a9570474b1d">Member</a>
, <br />
&#160;&#160;<a class="el" href="#a0d10149d69e32e3c86140b4d325925e5ac8ff9e15a93f800c74c05e7b37364816">Callee</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5ad637f66d25c9ff757bed6f168c73856e">Arguments</a>
, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5ab12a6228ac45af311c53602432f606b5">Declarators</a>
<br />
 }</td></tr>
<tr class="memdesc:a0d10149d69e32e3c86140b4d325925e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A relation between a parent and child node, e.g.  <a href="#a0d10149d69e32e3c86140b4d325925e5">More...</a><br /></td></tr>
<tr class="separator:a0d10149d69e32e3c86140b4d325925e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4f256ced784108d3fb273d242929676a" id="r_a4f256ced784108d3fb273d242929676a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1syntax_1_1TranslationUnit.html">syntax::TranslationUnit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f256ced784108d3fb273d242929676a">buildSyntaxTree</a> (<a class="el" href="classclang_1_1syntax_1_1Arena.html">Arena</a> &amp;A, <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;Context)</td></tr>
<tr class="memdesc:a4f256ced784108d3fb273d242929676a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a syntax tree for the main file.  <br /></td></tr>
<tr class="separator:a4f256ced784108d3fb273d242929676a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026e95f11b1e39147fa801cd73830da6" id="r_a026e95f11b1e39147fa801cd73830da6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1syntax_1_1Leaf.html">syntax::Leaf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a026e95f11b1e39147fa801cd73830da6">createLeaf</a> (<a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;A, <a class="el" href="namespaceclang_1_1tok.html#a9468a30b60853d1e39187d0905b9b588">tok::TokenKind</a> K, StringRef Spelling)</td></tr>
<tr class="memdesc:a026e95f11b1e39147fa801cd73830da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <code><a class="el" href="classclang_1_1syntax_1_1Leaf.html" title="A leaf node points to a single token inside the expanded token stream.">Leaf</a></code> from token with <code>Spelling</code> and assert it has the desired <code>TokenKind</code>.  <br /></td></tr>
<tr class="separator:a026e95f11b1e39147fa801cd73830da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc11ae1ecbd0919a1c725b58b2d9fa0" id="r_afbc11ae1ecbd0919a1c725b58b2d9fa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1syntax_1_1Leaf.html">syntax::Leaf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbc11ae1ecbd0919a1c725b58b2d9fa0">createLeaf</a> (<a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;A, <a class="el" href="namespaceclang_1_1tok.html#a9468a30b60853d1e39187d0905b9b588">tok::TokenKind</a> K)</td></tr>
<tr class="memdesc:afbc11ae1ecbd0919a1c725b58b2d9fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the token spelling from its <code>TokenKind</code>, then create <code><a class="el" href="classclang_1_1syntax_1_1Leaf.html" title="A leaf node points to a single token inside the expanded token stream.">Leaf</a></code> from this token.  <br /></td></tr>
<tr class="separator:afbc11ae1ecbd0919a1c725b58b2d9fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d04bca405be560952f816ed4c02bbd8" id="r_a7d04bca405be560952f816ed4c02bbd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1syntax_1_1Tree.html">syntax::Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d04bca405be560952f816ed4c02bbd8">createTree</a> (<a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;A, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; <a class="el" href="classclang_1_1syntax_1_1Node.html">syntax::Node</a> *, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5">syntax::NodeRole</a> &gt; &gt; <a class="el" href="FormatToken_8h.html#ad0276d0a5e0626af0baabe922db47c67">Children</a>, <a class="el" href="#a81b5b8b797bac504f7538749a7bb0a2a">syntax::NodeKind</a> K)</td></tr>
<tr class="memdesc:a7d04bca405be560952f816ed4c02bbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the concrete syntax node according to the specified <code>NodeKind</code> <code>K</code>.  <br /></td></tr>
<tr class="separator:a7d04bca405be560952f816ed4c02bbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7faebfdbba7ac8862370fd2cee2bd90a" id="r_a7faebfdbba7ac8862370fd2cee2bd90a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1syntax_1_1EmptyStatement.html">syntax::EmptyStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7faebfdbba7ac8862370fd2cee2bd90a">createEmptyStatement</a> (<a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;A)</td></tr>
<tr class="separator:a7faebfdbba7ac8862370fd2cee2bd90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd89f9a47c39ff754698c8714df181f1" id="r_abd89f9a47c39ff754698c8714df181f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1syntax_1_1Node.html">syntax::Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd89f9a47c39ff754698c8714df181f1">deepCopyExpandingMacros</a> (<a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;A, const <a class="el" href="classclang_1_1syntax_1_1Node.html">syntax::Node</a> *<a class="el" href="BuildTree_8cpp.html#ab409187cd8023f701425d74753612d6b">N</a>)</td></tr>
<tr class="memdesc:abd89f9a47c39ff754698c8714df181f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a completely independent copy of <code>N</code> with its macros expanded.  <br /></td></tr>
<tr class="separator:abd89f9a47c39ff754698c8714df181f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715c345b92c4d49b98a4b0d71cce07df" id="r_a715c345b92c4d49b98a4b0d71cce07df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a715c345b92c4d49b98a4b0d71cce07df">computeReplacements</a> (const <a class="el" href="classclang_1_1syntax_1_1Arena.html">Arena</a> &amp;A, const <a class="el" href="classclang_1_1syntax_1_1TranslationUnit.html">syntax::TranslationUnit</a> &amp;TU)</td></tr>
<tr class="memdesc:a715c345b92c4d49b98a4b0d71cce07df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes textual replacements required to mimic the tree modifications made to the syntax tree.  <br /></td></tr>
<tr class="separator:a715c345b92c4d49b98a4b0d71cce07df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac945be75b2e1a63c6fc656f3418fe455" id="r_ac945be75b2e1a63c6fc656f3418fe455"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac945be75b2e1a63c6fc656f3418fe455">removeStatement</a> (<a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;A, <a class="el" href="classclang_1_1syntax_1_1Statement.html">syntax::Statement</a> *S)</td></tr>
<tr class="memdesc:ac945be75b2e1a63c6fc656f3418fe455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a statement or replaces it with an empty statement where one is required syntactically.  <br /></td></tr>
<tr class="separator:ac945be75b2e1a63c6fc656f3418fe455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9773dfd304fc990b06ed6a7a8711e6f8" id="r_a9773dfd304fc990b06ed6a7a8711e6f8"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9773dfd304fc990b06ed6a7a8711e6f8">operator&lt;&lt;</a> (raw_ostream &amp;OS, <a class="el" href="#a81b5b8b797bac504f7538749a7bb0a2a">NodeKind</a> K)</td></tr>
<tr class="memdesc:a9773dfd304fc990b06ed6a7a8711e6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For debugging purposes.  <br /></td></tr>
<tr class="separator:a9773dfd304fc990b06ed6a7a8711e6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab327bf8bd6ce7e2ebe105061d44fd7cb" id="r_ab327bf8bd6ce7e2ebe105061d44fd7cb"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab327bf8bd6ce7e2ebe105061d44fd7cb">operator&lt;&lt;</a> (raw_ostream &amp;OS, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5">NodeRole</a> R)</td></tr>
<tr class="memdesc:ab327bf8bd6ce7e2ebe105061d44fd7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For debugging purposes.  <br /></td></tr>
<tr class="separator:ab327bf8bd6ce7e2ebe105061d44fd7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa2f5330bffd313bb05c4d4ed8d6042" id="r_a4aa2f5330bffd313bb05c4d4ed8d6042"><td class="memItemLeft" align="right" valign="top">llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4aa2f5330bffd313bb05c4d4ed8d6042">operator&lt;&lt;</a> (llvm::raw_ostream &amp;OS, const <a class="el" href="structclang_1_1syntax_1_1FileRange.html">FileRange</a> &amp;R)</td></tr>
<tr class="memdesc:a4aa2f5330bffd313bb05c4d4ed8d6042"><td class="mdescLeft">&#160;</td><td class="mdescRight">For debugging purposes.  <br /></td></tr>
<tr class="separator:a4aa2f5330bffd313bb05c4d4ed8d6042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee22380c758acfc7dc72398d4312bcfc" id="r_aee22380c758acfc7dc72398d4312bcfc"><td class="memItemLeft" align="right" valign="top">llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee22380c758acfc7dc72398d4312bcfc">operator&lt;&lt;</a> (llvm::raw_ostream &amp;OS, const <a class="el" href="classclang_1_1syntax_1_1Token.html">Token</a> &amp;T)</td></tr>
<tr class="memdesc:aee22380c758acfc7dc72398d4312bcfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">For debugging purposes. Equivalent to a call to <a class="el" href="classclang_1_1syntax_1_1Token.html#a10e327aee703a9281dd146fb9816b939" title="For debugging purposes.">Token::str()</a>.  <br /></td></tr>
<tr class="separator:aee22380c758acfc7dc72398d4312bcfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff502ef26cb84b374c72f21c9b44236" id="r_afff502ef26cb84b374c72f21c9b44236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afff502ef26cb84b374c72f21c9b44236">spelledTokensTouching</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, const <a class="el" href="classclang_1_1syntax_1_1TokenBuffer.html">syntax::TokenBuffer</a> &amp;Tokens)</td></tr>
<tr class="memdesc:afff502ef26cb84b374c72f21c9b44236"><td class="mdescLeft">&#160;</td><td class="mdescRight">The spelled tokens that overlap or touch a spelling location Loc.  <br /></td></tr>
<tr class="separator:afff502ef26cb84b374c72f21c9b44236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793cf39170ae045357f2299a8ad5d1ee" id="r_a793cf39170ae045357f2299a8ad5d1ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a793cf39170ae045357f2299a8ad5d1ee">spelledTokensTouching</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt; Tokens)</td></tr>
<tr class="separator:a793cf39170ae045357f2299a8ad5d1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4717e9f6a8df9c77f1bd3aedb282169e" id="r_a4717e9f6a8df9c77f1bd3aedb282169e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4717e9f6a8df9c77f1bd3aedb282169e">spelledIdentifierTouching</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt; Tokens)</td></tr>
<tr class="memdesc:a4717e9f6a8df9c77f1bd3aedb282169e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The identifier token that overlaps or touches a spelling location Loc.  <br /></td></tr>
<tr class="separator:a4717e9f6a8df9c77f1bd3aedb282169e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5495e074677ac58e95e398b46e079cb2" id="r_a5495e074677ac58e95e398b46e079cb2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5495e074677ac58e95e398b46e079cb2">spelledIdentifierTouching</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, const <a class="el" href="classclang_1_1syntax_1_1TokenBuffer.html">syntax::TokenBuffer</a> &amp;Tokens)</td></tr>
<tr class="separator:a5495e074677ac58e95e398b46e079cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ab6237c208ae112ad2abd4e003235b" id="r_a74ab6237c208ae112ad2abd4e003235b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74ab6237c208ae112ad2abd4e003235b">tokenize</a> (<a class="el" href="classclang_1_1FileID.html">FileID</a> FID, const <a class="el" href="classclang_1_1SourceManager.html">SourceManager</a> &amp;<a class="el" href="Basic_2Cuda_8cpp.html#ab6882f8bbaa96cde60db40335e62eb2e">SM</a>, const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;LO)</td></tr>
<tr class="memdesc:a74ab6237c208ae112ad2abd4e003235b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lex the text buffer, corresponding to <code>FID</code>, in raw mode and record the resulting spelled tokens.  <br /></td></tr>
<tr class="separator:a74ab6237c208ae112ad2abd4e003235b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a1ffeac5053cf3f2a36f48251ce417" id="r_a24a1ffeac5053cf3f2a36f48251ce417"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24a1ffeac5053cf3f2a36f48251ce417">tokenize</a> (const <a class="el" href="structclang_1_1syntax_1_1FileRange.html">FileRange</a> &amp;FR, const <a class="el" href="classclang_1_1SourceManager.html">SourceManager</a> &amp;<a class="el" href="Basic_2Cuda_8cpp.html#ab6882f8bbaa96cde60db40335e62eb2e">SM</a>, const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;LO)</td></tr>
<tr class="memdesc:a24a1ffeac5053cf3f2a36f48251ce417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to one above, instead of whole file tokenizes a part of it.  <br /></td></tr>
<tr class="separator:a24a1ffeac5053cf3f2a36f48251ce417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48156b5d50c571d3c6d3aa0a2c497e20" id="r_a48156b5d50c571d3c6d3aa0a2c497e20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48156b5d50c571d3c6d3aa0a2c497e20">operator==</a> (const <a class="el" href="structclang_1_1syntax_1_1Tree_1_1ConstChildIterator.html">Tree::ConstChildIterator</a> &amp;A, const <a class="el" href="structclang_1_1syntax_1_1Tree_1_1ConstChildIterator.html">Tree::ConstChildIterator</a> &amp;B)</td></tr>
<tr class="separator:a48156b5d50c571d3c6d3aa0a2c497e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a81b5b8b797bac504f7538749a7bb0a2a" name="a81b5b8b797bac504f7538749a7bb0a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b5b8b797bac504f7538749a7bb0a2a">&#9670;&#160;</a></span>NodeKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a81b5b8b797bac504f7538749a7bb0a2a">clang::syntax::NodeKind</a> : uint16_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A kind of a syntax node, used for implementing casts. </p>
<p>The ordering and blocks of enumerator constants must correspond to the inheritance hierarchy of <a class="el" href="classclang_1_1syntax_1_1Node.html" title="A node in a syntax tree.">syntax::Node</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a81b5b8b797bac504f7538749a7bb0a2aa26c550fe2b08ea192795846db6b692cb" name="a81b5b8b797bac504f7538749a7bb0a2aa26c550fe2b08ea192795846db6b692cb"></a>CONCRETE_NODE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a81b5b8b797bac504f7538749a7bb0a2aa556f203d5391bd45296ba9cafab6939c" name="a81b5b8b797bac504f7538749a7bb0a2aa556f203d5391bd45296ba9cafab6939c"></a>NODE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a81b5b8b797bac504f7538749a7bb0a2aa321196a7b020a3cdf4d1dbbc1bbaba52" name="a81b5b8b797bac504f7538749a7bb0a2aa321196a7b020a3cdf4d1dbbc1bbaba52"></a>ABSTRACT_NODE&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Nodes_8h_source.html#l00037">37</a> of file <a class="el" href="Nodes_8h_source.html">Nodes.h</a>.</p>

</div>
</div>
<a id="a0d10149d69e32e3c86140b4d325925e5" name="a0d10149d69e32e3c86140b4d325925e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d10149d69e32e3c86140b4d325925e5">&#9670;&#160;</a></span>NodeRole</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5">clang::syntax::NodeRole</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A relation between a parent and child node, e.g. </p>
<p>'left-hand-side of a binary expression'. Used for implementing accessors.</p>
<p>In general <code>NodeRole</code>s should be named the same as their accessors.</p>
<p>Some roles describe parent/child relations that occur multiple times in language grammar. We define only one role to describe all instances of such recurring relations. For example, grammar for both "if" and "while" statements requires an opening paren and a closing paren. The opening paren token is assigned the OpenParen role regardless of whether it appears as a child of <a class="el" href="classclang_1_1syntax_1_1IfStatement.html" title="if (cond) &lt;then-statement&gt; else &lt;else-statement&gt; FIXME: add condition that models &#39;expression or vari...">IfStatement</a> or <a class="el" href="classclang_1_1syntax_1_1WhileStatement.html" title="while (&lt;cond&gt;) &lt;body&gt;">WhileStatement</a> node. More generally, when grammar requires a certain fixed token (like a specific keyword, or an opening paren), we define a role for this token and use it across all grammar rules with the same requirement. Names of such reusable roles end with a ~Token or a ~Keyword suffix. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a41cc07ca5bb4a5988322245a665a16f8" name="a0d10149d69e32e3c86140b4d325925e5a41cc07ca5bb4a5988322245a665a16f8"></a>Detached&#160;</td><td class="fielddoc"><p>A node without a parent. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a88183b946cc5f0e8c96b2e66e1c74a7e" name="a0d10149d69e32e3c86140b4d325925e5a88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc"><p>Children of an unknown semantic nature, e.g. skipped tokens, comments. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5ad5b985fa59b8b23c9f237e8c9df0349f" name="a0d10149d69e32e3c86140b4d325925e5ad5b985fa59b8b23c9f237e8c9df0349f"></a>OpenParen&#160;</td><td class="fielddoc"><p>An opening parenthesis in argument lists and blocks, e.g. '{', '(', etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a56f5ae57e2b58737187d503944cab6cd" name="a0d10149d69e32e3c86140b4d325925e5a56f5ae57e2b58737187d503944cab6cd"></a>CloseParen&#160;</td><td class="fielddoc"><p>A closing parenthesis in argument lists and blocks, e.g. '}', ')', etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a7547a0ac0bd2577afe9388dfc89805ea" name="a0d10149d69e32e3c86140b4d325925e5a7547a0ac0bd2577afe9388dfc89805ea"></a>IntroducerKeyword&#160;</td><td class="fielddoc"><p>A keywords that introduces some grammar construct, e.g. 'if', 'try', etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a28f0b8951a3d115abc20f68762316ca5" name="a0d10149d69e32e3c86140b4d325925e5a28f0b8951a3d115abc20f68762316ca5"></a>LiteralToken&#160;</td><td class="fielddoc"><p>A token that represents a literal, e.g. 'nullptr', '1', 'true', etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5ae4ed9e8e60aa25c2496ee227f54f9377" name="a0d10149d69e32e3c86140b4d325925e5ae4ed9e8e60aa25c2496ee227f54f9377"></a>ArrowToken&#160;</td><td class="fielddoc"><p>Tokens or Keywords. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5ab40269cdb76e2169dc4c0e35d8486787" name="a0d10149d69e32e3c86140b4d325925e5ab40269cdb76e2169dc4c0e35d8486787"></a>ExternKeyword&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5ac254d57618c58574efba31bb528124fb" name="a0d10149d69e32e3c86140b4d325925e5ac254d57618c58574efba31bb528124fb"></a>TemplateKeyword&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5aa8ef626e9c0eafe3e8c568c0c7ef310d" name="a0d10149d69e32e3c86140b4d325925e5aa8ef626e9c0eafe3e8c568c0c7ef310d"></a>BodyStatement&#160;</td><td class="fielddoc"><p>An inner statement for those that have only a single child of kind statement, e.g. </p>
<p>loop body for while, for, etc; inner statement for case, default, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a22b39e80e2066739f3396c06a3f009e7" name="a0d10149d69e32e3c86140b4d325925e5a22b39e80e2066739f3396c06a3f009e7"></a>ListElement&#160;</td><td class="fielddoc"><p><a class="el" href="classclang_1_1syntax_1_1List.html" title="A list of Elements separated or terminated by a fixed token.">List</a> API roles. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5ad2b105a9154e8e15b3153249cf3a8aa8" name="a0d10149d69e32e3c86140b4d325925e5ad2b105a9154e8e15b3153249cf3a8aa8"></a>ListDelimiter&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a83c0b4306ec14cf15baa9d1cd377af23" name="a0d10149d69e32e3c86140b4d325925e5a83c0b4306ec14cf15baa9d1cd377af23"></a>OperatorToken&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a1b488933c47964ca059d24f978f094e4" name="a0d10149d69e32e3c86140b4d325925e5a1b488933c47964ca059d24f978f094e4"></a>Operand&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a9519654199c7499bb8864adb16bd8078" name="a0d10149d69e32e3c86140b4d325925e5a9519654199c7499bb8864adb16bd8078"></a>LeftHandSide&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a2e07cec0197c7aea8c2354d4d06c6623" name="a0d10149d69e32e3c86140b4d325925e5a2e07cec0197c7aea8c2354d4d06c6623"></a>RightHandSide&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5aef075575efe2059289041f1118338f18" name="a0d10149d69e32e3c86140b4d325925e5aef075575efe2059289041f1118338f18"></a>ReturnValue&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a0290b73cde0025b5a093756176463f34" name="a0d10149d69e32e3c86140b4d325925e5a0290b73cde0025b5a093756176463f34"></a>CaseValue&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a7cad0f174fa8345d623d0a7f8f70e62b" name="a0d10149d69e32e3c86140b4d325925e5a7cad0f174fa8345d623d0a7f8f70e62b"></a>ThenStatement&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a693581a349737568c6eed825bc9e8183" name="a0d10149d69e32e3c86140b4d325925e5a693581a349737568c6eed825bc9e8183"></a>ElseKeyword&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5affe69b660ba55a5f2d68e56ac13f31c6" name="a0d10149d69e32e3c86140b4d325925e5affe69b660ba55a5f2d68e56ac13f31c6"></a>ElseStatement&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5aa1a6657be79cc0fc1e9b23b9e108f043" name="a0d10149d69e32e3c86140b4d325925e5aa1a6657be79cc0fc1e9b23b9e108f043"></a>Expression&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a2af6fd9ec72aee193ee7ffe09638e08f" name="a0d10149d69e32e3c86140b4d325925e5a2af6fd9ec72aee193ee7ffe09638e08f"></a>Statement&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a9e2941b3c81256fac10392aaca4ccfde" name="a0d10149d69e32e3c86140b4d325925e5a9e2941b3c81256fac10392aaca4ccfde"></a>Condition&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a4c2a8fe7eaf24721cc7a9f0175115bd4" name="a0d10149d69e32e3c86140b4d325925e5a4c2a8fe7eaf24721cc7a9f0175115bd4"></a>Message&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5aae1289ec5221a0ecb07a1440f3cc97c2" name="a0d10149d69e32e3c86140b4d325925e5aae1289ec5221a0ecb07a1440f3cc97c2"></a>Declarator&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a6246655a4c0a99b49f104cd87a0a7a7a" name="a0d10149d69e32e3c86140b4d325925e5a6246655a4c0a99b49f104cd87a0a7a7a"></a>Declaration&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a6f6cb72d544962fa333e2e34ce64f719" name="a0d10149d69e32e3c86140b4d325925e5a6f6cb72d544962fa333e2e34ce64f719"></a>Size&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a3225a10b07f1580f10dee4abc3779e6c" name="a0d10149d69e32e3c86140b4d325925e5a3225a10b07f1580f10dee4abc3779e6c"></a>Parameters&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a095a2910571dda799078657b7d11a941" name="a0d10149d69e32e3c86140b4d325925e5a095a2910571dda799078657b7d11a941"></a>TrailingReturn&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5aa43d0e23c5b5a3c83e986a71d0203536" name="a0d10149d69e32e3c86140b4d325925e5aa43d0e23c5b5a3c83e986a71d0203536"></a>UnqualifiedId&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a75a47e1c183d2fea32df2a5e573ed35f" name="a0d10149d69e32e3c86140b4d325925e5a75a47e1c183d2fea32df2a5e573ed35f"></a>Qualifier&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5ac37f67826c216dfcf8ef24375fa263ac" name="a0d10149d69e32e3c86140b4d325925e5ac37f67826c216dfcf8ef24375fa263ac"></a>SubExpression&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a497031794414a552435f90151ac3b54b" name="a0d10149d69e32e3c86140b4d325925e5a497031794414a552435f90151ac3b54b"></a>Object&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a61e00b7ad470c7b8638b10803d4d67c9" name="a0d10149d69e32e3c86140b4d325925e5a61e00b7ad470c7b8638b10803d4d67c9"></a>AccessToken&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a858ba4765e53c712ef672a9570474b1d" name="a0d10149d69e32e3c86140b4d325925e5a858ba4765e53c712ef672a9570474b1d"></a>Member&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5ac8ff9e15a93f800c74c05e7b37364816" name="a0d10149d69e32e3c86140b4d325925e5ac8ff9e15a93f800c74c05e7b37364816"></a>Callee&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5ad637f66d25c9ff757bed6f168c73856e" name="a0d10149d69e32e3c86140b4d325925e5ad637f66d25c9ff757bed6f168c73856e"></a>Arguments&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5ab12a6228ac45af311c53602432f606b5" name="a0d10149d69e32e3c86140b4d325925e5ab12a6228ac45af311c53602432f606b5"></a>Declarators&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Nodes_8h_source.html#l00059">59</a> of file <a class="el" href="Nodes_8h_source.html">Nodes.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4f256ced784108d3fb273d242929676a" name="a4f256ced784108d3fb273d242929676a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f256ced784108d3fb273d242929676a">&#9670;&#160;</a></span>buildSyntaxTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1syntax_1_1TranslationUnit.html">syntax::TranslationUnit</a> * clang::syntax::buildSyntaxTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1syntax_1_1Arena.html">Arena</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a syntax tree for the main file. </p>
<p>This usually covers the whole <a class="el" href="classclang_1_1TranslationUnitDecl.html" title="The top declaration context.">TranslationUnitDecl</a>, but can be restricted by the <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>'s traversal scope. </p>

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l01714">1714</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuildTree_8cpp_source.html#l01640">Builder</a>, and <a class="el" href="BuildTree_8cpp_source.html#l01641">Context</a>.</p>

</div>
</div>
<a id="a715c345b92c4d49b98a4b0d71cce07df" name="a715c345b92c4d49b98a4b0d71cce07df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715c345b92c4d49b98a4b0d71cce07df">&#9670;&#160;</a></span>computeReplacements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> clang::syntax::computeReplacements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1syntax_1_1Arena.html">Arena</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1syntax_1_1TranslationUnit.html">syntax::TranslationUnit</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>TU</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes textual replacements required to mimic the tree modifications made to the syntax tree. </p>

<p class="definition">Definition at line <a class="el" href="ComputeReplacements_8cpp_source.html#l00086">86</a> of file <a class="el" href="ComputeReplacements_8cpp_source.html">ComputeReplacements.cpp</a>.</p>

<p class="reference">References <a class="el" href="Replacement_8cpp_source.html#l00245">clang::tooling::Replacements::add()</a>, <a class="el" href="SemaChecking_8cpp_source.html#l09348">emitReplacement()</a>, <a class="el" href="Tree_8h_source.html#l00046">clang::syntax::Arena::getSourceManager()</a>, <a class="el" href="Tree_8cpp_source.html#l00039">clang::syntax::Arena::getTokenBuffer()</a>, <a class="el" href="Tokens_8cpp_source.html#l00119">clang::syntax::Token::range()</a>, <a class="el" href="Basic_2Cuda_8cpp_source.html#l00062">SM</a>, and <a class="el" href="Tokens_8cpp_source.html#l00176">clang::syntax::FileRange::text()</a>.</p>

</div>
</div>
<a id="a7faebfdbba7ac8862370fd2cee2bd90a" name="a7faebfdbba7ac8862370fd2cee2bd90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7faebfdbba7ac8862370fd2cee2bd90a">&#9670;&#160;</a></span>createEmptyStatement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1syntax_1_1EmptyStatement.html">syntax::EmptyStatement</a> * clang::syntax::createEmptyStatement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Synthesis_8cpp_source.html#l00227">227</a> of file <a class="el" href="Synthesis_8cpp_source.html">Synthesis.cpp</a>.</p>

<p class="reference">References <a class="el" href="Address_8h_source.html#l00108">clang::cast()</a>, <a class="el" href="Synthesis_8cpp_source.html#l00037">createLeaf()</a>, and <a class="el" href="Synthesis_8cpp_source.html#l00197">createTree()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Mutations_8cpp_source.html#l00080">removeStatement()</a>.</p>

</div>
</div>
<a id="afbc11ae1ecbd0919a1c725b58b2d9fa0" name="afbc11ae1ecbd0919a1c725b58b2d9fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc11ae1ecbd0919a1c725b58b2d9fa0">&#9670;&#160;</a></span>createLeaf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1syntax_1_1Leaf.html">syntax::Leaf</a> * clang::syntax::createLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1tok.html#a9468a30b60853d1e39187d0905b9b588">tok::TokenKind</a></td>          <td class="paramname"><span class="paramname"><em>K</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the token spelling from its <code>TokenKind</code>, then create <code><a class="el" href="classclang_1_1syntax_1_1Leaf.html" title="A leaf node points to a single token inside the expanded token stream.">Leaf</a></code> from this token. </p>

<p class="definition">Definition at line <a class="el" href="Synthesis_8cpp_source.html#l00052">52</a> of file <a class="el" href="Synthesis_8cpp_source.html">Synthesis.cpp</a>.</p>

<p class="reference">References <a class="el" href="Synthesis_8cpp_source.html#l00037">createLeaf()</a>, <a class="el" href="TokenKinds_8cpp_source.html#l00040">clang::tok::getKeywordSpelling()</a>, and <a class="el" href="TokenKinds_8cpp_source.html#l00031">clang::tok::getPunctuatorSpelling()</a>.</p>

</div>
</div>
<a id="a026e95f11b1e39147fa801cd73830da6" name="a026e95f11b1e39147fa801cd73830da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026e95f11b1e39147fa801cd73830da6">&#9670;&#160;</a></span>createLeaf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1syntax_1_1Leaf.html">syntax::Leaf</a> * clang::syntax::createLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1tok.html#a9468a30b60853d1e39187d0905b9b588">tok::TokenKind</a></td>          <td class="paramname"><span class="paramname"><em>K</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Spelling</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <code><a class="el" href="classclang_1_1syntax_1_1Leaf.html" title="A leaf node points to a single token inside the expanded token stream.">Leaf</a></code> from token with <code>Spelling</code> and assert it has the desired <code>TokenKind</code>. </p>

<p class="definition">Definition at line <a class="el" href="Synthesis_8cpp_source.html#l00037">37</a> of file <a class="el" href="Synthesis_8cpp_source.html">Synthesis.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tree_8cpp_source.html#l00269">clang::syntax::Node::assertInvariants()</a>, <a class="el" href="Tree_8h_source.html#l00050">clang::syntax::Arena::getAllocator()</a>, and <a class="el" href="Synthesis_8cpp_source.html#l00018">clang::syntax::FactoryImpl::setCanModify()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Synthesis_8cpp_source.html#l00227">createEmptyStatement()</a>, <a class="el" href="Synthesis_8cpp_source.html#l00052">createLeaf()</a>, and <a class="el" href="Synthesis_8cpp_source.html#l00210">deepCopyExpandingMacros()</a>.</p>

</div>
</div>
<a id="a7d04bca405be560952f816ed4c02bbd8" name="a7d04bca405be560952f816ed4c02bbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d04bca405be560952f816ed4c02bbd8">&#9670;&#160;</a></span>createTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1syntax_1_1Tree.html">syntax::Tree</a> * clang::syntax::createTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; <a class="el" href="classclang_1_1syntax_1_1Node.html">syntax::Node</a> *, <a class="el" href="#a0d10149d69e32e3c86140b4d325925e5">syntax::NodeRole</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>Children</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a81b5b8b797bac504f7538749a7bb0a2a">syntax::NodeKind</a></td>          <td class="paramname"><span class="paramname"><em>K</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the concrete syntax node according to the specified <code>NodeKind</code> <code>K</code>. </p>
<p>Returns it as a pointer to the base class <code><a class="el" href="classclang_1_1syntax_1_1Tree.html" title="A node that has children and represents a syntactic language construct.">Tree</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Synthesis_8cpp_source.html#l00197">197</a> of file <a class="el" href="Synthesis_8cpp_source.html">Synthesis.cpp</a>.</p>

<p class="reference">References <a class="el" href="FormatToken_8h_source.html#l00859">Children</a>.</p>

<p class="reference">Referenced by <a class="el" href="Synthesis_8cpp_source.html#l00227">createEmptyStatement()</a>, and <a class="el" href="Synthesis_8cpp_source.html#l00210">deepCopyExpandingMacros()</a>.</p>

</div>
</div>
<a id="abd89f9a47c39ff754698c8714df181f1" name="abd89f9a47c39ff754698c8714df181f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd89f9a47c39ff754698c8714df181f1">&#9670;&#160;</a></span>deepCopyExpandingMacros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1syntax_1_1Node.html">syntax::Node</a> * clang::syntax::deepCopyExpandingMacros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1syntax_1_1Node.html">syntax::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a completely independent copy of <code>N</code> with its macros expanded. </p>
<p>The copy is:</p><ul>
<li>Detached, i.e. <code>Parent == NextSibling == nullptr</code> and <code>Role == Detached</code>.</li>
<li>Synthesized, i.e. <code>Original == false</code>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Synthesis_8cpp_source.html#l00210">210</a> of file <a class="el" href="Synthesis_8cpp_source.html">Synthesis.cpp</a>.</p>

<p class="reference">References <a class="el" href="Address_8h_source.html#l00108">clang::cast()</a>, <a class="el" href="FormatToken_8h_source.html#l00859">Children</a>, <a class="el" href="Synthesis_8cpp_source.html#l00037">createLeaf()</a>, <a class="el" href="Synthesis_8cpp_source.html#l00197">createTree()</a>, <a class="el" href="Synthesis_8cpp_source.html#l00210">deepCopyExpandingMacros()</a>, <a class="el" href="Tree_8h_source.html#l00046">clang::syntax::Arena::getSourceManager()</a>, and <a class="el" href="BuildTree_8cpp_source.html#l01562">N</a>.</p>

<p class="reference">Referenced by <a class="el" href="Synthesis_8cpp_source.html#l00210">deepCopyExpandingMacros()</a>.</p>

</div>
</div>
<a id="a4aa2f5330bffd313bb05c4d4ed8d6042" name="a4aa2f5330bffd313bb05c4d4ed8d6042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa2f5330bffd313bb05c4d4ed8d6042">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::raw_ostream &amp; clang::syntax::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>OS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structclang_1_1syntax_1_1FileRange.html">FileRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>R</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For debugging purposes. </p>

<p class="definition">Definition at line <a class="el" href="Tokens_8cpp_source.html#l00169">169</a> of file <a class="el" href="Tokens_8cpp_source.html">Tokens.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tokens_8h_source.html#l00063">clang::syntax::FileRange::beginOffset()</a>, <a class="el" href="Tokens_8h_source.html#l00065">clang::syntax::FileRange::endOffset()</a>, <a class="el" href="Tokens_8h_source.html#l00061">clang::syntax::FileRange::file()</a>, and <a class="el" href="SourceLocation_8h_source.html#l00058">clang::FileID::getHashValue()</a>.</p>

</div>
</div>
<a id="aee22380c758acfc7dc72398d4312bcfc" name="aee22380c758acfc7dc72398d4312bcfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee22380c758acfc7dc72398d4312bcfc">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::raw_ostream &amp; clang::syntax::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>OS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1syntax_1_1Token.html">Token</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>T</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For debugging purposes. Equivalent to a call to <a class="el" href="classclang_1_1syntax_1_1Token.html#a10e327aee703a9281dd146fb9816b939" title="For debugging purposes.">Token::str()</a>. </p>

<p class="definition">Definition at line <a class="el" href="Tokens_8cpp_source.html#l00138">138</a> of file <a class="el" href="Tokens_8cpp_source.html">Tokens.cpp</a>.</p>

</div>
</div>
<a id="a9773dfd304fc990b06ed6a7a8711e6f8" name="a9773dfd304fc990b06ed6a7a8711e6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9773dfd304fc990b06ed6a7a8711e6f8">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; clang::syntax::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>OS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a81b5b8b797bac504f7538749a7bb0a2a">NodeKind</a></td>          <td class="paramname"><span class="paramname"><em>K</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For debugging purposes. </p>

<p class="definition">Definition at line <a class="el" href="Nodes_8cpp_source.html#l00013">13</a> of file <a class="el" href="Nodes_8cpp_source.html">Nodes.cpp</a>.</p>

</div>
</div>
<a id="ab327bf8bd6ce7e2ebe105061d44fd7cb" name="ab327bf8bd6ce7e2ebe105061d44fd7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab327bf8bd6ce7e2ebe105061d44fd7cb">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; clang::syntax::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>OS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0d10149d69e32e3c86140b4d325925e5">NodeRole</a></td>          <td class="paramname"><span class="paramname"><em>R</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For debugging purposes. </p>

<p class="definition">Definition at line <a class="el" href="Nodes_8cpp_source.html#l00023">23</a> of file <a class="el" href="Nodes_8cpp_source.html">Nodes.cpp</a>.</p>

</div>
</div>
<a id="a48156b5d50c571d3c6d3aa0a2c497e20" name="a48156b5d50c571d3c6d3aa0a2c497e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48156b5d50c571d3c6d3aa0a2c497e20">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::syntax::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1syntax_1_1Tree_1_1ConstChildIterator.html">Tree::ConstChildIterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structclang_1_1syntax_1_1Tree_1_1ConstChildIterator.html">Tree::ConstChildIterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00275">275</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="ac945be75b2e1a63c6fc656f3418fe455" name="ac945be75b2e1a63c6fc656f3418fe455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac945be75b2e1a63c6fc656f3418fe455">&#9670;&#160;</a></span>removeStatement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clang::syntax::removeStatement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1syntax_1_1Statement.html">syntax::Statement</a> *</td>          <td class="paramname"><span class="paramname"><em>S</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a statement or replaces it with an empty statement where one is required syntactically. </p>
<p>E.g., in the following example: if (cond) { foo(); } else bar(); One can remove <code>foo();</code> completely and to remove <code>bar();</code> we would need to replace it with an empty statement. EXPECTS: S-&gt;canModify() == true </p>

<p class="definition">Definition at line <a class="el" href="Mutations_8cpp_source.html#l00080">80</a> of file <a class="el" href="Mutations_8cpp_source.html">Mutations.cpp</a>.</p>

<p class="reference">References <a class="el" href="Synthesis_8cpp_source.html#l00227">createEmptyStatement()</a>.</p>

</div>
</div>
<a id="a5495e074677ac58e95e398b46e079cb2" name="a5495e074677ac58e95e398b46e079cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5495e074677ac58e95e398b46e079cb2">&#9670;&#160;</a></span>spelledIdentifierTouching() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> * clang::syntax::spelledIdentifierTouching </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>Loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1syntax_1_1TokenBuffer.html">syntax::TokenBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Tokens</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tokens_8cpp_source.html#l00476">476</a> of file <a class="el" href="Tokens_8cpp_source.html">Tokens.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tokens_8cpp_source.html#l00466">spelledIdentifierTouching()</a>.</p>

</div>
</div>
<a id="a4717e9f6a8df9c77f1bd3aedb282169e" name="a4717e9f6a8df9c77f1bd3aedb282169e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4717e9f6a8df9c77f1bd3aedb282169e">&#9670;&#160;</a></span>spelledIdentifierTouching() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> * clang::syntax::spelledIdentifierTouching </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>Loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Tokens</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The identifier token that overlaps or touches a spelling location Loc. </p>
<p>If there is none, returns nullptr. </p>

<p class="definition">Definition at line <a class="el" href="Tokens_8cpp_source.html#l00466">466</a> of file <a class="el" href="Tokens_8cpp_source.html">Tokens.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tokens_8cpp_source.html#l00459">spelledTokensTouching()</a>, and <a class="el" href="FormatToken_8h_source.html#l00643">Tok</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tokens_8cpp_source.html#l00476">spelledIdentifierTouching()</a>.</p>

</div>
</div>
<a id="afff502ef26cb84b374c72f21c9b44236" name="afff502ef26cb84b374c72f21c9b44236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff502ef26cb84b374c72f21c9b44236">&#9670;&#160;</a></span>spelledTokensTouching() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt; clang::syntax::spelledTokensTouching </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>Loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1syntax_1_1TokenBuffer.html">syntax::TokenBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Tokens</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The spelled tokens that overlap or touch a spelling location Loc. </p>
<p>This always returns 0-2 tokens. </p>

<p class="definition">Definition at line <a class="el" href="Tokens_8cpp_source.html#l00459">459</a> of file <a class="el" href="Tokens_8cpp_source.html">Tokens.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tokens_8cpp_source.html#l00459">spelledTokensTouching()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tokens_8cpp_source.html#l00466">spelledIdentifierTouching()</a>, and <a class="el" href="Tokens_8cpp_source.html#l00459">spelledTokensTouching()</a>.</p>

</div>
</div>
<a id="a793cf39170ae045357f2299a8ad5d1ee" name="a793cf39170ae045357f2299a8ad5d1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793cf39170ae045357f2299a8ad5d1ee">&#9670;&#160;</a></span>spelledTokensTouching() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt; clang::syntax::spelledTokensTouching </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>Loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Tokens</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tokens_8cpp_source.html#l00445">445</a> of file <a class="el" href="Tokens_8cpp_source.html">Tokens.cpp</a>.</p>

<p class="reference">References <a class="el" href="SourceLocation_8h_source.html#l00102">clang::SourceLocation::isFileID()</a>, and <a class="el" href="FormatToken_8h_source.html#l00643">Tok</a>.</p>

</div>
</div>
<a id="a24a1ffeac5053cf3f2a36f48251ce417" name="a24a1ffeac5053cf3f2a36f48251ce417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a1ffeac5053cf3f2a36f48251ce417">&#9670;&#160;</a></span>tokenize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt; clang::syntax::tokenize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1syntax_1_1FileRange.html">FileRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>FR</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1SourceManager.html">SourceManager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SM</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>LO</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to one above, instead of whole file tokenizes a part of it. </p>
<p>Note that, the first token might be incomplete if FR.startOffset is not at the beginning of a token, and the last token returned will start before the FR.endOffset but might end after it. </p>

<p class="definition">Definition at line <a class="el" href="Tokens_8cpp_source.html#l00497">497</a> of file <a class="el" href="Tokens_8cpp_source.html">Tokens.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tokens_8h_source.html#l00063">clang::syntax::FileRange::beginOffset()</a>, <a class="el" href="Tokens_8h_source.html#l00065">clang::syntax::FileRange::endOffset()</a>, <a class="el" href="Tokens_8h_source.html#l00061">clang::syntax::FileRange::file()</a>, <a class="el" href="IdentifierTable_8h_source.html#l00528">clang::IdentifierTable::get()</a>, <a class="el" href="Lexer_8h_source.html#l00273">clang::Lexer::getCurrentBufferOffset()</a>, <a class="el" href="IdentifierTable_8h_source.html#l00190">clang::IdentifierInfo::getTokenID()</a>, <a class="el" href="Lexer_8h_source.html#l00198">clang::Lexer::LexFromRawLexer()</a>, and <a class="el" href="Basic_2Cuda_8cpp_source.html#l00062">SM</a>.</p>

</div>
</div>
<a id="a74ab6237c208ae112ad2abd4e003235b" name="a74ab6237c208ae112ad2abd4e003235b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ab6237c208ae112ad2abd4e003235b">&#9670;&#160;</a></span>tokenize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt; clang::syntax::tokenize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileID.html">FileID</a></td>          <td class="paramname"><span class="paramname"><em>FID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1SourceManager.html">SourceManager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SM</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>LO</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lex the text buffer, corresponding to <code>FID</code>, in raw mode and record the resulting spelled tokens. </p>
<p>Does minimal post-processing on raw identifiers, setting the appropriate token kind (instead of the raw_identifier reported by lexer in raw mode). This is a very low-level function, most users should prefer to use <a class="el" href="classclang_1_1syntax_1_1TokenCollector.html" title="Collects tokens for the main file while running the frontend action.">TokenCollector</a>. Lexing in raw mode produces wildly different results from what one might expect when running a C++ frontend, e.g. preprocessor does not run at all. The result will <em>not</em> have a 'eof' token at the end. </p>

<p class="definition">Definition at line <a class="el" href="Tokens_8cpp_source.html#l00530">530</a> of file <a class="el" href="Tokens_8cpp_source.html">Tokens.cpp</a>.</p>

<p class="reference">References <a class="el" href="Basic_2Cuda_8cpp_source.html#l00062">SM</a>, and <a class="el" href="Tokens_8cpp_source.html#l00530">tokenize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tokens_8cpp_source.html#l00530">tokenize()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 8 2024 10:08:26 for clang by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
