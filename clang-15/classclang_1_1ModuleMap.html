<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: clang::ModuleMap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">clang<span id="projectnumber">&#160;15.0.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceclang.html">clang</a></li><li class="navelem"><a class="el" href="classclang_1_1ModuleMap.html">ModuleMap</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classclang_1_1ModuleMap-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">clang::ModuleMap Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="ModuleMap_8h_source.html">clang/Lex/ModuleMap.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A header that is known to reside within a given module, whether it was included or excluded.  <a href="classclang_1_1ModuleMap_1_1KnownHeader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac7a2413d4d0a8f29d2dad359bcfd8dec" id="r_ac7a2413d4d0a8f29d2dad359bcfd8dec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a> { <a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8deca50b6dee47a2d5b1f50f46dc46e4c96aa">NormalHeader</a> = 0x0
, <a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8deca0500e1f1c1ee8f9e6c76c993aa48b0d4">PrivateHeader</a> = 0x1
, <a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8decad7e8857e09c5d0fbe70ad90e0e584200">TextualHeader</a> = 0x2
 }</td></tr>
<tr class="memdesc:ac7a2413d4d0a8f29d2dad359bcfd8dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags describing the role of a module header.  <a href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">More...</a><br /></td></tr>
<tr class="separator:ac7a2413d4d0a8f29d2dad359bcfd8dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22c56a8f11f61caa8ab58809a21cca3" id="r_ac22c56a8f11f61caa8ab58809a21cca3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac22c56a8f11f61caa8ab58809a21cca3">AdditionalModMapsSet</a> = <a class="el" href="classllvm_1_1SmallPtrSet.html">llvm::SmallPtrSet</a>&lt;const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *, 1&gt;</td></tr>
<tr class="separator:ac22c56a8f11f61caa8ab58809a21cca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b352087754574155a198a4cb0d6e197" id="r_a1b352087754574155a198a4cb0d6e197"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b352087754574155a198a4cb0d6e197">module_iterator</a> = llvm::StringMap&lt;<a class="el" href="classclang_1_1Module.html">Module</a> *&gt;::const_iterator</td></tr>
<tr class="separator:a1b352087754574155a198a4cb0d6e197"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac588ee8d4c631303982ed1c68002f49d" id="r_ac588ee8d4c631303982ed1c68002f49d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac588ee8d4c631303982ed1c68002f49d">resolveLinkAsDependencies</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod)</td></tr>
<tr class="memdesc:ac588ee8d4c631303982ed1c68002f49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use PendingLinkAsModule information to mark top level link names that are going to be replaced by export_as aliases.  <br /></td></tr>
<tr class="separator:ac588ee8d4c631303982ed1c68002f49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06068cd4735154ef4218ab96f9462412" id="r_a06068cd4735154ef4218ab96f9462412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06068cd4735154ef4218ab96f9462412">addLinkAsDependency</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod)</td></tr>
<tr class="memdesc:a06068cd4735154ef4218ab96f9462412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make module to use export_as as the link dependency name if enough information is available or add it to a pending list otherwise.  <br /></td></tr>
<tr class="separator:a06068cd4735154ef4218ab96f9462412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767bb9d1787801348282cf9b588df471" id="r_a767bb9d1787801348282cf9b588df471"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a767bb9d1787801348282cf9b588df471">ModuleMap</a> (<a class="el" href="classclang_1_1SourceManager.html">SourceManager</a> &amp;SourceMgr, <a class="el" href="classclang_1_1DiagnosticsEngine.html">DiagnosticsEngine</a> &amp;Diags, const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;LangOpts, const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> *Target, <a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a> &amp;HeaderInfo)</td></tr>
<tr class="memdesc:a767bb9d1787801348282cf9b588df471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new module map.  <br /></td></tr>
<tr class="separator:a767bb9d1787801348282cf9b588df471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8769cd7eba3cb7f8f1cd2dde890603d" id="r_ab8769cd7eba3cb7f8f1cd2dde890603d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8769cd7eba3cb7f8f1cd2dde890603d">~ModuleMap</a> ()</td></tr>
<tr class="memdesc:ab8769cd7eba3cb7f8f1cd2dde890603d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the module map.  <br /></td></tr>
<tr class="separator:ab8769cd7eba3cb7f8f1cd2dde890603d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc441df169e00dbd5ab3a5db003d454f" id="r_abc441df169e00dbd5ab3a5db003d454f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc441df169e00dbd5ab3a5db003d454f">setTarget</a> (const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> &amp;Target)</td></tr>
<tr class="memdesc:abc441df169e00dbd5ab3a5db003d454f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target information.  <br /></td></tr>
<tr class="separator:abc441df169e00dbd5ab3a5db003d454f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c624a7392febb43c7bb1a19e835ab34" id="r_a6c624a7392febb43c7bb1a19e835ab34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c624a7392febb43c7bb1a19e835ab34">setBuiltinIncludeDir</a> (const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *Dir)</td></tr>
<tr class="memdesc:a6c624a7392febb43c7bb1a19e835ab34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the directory that contains Clang-supplied include files, such as our <a class="el" href="stdarg_8h.html">stdarg.h</a> or <a class="el" href="tgmath_8h.html">tgmath.h</a>.  <br /></td></tr>
<tr class="separator:a6c624a7392febb43c7bb1a19e835ab34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68be9dccb44faab58c2109371768c01e" id="r_a68be9dccb44faab58c2109371768c01e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68be9dccb44faab58c2109371768c01e">getBuiltinDir</a> () const</td></tr>
<tr class="memdesc:a68be9dccb44faab58c2109371768c01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the directory that contains Clang-supplied include files.  <br /></td></tr>
<tr class="separator:a68be9dccb44faab58c2109371768c01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8ca3bc91f0e93e6c706b80f263e521" id="r_a1e8ca3bc91f0e93e6c706b80f263e521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e8ca3bc91f0e93e6c706b80f263e521">isBuiltinHeader</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *<a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">File</a>)</td></tr>
<tr class="separator:a1e8ca3bc91f0e93e6c706b80f263e521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516ba163200648ee309a8b16ccc0d62a" id="r_a516ba163200648ee309a8b16ccc0d62a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a516ba163200648ee309a8b16ccc0d62a">addModuleMapCallbacks</a> (std::unique_ptr&lt; <a class="el" href="classclang_1_1ModuleMapCallbacks.html">ModuleMapCallbacks</a> &gt; Callback)</td></tr>
<tr class="memdesc:a516ba163200648ee309a8b16ccc0d62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a module map callback.  <br /></td></tr>
<tr class="separator:a516ba163200648ee309a8b16ccc0d62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8806b0826524879693983c42a0cd9aa9" id="r_a8806b0826524879693983c42a0cd9aa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8806b0826524879693983c42a0cd9aa9">findModuleForHeader</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *<a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">File</a>, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> AllowTextual=<a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:a8806b0826524879693983c42a0cd9aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the module that owns the given header file, if any.  <br /></td></tr>
<tr class="separator:a8806b0826524879693983c42a0cd9aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cf9768b587f077bf7916c10754713a" id="r_a94cf9768b587f077bf7916c10754713a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94cf9768b587f077bf7916c10754713a">findAllModulesForHeader</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *<a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">File</a>)</td></tr>
<tr class="memdesc:a94cf9768b587f077bf7916c10754713a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the modules that contain the given header file.  <br /></td></tr>
<tr class="separator:a94cf9768b587f077bf7916c10754713a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7569af5b4b731de5a135caf8636681b3" id="r_a7569af5b4b731de5a135caf8636681b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7569af5b4b731de5a135caf8636681b3">findResolvedModulesForHeader</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *<a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">File</a>) const</td></tr>
<tr class="memdesc:a7569af5b4b731de5a135caf8636681b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="#a94cf9768b587f077bf7916c10754713a">findAllModulesForHeader</a>, but do not attempt to infer module ownership from umbrella headers if we've not already done so.  <br /></td></tr>
<tr class="separator:a7569af5b4b731de5a135caf8636681b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ce2c7a23bcff10e7ae4bfcda637182" id="r_a64ce2c7a23bcff10e7ae4bfcda637182"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64ce2c7a23bcff10e7ae4bfcda637182">resolveHeaderDirectives</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *<a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">File</a>) const</td></tr>
<tr class="memdesc:a64ce2c7a23bcff10e7ae4bfcda637182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all lazy header directives for the specified file.  <br /></td></tr>
<tr class="separator:a64ce2c7a23bcff10e7ae4bfcda637182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7f7d3851e51a8409988c5c182490ac" id="r_a2a7f7d3851e51a8409988c5c182490ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a7f7d3851e51a8409988c5c182490ac">resolveHeaderDirectives</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> * &gt; <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">File</a>) const</td></tr>
<tr class="memdesc:a2a7f7d3851e51a8409988c5c182490ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve lazy header directives for the specified module.  <br /></td></tr>
<tr class="separator:a2a7f7d3851e51a8409988c5c182490ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cfc8d05dbf3c2cceb132f4c789b8d1" id="r_a22cfc8d05dbf3c2cceb132f4c789b8d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22cfc8d05dbf3c2cceb132f4c789b8d1">diagnoseHeaderInclusion</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *RequestingModule, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> RequestingModuleIsModuleInterface, <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> FilenameLoc, StringRef <a class="el" href="Format_8cpp.html#ad1d2004964f78dae576fc66650252f7c">Filename</a>, <a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">File</a>)</td></tr>
<tr class="memdesc:a22cfc8d05dbf3c2cceb132f4c789b8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports errors if a module must not include a specific file.  <br /></td></tr>
<tr class="separator:a22cfc8d05dbf3c2cceb132f4c789b8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc11dbc10f0658870b83753074c3c1d9" id="r_afc11dbc10f0658870b83753074c3c1d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc11dbc10f0658870b83753074c3c1d9">isHeaderInUnavailableModule</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *Header) const</td></tr>
<tr class="memdesc:afc11dbc10f0658870b83753074c3c1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the given header is part of a module marked 'unavailable'.  <br /></td></tr>
<tr class="separator:afc11dbc10f0658870b83753074c3c1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890ef9bee13458036c9e4d5d7df58c8f" id="r_a890ef9bee13458036c9e4d5d7df58c8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a890ef9bee13458036c9e4d5d7df58c8f">isHeaderUnavailableInModule</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *Header, const <a class="el" href="classclang_1_1Module.html">Module</a> *RequestingModule) const</td></tr>
<tr class="memdesc:a890ef9bee13458036c9e4d5d7df58c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the given header is unavailable as part of the specified module.  <br /></td></tr>
<tr class="separator:a890ef9bee13458036c9e4d5d7df58c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bee9d02a3e7ced6bc9f7dd42ede743" id="r_a35bee9d02a3e7ced6bc9f7dd42ede743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35bee9d02a3e7ced6bc9f7dd42ede743">findModule</a> (StringRef Name) const</td></tr>
<tr class="memdesc:a35bee9d02a3e7ced6bc9f7dd42ede743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a module with the given name.  <br /></td></tr>
<tr class="separator:a35bee9d02a3e7ced6bc9f7dd42ede743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9682383d1483005eb8de8ab46275f5e5" id="r_a9682383d1483005eb8de8ab46275f5e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9682383d1483005eb8de8ab46275f5e5">lookupModuleUnqualified</a> (StringRef Name, <a class="el" href="classclang_1_1Module.html">Module</a> *Context) const</td></tr>
<tr class="memdesc:a9682383d1483005eb8de8ab46275f5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a module with the given name using lexical name lookup, starting at the given context.  <br /></td></tr>
<tr class="separator:a9682383d1483005eb8de8ab46275f5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bd056e3b16607ace724463606dd3d5" id="r_ac4bd056e3b16607ace724463606dd3d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4bd056e3b16607ace724463606dd3d5">lookupModuleQualified</a> (StringRef Name, <a class="el" href="classclang_1_1Module.html">Module</a> *Context) const</td></tr>
<tr class="memdesc:ac4bd056e3b16607ace724463606dd3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a module with the given name within the given context, using direct (qualified) name lookup.  <br /></td></tr>
<tr class="separator:ac4bd056e3b16607ace724463606dd3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115a5b7b114346aaa534995084fc3ac0" id="r_a115a5b7b114346aaa534995084fc3ac0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classclang_1_1Module.html">Module</a> *, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a115a5b7b114346aaa534995084fc3ac0">findOrCreateModule</a> (StringRef Name, <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsFramework, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsExplicit)</td></tr>
<tr class="memdesc:a115a5b7b114346aaa534995084fc3ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a new module or submodule, or create it if it does not already exist.  <br /></td></tr>
<tr class="separator:a115a5b7b114346aaa534995084fc3ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab984430b63c290eb25d0b696d486303c" id="r_ab984430b63c290eb25d0b696d486303c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab984430b63c290eb25d0b696d486303c">createGlobalModuleFragmentForModuleUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>=nullptr)</td></tr>
<tr class="memdesc:ab984430b63c290eb25d0b696d486303c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a global module fragment for a C++ module unit.  <br /></td></tr>
<tr class="separator:ab984430b63c290eb25d0b696d486303c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea4a5b3bc65f0ff822859970c2ecac0" id="r_acea4a5b3bc65f0ff822859970c2ecac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acea4a5b3bc65f0ff822859970c2ecac0">createPrivateModuleFragmentForInterfaceUnit</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>, <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc)</td></tr>
<tr class="memdesc:acea4a5b3bc65f0ff822859970c2ecac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a global module fragment for a C++ module interface unit.  <br /></td></tr>
<tr class="separator:acea4a5b3bc65f0ff822859970c2ecac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3b29c079da00f53ccd31b16f5a413a" id="r_a6c3b29c079da00f53ccd31b16f5a413a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c3b29c079da00f53ccd31b16f5a413a">createModuleForInterfaceUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, StringRef Name, <a class="el" href="classclang_1_1Module.html">Module</a> *GlobalModule)</td></tr>
<tr class="memdesc:a6c3b29c079da00f53ccd31b16f5a413a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new module for a C++ module interface unit.  <br /></td></tr>
<tr class="separator:a6c3b29c079da00f53ccd31b16f5a413a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1418097f85910bca7bd12b1f17208b" id="r_a1a1418097f85910bca7bd12b1f17208b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a1418097f85910bca7bd12b1f17208b">createHeaderModule</a> (StringRef Name, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a> &gt; Headers)</td></tr>
<tr class="memdesc:a1a1418097f85910bca7bd12b1f17208b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a header module from the specified list of headers.  <br /></td></tr>
<tr class="separator:a1a1418097f85910bca7bd12b1f17208b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488004c9aee8ccd0836e58ab114813ed" id="r_a488004c9aee8ccd0836e58ab114813ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a488004c9aee8ccd0836e58ab114813ed">createHeaderUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, StringRef Name, <a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a> H)</td></tr>
<tr class="memdesc:a488004c9aee8ccd0836e58ab114813ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a C++20 header unit.  <br /></td></tr>
<tr class="separator:a488004c9aee8ccd0836e58ab114813ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78651ebbabbed8598a8b3d71c0712f6" id="r_ad78651ebbabbed8598a8b3d71c0712f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78651ebbabbed8598a8b3d71c0712f6">inferFrameworkModule</a> (const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *FrameworkDir, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsSystem, <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>)</td></tr>
<tr class="memdesc:ad78651ebbabbed8598a8b3d71c0712f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the contents of a framework module map from the given framework directory.  <br /></td></tr>
<tr class="separator:ad78651ebbabbed8598a8b3d71c0712f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031a847ae6f15d895ef5808fd4af56aa" id="r_a031a847ae6f15d895ef5808fd4af56aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a031a847ae6f15d895ef5808fd4af56aa">createShadowedModule</a> (StringRef Name, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsFramework, <a class="el" href="classclang_1_1Module.html">Module</a> *ShadowingModule)</td></tr>
<tr class="memdesc:a031a847ae6f15d895ef5808fd4af56aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new top-level module that is shadowed by <code>ShadowingModule</code>.  <br /></td></tr>
<tr class="separator:a031a847ae6f15d895ef5808fd4af56aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390f6e47e08d60984fca9c6c492d42f7" id="r_a390f6e47e08d60984fca9c6c492d42f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a390f6e47e08d60984fca9c6c492d42f7">finishModuleDeclarationScope</a> ()</td></tr>
<tr class="memdesc:a390f6e47e08d60984fca9c6c492d42f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new declaration scope for module names, allowing previously defined modules to shadow definitions from the new scope.  <br /></td></tr>
<tr class="separator:a390f6e47e08d60984fca9c6c492d42f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df11cf9b74e240aa373f25c1a63b49f" id="r_a3df11cf9b74e240aa373f25c1a63b49f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3df11cf9b74e240aa373f25c1a63b49f">mayShadowNewModule</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *ExistingModule)</td></tr>
<tr class="separator:a3df11cf9b74e240aa373f25c1a63b49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b14289476fe5638600e7e1d78f41a0e" id="r_a3b14289476fe5638600e7e1d78f41a0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b14289476fe5638600e7e1d78f41a0e">canInferFrameworkModule</a> (const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *Dir) const</td></tr>
<tr class="memdesc:a3b14289476fe5638600e7e1d78f41a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a framework module can be inferred in the given directory.  <br /></td></tr>
<tr class="separator:a3b14289476fe5638600e7e1d78f41a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71ec7ef5400f119c1e95c28dad0371d" id="r_ab71ec7ef5400f119c1e95c28dad0371d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab71ec7ef5400f119c1e95c28dad0371d">getContainingModuleMapFile</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="classclang_1_1Module.html">Module</a>) const</td></tr>
<tr class="memdesc:ab71ec7ef5400f119c1e95c28dad0371d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the module map file containing the definition of the given module.  <br /></td></tr>
<tr class="separator:ab71ec7ef5400f119c1e95c28dad0371d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad77286fb30719f2f516e5a67acaefe" id="r_a8ad77286fb30719f2f516e5a67acaefe"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ad77286fb30719f2f516e5a67acaefe">getModuleMapFileForUniquing</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *M) const</td></tr>
<tr class="memdesc:a8ad77286fb30719f2f516e5a67acaefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the module map file that (along with the module name) uniquely identifies this module.  <br /></td></tr>
<tr class="separator:a8ad77286fb30719f2f516e5a67acaefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cf116b47bb6201a8154feab288cc65" id="r_a64cf116b47bb6201a8154feab288cc65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64cf116b47bb6201a8154feab288cc65">setInferredModuleAllowedBy</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *M, const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *ModMap)</td></tr>
<tr class="separator:a64cf116b47bb6201a8154feab288cc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f089144fb15ba586196345ad98b8d0c" id="r_a9f089144fb15ba586196345ad98b8d0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac22c56a8f11f61caa8ab58809a21cca3">AdditionalModMapsSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f089144fb15ba586196345ad98b8d0c">getAdditionalModuleMapFiles</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *M)</td></tr>
<tr class="memdesc:a9f089144fb15ba586196345ad98b8d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get any module map files other than getModuleMapFileForUniquing(M) that define submodules of a top-level module <code>M</code>.  <br /></td></tr>
<tr class="separator:a9f089144fb15ba586196345ad98b8d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748c66535339dbf5b860b72eff5cbadb" id="r_a748c66535339dbf5b860b72eff5cbadb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a748c66535339dbf5b860b72eff5cbadb">addAdditionalModuleMapFile</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *M, const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *<a class="el" href="classclang_1_1ModuleMap.html">ModuleMap</a>)</td></tr>
<tr class="separator:a748c66535339dbf5b860b72eff5cbadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d91ee91e3d302d32885c4d790b3915" id="r_a03d91ee91e3d302d32885c4d790b3915"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03d91ee91e3d302d32885c4d790b3915">resolveExports</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Complain)</td></tr>
<tr class="memdesc:a03d91ee91e3d302d32885c4d790b3915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all of the unresolved exports in the given module.  <br /></td></tr>
<tr class="separator:a03d91ee91e3d302d32885c4d790b3915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff262a15ac7933edd463953d969e4f6b" id="r_aff262a15ac7933edd463953d969e4f6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff262a15ac7933edd463953d969e4f6b">resolveUses</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Complain)</td></tr>
<tr class="memdesc:aff262a15ac7933edd463953d969e4f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all of the unresolved uses in the given module.  <br /></td></tr>
<tr class="separator:aff262a15ac7933edd463953d969e4f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635593eb7f27a7297eb22afacd08d104" id="r_a635593eb7f27a7297eb22afacd08d104"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a635593eb7f27a7297eb22afacd08d104">resolveConflicts</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Complain)</td></tr>
<tr class="memdesc:a635593eb7f27a7297eb22afacd08d104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all of the unresolved conflicts in the given module.  <br /></td></tr>
<tr class="separator:a635593eb7f27a7297eb22afacd08d104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac236ffc11120133f8b4908b175e98172" id="r_ac236ffc11120133f8b4908b175e98172"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac236ffc11120133f8b4908b175e98172">setUmbrellaHeader</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *UmbrellaHeader, const Twine &amp;NameAsWritten, const Twine &amp;PathRelativeToRootModuleDirectory)</td></tr>
<tr class="memdesc:ac236ffc11120133f8b4908b175e98172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the umbrella header of the given module to the given header.  <br /></td></tr>
<tr class="separator:ac236ffc11120133f8b4908b175e98172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5148fa4f93b67492291bee915c9e27" id="r_a4c5148fa4f93b67492291bee915c9e27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c5148fa4f93b67492291bee915c9e27">setUmbrellaDir</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *UmbrellaDir, const Twine &amp;NameAsWritten, const Twine &amp;PathRelativeToRootModuleDirectory)</td></tr>
<tr class="memdesc:a4c5148fa4f93b67492291bee915c9e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the umbrella directory of the given module to the given directory.  <br /></td></tr>
<tr class="separator:a4c5148fa4f93b67492291bee915c9e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb605a0f3e5ac2213bab92d201fc1ec1" id="r_acb605a0f3e5ac2213bab92d201fc1ec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb605a0f3e5ac2213bab92d201fc1ec1">addHeader</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a> Header, <a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a> <a class="el" href="FormatToken_8h.html#a0b435a0263eeabdc103dad5124bf391a">Role</a>, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Imported=<a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:acb605a0f3e5ac2213bab92d201fc1ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds this header to the given module.  <br /></td></tr>
<tr class="separator:acb605a0f3e5ac2213bab92d201fc1ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836cc1b5aecd0071b6e90837fefa0b2a" id="r_a836cc1b5aecd0071b6e90837fefa0b2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a836cc1b5aecd0071b6e90837fefa0b2a">excludeHeader</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a> Header)</td></tr>
<tr class="memdesc:a836cc1b5aecd0071b6e90837fefa0b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks this header as being excluded from the given module.  <br /></td></tr>
<tr class="separator:a836cc1b5aecd0071b6e90837fefa0b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516cfeb32bb3a464262cf6f369417eab" id="r_a516cfeb32bb3a464262cf6f369417eab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a516cfeb32bb3a464262cf6f369417eab">parseModuleMapFile</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *<a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">File</a>, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsSystem, const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *HomeDir, <a class="el" href="classclang_1_1FileID.html">FileID</a> ID=<a class="el" href="classclang_1_1FileID.html">FileID</a>(), <a class="el" href="classunsigned.html">unsigned</a> *<a class="el" href="Format_8cpp.html#a9fcf84dffafb0ea03c0f9b686ddbf2b3">Offset</a>=nullptr, <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> ExternModuleLoc=<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>())</td></tr>
<tr class="memdesc:a516cfeb32bb3a464262cf6f369417eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the given module map file, and record any modules we encounter.  <br /></td></tr>
<tr class="separator:a516cfeb32bb3a464262cf6f369417eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed1579ac35c5dcb1ab68449949a6912" id="r_a0ed1579ac35c5dcb1ab68449949a6912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ed1579ac35c5dcb1ab68449949a6912">dump</a> ()</td></tr>
<tr class="memdesc:a0ed1579ac35c5dcb1ab68449949a6912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the contents of the module map, for debugging purposes.  <br /></td></tr>
<tr class="separator:a0ed1579ac35c5dcb1ab68449949a6912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab65f1f0882fcff9a15da9cfbf0fd02" id="r_a6ab65f1f0882fcff9a15da9cfbf0fd02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a1b352087754574155a198a4cb0d6e197">module_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ab65f1f0882fcff9a15da9cfbf0fd02">module_begin</a> () const</td></tr>
<tr class="separator:a6ab65f1f0882fcff9a15da9cfbf0fd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9e3147d81ec86cf00eea874d9ea95b" id="r_a9d9e3147d81ec86cf00eea874d9ea95b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a1b352087754574155a198a4cb0d6e197">module_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d9e3147d81ec86cf00eea874d9ea95b">module_end</a> () const</td></tr>
<tr class="separator:a9d9e3147d81ec86cf00eea874d9ea95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc466d3e7e6077fea6c69d48759ec723" id="r_afc466d3e7e6077fea6c69d48759ec723"><td class="memItemLeft" align="right" valign="top">llvm::iterator_range&lt; <a class="el" href="#a1b352087754574155a198a4cb0d6e197">module_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc466d3e7e6077fea6c69d48759ec723">modules</a> () const</td></tr>
<tr class="separator:afc466d3e7e6077fea6c69d48759ec723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61bce84c6ecb21f1f05539c84b855ad" id="r_ac61bce84c6ecb21f1f05539c84b855ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac61bce84c6ecb21f1f05539c84b855ad">cacheModuleLoad</a> (const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;II, <a class="el" href="classclang_1_1Module.html">Module</a> *M)</td></tr>
<tr class="memdesc:ac61bce84c6ecb21f1f05539c84b855ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache a module load. M might be nullptr.  <br /></td></tr>
<tr class="separator:ac61bce84c6ecb21f1f05539c84b855ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4bd7b843a23c66a57650297df1c545" id="r_a4b4bd7b843a23c66a57650297df1c545"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="classclang_1_1Module.html">Module</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b4bd7b843a23c66a57650297df1c545">getCachedModuleLoad</a> (const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;II)</td></tr>
<tr class="memdesc:a4b4bd7b843a23c66a57650297df1c545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a cached module load.  <br /></td></tr>
<tr class="separator:a4b4bd7b843a23c66a57650297df1c545"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af95957116dd995616c90e64c864811cd" id="r_af95957116dd995616c90e64c864811cd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af95957116dd995616c90e64c864811cd">headerKindToRole</a> (<a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a> Kind)</td></tr>
<tr class="memdesc:af95957116dd995616c90e64c864811cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a header kind to a role. Requires Kind to not be HK_Excluded.  <br /></td></tr>
<tr class="separator:af95957116dd995616c90e64c864811cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c51efd0ee64aaadd73218544eeeb01" id="r_a32c51efd0ee64aaadd73218544eeeb01"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32c51efd0ee64aaadd73218544eeeb01">headerRoleToKind</a> (<a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a> <a class="el" href="FormatToken_8h.html#a0b435a0263eeabdc103dad5124bf391a">Role</a>)</td></tr>
<tr class="memdesc:a32c51efd0ee64aaadd73218544eeeb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a header role to a kind.  <br /></td></tr>
<tr class="separator:a32c51efd0ee64aaadd73218544eeeb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c825f7506d1abd0d9bc54eba6330e6" id="r_a40c825f7506d1abd0d9bc54eba6330e6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40c825f7506d1abd0d9bc54eba6330e6">isBuiltinHeader</a> (StringRef FileName)</td></tr>
<tr class="memdesc:a40c825f7506d1abd0d9bc54eba6330e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this a compiler builtin header?  <br /></td></tr>
<tr class="separator:a40c825f7506d1abd0d9bc54eba6330e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a69fccb440615f32e24516ed4e718457d" id="r_a69fccb440615f32e24516ed4e718457d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69fccb440615f32e24516ed4e718457d">ModuleMapParser</a></td></tr>
<tr class="separator:a69fccb440615f32e24516ed4e718457d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00075">75</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac22c56a8f11f61caa8ab58809a21cca3" name="ac22c56a8f11f61caa8ab58809a21cca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22c56a8f11f61caa8ab58809a21cca3">&#9670;&#160;</a></span>AdditionalModMapsSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac22c56a8f11f61caa8ab58809a21cca3">clang::ModuleMap::AdditionalModMapsSet</a> = <a class="el" href="classllvm_1_1SmallPtrSet.html">llvm::SmallPtrSet</a>&lt;const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00193">193</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<a id="a1b352087754574155a198a4cb0d6e197" name="a1b352087754574155a198a4cb0d6e197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b352087754574155a198a4cb0d6e197">&#9670;&#160;</a></span>module_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1b352087754574155a198a4cb0d6e197">clang::ModuleMap::module_iterator</a> = llvm::StringMap&lt;<a class="el" href="classclang_1_1Module.html">Module</a> *&gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00713">713</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac7a2413d4d0a8f29d2dad359bcfd8dec" name="ac7a2413d4d0a8f29d2dad359bcfd8dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">&#9670;&#160;</a></span>ModuleHeaderRole</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">clang::ModuleMap::ModuleHeaderRole</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags describing the role of a module header. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac7a2413d4d0a8f29d2dad359bcfd8deca50b6dee47a2d5b1f50f46dc46e4c96aa" name="ac7a2413d4d0a8f29d2dad359bcfd8deca50b6dee47a2d5b1f50f46dc46e4c96aa"></a>NormalHeader&#160;</td><td class="fielddoc"><p>This header is normally included in the module. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a2413d4d0a8f29d2dad359bcfd8deca0500e1f1c1ee8f9e6c76c993aa48b0d4" name="ac7a2413d4d0a8f29d2dad359bcfd8deca0500e1f1c1ee8f9e6c76c993aa48b0d4"></a>PrivateHeader&#160;</td><td class="fielddoc"><p>This header is included but private. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a2413d4d0a8f29d2dad359bcfd8decad7e8857e09c5d0fbe70ad90e0e584200" name="ac7a2413d4d0a8f29d2dad359bcfd8decad7e8857e09c5d0fbe70ad90e0e584200"></a>TextualHeader&#160;</td><td class="fielddoc"><p>This header is part of the module (for layering purposes) but should be textually included. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00128">128</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a767bb9d1787801348282cf9b588df471" name="a767bb9d1787801348282cf9b588df471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767bb9d1787801348282cf9b588df471">&#9670;&#160;</a></span>ModuleMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ModuleMap::ModuleMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceManager.html">SourceManager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SourceMgr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1DiagnosticsEngine.html">DiagnosticsEngine</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Diags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>LangOpts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>Target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>HeaderInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new module map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SourceMgr</td><td>The source manager used to find module files and headers. This source manager should be shared with the header-search mechanism, since they will refer to the same headers.</td></tr>
    <tr><td class="paramname">Diags</td><td>A diagnostic engine used for diagnostics.</td></tr>
    <tr><td class="paramname">LangOpts</td><td>Language options for this translation unit.</td></tr>
    <tr><td class="paramname">Target</td><td>The target for this translation unit. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00314">314</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="ab8769cd7eba3cb7f8f1cd2dde890603d" name="ab8769cd7eba3cb7f8f1cd2dde890603d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8769cd7eba3cb7f8f1cd2dde890603d">&#9670;&#160;</a></span>~ModuleMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ModuleMap::~ModuleMap </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the module map. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00322">322</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a748c66535339dbf5b860b72eff5cbadb" name="a748c66535339dbf5b860b72eff5cbadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748c66535339dbf5b860b72eff5cbadb">&#9670;&#160;</a></span>addAdditionalModuleMapFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::addAdditionalModuleMapFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>ModuleMap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01295">1295</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="acb605a0f3e5ac2213bab92d201fc1ec1" name="acb605a0f3e5ac2213bab92d201fc1ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb605a0f3e5ac2213bab92d201fc1ec1">&#9670;&#160;</a></span>addHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::addHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a></td>          <td class="paramname"><span class="paramname"><em>Header</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a></td>          <td class="paramname"><span class="paramname"><em>Role</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>Imported</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds this header to the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Role</td><td>The role of the header wrt the module. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01235">1235</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00214">clang::Module::Header::Entry</a>, <a class="el" href="FileEntry_8h_source.html#l00361">clang::FileEntry::getName()</a>, <a class="el" href="Module_8h_source.html#l00586">clang::Module::getTopLevelModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00076">headerRoleToKind()</a>, <a class="el" href="Module_8h_source.html#l00230">clang::Module::Headers</a>, <a class="el" href="LangOptions_8h_source.html#l00494">clang::LangOptions::isCompilingModule()</a>, <a class="el" href="HeaderSearch_8cpp_source.html#l01348">clang::HeaderSearch::MarkFileModuleHeader()</a>, and <a class="el" href="FormatToken_8h_source.html#l00729">Role</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00882">createHeaderModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00905">createHeaderUnit()</a>, and <a class="el" href="ASTReader_8cpp_source.html#l01912">clang::serialization::reader::HeaderFileInfoTrait::ReadData()</a>.</p>

</div>
</div>
<a id="a06068cd4735154ef4218ab96f9462412" name="a06068cd4735154ef4218ab96f9462412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06068cd4735154ef4218ab96f9462412">&#9670;&#160;</a></span>addLinkAsDependency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::addLinkAsDependency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make module to use export_as as the link dependency name if enough information is available or add it to a pending list otherwise. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00069">69</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00158">clang::Module::ExportAsModule</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00787">findModule()</a>, <a class="el" href="Module_8h_source.html#l00099">clang::Module::Name</a>, and <a class="el" href="Module_8h_source.html#l00408">clang::Module::UseExportAsModuleLinkName</a>.</p>

</div>
</div>
<a id="a516ba163200648ee309a8b16ccc0d62a" name="a516ba163200648ee309a8b16ccc0d62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516ba163200648ee309a8b16ccc0d62a">&#9670;&#160;</a></span>addModuleMapCallbacks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::addModuleMapCallbacks </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classclang_1_1ModuleMapCallbacks.html">ModuleMapCallbacks</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Callback</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a module map callback. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00418">418</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="DependencyFile_8cpp_source.html#l00177">clang::DependencyCollector::attachToPreprocessor()</a>, and <a class="el" href="ModuleDependencyCollector_8cpp_source.html#l00105">clang::ModuleDependencyCollector::attachToPreprocessor()</a>.</p>

</div>
</div>
<a id="ac61bce84c6ecb21f1f05539c84b855ad" name="ac61bce84c6ecb21f1f05539c84b855ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61bce84c6ecb21f1f05539c84b855ad">&#9670;&#160;</a></span>cacheModuleLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::cacheModuleLoad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>II</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>M</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache a module load. M might be nullptr. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00722">722</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l01942">clang::CompilerInstance::loadModule()</a>.</p>

</div>
</div>
<a id="a3b14289476fe5638600e7e1d78f41a0e" name="a3b14289476fe5638600e7e1d78f41a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b14289476fe5638600e7e1d78f41a0e">&#9670;&#160;</a></span>canInferFrameworkModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::ModuleMap::canInferFrameworkModule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>Dir</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a framework module can be inferred in the given directory. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00595">595</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrontendAction_8cpp_source.html#l00436">loadModuleMapForModuleBuild()</a>.</p>

</div>
</div>
<a id="ab984430b63c290eb25d0b696d486303c" name="ab984430b63c290eb25d0b696d486303c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab984430b63c290eb25d0b696d486303c">&#9670;&#160;</a></span>createGlobalModuleFragmentForModuleUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createGlobalModuleFragmentForModuleUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>Loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Parent</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a global module fragment for a C++ module unit. </p>
<p>We model the global module fragment as a submodule of the module interface unit. Unfortunately, we can't create the module interface unit's <a class="el" href="classclang_1_1Module.html" title="Describes a module or submodule.">Module</a> until later, because we don't know what it will be called usually. See C++20 [module.unit]/7.2 for the case we could know its parent. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00832">832</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00122">clang::Module::GlobalModuleFragment</a>, <a class="el" href="namespaceclang.html#ad145f7432ac192abba688627ec3d64dcae55f75a29310d7b60f7ac1d390c8ae42">clang::Module</a>, <a class="el" href="ASTDiff_8cpp_source.html#l00192">Parent</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="a1a1418097f85910bca7bd12b1f17208b" name="a1a1418097f85910bca7bd12b1f17208b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a1418097f85910bca7bd12b1f17208b">&#9670;&#160;</a></span>createHeaderModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createHeaderModule </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Headers</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a header module from the specified list of headers. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00882">882</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l01235">addHeader()</a>, <a class="el" href="LangOptions_8h_source.html#l00417">clang::LangOptions::CurrentModule</a>, <a class="el" href="Module_8h_source.html#l00355">clang::Module::Exports</a>, <a class="el" href="namespaceclang.html#ad145f7432ac192abba688627ec3d64dcae55f75a29310d7b60f7ac1d390c8ae42">clang::Module</a>, <a class="el" href="Module_8h_source.html#l00110">clang::Module::ModuleInterfaceUnit</a>, <a class="el" href="ModuleMap_8h_source.html#l00130">NormalHeader</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="a488004c9aee8ccd0836e58ab114813ed" name="a488004c9aee8ccd0836e58ab114813ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488004c9aee8ccd0836e58ab114813ed">&#9670;&#160;</a></span>createHeaderUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createHeaderUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>Loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a></td>          <td class="paramname"><span class="paramname"><em>H</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a C++20 header unit. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00905">905</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l01235">addHeader()</a>, <a class="el" href="LangOptions_8h_source.html#l00417">clang::LangOptions::CurrentModule</a>, <a class="el" href="namespaceclang.html#ad145f7432ac192abba688627ec3d64dcae55f75a29310d7b60f7ac1d390c8ae42">clang::Module</a>, <a class="el" href="Module_8h_source.html#l00113">clang::Module::ModuleHeaderUnit</a>, <a class="el" href="ModuleMap_8h_source.html#l00130">NormalHeader</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="a6c3b29c079da00f53ccd31b16f5a413a" name="a6c3b29c079da00f53ccd31b16f5a413a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3b29c079da00f53ccd31b16f5a413a">&#9670;&#160;</a></span>createModuleForInterfaceUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createModuleForInterfaceUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>Loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>GlobalModule</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new module for a C++ module interface unit. </p>
<p>The module must not already exist, and will be configured for the current compilation.</p>
<p>Note that this also sets the current module to the newly-created module.</p>
<dl class="section return"><dt>Returns</dt><dd>The newly-created module. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00854">854</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="LangOptions_8h_source.html#l00417">clang::LangOptions::CurrentModule</a>, <a class="el" href="namespaceclang.html#ad145f7432ac192abba688627ec3d64dcae55f75a29310d7b60f7ac1d390c8ae42">clang::Module</a>, <a class="el" href="Module_8h_source.html#l00110">clang::Module::ModuleInterfaceUnit</a>, <a class="el" href="ModuleMap_8h_source.html#l00133">PrivateHeader</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="acea4a5b3bc65f0ff822859970c2ecac0" name="acea4a5b3bc65f0ff822859970c2ecac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea4a5b3bc65f0ff822859970c2ecac0">&#9670;&#160;</a></span>createPrivateModuleFragmentForInterfaceUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createPrivateModuleFragmentForInterfaceUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>Loc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a global module fragment for a C++ module interface unit. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00845">845</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#ad145f7432ac192abba688627ec3d64dcae55f75a29310d7b60f7ac1d390c8ae42">clang::Module</a>, <a class="el" href="ASTDiff_8cpp_source.html#l00192">Parent</a>, <a class="el" href="Module_8h_source.html#l00125">clang::Module::PrivateModuleFragment</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="a031a847ae6f15d895ef5808fd4af56aa" name="a031a847ae6f15d895ef5808fd4af56aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031a847ae6f15d895ef5808fd4af56aa">&#9670;&#160;</a></span>createShadowedModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createShadowedModule </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsFramework</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>ShadowingModule</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new top-level module that is shadowed by <code>ShadowingModule</code>. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01124">1124</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8cpp_source.html#l00303">clang::Module::markUnavailable()</a>, <a class="el" href="namespaceclang.html#ad145f7432ac192abba688627ec3d64dcae55f75a29310d7b60f7ac1d390c8ae42">clang::Module</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="a22cfc8d05dbf3c2cceb132f4c789b8d1" name="a22cfc8d05dbf3c2cceb132f4c789b8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cfc8d05dbf3c2cceb132f4c789b8d1">&#9670;&#160;</a></span>diagnoseHeaderInclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::diagnoseHeaderInclusion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>RequestingModule</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>RequestingModuleIsModuleInterface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>FilenameLoc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a></td>          <td class="paramname"><span class="paramname"><em>File</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports errors if a module must not include a specific file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RequestingModule</td><td>The module including a file.</td></tr>
    <tr><td class="paramname">RequestingModuleIsModuleInterface</td><td><code>true</code> if the inclusion is in the interface of RequestingModule, <code>false</code> if it's in the implementation of RequestingModule. Value is ignored and meaningless if RequestingModule is nullptr.</td></tr>
    <tr><td class="paramname">FilenameLoc</td><td>The location of the inclusion's filename.</td></tr>
    <tr><td class="paramname">Filename</td><td>The included filename as written.</td></tr>
    <tr><td class="paramname">File</td><td>The included file. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00471">471</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8cpp_source.html#l00270">clang::Module::directlyUses()</a>, <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="Format_8cpp_source.html#l02577">Filename</a>, <a class="el" href="Module_8cpp_source.html#l00219">clang::Module::getFullModuleName()</a>, <a class="el" href="ModuleMap_8h_source.html#l00170">clang::ModuleMap::KnownHeader::getModule()</a>, <a class="el" href="Module_8h_source.html#l00586">clang::Module::getTopLevelModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00467">getTopLevelOrNull()</a>, <a class="el" href="LangOptions_8h_source.html#l00494">clang::LangOptions::isCompilingModule()</a>, <a class="el" href="Module_8h_source.html#l00283">clang::Module::IsFramework</a>, <a class="el" href="Module_8h_source.html#l00099">clang::Module::Name</a>, <a class="el" href="Basic_2Diagnostic_8h_source.html#l01537">clang::DiagnosticsEngine::Report()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l01200">resolveHeaderDirectives()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l01335">resolveUses()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00446">violatesPrivateInclude()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PPDirectives_8cpp_source.html#l00946">clang::Preprocessor::LookupFile()</a>.</p>

</div>
</div>
<a id="a0ed1579ac35c5dcb1ab68449949a6912" name="a0ed1579ac35c5dcb1ab68449949a6912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed1579ac35c5dcb1ab68449949a6912">&#9670;&#160;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_DUMP_METHOD void ModuleMap::dump </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the contents of the module map, for debugging purposes. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01300">1300</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8cpp_source.html#l00434">clang::Module::print()</a>.</p>

</div>
</div>
<a id="a836cc1b5aecd0071b6e90837fefa0b2a" name="a836cc1b5aecd0071b6e90837fefa0b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836cc1b5aecd0071b6e90837fefa0b2a">&#9670;&#160;</a></span>excludeHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::excludeHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a></td>          <td class="paramname"><span class="paramname"><em>Header</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks this header as being excluded from the given module. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01263">1263</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00214">clang::Module::Header::Entry</a>, <a class="el" href="Module_8h_source.html#l00230">clang::Module::Headers</a>, and <a class="el" href="Module_8h_source.html#l00205">clang::Module::HK_Excluded</a>.</p>

</div>
</div>
<a id="a94cf9768b587f077bf7916c10754713a" name="a94cf9768b587f077bf7916c10754713a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cf9768b587f077bf7916c10754713a">&#9670;&#160;</a></span>findAllModulesForHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">ModuleMap::KnownHeader</a> &gt; ModuleMap::findAllModulesForHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve all the modules that contain the given header file. </p>
<p>Note that this does not implicitly load module maps, except for builtin headers, and does not consult the external source. (Those checks are the responsibility of <a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a>.)</p>
<p>Typically, <a class="el" href="#a8806b0826524879693983c42a0cd9aa9">findModuleForHeader</a> should be used instead, as it picks the preferred module for the header. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00667">667</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, and <a class="el" href="namespaceclang.html#aedc7162ec0f3d122748b0f5521e82546a6adf97f83acf6453d4a6a4b1070f3754">clang::None</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l01533">clang::HeaderSearch::findAllModulesForHeader()</a>.</p>

</div>
</div>
<a id="a35bee9d02a3e7ced6bc9f7dd42ede743" name="a35bee9d02a3e7ced6bc9f7dd42ede743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bee9d02a3e7ced6bc9f7dd42ede743">&#9670;&#160;</a></span>findModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::findModule </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a module with the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The named module, if known; otherwise, returns null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00787">787</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00069">addLinkAsDependency()</a>, <a class="el" href="ModuleManager_8cpp_source.html#l00053">clang::serialization::ModuleManager::lookupByModuleName()</a>, <a class="el" href="HeaderSearch_8cpp_source.html#l00278">clang::HeaderSearch::lookupModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00805">lookupModuleQualified()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00795">lookupModuleUnqualified()</a>, <a class="el" href="ModuleManager_8cpp_source.html#l00252">clang::serialization::ModuleManager::removeModules()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00058">resolveLinkAsDependencies()</a>.</p>

</div>
</div>
<a id="a8806b0826524879693983c42a0cd9aa9" name="a8806b0826524879693983c42a0cd9aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8806b0826524879693983c42a0cd9aa9">&#9670;&#160;</a></span>findModuleForHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">ModuleMap::KnownHeader</a> ModuleMap::findModuleForHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>File</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>AllowTextual</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the module that owns the given header file, if any. </p>
<p>Note that this does not implicitly load module maps, except for builtin headers, and does not consult the external source. (Those checks are the responsibility of <a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a>.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">File</td><td>The header file that is likely to be included.</td></tr>
    <tr><td class="paramname">AllowTextual</td><td>If <code>true</code> and <code>File</code> is a textual header, return its owning module. Otherwise, no <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html" title="A header that is known to reside within a given module, whether it was included or excluded.">KnownHeader</a> will be returned if the file is only known as a textual header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The module <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html" title="A header that is known to reside within a given module, whether it was included or excluded.">KnownHeader</a>, which provides the module that owns the given header file. The <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html" title="A header that is known to reside within a given module, whether it was included or excluded.">KnownHeader</a> is default constructed to indicate that no module owns this header file. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00569">569</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="ModuleMap_8h_source.html#l00170">clang::ModuleMap::KnownHeader::getModule()</a>, <a class="el" href="Module_8h_source.html#l00586">clang::Module::getTopLevelModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00546">isBetterKnownHeader()</a>, <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>, and <a class="el" href="ModuleMap_8h_source.html#l00137">TextualHeader</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l01522">clang::HeaderSearch::findModuleForHeader()</a>, and <a class="el" href="PPDirectives_8cpp_source.html#l00859">clang::Preprocessor::getModuleForLocation()</a>.</p>

</div>
</div>
<a id="a115a5b7b114346aaa534995084fc3ac0" name="a115a5b7b114346aaa534995084fc3ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115a5b7b114346aaa534995084fc3ac0">&#9670;&#160;</a></span>findOrCreateModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classclang_1_1Module.html">Module</a> *, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt; ModuleMap::findOrCreateModule </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsFramework</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsExplicit</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a new module or submodule, or create it if it does not already exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to find or create.</td></tr>
    <tr><td class="paramname">Parent</td><td>The module that will act as the parent of this submodule, or nullptr to indicate that this is a top-level module.</td></tr>
    <tr><td class="paramname">IsFramework</td><td>Whether this is a framework module.</td></tr>
    <tr><td class="paramname">IsExplicit</td><td>Whether this is an explicit submodule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The found or newly-created module, along with a boolean value that will be true if the module is newly-created. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00812">812</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="LangOptions_8h_source.html#l00417">clang::LangOptions::CurrentModule</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00805">lookupModuleQualified()</a>, <a class="el" href="namespaceclang.html#ad145f7432ac192abba688627ec3d64dcae55f75a29310d7b60f7ac1d390c8ae42">clang::Module</a>, <a class="el" href="ASTDiff_8cpp_source.html#l00192">Parent</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="a7569af5b4b731de5a135caf8636681b3" name="a7569af5b4b731de5a135caf8636681b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7569af5b4b731de5a135caf8636681b3">&#9670;&#160;</a></span>findResolvedModulesForHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">ModuleMap::KnownHeader</a> &gt; ModuleMap::findResolvedModulesForHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>File</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="#a94cf9768b587f077bf7916c10754713a">findAllModulesForHeader</a>, but do not attempt to infer module ownership from umbrella headers if we've not already done so. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00679">679</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="namespaceclang.html#aedc7162ec0f3d122748b0f5521e82546a6adf97f83acf6453d4a6a4b1070f3754">clang::None</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l01200">resolveHeaderDirectives()</a>.</p>

</div>
</div>
<a id="a390f6e47e08d60984fca9c6c492d42f7" name="a390f6e47e08d60984fca9c6c492d42f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390f6e47e08d60984fca9c6c492d42f7">&#9670;&#160;</a></span>finishModuleDeclarationScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::finishModuleDeclarationScope </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new declaration scope for module names, allowing previously defined modules to shadow definitions from the new scope. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classclang_1_1Module.html" title="Describes a module or submodule.">Module</a> names from earlier scopes will shadow names from the new scope, which is the opposite of how shadowing works for variables. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00586">586</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrontendAction_8cpp_source.html#l00567">clang::FrontendAction::BeginSourceFile()</a>.</p>

</div>
</div>
<a id="a9f089144fb15ba586196345ad98b8d0c" name="a9f089144fb15ba586196345ad98b8d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f089144fb15ba586196345ad98b8d0c">&#9670;&#160;</a></span>getAdditionalModuleMapFiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac22c56a8f11f61caa8ab58809a21cca3">AdditionalModMapsSet</a> * clang::ModuleMap::getAdditionalModuleMapFiles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>M</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get any module map files other than getModuleMapFileForUniquing(M) that define submodules of a top-level module <code>M</code>. </p>
<p>This is cheaper than getting the module map file for each submodule individually, since the expected number of results is very small. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00626">626</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<a id="a68be9dccb44faab58c2109371768c01e" name="a68be9dccb44faab58c2109371768c01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68be9dccb44faab58c2109371768c01e">&#9670;&#160;</a></span>getBuiltinDir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> * clang::ModuleMap::getBuiltinDir </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the directory that contains Clang-supplied include files. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00409">409</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<a id="a4b4bd7b843a23c66a57650297df1c545" name="a4b4bd7b843a23c66a57650297df1c545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4bd7b843a23c66a57650297df1c545">&#9670;&#160;</a></span>getCachedModuleLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="classclang_1_1Module.html">Module</a> * &gt; clang::ModuleMap::getCachedModuleLoad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>II</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a cached module load. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00727">727</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#aedc7162ec0f3d122748b0f5521e82546a6adf97f83acf6453d4a6a4b1070f3754">clang::None</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l01942">clang::CompilerInstance::loadModule()</a>.</p>

</div>
</div>
<a id="ab71ec7ef5400f119c1e95c28dad0371d" name="ab71ec7ef5400f119c1e95c28dad0371d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71ec7ef5400f119c1e95c28dad0371d">&#9670;&#160;</a></span>getContainingModuleMapFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> * ModuleMap::getContainingModuleMapFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Module</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the module map file containing the definition of the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classclang_1_1Module.html" title="Describes a module or submodule.">Module</a></td><td>The module whose module map file will be returned, if known.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The file entry for the module map file containing the given module, or nullptr if the module definition was inferred. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01274">1274</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00102">clang::Module::DefinitionLoc</a>, and <a class="el" href="SourceLocation_8h_source.html#l00111">clang::SourceLocation::isInvalid()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l01287">compileModule()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l01282">getModuleMapFileForUniquing()</a>.</p>

</div>
</div>
<a id="a8ad77286fb30719f2f516e5a67acaefe" name="a8ad77286fb30719f2f516e5a67acaefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad77286fb30719f2f516e5a67acaefe">&#9670;&#160;</a></span>getModuleMapFileForUniquing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> * ModuleMap::getModuleMapFileForUniquing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>M</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the module map file that (along with the module name) uniquely identifies this module. </p>
<p>The particular module that <code>Name</code> refers to may depend on how the module was found in header search. However, the combination of <code>Name</code> and this module map will be globally unique for top-level modules. In the case of inferred modules, returns the module map that allowed the inference (e.g. contained 'module *'). Otherwise, returns <a class="el" href="#ab71ec7ef5400f119c1e95c28dad0371d" title="Retrieve the module map file containing the definition of the given module.">getContainingModuleMapFile()</a>. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01282">1282</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l01274">getContainingModuleMapFile()</a>, and <a class="el" href="Module_8h_source.html#l00298">clang::Module::IsInferred</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l01287">compileModule()</a>, <a class="el" href="HeaderSearch_8cpp_source.html#l00172">clang::HeaderSearch::getCachedModuleFileName()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l00213">clang::HeaderSearch::getPrebuiltImplicitModuleFileName()</a>.</p>

</div>
</div>
<a id="af95957116dd995616c90e64c864811cd" name="af95957116dd995616c90e64c864811cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95957116dd995616c90e64c864811cd">&#9670;&#160;</a></span>headerKindToRole()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleMap::ModuleHeaderRole</a> ModuleMap::headerKindToRole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a></td>          <td class="paramname"><span class="paramname"><em>Kind</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a header kind to a role. Requires Kind to not be HK_Excluded. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00091">91</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00205">clang::Module::HK_Excluded</a>, <a class="el" href="Module_8h_source.html#l00201">clang::Module::HK_Normal</a>, <a class="el" href="Module_8h_source.html#l00203">clang::Module::HK_Private</a>, <a class="el" href="Module_8h_source.html#l00204">clang::Module::HK_PrivateTextual</a>, <a class="el" href="Module_8h_source.html#l00202">clang::Module::HK_Textual</a>, <a class="el" href="ModuleMap_8h_source.html#l00130">NormalHeader</a>, <a class="el" href="ModuleMap_8h_source.html#l00133">PrivateHeader</a>, and <a class="el" href="ModuleMap_8h_source.html#l00137">TextualHeader</a>.</p>

</div>
</div>
<a id="a32c51efd0ee64aaadd73218544eeeb01" name="a32c51efd0ee64aaadd73218544eeeb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c51efd0ee64aaadd73218544eeeb01">&#9670;&#160;</a></span>headerRoleToKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a> ModuleMap::headerRoleToKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a></td>          <td class="paramname"><span class="paramname"><em>Role</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a header role to a kind. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00076">76</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00201">clang::Module::HK_Normal</a>, <a class="el" href="Module_8h_source.html#l00203">clang::Module::HK_Private</a>, <a class="el" href="Module_8h_source.html#l00204">clang::Module::HK_PrivateTextual</a>, <a class="el" href="Module_8h_source.html#l00202">clang::Module::HK_Textual</a>, <a class="el" href="ModuleMap_8h_source.html#l00130">NormalHeader</a>, <a class="el" href="ModuleMap_8h_source.html#l00133">PrivateHeader</a>, <a class="el" href="FormatToken_8h_source.html#l00729">Role</a>, and <a class="el" href="ModuleMap_8h_source.html#l00137">TextualHeader</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l01235">addHeader()</a>.</p>

</div>
</div>
<a id="ad78651ebbabbed8598a8b3d71c0712f6" name="ad78651ebbabbed8598a8b3d71c0712f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78651ebbabbed8598a8b3d71c0712f6">&#9670;&#160;</a></span>inferFrameworkModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::inferFrameworkModule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>FrameworkDir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsSystem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Parent</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the contents of a framework module map from the given framework directory. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00943">943</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ASTDiff_8cpp_source.html#l00192">Parent</a>.</p>

</div>
</div>
<a id="a1e8ca3bc91f0e93e6c706b80f263e521" name="a1e8ca3bc91f0e93e6c706b80f263e521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8ca3bc91f0e93e6c706b80f263e521">&#9670;&#160;</a></span>isBuiltinHeader() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isBuiltinHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00391">391</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00375">isBuiltinHeader()</a>.</p>

</div>
</div>
<a id="a40c825f7506d1abd0d9bc54eba6330e6" name="a40c825f7506d1abd0d9bc54eba6330e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c825f7506d1abd0d9bc54eba6330e6">&#9670;&#160;</a></span>isBuiltinHeader() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isBuiltinHeader </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>FileName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this a compiler builtin header? </p>
<p>Determine whether the given file name is the name of a builtin header, supplied by Clang to replace, override, or augment existing system headers. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00375">375</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00391">isBuiltinHeader()</a>, <a class="el" href="HeaderSearch_8cpp_source.html#l01367">clang::HeaderSearch::ShouldEnterIncludeFile()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l01542">suggestModule()</a>.</p>

</div>
</div>
<a id="afc11dbc10f0658870b83753074c3c1d9" name="afc11dbc10f0658870b83753074c3c1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc11dbc10f0658870b83753074c3c1d9">&#9670;&#160;</a></span>isHeaderInUnavailableModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isHeaderInUnavailableModule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>Header</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the given header is part of a module marked 'unavailable'. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00688">688</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l00693">isHeaderUnavailableInModule()</a>.</p>

</div>
</div>
<a id="a890ef9bee13458036c9e4d5d7df58c8f" name="a890ef9bee13458036c9e4d5d7df58c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890ef9bee13458036c9e4d5d7df58c8f">&#9670;&#160;</a></span>isHeaderUnavailableInModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isHeaderUnavailableInModule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>Header</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>RequestingModule</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the given header is unavailable as part of the specified module. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00693">693</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="FileEntry_8h_source.html#l00371">clang::FileEntry::getDir()</a>, <a class="el" href="DirectoryEntry_8h_source.html#l00045">clang::DirectoryEntry::getName()</a>, <a class="el" href="FileEntry_8h_source.html#l00361">clang::FileEntry::getName()</a>, <a class="el" href="Module_8cpp_source.html#l00244">clang::Module::getUmbrellaDir()</a>, <a class="el" href="Module_8h_source.html#l00304">clang::Module::InferSubmodules</a>, <a class="el" href="Module_8h_source.html#l00466">clang::Module::isAvailable()</a>, <a class="el" href="Module_8cpp_source.html#l00173">clang::Module::isSubModuleOf()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00805">lookupModuleQualified()</a>, <a class="el" href="Module_8h_source.html#l00133">clang::Module::Parent</a>, <a class="el" href="ModuleMap_8cpp_source.html#l01200">resolveHeaderDirectives()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00336">sanitizeFilenameAsIdentifier()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00137">TextualHeader</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrontendAction_8cpp_source.html#l00327">collectModuleHeaderIncludes()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00688">isHeaderInUnavailableModule()</a>.</p>

</div>
</div>
<a id="ac4bd056e3b16607ace724463606dd3d5" name="ac4bd056e3b16607ace724463606dd3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bd056e3b16607ace724463606dd3d5">&#9670;&#160;</a></span>lookupModuleQualified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::lookupModuleQualified </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Context</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a module with the given name within the given context, using direct (qualified) name lookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to look up.</td></tr>
    <tr><td class="paramname">Context</td><td>The module for which we will look for a submodule. If null, we will look for a top-level module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The named submodule, if known; otherwose, returns null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00805">805</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l00787">findModule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00812">findOrCreateModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00693">isHeaderUnavailableInModule()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00795">lookupModuleUnqualified()</a>.</p>

</div>
</div>
<a id="a9682383d1483005eb8de8ab46275f5e5" name="a9682383d1483005eb8de8ab46275f5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9682383d1483005eb8de8ab46275f5e5">&#9670;&#160;</a></span>lookupModuleUnqualified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::lookupModuleUnqualified </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Context</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a module with the given name using lexical name lookup, starting at the given context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to look up.</td></tr>
    <tr><td class="paramname">Context</td><td>The module context, from which we will perform lexical name lookup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The named module, if known; otherwise, returns null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00795">795</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l00787">findModule()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00805">lookupModuleQualified()</a>.</p>

</div>
</div>
<a id="a3df11cf9b74e240aa373f25c1a63b49f" name="a3df11cf9b74e240aa373f25c1a63b49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df11cf9b74e240aa373f25c1a63b49f">&#9670;&#160;</a></span>mayShadowNewModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::ModuleMap::mayShadowNewModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>ExistingModule</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00588">588</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00133">clang::Module::Parent</a>.</p>

</div>
</div>
<a id="a6ab65f1f0882fcff9a15da9cfbf0fd02" name="a6ab65f1f0882fcff9a15da9cfbf0fd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab65f1f0882fcff9a15da9cfbf0fd02">&#9670;&#160;</a></span>module_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1b352087754574155a198a4cb0d6e197">module_iterator</a> clang::ModuleMap::module_begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00715">715</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l02191">clang::CompilerInstance::loadGlobalModuleIndex()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00717">modules()</a>.</p>

</div>
</div>
<a id="a9d9e3147d81ec86cf00eea874d9ea95b" name="a9d9e3147d81ec86cf00eea874d9ea95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9e3147d81ec86cf00eea874d9ea95b">&#9670;&#160;</a></span>module_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1b352087754574155a198a4cb0d6e197">module_iterator</a> clang::ModuleMap::module_end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00716">716</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l02191">clang::CompilerInstance::loadGlobalModuleIndex()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00717">modules()</a>.</p>

</div>
</div>
<a id="afc466d3e7e6077fea6c69d48759ec723" name="afc466d3e7e6077fea6c69d48759ec723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc466d3e7e6077fea6c69d48759ec723">&#9670;&#160;</a></span>modules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::iterator_range&lt; <a class="el" href="#a1b352087754574155a198a4cb0d6e197">module_iterator</a> &gt; clang::ModuleMap::modules </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00717">717</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00715">module_begin()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00716">module_end()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l01792">clang::HeaderSearch::collectAllModules()</a>.</p>

</div>
</div>
<a id="a516cfeb32bb3a464262cf6f369417eab" name="a516cfeb32bb3a464262cf6f369417eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516cfeb32bb3a464262cf6f369417eab">&#9670;&#160;</a></span>parseModuleMapFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::parseModuleMapFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>File</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsSystem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>HomeDir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileID.html">FileID</a></td>          <td class="paramname"><span class="paramname"><em>ID</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classclang_1_1FileID.html">FileID</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a></td>          <td class="paramname"><span class="paramname"><em>ExternModuleLoc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the given module map file, and record any modules we encounter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">File</td><td>The file to be parsed.</td></tr>
    <tr><td class="paramname">IsSystem</td><td>Whether this module map file is in a system header directory, and therefore should be considered a system module.</td></tr>
    <tr><td class="paramname">HomeDir</td><td>The directory in which relative paths within this module map file will be resolved.</td></tr>
    <tr><td class="paramname">ID</td><td>The <a class="el" href="classclang_1_1FileID.html" title="An opaque identifier used by SourceManager which refers to a source file (MemoryBuffer) along with it...">FileID</a> of the file to process, if we've already entered it.</td></tr>
    <tr><td class="paramname">Offset</td><td>[inout] On input the offset at which to start parsing. On output, the offset at which the module map terminated.</td></tr>
    <tr><td class="paramname">ExternModuleLoc</td><td>The location of the "extern module" declaration that caused us to load this module map file, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an error occurred, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l03018">3018</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="SourceManager_8h_source.html#l00084">clang::SrcMgr::C_System_ModuleMap</a>, <a class="el" href="SourceManager_8h_source.html#l00083">clang::SrcMgr::C_User_ModuleMap</a>, <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="Lexer_8cpp_source.html#l01148">clang::Lexer::getSourceLocation()</a>, <a class="el" href="Format_8cpp_source.html#l02579">Offset</a>, and <a class="el" href="namespaceclang.html#a7491b5cdc2843824aac96e74c3947c87a8eea62084ca7e541d918e823422bd82e">clang::Result</a>.</p>

</div>
</div>
<a id="a635593eb7f27a7297eb22afacd08d104" name="a635593eb7f27a7297eb22afacd08d104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635593eb7f27a7297eb22afacd08d104">&#9670;&#160;</a></span>resolveConflicts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::resolveConflicts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>Complain</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all of the unresolved conflicts in the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mod</td><td>The module whose conflicts should be resolved.</td></tr>
    <tr><td class="paramname">Complain</td><td>Whether to emit diagnostics for failures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any errors were encountered while resolving conflicts, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01348">1348</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00437">clang::Module::Conflicts</a>, <a class="el" href="Module_8h_source.html#l00433">clang::Module::Conflict::Message</a>, <a class="el" href="Module_8h_source.html#l00430">clang::Module::Conflict::Other</a>, <a class="el" href="namespaceclang.html#addf89b16eec81ec256e98fa0cc9cdd65a4a3b76ab214699973b85cc072788ff7d">clang::Unresolved</a>, and <a class="el" href="Module_8h_source.html#l00425">clang::Module::UnresolvedConflicts</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sema_8cpp_source.html#l01105">clang::Sema::ActOnEndOfTranslationUnit()</a>, and <a class="el" href="PPLexerChange_8cpp_source.html#l00684">clang::Preprocessor::EnterSubmodule()</a>.</p>

</div>
</div>
<a id="a03d91ee91e3d302d32885c4d790b3915" name="a03d91ee91e3d302d32885c4d790b3915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d91ee91e3d302d32885c4d790b3915">&#9670;&#160;</a></span>resolveExports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::resolveExports </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>Complain</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all of the unresolved exports in the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mod</td><td>The module whose exports should be resolved.</td></tr>
    <tr><td class="paramname">Complain</td><td>Whether to emit diagnostics for failures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any errors were encountered while resolving exports, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01322">1322</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00355">clang::Module::Exports</a>, <a class="el" href="namespaceclang.html#addf89b16eec81ec256e98fa0cc9cdd65a4a3b76ab214699973b85cc072788ff7d">clang::Unresolved</a>, and <a class="el" href="Module_8h_source.html#l00373">clang::Module::UnresolvedExports</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sema_8cpp_source.html#l01105">clang::Sema::ActOnEndOfTranslationUnit()</a>, and <a class="el" href="PPLexerChange_8cpp_source.html#l00684">clang::Preprocessor::EnterSubmodule()</a>.</p>

</div>
</div>
<a id="a64ce2c7a23bcff10e7ae4bfcda637182" name="a64ce2c7a23bcff10e7ae4bfcda637182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ce2c7a23bcff10e7ae4bfcda637182">&#9670;&#160;</a></span>resolveHeaderDirectives() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::resolveHeaderDirectives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>File</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all lazy header directives for the specified file. </p>
<p>This ensures that the <a class="el" href="structclang_1_1HeaderFileInfo.html" title="The preprocessor keeps track of this information for each file that is #included.">HeaderFileInfo</a> on <a class="el" href="classclang_1_1HeaderSearch.html" title="Encapsulates the information needed to find the file referenced by a #include or #include_next,...">HeaderSearch</a> is up to date. This is effectively internal, but is exposed so <a class="el" href="classclang_1_1HeaderSearch.html" title="Encapsulates the information needed to find the file referenced by a #include or #include_next,...">HeaderSearch</a> can call it. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01200">1200</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l01200">resolveHeaderDirectives()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrontendAction_8cpp_source.html#l00327">collectModuleHeaderIncludes()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00471">diagnoseHeaderInclusion()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00679">findResolvedModulesForHeader()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00693">isHeaderUnavailableInModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l01200">resolveHeaderDirectives()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l01367">clang::HeaderSearch::ShouldEnterIncludeFile()</a>.</p>

</div>
</div>
<a id="a2a7f7d3851e51a8409988c5c182490ac" name="a2a7f7d3851e51a8409988c5c182490ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7f7d3851e51a8409988c5c182490ac">&#9670;&#160;</a></span>resolveHeaderDirectives() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::resolveHeaderDirectives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>File</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve lazy header directives for the specified module. </p>
<p>If File is provided, only headers with same size and modtime are resolved. If File is not set, all headers are resolved. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01216">1216</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="Module_8h_source.html#l00241">clang::Module::UnresolvedHeaderDirective::ModTime</a>, <a class="el" href="Module_8h_source.html#l00240">clang::Module::UnresolvedHeaderDirective::Size</a>, and <a class="el" href="Module_8h_source.html#l00246">clang::Module::UnresolvedHeaders</a>.</p>

</div>
</div>
<a id="ac588ee8d4c631303982ed1c68002f49d" name="ac588ee8d4c631303982ed1c68002f49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac588ee8d4c631303982ed1c68002f49d">&#9670;&#160;</a></span>resolveLinkAsDependencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::resolveLinkAsDependencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use PendingLinkAsModule information to mark top level link names that are going to be replaced by export_as aliases. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00058">58</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l00787">findModule()</a>, and <a class="el" href="Module_8h_source.html#l00099">clang::Module::Name</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l01942">clang::CompilerInstance::loadModule()</a>.</p>

</div>
</div>
<a id="aff262a15ac7933edd463953d969e4f6b" name="aff262a15ac7933edd463953d969e4f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff262a15ac7933edd463953d969e4f6b">&#9670;&#160;</a></span>resolveUses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::resolveUses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>Complain</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all of the unresolved uses in the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mod</td><td>The module whose uses should be resolved.</td></tr>
    <tr><td class="paramname">Complain</td><td>Whether to emit diagnostics for failures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any errors were encountered while resolving uses, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01335">1335</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00376">clang::Module::DirectUses</a>, <a class="el" href="namespaceclang.html#addf89b16eec81ec256e98fa0cc9cdd65a4a3b76ab214699973b85cc072788ff7d">clang::Unresolved</a>, and <a class="el" href="Module_8h_source.html#l00379">clang::Module::UnresolvedDirectUses</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sema_8cpp_source.html#l01105">clang::Sema::ActOnEndOfTranslationUnit()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00471">diagnoseHeaderInclusion()</a>, <a class="el" href="PPLexerChange_8cpp_source.html#l00684">clang::Preprocessor::EnterSubmodule()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l01542">suggestModule()</a>.</p>

</div>
</div>
<a id="a6c624a7392febb43c7bb1a19e835ab34" name="a6c624a7392febb43c7bb1a19e835ab34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c624a7392febb43c7bb1a19e835ab34">&#9670;&#160;</a></span>setBuiltinIncludeDir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::setBuiltinIncludeDir </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>Dir</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the directory that contains Clang-supplied include files, such as our <a class="el" href="stdarg_8h.html">stdarg.h</a> or <a class="el" href="tgmath_8h.html">tgmath.h</a>. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00404">404</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitHeaderSearch_8cpp_source.html#l00658">clang::ApplyHeaderSearchOptions()</a>.</p>

</div>
</div>
<a id="a64cf116b47bb6201a8154feab288cc65" name="a64cf116b47bb6201a8154feab288cc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cf116b47bb6201a8154feab288cc65">&#9670;&#160;</a></span>setInferredModuleAllowedBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setInferredModuleAllowedBy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>ModMap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01290">1290</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00298">clang::Module::IsInferred</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrontendAction_8cpp_source.html#l00477">prepareToBuildModule()</a>.</p>

</div>
</div>
<a id="abc441df169e00dbd5ab3a5db003d454f" name="abc441df169e00dbd5ab3a5db003d454f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc441df169e00dbd5ab3a5db003d454f">&#9670;&#160;</a></span>setTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the target information. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00329">329</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l00722">clang::HeaderSearch::setTarget()</a>.</p>

</div>
</div>
<a id="a4c5148fa4f93b67492291bee915c9e27" name="a4c5148fa4f93b67492291bee915c9e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5148fa4f93b67492291bee915c9e27">&#9670;&#160;</a></span>setUmbrellaDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setUmbrellaDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>UmbrellaDir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>NameAsWritten</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>PathRelativeToRootModuleDirectory</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the umbrella directory of the given module to the given directory. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01154">1154</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00145">clang::Module::Umbrella</a>, <a class="el" href="Module_8h_source.html#l00151">clang::Module::UmbrellaAsWritten</a>, and <a class="el" href="Module_8h_source.html#l00154">clang::Module::UmbrellaRelativeToRootModuleDirectory</a>.</p>

</div>
</div>
<a id="ac236ffc11120133f8b4908b175e98172" name="ac236ffc11120133f8b4908b175e98172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac236ffc11120133f8b4908b175e98172">&#9670;&#160;</a></span>setUmbrellaHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setUmbrellaHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *</td>          <td class="paramname"><span class="paramname"><em>Mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>UmbrellaHeader</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>NameAsWritten</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>PathRelativeToRootModuleDirectory</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the umbrella header of the given module to the given header. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01139">1139</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="FileEntry_8h_source.html#l00371">clang::FileEntry::getDir()</a>, <a class="el" href="ModuleMap_8h_source.html#l00130">NormalHeader</a>, <a class="el" href="Module_8h_source.html#l00145">clang::Module::Umbrella</a>, <a class="el" href="Module_8h_source.html#l00151">clang::Module::UmbrellaAsWritten</a>, and <a class="el" href="Module_8h_source.html#l00154">clang::Module::UmbrellaRelativeToRootModuleDirectory</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a69fccb440615f32e24516ed4e718457d" name="a69fccb440615f32e24516ed4e718457d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fccb440615f32e24516ed4e718457d">&#9670;&#160;</a></span>ModuleMapParser</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classclang_1_1ModuleMapParser.html">ModuleMapParser</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00196">196</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/clang/Lex/<a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a></li>
<li>lib/Lex/<a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 10 2024 10:25:11 for clang by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
